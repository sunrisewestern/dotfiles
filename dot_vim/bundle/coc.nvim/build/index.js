"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options2) {
      options2 = options2 || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse4(val);
      } else if (type === "number" && isFinite(val)) {
        return options2.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse4(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name2) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name2 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format2];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name2) {
        if (name2[name2.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name2)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name2)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module2) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/has-flag/index.js"(exports, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports, module2) {
    "use strict";
    var os13 = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os13.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports, module2) {
    var tty = require("tty");
    var util4 = require("util");
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util4.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name2, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name2} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name2 + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util4.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util4.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util4.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/rfdc/index.js
var require_rfdc = __commonJS({
  "node_modules/rfdc/index.js"(exports, module2) {
    "use strict";
    module2.exports = rfdc;
    function copyBuffer(cur) {
      if (cur instanceof Buffer) {
        return Buffer.from(cur);
      }
      return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length);
    }
    function rfdc(opts) {
      opts = opts || {};
      if (opts.circles)
        return rfdcCircles(opts);
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn) {
        var keys = Object.keys(a);
        var a2 = new Array(keys.length);
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          var cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur instanceof Date) {
            a2[k] = new Date(cur);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k] = copyBuffer(cur);
          } else {
            a2[k] = fn(cur);
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, clone);
        if (o instanceof Map)
          return new Map(cloneArray(Array.from(o), clone));
        if (o instanceof Set)
          return new Set(cloneArray(Array.from(o), clone));
        var o2 = {};
        for (var k in o) {
          if (Object.hasOwnProperty.call(o, k) === false)
            continue;
          var cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur instanceof Date) {
            o2[k] = new Date(cur);
          } else if (cur instanceof Map) {
            o2[k] = new Map(cloneArray(Array.from(cur), clone));
          } else if (cur instanceof Set) {
            o2[k] = new Set(cloneArray(Array.from(cur), clone));
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = clone(cur);
          }
        }
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, cloneProto);
        if (o instanceof Map)
          return new Map(cloneArray(Array.from(o), cloneProto));
        if (o instanceof Set)
          return new Set(cloneArray(Array.from(o), cloneProto));
        var o2 = {};
        for (var k in o) {
          var cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur instanceof Date) {
            o2[k] = new Date(cur);
          } else if (cur instanceof Map) {
            o2[k] = new Map(cloneArray(Array.from(cur), cloneProto));
          } else if (cur instanceof Set) {
            o2[k] = new Set(cloneArray(Array.from(cur), cloneProto));
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = cloneProto(cur);
          }
        }
        return o2;
      }
    }
    function rfdcCircles(opts) {
      var refs = [];
      var refsNew = [];
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn) {
        var keys = Object.keys(a);
        var a2 = new Array(keys.length);
        for (var i = 0; i < keys.length; i++) {
          var k = keys[i];
          var cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur instanceof Date) {
            a2[k] = new Date(cur);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k] = copyBuffer(cur);
          } else {
            var index = refs.indexOf(cur);
            if (index !== -1) {
              a2[k] = refsNew[index];
            } else {
              a2[k] = fn(cur);
            }
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, clone);
        if (o instanceof Map)
          return new Map(cloneArray(Array.from(o), clone));
        if (o instanceof Set)
          return new Set(cloneArray(Array.from(o), clone));
        var o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (var k in o) {
          if (Object.hasOwnProperty.call(o, k) === false)
            continue;
          var cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur instanceof Date) {
            o2[k] = new Date(cur);
          } else if (cur instanceof Map) {
            o2[k] = new Map(cloneArray(Array.from(cur), clone));
          } else if (cur instanceof Set) {
            o2[k] = new Set(cloneArray(Array.from(cur), clone));
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            var i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = clone(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null)
          return o;
        if (o instanceof Date)
          return new Date(o);
        if (Array.isArray(o))
          return cloneArray(o, cloneProto);
        if (o instanceof Map)
          return new Map(cloneArray(Array.from(o), cloneProto));
        if (o instanceof Set)
          return new Set(cloneArray(Array.from(o), cloneProto));
        var o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (var k in o) {
          var cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur instanceof Date) {
            o2[k] = new Date(cur);
          } else if (cur instanceof Map) {
            o2[k] = new Map(cloneArray(Array.from(cur), cloneProto));
          } else if (cur instanceof Set) {
            o2[k] = new Set(cloneArray(Array.from(cur), cloneProto));
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            var i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = cloneProto(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
    }
  }
});

// node_modules/log4js/lib/configuration.js
var require_configuration = __commonJS({
  "node_modules/log4js/lib/configuration.js"(exports, module2) {
    var util4 = require("util");
    var debug = require_src()("log4js:configuration");
    var preProcessingListeners = [];
    var listeners = [];
    var not = (thing) => !thing;
    var anObject = (thing) => thing && typeof thing === "object" && !Array.isArray(thing);
    var validIdentifier = (thing) => /^[A-Za-z][A-Za-z0-9_]*$/g.test(thing);
    var anInteger = (thing) => thing && typeof thing === "number" && Number.isInteger(thing);
    var addListener = (fn) => {
      listeners.push(fn);
      debug(`Added listener, now ${listeners.length} listeners`);
    };
    var addPreProcessingListener = (fn) => {
      preProcessingListeners.push(fn);
      debug(`Added pre-processing listener, now ${preProcessingListeners.length} listeners`);
    };
    var throwExceptionIf = (config, checks, message) => {
      const tests = Array.isArray(checks) ? checks : [checks];
      tests.forEach((test) => {
        if (test) {
          throw new Error(`Problem with log4js configuration: (${util4.inspect(config, { depth: 5 })}) - ${message}`);
        }
      });
    };
    var configure = (candidate) => {
      debug("New configuration to be validated: ", candidate);
      throwExceptionIf(candidate, not(anObject(candidate)), "must be an object.");
      debug(`Calling pre-processing listeners (${preProcessingListeners.length})`);
      preProcessingListeners.forEach((listener) => listener(candidate));
      debug("Configuration pre-processing finished.");
      debug(`Calling configuration listeners (${listeners.length})`);
      listeners.forEach((listener) => listener(candidate));
      debug("Configuration finished.");
    };
    module2.exports = {
      configure,
      addListener,
      addPreProcessingListener,
      throwExceptionIf,
      anObject,
      anInteger,
      validIdentifier,
      not
    };
  }
});

// node_modules/date-format/lib/index.js
var require_lib = __commonJS({
  "node_modules/date-format/lib/index.js"(exports, module2) {
    "use strict";
    function padWithZeros(vNumber, width) {
      var numAsString = vNumber.toString();
      while (numAsString.length < width) {
        numAsString = "0" + numAsString;
      }
      return numAsString;
    }
    function addZero(vNumber) {
      return padWithZeros(vNumber, 2);
    }
    function offset(timezoneOffset) {
      var os13 = Math.abs(timezoneOffset);
      var h = String(Math.floor(os13 / 60));
      var m = String(os13 % 60);
      h = ("0" + h).slice(-2);
      m = ("0" + m).slice(-2);
      return timezoneOffset === 0 ? "Z" : (timezoneOffset < 0 ? "+" : "-") + h + ":" + m;
    }
    function asString(format2, date) {
      if (typeof format2 !== "string") {
        date = format2;
        format2 = module2.exports.ISO8601_FORMAT;
      }
      if (!date) {
        date = module2.exports.now();
      }
      var vDay = addZero(date.getDate());
      var vMonth = addZero(date.getMonth() + 1);
      var vYearLong = addZero(date.getFullYear());
      var vYearShort = addZero(vYearLong.substring(2, 4));
      var vYear = format2.indexOf("yyyy") > -1 ? vYearLong : vYearShort;
      var vHour = addZero(date.getHours());
      var vMinute = addZero(date.getMinutes());
      var vSecond = addZero(date.getSeconds());
      var vMillisecond = padWithZeros(date.getMilliseconds(), 3);
      var vTimeZone = offset(date.getTimezoneOffset());
      var formatted = format2.replace(/dd/g, vDay).replace(/MM/g, vMonth).replace(/y{1,4}/g, vYear).replace(/hh/g, vHour).replace(/mm/g, vMinute).replace(/ss/g, vSecond).replace(/SSS/g, vMillisecond).replace(/O/g, vTimeZone);
      return formatted;
    }
    function setDatePart(date, part, value, local) {
      date["set" + (local ? "" : "UTC") + part](value);
    }
    function extractDateParts(pattern, str, missingValuesDate) {
      var local = pattern.indexOf("O") < 0;
      var matchers = [
        {
          pattern: /y{1,4}/,
          regexp: "\\d{1,4}",
          fn: function(date2, value) {
            setDatePart(date2, "FullYear", value, local);
          }
        },
        {
          pattern: /MM/,
          regexp: "\\d{1,2}",
          fn: function(date2, value) {
            setDatePart(date2, "Month", value - 1, local);
          }
        },
        {
          pattern: /dd/,
          regexp: "\\d{1,2}",
          fn: function(date2, value) {
            setDatePart(date2, "Date", value, local);
          }
        },
        {
          pattern: /hh/,
          regexp: "\\d{1,2}",
          fn: function(date2, value) {
            setDatePart(date2, "Hours", value, local);
          }
        },
        {
          pattern: /mm/,
          regexp: "\\d\\d",
          fn: function(date2, value) {
            setDatePart(date2, "Minutes", value, local);
          }
        },
        {
          pattern: /ss/,
          regexp: "\\d\\d",
          fn: function(date2, value) {
            setDatePart(date2, "Seconds", value, local);
          }
        },
        {
          pattern: /SSS/,
          regexp: "\\d\\d\\d",
          fn: function(date2, value) {
            setDatePart(date2, "Milliseconds", value, local);
          }
        },
        {
          pattern: /O/,
          regexp: "[+-]\\d{1,2}:?\\d{2}?|Z",
          fn: function(date2, value) {
            if (value === "Z") {
              value = 0;
            } else {
              value = value.replace(":", "");
            }
            var offset2 = Math.abs(value);
            var timezoneOffset = (value > 0 ? -1 : 1) * (offset2 % 100 + Math.floor(offset2 / 100) * 60);
            date2.setUTCMinutes(date2.getUTCMinutes() + timezoneOffset);
          }
        }
      ];
      var parsedPattern = matchers.reduce(function(p, m) {
        if (m.pattern.test(p.regexp)) {
          m.index = p.regexp.match(m.pattern).index;
          p.regexp = p.regexp.replace(m.pattern, "(" + m.regexp + ")");
        } else {
          m.index = -1;
        }
        return p;
      }, { regexp: pattern, index: [] });
      var dateFns = matchers.filter(function(m) {
        return m.index > -1;
      });
      dateFns.sort(function(a, b) {
        return a.index - b.index;
      });
      var matcher = new RegExp(parsedPattern.regexp);
      var matches = matcher.exec(str);
      if (matches) {
        var date = missingValuesDate || module2.exports.now();
        dateFns.forEach(function(f, i) {
          f.fn(date, matches[i + 1]);
        });
        return date;
      }
      throw new Error("String '" + str + "' could not be parsed as '" + pattern + "'");
    }
    function parse4(pattern, str, missingValuesDate) {
      if (!pattern) {
        throw new Error("pattern must be supplied");
      }
      return extractDateParts(pattern, str, missingValuesDate);
    }
    function now() {
      return new Date();
    }
    module2.exports = asString;
    module2.exports.asString = asString;
    module2.exports.parse = parse4;
    module2.exports.now = now;
    module2.exports.ISO8601_FORMAT = "yyyy-MM-ddThh:mm:ss.SSS";
    module2.exports.ISO8601_WITH_TZ_OFFSET_FORMAT = "yyyy-MM-ddThh:mm:ss.SSSO";
    module2.exports.DATETIME_FORMAT = "dd MM yyyy hh:mm:ss.SSS";
    module2.exports.ABSOLUTETIME_FORMAT = "hh:mm:ss.SSS";
  }
});

// node_modules/log4js/lib/layouts.js
var require_layouts = __commonJS({
  "node_modules/log4js/lib/layouts.js"(exports, module2) {
    var dateFormat = require_lib();
    var os13 = require("os");
    var util4 = require("util");
    var path41 = require("path");
    var styles2 = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [90, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [91, 39],
      yellow: [33, 39]
    };
    function colorizeStart(style2) {
      return style2 ? `\x1B[${styles2[style2][0]}m` : "";
    }
    function colorizeEnd(style2) {
      return style2 ? `\x1B[${styles2[style2][1]}m` : "";
    }
    function colorize(str, style2) {
      return colorizeStart(style2) + str + colorizeEnd(style2);
    }
    function timestampLevelAndCategory(loggingEvent, colour) {
      return colorize(util4.format("[%s] [%s] %s - ", dateFormat.asString(loggingEvent.startTime), loggingEvent.level.toString(), loggingEvent.categoryName), colour);
    }
    function basicLayout(loggingEvent) {
      return timestampLevelAndCategory(loggingEvent) + util4.format(...loggingEvent.data);
    }
    function colouredLayout(loggingEvent) {
      return timestampLevelAndCategory(loggingEvent, loggingEvent.level.colour) + util4.format(...loggingEvent.data);
    }
    function messagePassThroughLayout(loggingEvent) {
      return util4.format(...loggingEvent.data);
    }
    function dummyLayout(loggingEvent) {
      return loggingEvent.data[0];
    }
    function patternLayout(pattern, tokens) {
      const TTCC_CONVERSION_PATTERN = "%r %p %c - %m%n";
      const regex3 = /%(-?[0-9]+)?(\.?-?[0-9]+)?([[\]cdhmnprzxXyflos%])(\{([^}]+)\})?|([^%]+)/;
      pattern = pattern || TTCC_CONVERSION_PATTERN;
      function categoryName(loggingEvent, specifier) {
        let loggerName = loggingEvent.categoryName;
        if (specifier) {
          const precision = parseInt(specifier, 10);
          const loggerNameBits = loggerName.split(".");
          if (precision < loggerNameBits.length) {
            loggerName = loggerNameBits.slice(loggerNameBits.length - precision).join(".");
          }
        }
        return loggerName;
      }
      function formatAsDate(loggingEvent, specifier) {
        let format2 = dateFormat.ISO8601_FORMAT;
        if (specifier) {
          format2 = specifier;
          if (format2 === "ISO8601") {
            format2 = dateFormat.ISO8601_FORMAT;
          } else if (format2 === "ISO8601_WITH_TZ_OFFSET") {
            format2 = dateFormat.ISO8601_WITH_TZ_OFFSET_FORMAT;
          } else if (format2 === "ABSOLUTE") {
            format2 = dateFormat.ABSOLUTETIME_FORMAT;
          } else if (format2 === "DATE") {
            format2 = dateFormat.DATETIME_FORMAT;
          }
        }
        return dateFormat.asString(format2, loggingEvent.startTime);
      }
      function hostname() {
        return os13.hostname().toString();
      }
      function formatMessage(loggingEvent) {
        return util4.format(...loggingEvent.data);
      }
      function endOfLine() {
        return os13.EOL;
      }
      function logLevel(loggingEvent) {
        return loggingEvent.level.toString();
      }
      function startTime(loggingEvent) {
        return dateFormat.asString("hh:mm:ss", loggingEvent.startTime);
      }
      function startColour(loggingEvent) {
        return colorizeStart(loggingEvent.level.colour);
      }
      function endColour(loggingEvent) {
        return colorizeEnd(loggingEvent.level.colour);
      }
      function percent() {
        return "%";
      }
      function pid(loggingEvent) {
        return loggingEvent && loggingEvent.pid ? loggingEvent.pid.toString() : process.pid.toString();
      }
      function clusterInfo() {
        return pid();
      }
      function userDefined(loggingEvent, specifier) {
        if (typeof tokens[specifier] !== "undefined") {
          return typeof tokens[specifier] === "function" ? tokens[specifier](loggingEvent) : tokens[specifier];
        }
        return null;
      }
      function contextDefined(loggingEvent, specifier) {
        const resolver2 = loggingEvent.context[specifier];
        if (typeof resolver2 !== "undefined") {
          return typeof resolver2 === "function" ? resolver2(loggingEvent) : resolver2;
        }
        return null;
      }
      function fileName(loggingEvent, specifier) {
        let filename = loggingEvent.fileName || "";
        if (specifier) {
          const fileDepth = parseInt(specifier, 10);
          const fileList = filename.split(path41.sep);
          if (fileList.length > fileDepth) {
            filename = fileList.slice(-fileDepth).join(path41.sep);
          }
        }
        return filename;
      }
      function lineNumber(loggingEvent) {
        return loggingEvent.lineNumber ? `${loggingEvent.lineNumber}` : "";
      }
      function columnNumber(loggingEvent) {
        return loggingEvent.columnNumber ? `${loggingEvent.columnNumber}` : "";
      }
      function callStack(loggingEvent) {
        return loggingEvent.callStack || "";
      }
      const replacers = {
        c: categoryName,
        d: formatAsDate,
        h: hostname,
        m: formatMessage,
        n: endOfLine,
        p: logLevel,
        r: startTime,
        "[": startColour,
        "]": endColour,
        y: clusterInfo,
        z: pid,
        "%": percent,
        x: userDefined,
        X: contextDefined,
        f: fileName,
        l: lineNumber,
        o: columnNumber,
        s: callStack
      };
      function replaceToken(conversionCharacter, loggingEvent, specifier) {
        return replacers[conversionCharacter](loggingEvent, specifier);
      }
      function truncate(truncation, toTruncate) {
        let len;
        if (truncation) {
          len = parseInt(truncation.substr(1), 10);
          return len > 0 ? toTruncate.slice(0, len) : toTruncate.slice(len);
        }
        return toTruncate;
      }
      function pad2(padding, toPad) {
        let len;
        if (padding) {
          if (padding.charAt(0) === "-") {
            len = parseInt(padding.substr(1), 10);
            while (toPad.length < len) {
              toPad += " ";
            }
          } else {
            len = parseInt(padding, 10);
            while (toPad.length < len) {
              toPad = ` ${toPad}`;
            }
          }
        }
        return toPad;
      }
      function truncateAndPad(toTruncAndPad, truncation, padding) {
        let replacement = toTruncAndPad;
        replacement = truncate(truncation, replacement);
        replacement = pad2(padding, replacement);
        return replacement;
      }
      return function(loggingEvent) {
        let formattedString = "";
        let result;
        let searchString = pattern;
        while ((result = regex3.exec(searchString)) !== null) {
          const padding = result[1];
          const truncation = result[2];
          const conversionCharacter = result[3];
          const specifier = result[5];
          const text = result[6];
          if (text) {
            formattedString += text.toString();
          } else {
            const replacement = replaceToken(conversionCharacter, loggingEvent, specifier);
            formattedString += truncateAndPad(replacement, truncation, padding);
          }
          searchString = searchString.substr(result.index + result[0].length);
        }
        return formattedString;
      };
    }
    var layoutMakers = {
      messagePassThrough() {
        return messagePassThroughLayout;
      },
      basic() {
        return basicLayout;
      },
      colored() {
        return colouredLayout;
      },
      coloured() {
        return colouredLayout;
      },
      pattern(config) {
        return patternLayout(config && config.pattern, config && config.tokens);
      },
      dummy() {
        return dummyLayout;
      }
    };
    module2.exports = {
      basicLayout,
      messagePassThroughLayout,
      patternLayout,
      colouredLayout,
      coloredLayout: colouredLayout,
      dummyLayout,
      addLayout(name2, serializerGenerator) {
        layoutMakers[name2] = serializerGenerator;
      },
      layout(name2, config) {
        return layoutMakers[name2] && layoutMakers[name2](config);
      }
    };
  }
});

// node_modules/log4js/lib/levels.js
var require_levels = __commonJS({
  "node_modules/log4js/lib/levels.js"(exports, module2) {
    var configuration = require_configuration();
    var validColours = [
      "white",
      "grey",
      "black",
      "blue",
      "cyan",
      "green",
      "magenta",
      "red",
      "yellow"
    ];
    var Level = class {
      constructor(level, levelStr, colour) {
        this.level = level;
        this.levelStr = levelStr;
        this.colour = colour;
      }
      toString() {
        return this.levelStr;
      }
      static getLevel(sArg, defaultLevel) {
        if (!sArg) {
          return defaultLevel;
        }
        if (sArg instanceof Level) {
          return sArg;
        }
        if (sArg instanceof Object && sArg.levelStr) {
          sArg = sArg.levelStr;
        }
        return Level[sArg.toString().toUpperCase()] || defaultLevel;
      }
      static addLevels(customLevels) {
        if (customLevels) {
          const levels = Object.keys(customLevels);
          levels.forEach((l) => {
            const levelStr = l.toUpperCase();
            Level[levelStr] = new Level(customLevels[l].value, levelStr, customLevels[l].colour);
            const existingLevelIndex = Level.levels.findIndex((lvl) => lvl.levelStr === levelStr);
            if (existingLevelIndex > -1) {
              Level.levels[existingLevelIndex] = Level[levelStr];
            } else {
              Level.levels.push(Level[levelStr]);
            }
          });
          Level.levels.sort((a, b) => a.level - b.level);
        }
      }
      isLessThanOrEqualTo(otherLevel) {
        if (typeof otherLevel === "string") {
          otherLevel = Level.getLevel(otherLevel);
        }
        return this.level <= otherLevel.level;
      }
      isGreaterThanOrEqualTo(otherLevel) {
        if (typeof otherLevel === "string") {
          otherLevel = Level.getLevel(otherLevel);
        }
        return this.level >= otherLevel.level;
      }
      isEqualTo(otherLevel) {
        if (typeof otherLevel === "string") {
          otherLevel = Level.getLevel(otherLevel);
        }
        return this.level === otherLevel.level;
      }
    };
    Level.levels = [];
    Level.addLevels({
      ALL: { value: Number.MIN_VALUE, colour: "grey" },
      TRACE: { value: 5e3, colour: "blue" },
      DEBUG: { value: 1e4, colour: "cyan" },
      INFO: { value: 2e4, colour: "green" },
      WARN: { value: 3e4, colour: "yellow" },
      ERROR: { value: 4e4, colour: "red" },
      FATAL: { value: 5e4, colour: "magenta" },
      MARK: { value: 9007199254740992, colour: "grey" },
      OFF: { value: Number.MAX_VALUE, colour: "grey" }
    });
    configuration.addListener((config) => {
      const levelConfig = config.levels;
      if (levelConfig) {
        configuration.throwExceptionIf(config, configuration.not(configuration.anObject(levelConfig)), "levels must be an object");
        const newLevels = Object.keys(levelConfig);
        newLevels.forEach((l) => {
          configuration.throwExceptionIf(config, configuration.not(configuration.validIdentifier(l)), `level name "${l}" is not a valid identifier (must start with a letter, only contain A-Z,a-z,0-9,_)`);
          configuration.throwExceptionIf(config, configuration.not(configuration.anObject(levelConfig[l])), `level "${l}" must be an object`);
          configuration.throwExceptionIf(config, configuration.not(levelConfig[l].value), `level "${l}" must have a 'value' property`);
          configuration.throwExceptionIf(config, configuration.not(configuration.anInteger(levelConfig[l].value)), `level "${l}".value must have an integer value`);
          configuration.throwExceptionIf(config, configuration.not(levelConfig[l].colour), `level "${l}" must have a 'colour' property`);
          configuration.throwExceptionIf(config, configuration.not(validColours.indexOf(levelConfig[l].colour) > -1), `level "${l}".colour must be one of ${validColours.join(", ")}`);
        });
      }
    });
    configuration.addListener((config) => {
      Level.addLevels(config.levels);
    });
    module2.exports = Level;
  }
});

// node_modules/flatted/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/flatted/cjs/index.js"(exports) {
    "use strict";
    var { parse: $parse, stringify: $stringify } = JSON;
    var { keys } = Object;
    var Primitive = String;
    var primitive = "string";
    var ignore = {};
    var object = "object";
    var noop = (_, value) => value;
    var primitives = (value) => value instanceof Primitive ? Primitive(value) : value;
    var Primitives = (_, value) => typeof value === primitive ? new Primitive(value) : value;
    var revive = (input, parsed, output, $) => {
      const lazy = [];
      for (let ke = keys(output), { length } = ke, y = 0; y < length; y++) {
        const k = ke[y];
        const value = output[k];
        if (value instanceof Primitive) {
          const tmp = input[value];
          if (typeof tmp === object && !parsed.has(tmp)) {
            parsed.add(tmp);
            output[k] = ignore;
            lazy.push({ k, a: [input, parsed, tmp, $] });
          } else
            output[k] = $.call(output, k, tmp);
        } else if (output[k] !== ignore)
          output[k] = $.call(output, k, value);
      }
      for (let { length } = lazy, i = 0; i < length; i++) {
        const { k, a } = lazy[i];
        output[k] = $.call(output, k, revive.apply(null, a));
      }
      return output;
    };
    var set = (known, input, value) => {
      const index = Primitive(input.push(value) - 1);
      known.set(value, index);
      return index;
    };
    var parse4 = (text, reviver) => {
      const input = $parse(text, Primitives).map(primitives);
      const value = input[0];
      const $ = reviver || noop;
      const tmp = typeof value === object && value ? revive(input, /* @__PURE__ */ new Set(), value, $) : value;
      return $.call({ "": tmp }, "", tmp);
    };
    exports.parse = parse4;
    var stringify2 = (value, replacer, space) => {
      const $ = replacer && typeof replacer === object ? (k, v) => k === "" || -1 < replacer.indexOf(k) ? v : void 0 : replacer || noop;
      const known = /* @__PURE__ */ new Map();
      const input = [];
      const output = [];
      let i = +set(known, input, $.call({ "": value }, "", value));
      let firstRun = !i;
      while (i < input.length) {
        firstRun = true;
        output[i] = $stringify(input[i++], replace, space);
      }
      return "[" + output.join(",") + "]";
      function replace(key, value2) {
        if (firstRun) {
          firstRun = !firstRun;
          return value2;
        }
        const after = $.call(this, key, value2);
        switch (typeof after) {
          case object:
            if (after === null)
              return after;
          case primitive:
            return known.get(after) || set(known, input, after);
        }
        return after;
      }
    };
    exports.stringify = stringify2;
    var toJSON = (any) => $parse(stringify2(any));
    exports.toJSON = toJSON;
    var fromJSON = (any) => parse4($stringify(any));
    exports.fromJSON = fromJSON;
  }
});

// node_modules/log4js/lib/LoggingEvent.js
var require_LoggingEvent = __commonJS({
  "node_modules/log4js/lib/LoggingEvent.js"(exports, module2) {
    var flatted = require_cjs();
    var levels = require_levels();
    var LoggingEvent = class {
      constructor(categoryName, level, data, context, location) {
        this.startTime = new Date();
        this.categoryName = categoryName;
        this.data = data;
        this.level = level;
        this.context = Object.assign({}, context);
        this.pid = process.pid;
        if (location) {
          this.functionName = location.functionName;
          this.fileName = location.fileName;
          this.lineNumber = location.lineNumber;
          this.columnNumber = location.columnNumber;
          this.callStack = location.callStack;
        }
      }
      serialise() {
        const logData = this.data.map((e) => {
          if (e && e.message && e.stack) {
            e = Object.assign({ message: e.message, stack: e.stack }, e);
          }
          return e;
        });
        this.data = logData;
        return flatted.stringify(this);
      }
      static deserialise(serialised) {
        let event;
        try {
          const rehydratedEvent = flatted.parse(serialised);
          rehydratedEvent.data = rehydratedEvent.data.map((e) => {
            if (e && e.message && e.stack) {
              const fakeError = new Error(e);
              Object.keys(e).forEach((key) => {
                fakeError[key] = e[key];
              });
              e = fakeError;
            }
            return e;
          });
          event = new LoggingEvent(rehydratedEvent.categoryName, levels.getLevel(rehydratedEvent.level.levelStr), rehydratedEvent.data, rehydratedEvent.context);
          event.startTime = new Date(rehydratedEvent.startTime);
          event.pid = rehydratedEvent.pid;
          event.cluster = rehydratedEvent.cluster;
        } catch (e) {
          event = new LoggingEvent("log4js", levels.ERROR, ["Unable to parse log:", serialised, "because: ", e]);
        }
        return event;
      }
    };
    module2.exports = LoggingEvent;
  }
});

// node_modules/log4js/lib/clustering.js
var require_clustering = __commonJS({
  "node_modules/log4js/lib/clustering.js"(exports, module2) {
    var debug = require_src()("log4js:clustering");
    var LoggingEvent = require_LoggingEvent();
    var configuration = require_configuration();
    var disabled = false;
    var cluster = null;
    try {
      cluster = require("cluster");
    } catch (e) {
      debug("cluster module not present");
      disabled = true;
    }
    var listeners = [];
    var pm2 = false;
    var pm2InstanceVar = "NODE_APP_INSTANCE";
    var isPM2Master = () => pm2 && process.env[pm2InstanceVar] === "0";
    var isMaster = () => disabled || cluster.isMaster || isPM2Master();
    var sendToListeners = (logEvent) => {
      listeners.forEach((l) => l(logEvent));
    };
    var receiver = (worker, message) => {
      debug("cluster message received from worker ", worker, ": ", message);
      if (worker.topic && worker.data) {
        message = worker;
        worker = void 0;
      }
      if (message && message.topic && message.topic === "log4js:message") {
        debug("received message: ", message.data);
        const logEvent = LoggingEvent.deserialise(message.data);
        sendToListeners(logEvent);
      }
    };
    if (!disabled) {
      configuration.addListener((config) => {
        listeners.length = 0;
        ({
          pm2,
          disableClustering: disabled,
          pm2InstanceVar = "NODE_APP_INSTANCE"
        } = config);
        debug(`clustering disabled ? ${disabled}`);
        debug(`cluster.isMaster ? ${cluster && cluster.isMaster}`);
        debug(`pm2 enabled ? ${pm2}`);
        debug(`pm2InstanceVar = ${pm2InstanceVar}`);
        debug(`process.env[${pm2InstanceVar}] = ${process.env[pm2InstanceVar]}`);
        if (pm2) {
          process.removeListener("message", receiver);
        }
        if (cluster && cluster.removeListener) {
          cluster.removeListener("message", receiver);
        }
        if (disabled || config.disableClustering) {
          debug("Not listening for cluster messages, because clustering disabled.");
        } else if (isPM2Master()) {
          debug("listening for PM2 broadcast messages");
          process.on("message", receiver);
        } else if (cluster.isMaster) {
          debug("listening for cluster messages");
          cluster.on("message", receiver);
        } else {
          debug("not listening for messages, because we are not a master process");
        }
      });
    }
    module2.exports = {
      onlyOnMaster: (fn, notMaster) => isMaster() ? fn() : notMaster,
      isMaster,
      send: (msg) => {
        if (isMaster()) {
          sendToListeners(msg);
        } else {
          if (!pm2) {
            msg.cluster = {
              workerId: cluster.worker.id,
              worker: process.pid
            };
          }
          process.send({ topic: "log4js:message", data: msg.serialise() });
        }
      },
      onMessage: (listener) => {
        listeners.push(listener);
      }
    };
  }
});

// node_modules/log4js/lib/appenders/adapters.js
var require_adapters = __commonJS({
  "node_modules/log4js/lib/appenders/adapters.js"(exports, module2) {
    function maxFileSizeUnitTransform(maxLogSize) {
      if (typeof maxLogSize === "number" && Number.isInteger(maxLogSize)) {
        return maxLogSize;
      }
      const units = {
        K: 1024,
        M: 1024 * 1024,
        G: 1024 * 1024 * 1024
      };
      const validUnit = Object.keys(units);
      const unit = maxLogSize.substr(maxLogSize.length - 1).toLocaleUpperCase();
      const value = maxLogSize.substring(0, maxLogSize.length - 1).trim();
      if (validUnit.indexOf(unit) < 0 || !Number.isInteger(Number(value))) {
        throw Error(`maxLogSize: "${maxLogSize}" is invalid`);
      } else {
        return value * units[unit];
      }
    }
    function adapter(configAdapter, config) {
      const newConfig = Object.assign({}, config);
      Object.keys(configAdapter).forEach((key) => {
        if (newConfig[key]) {
          newConfig[key] = configAdapter[key](config[key]);
        }
      });
      return newConfig;
    }
    function fileAppenderAdapter(config) {
      const configAdapter = {
        maxLogSize: maxFileSizeUnitTransform
      };
      return adapter(configAdapter, config);
    }
    var adapters = {
      file: fileAppenderAdapter,
      fileSync: fileAppenderAdapter
    };
    module2.exports.modifyConfig = (config) => adapters[config.type] ? adapters[config.type](config) : config;
  }
});

// node_modules/log4js/lib/appenders/console.js
var require_console = __commonJS({
  "node_modules/log4js/lib/appenders/console.js"(exports, module2) {
    var consoleLog = console.log.bind(console);
    function consoleAppender(layout, timezoneOffset) {
      return (loggingEvent) => {
        consoleLog(layout(loggingEvent, timezoneOffset));
      };
    }
    function configure(config, layouts) {
      let layout = layouts.colouredLayout;
      if (config.layout) {
        layout = layouts.layout(config.layout.type, config.layout);
      }
      return consoleAppender(layout, config.timezoneOffset);
    }
    module2.exports.configure = configure;
  }
});

// node_modules/log4js/lib/appenders/stdout.js
var require_stdout = __commonJS({
  "node_modules/log4js/lib/appenders/stdout.js"(exports) {
    function stdoutAppender(layout, timezoneOffset) {
      return (loggingEvent) => {
        process.stdout.write(`${layout(loggingEvent, timezoneOffset)}
`);
      };
    }
    function configure(config, layouts) {
      let layout = layouts.colouredLayout;
      if (config.layout) {
        layout = layouts.layout(config.layout.type, config.layout);
      }
      return stdoutAppender(layout, config.timezoneOffset);
    }
    exports.configure = configure;
  }
});

// node_modules/log4js/lib/appenders/stderr.js
var require_stderr = __commonJS({
  "node_modules/log4js/lib/appenders/stderr.js"(exports, module2) {
    function stderrAppender(layout, timezoneOffset) {
      return (loggingEvent) => {
        process.stderr.write(`${layout(loggingEvent, timezoneOffset)}
`);
      };
    }
    function configure(config, layouts) {
      let layout = layouts.colouredLayout;
      if (config.layout) {
        layout = layouts.layout(config.layout.type, config.layout);
      }
      return stderrAppender(layout, config.timezoneOffset);
    }
    module2.exports.configure = configure;
  }
});

// node_modules/log4js/lib/appenders/logLevelFilter.js
var require_logLevelFilter = __commonJS({
  "node_modules/log4js/lib/appenders/logLevelFilter.js"(exports, module2) {
    function logLevelFilter(minLevelString, maxLevelString, appender, levels) {
      const minLevel = levels.getLevel(minLevelString);
      const maxLevel = levels.getLevel(maxLevelString, levels.FATAL);
      return (logEvent) => {
        const eventLevel = logEvent.level;
        if (eventLevel.isGreaterThanOrEqualTo(minLevel) && eventLevel.isLessThanOrEqualTo(maxLevel)) {
          appender(logEvent);
        }
      };
    }
    function configure(config, layouts, findAppender, levels) {
      const appender = findAppender(config.appender);
      return logLevelFilter(config.level, config.maxLevel, appender, levels);
    }
    module2.exports.configure = configure;
  }
});

// node_modules/log4js/lib/appenders/categoryFilter.js
var require_categoryFilter = __commonJS({
  "node_modules/log4js/lib/appenders/categoryFilter.js"(exports, module2) {
    var debug = require_src()("log4js:categoryFilter");
    function categoryFilter(excludes, appender) {
      if (typeof excludes === "string")
        excludes = [excludes];
      return (logEvent) => {
        debug(`Checking ${logEvent.categoryName} against ${excludes}`);
        if (excludes.indexOf(logEvent.categoryName) === -1) {
          debug("Not excluded, sending to appender");
          appender(logEvent);
        }
      };
    }
    function configure(config, layouts, findAppender) {
      const appender = findAppender(config.appender);
      return categoryFilter(config.exclude, appender);
    }
    module2.exports.configure = configure;
  }
});

// node_modules/log4js/lib/appenders/noLogFilter.js
var require_noLogFilter = __commonJS({
  "node_modules/log4js/lib/appenders/noLogFilter.js"(exports, module2) {
    var debug = require_src()("log4js:noLogFilter");
    function removeNullOrEmptyRegexp(regexp) {
      const filtered = regexp.filter((el) => el != null && el !== "");
      return filtered;
    }
    function noLogFilter(filters, appender) {
      return (logEvent) => {
        debug(`Checking data: ${logEvent.data} against filters: ${filters}`);
        if (typeof filters === "string") {
          filters = [filters];
        }
        filters = removeNullOrEmptyRegexp(filters);
        const regex3 = new RegExp(filters.join("|"), "i");
        if (filters.length === 0 || logEvent.data.findIndex((value) => regex3.test(value)) < 0) {
          debug("Not excluded, sending to appender");
          appender(logEvent);
        }
      };
    }
    function configure(config, layouts, findAppender) {
      const appender = findAppender(config.appender);
      return noLogFilter(config.exclude, appender);
    }
    module2.exports.configure = configure;
  }
});

// node_modules/universalify/index.js
var require_universalify = __commonJS({
  "node_modules/universalify/index.js"(exports) {
    "use strict";
    exports.fromCallback = function(fn) {
      return Object.defineProperty(function(...args) {
        if (typeof args[args.length - 1] === "function")
          fn.apply(this, args);
        else {
          return new Promise((resolve3, reject) => {
            fn.call(this, ...args, (err, res) => err != null ? reject(err) : resolve3(res));
          });
        }
      }, "name", { value: fn.name });
    };
    exports.fromPromise = function(fn) {
      return Object.defineProperty(function(...args) {
        const cb = args[args.length - 1];
        if (typeof cb !== "function")
          return fn.apply(this, args);
        else
          fn.apply(this, args.slice(0, -1)).then((r) => cb(null, r), cb);
      }, "name", { value: fn.name });
    };
  }
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "node_modules/graceful-fs/polyfills.js"(exports, module2) {
    var constants = require("constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform2 = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module2.exports = patch;
    function patch(fs29) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs29);
      }
      if (!fs29.lutimes) {
        patchLutimes(fs29);
      }
      fs29.chown = chownFix(fs29.chown);
      fs29.fchown = chownFix(fs29.fchown);
      fs29.lchown = chownFix(fs29.lchown);
      fs29.chmod = chmodFix(fs29.chmod);
      fs29.fchmod = chmodFix(fs29.fchmod);
      fs29.lchmod = chmodFix(fs29.lchmod);
      fs29.chownSync = chownFixSync(fs29.chownSync);
      fs29.fchownSync = chownFixSync(fs29.fchownSync);
      fs29.lchownSync = chownFixSync(fs29.lchownSync);
      fs29.chmodSync = chmodFixSync(fs29.chmodSync);
      fs29.fchmodSync = chmodFixSync(fs29.fchmodSync);
      fs29.lchmodSync = chmodFixSync(fs29.lchmodSync);
      fs29.stat = statFix(fs29.stat);
      fs29.fstat = statFix(fs29.fstat);
      fs29.lstat = statFix(fs29.lstat);
      fs29.statSync = statFixSync(fs29.statSync);
      fs29.fstatSync = statFixSync(fs29.fstatSync);
      fs29.lstatSync = statFixSync(fs29.lstatSync);
      if (!fs29.lchmod) {
        fs29.lchmod = function(path41, mode, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs29.lchmodSync = function() {
        };
      }
      if (!fs29.lchown) {
        fs29.lchown = function(path41, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs29.lchownSync = function() {
        };
      }
      if (platform2 === "win32") {
        fs29.rename = function(fs$rename) {
          return function(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs29.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          };
        }(fs29.rename);
      }
      fs29.read = function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs29, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs29, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs29.read);
      fs29.readSync = function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs29, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs29.readSync);
      function patchLchmod(fs30) {
        fs30.lchmod = function(path41, mode, callback) {
          fs30.open(path41, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
            if (err) {
              if (callback)
                callback(err);
              return;
            }
            fs30.fchmod(fd, mode, function(err2) {
              fs30.close(fd, function(err22) {
                if (callback)
                  callback(err2 || err22);
              });
            });
          });
        };
        fs30.lchmodSync = function(path41, mode) {
          var fd = fs30.openSync(path41, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs30.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs30.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs30.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs30) {
        if (constants.hasOwnProperty("O_SYMLINK")) {
          fs30.lutimes = function(path41, at, mt, cb) {
            fs30.open(path41, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs30.futimes(fd, at, mt, function(er2) {
                fs30.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs30.lutimesSync = function(path41, at, mt) {
            var fd = fs30.openSync(path41, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs30.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs30.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs30.closeSync(fd);
              }
            }
            return ret;
          };
        } else {
          fs30.lutimes = function(_a, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs30.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs29, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs29, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs29, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs29, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options2, cb) {
          if (typeof options2 === "function") {
            cb = options2;
            options2 = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options2 ? orig.call(fs29, target, options2, callback) : orig.call(fs29, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options2) {
          var stats = options2 ? orig.call(fs29, target, options2) : orig.call(fs29, target);
          if (stats.uid < 0)
            stats.uid += 4294967296;
          if (stats.gid < 0)
            stats.gid += 4294967296;
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "node_modules/graceful-fs/legacy-streams.js"(exports, module2) {
    var Stream = require("stream").Stream;
    module2.exports = legacy;
    function legacy(fs29) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path41, options2) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path41, options2);
        Stream.call(this);
        var self2 = this;
        this.path = path41;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options2 = options2 || {};
        var keys = Object.keys(options2);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options2[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if (typeof this.start !== "number") {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if (typeof this.end !== "number") {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self2._read();
          });
          return;
        }
        fs29.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self2.emit("error", err);
            self2.readable = false;
            return;
          }
          self2.fd = fd;
          self2.emit("open", fd);
          self2._read();
        });
      }
      function WriteStream(path41, options2) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path41, options2);
        Stream.call(this);
        this.path = path41;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options2 = options2 || {};
        var keys = Object.keys(options2);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options2[key];
        }
        if (this.start !== void 0) {
          if (typeof this.start !== "number") {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs29.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "node_modules/graceful-fs/clone.js"(exports, module2) {
    "use strict";
    module2.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "node_modules/graceful-fs/graceful-fs.js"(exports, module2) {
    var fs29 = require("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util4 = require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug = noop;
    if (util4.debuglog)
      debug = util4.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug = function() {
        var m = util4.format.apply(util4, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs29[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs29, queue);
      fs29.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs29, fd, function(err) {
            if (!err) {
              retry();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs29.close);
      fs29.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs29, arguments);
          retry();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs29.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug(fs29[gracefulQueue]);
          require("assert").equal(fs29[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs29[gracefulQueue]);
    }
    module2.exports = patch(clone(fs29));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs29.__patched) {
      module2.exports = patch(fs29);
      fs29.__patched = true;
    }
    function patch(fs30) {
      polyfills(fs30);
      fs30.gracefulify = patch;
      fs30.createReadStream = createReadStream;
      fs30.createWriteStream = createWriteStream;
      var fs$readFile = fs30.readFile;
      fs30.readFile = readFile2;
      function readFile2(path41, options2, cb) {
        if (typeof options2 === "function")
          cb = options2, options2 = null;
        return go$readFile(path41, options2, cb);
        function go$readFile(path42, options3, cb2) {
          return fs$readFile(path42, options3, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path42, options3, cb2]]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
              retry();
            }
          });
        }
      }
      var fs$writeFile = fs30.writeFile;
      fs30.writeFile = writeFile2;
      function writeFile2(path41, data, options2, cb) {
        if (typeof options2 === "function")
          cb = options2, options2 = null;
        return go$writeFile(path41, data, options2, cb);
        function go$writeFile(path42, data2, options3, cb2) {
          return fs$writeFile(path42, data2, options3, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path42, data2, options3, cb2]]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
              retry();
            }
          });
        }
      }
      var fs$appendFile = fs30.appendFile;
      if (fs$appendFile)
        fs30.appendFile = appendFile;
      function appendFile(path41, data, options2, cb) {
        if (typeof options2 === "function")
          cb = options2, options2 = null;
        return go$appendFile(path41, data, options2, cb);
        function go$appendFile(path42, data2, options3, cb2) {
          return fs$appendFile(path42, data2, options3, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path42, data2, options3, cb2]]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
              retry();
            }
          });
        }
      }
      var fs$copyFile = fs30.copyFile;
      if (fs$copyFile)
        fs30.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return fs$copyFile(src, dest, flags, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([fs$copyFile, [src, dest, flags, cb]]);
          else {
            if (typeof cb === "function")
              cb.apply(this, arguments);
            retry();
          }
        });
      }
      var fs$readdir = fs30.readdir;
      fs30.readdir = readdir;
      function readdir(path41, options2, cb) {
        var args = [path41];
        if (typeof options2 !== "function") {
          args.push(options2);
        } else {
          cb = options2;
        }
        args.push(go$readdir$cb);
        return go$readdir(args);
        function go$readdir$cb(err, files) {
          if (files && files.sort)
            files.sort();
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$readdir, [args]]);
          else {
            if (typeof cb === "function")
              cb.apply(this, arguments);
            retry();
          }
        }
      }
      function go$readdir(args) {
        return fs$readdir.apply(fs30, args);
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs30);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs30.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs30.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs30, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs30, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs30, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs30, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path41, options2) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path41, options2) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path41, options2) {
        return new fs30.ReadStream(path41, options2);
      }
      function createWriteStream(path41, options2) {
        return new fs30.WriteStream(path41, options2);
      }
      var fs$open = fs30.open;
      fs30.open = open;
      function open(path41, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path41, flags, mode, cb);
        function go$open(path42, flags2, mode2, cb2) {
          return fs$open(path42, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path42, flags2, mode2, cb2]]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
              retry();
            }
          });
        }
      }
      return fs30;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]);
      fs29[gracefulQueue].push(elem);
    }
    function retry() {
      var elem = fs29[gracefulQueue].shift();
      if (elem) {
        debug("RETRY", elem[0].name, elem[1]);
        elem[0].apply(null, elem[1]);
      }
    }
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/fs/index.js
var require_fs = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/fs/index.js"(exports) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs29 = require_graceful_fs();
    var api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchmod",
      "lchown",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => {
      return typeof fs29[key] === "function";
    });
    Object.assign(exports, fs29);
    api.forEach((method) => {
      exports[method] = u(fs29[method]);
    });
    exports.realpath.native = u(fs29.realpath.native);
    exports.exists = function(filename, callback) {
      if (typeof callback === "function") {
        return fs29.exists(filename, callback);
      }
      return new Promise((resolve3) => {
        return fs29.exists(filename, resolve3);
      });
    };
    exports.read = function(fd, buffer, offset, length, position, callback) {
      if (typeof callback === "function") {
        return fs29.read(fd, buffer, offset, length, position, callback);
      }
      return new Promise((resolve3, reject) => {
        fs29.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
          if (err)
            return reject(err);
          resolve3({ bytesRead, buffer: buffer2 });
        });
      });
    };
    exports.write = function(fd, buffer, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs29.write(fd, buffer, ...args);
      }
      return new Promise((resolve3, reject) => {
        fs29.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
          if (err)
            return reject(err);
          resolve3({ bytesWritten, buffer: buffer2 });
        });
      });
    };
    if (typeof fs29.writev === "function") {
      exports.writev = function(fd, buffers, ...args) {
        if (typeof args[args.length - 1] === "function") {
          return fs29.writev(fd, buffers, ...args);
        }
        return new Promise((resolve3, reject) => {
          fs29.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
            if (err)
              return reject(err);
            resolve3({ bytesWritten, buffers: buffers2 });
          });
        });
      };
    }
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/utils.js
var require_utils = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/utils.js"(exports, module2) {
    "use strict";
    var path41 = require("path");
    module2.exports.checkPath = function checkPath(pth) {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path41.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const error = new Error(`Path contains invalid characters: ${pth}`);
          error.code = "EINVAL";
          throw error;
        }
      }
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/make-dir.js"(exports, module2) {
    "use strict";
    var fs29 = require_fs();
    var { checkPath } = require_utils();
    var getMode = (options2) => {
      const defaults3 = { mode: 511 };
      if (typeof options2 === "number")
        return options2;
      return __spreadValues(__spreadValues({}, defaults3), options2).mode;
    };
    module2.exports.makeDir = async (dir, options2) => {
      checkPath(dir);
      return fs29.mkdir(dir, {
        mode: getMode(options2),
        recursive: true
      });
    };
    module2.exports.makeDirSync = (dir, options2) => {
      checkPath(dir);
      return fs29.mkdirSync(dir, {
        mode: getMode(options2),
        recursive: true
      });
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/mkdirs/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var { makeDir: _makeDir, makeDirSync } = require_make_dir();
    var makeDir = u(_makeDir);
    module2.exports = {
      mkdirs: makeDir,
      mkdirsSync: makeDirSync,
      mkdirp: makeDir,
      mkdirpSync: makeDirSync,
      ensureDir: makeDir,
      ensureDirSync: makeDirSync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/util/utimes.js
var require_utimes = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/util/utimes.js"(exports, module2) {
    "use strict";
    var fs29 = require_graceful_fs();
    function utimesMillis(path41, atime, mtime, callback) {
      fs29.open(path41, "r+", (err, fd) => {
        if (err)
          return callback(err);
        fs29.futimes(fd, atime, mtime, (futimesErr) => {
          fs29.close(fd, (closeErr) => {
            if (callback)
              callback(futimesErr || closeErr);
          });
        });
      });
    }
    function utimesMillisSync(path41, atime, mtime) {
      const fd = fs29.openSync(path41, "r+");
      fs29.futimesSync(fd, atime, mtime);
      return fs29.closeSync(fd);
    }
    module2.exports = {
      utimesMillis,
      utimesMillisSync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/util/stat.js
var require_stat = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/util/stat.js"(exports, module2) {
    "use strict";
    var fs29 = require_fs();
    var path41 = require("path");
    var util4 = require("util");
    function getStats(src, dest, opts) {
      const statFunc = opts.dereference ? (file) => fs29.stat(file, { bigint: true }) : (file) => fs29.lstat(file, { bigint: true });
      return Promise.all([
        statFunc(src),
        statFunc(dest).catch((err) => {
          if (err.code === "ENOENT")
            return null;
          throw err;
        })
      ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
    }
    function getStatsSync(src, dest, opts) {
      let destStat;
      const statFunc = opts.dereference ? (file) => fs29.statSync(file, { bigint: true }) : (file) => fs29.lstatSync(file, { bigint: true });
      const srcStat = statFunc(src);
      try {
        destStat = statFunc(dest);
      } catch (err) {
        if (err.code === "ENOENT")
          return { srcStat, destStat: null };
        throw err;
      }
      return { srcStat, destStat };
    }
    function checkPaths(src, dest, funcName, opts, cb) {
      util4.callbackify(getStats)(src, dest, opts, (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, destStat } = stats;
        if (destStat) {
          if (areIdentical(srcStat, destStat)) {
            const srcBaseName = path41.basename(src);
            const destBaseName = path41.basename(dest);
            if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
              return cb(null, { srcStat, destStat, isChangingCase: true });
            }
            return cb(new Error("Source and destination must not be the same."));
          }
          if (srcStat.isDirectory() && !destStat.isDirectory()) {
            return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
          }
          if (!srcStat.isDirectory() && destStat.isDirectory()) {
            return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`));
          }
        }
        if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
          return cb(new Error(errMsg(src, dest, funcName)));
        }
        return cb(null, { srcStat, destStat });
      });
    }
    function checkPathsSync(src, dest, funcName, opts) {
      const { srcStat, destStat } = getStatsSync(src, dest, opts);
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path41.basename(src);
          const destBaseName = path41.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
            return { srcStat, destStat, isChangingCase: true };
          }
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
        }
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }
    function checkParentPaths(src, srcStat, dest, funcName, cb) {
      const srcParent = path41.resolve(path41.dirname(src));
      const destParent = path41.resolve(path41.dirname(dest));
      if (destParent === srcParent || destParent === path41.parse(destParent).root)
        return cb();
      fs29.stat(destParent, { bigint: true }, (err, destStat) => {
        if (err) {
          if (err.code === "ENOENT")
            return cb();
          return cb(err);
        }
        if (areIdentical(srcStat, destStat)) {
          return cb(new Error(errMsg(src, dest, funcName)));
        }
        return checkParentPaths(src, srcStat, destParent, funcName, cb);
      });
    }
    function checkParentPathsSync(src, srcStat, dest, funcName) {
      const srcParent = path41.resolve(path41.dirname(src));
      const destParent = path41.resolve(path41.dirname(dest));
      if (destParent === srcParent || destParent === path41.parse(destParent).root)
        return;
      let destStat;
      try {
        destStat = fs29.statSync(destParent, { bigint: true });
      } catch (err) {
        if (err.code === "ENOENT")
          return;
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPathsSync(src, srcStat, destParent, funcName);
    }
    function areIdentical(srcStat, destStat) {
      return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
    }
    function isSrcSubdir(src, dest) {
      const srcArr = path41.resolve(src).split(path41.sep).filter((i) => i);
      const destArr = path41.resolve(dest).split(path41.sep).filter((i) => i);
      return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);
    }
    function errMsg(src, dest, funcName) {
      return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
    }
    module2.exports = {
      checkPaths,
      checkPathsSync,
      checkParentPaths,
      checkParentPathsSync,
      isSrcSubdir,
      areIdentical
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/copy-sync/copy-sync.js
var require_copy_sync = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/copy-sync/copy-sync.js"(exports, module2) {
    "use strict";
    var fs29 = require_graceful_fs();
    var path41 = require("path");
    var mkdirsSync = require_mkdirs().mkdirsSync;
    var utimesMillisSync = require_utimes().utimesMillisSync;
    var stat = require_stat();
    function copySync(src, dest, opts) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
      }
      const { srcStat, destStat } = stat.checkPathsSync(src, dest, "copy", opts);
      stat.checkParentPathsSync(src, srcStat, dest, "copy");
      return handleFilterAndCopy(destStat, src, dest, opts);
    }
    function handleFilterAndCopy(destStat, src, dest, opts) {
      if (opts.filter && !opts.filter(src, dest))
        return;
      const destParent = path41.dirname(dest);
      if (!fs29.existsSync(destParent))
        mkdirsSync(destParent);
      return getStats(destStat, src, dest, opts);
    }
    function startCopy(destStat, src, dest, opts) {
      if (opts.filter && !opts.filter(src, dest))
        return;
      return getStats(destStat, src, dest, opts);
    }
    function getStats(destStat, src, dest, opts) {
      const statSync = opts.dereference ? fs29.statSync : fs29.lstatSync;
      const srcStat = statSync(src);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src, dest, opts);
      else if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts);
      else if (srcStat.isSocket())
        throw new Error(`Cannot copy a socket file: ${src}`);
      else if (srcStat.isFIFO())
        throw new Error(`Cannot copy a FIFO pipe: ${src}`);
      throw new Error(`Unknown file: ${src}`);
    }
    function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return copyFile(srcStat, src, dest, opts);
      return mayCopyFile(srcStat, src, dest, opts);
    }
    function mayCopyFile(srcStat, src, dest, opts) {
      if (opts.overwrite) {
        fs29.unlinkSync(dest);
        return copyFile(srcStat, src, dest, opts);
      } else if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    function copyFile(srcStat, src, dest, opts) {
      fs29.copyFileSync(src, dest);
      if (opts.preserveTimestamps)
        handleTimestamps(srcStat.mode, src, dest);
      return setDestMode(dest, srcStat.mode);
    }
    function handleTimestamps(srcMode, src, dest) {
      if (fileIsNotWritable(srcMode))
        makeFileWritable(dest, srcMode);
      return setDestTimestamps(src, dest);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return setDestMode(dest, srcMode | 128);
    }
    function setDestMode(dest, srcMode) {
      return fs29.chmodSync(dest, srcMode);
    }
    function setDestTimestamps(src, dest) {
      const updatedSrcStat = fs29.statSync(src);
      return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return mkDirAndCopy(srcStat.mode, src, dest, opts);
      return copyDir(src, dest, opts);
    }
    function mkDirAndCopy(srcMode, src, dest, opts) {
      fs29.mkdirSync(dest);
      copyDir(src, dest, opts);
      return setDestMode(dest, srcMode);
    }
    function copyDir(src, dest, opts) {
      fs29.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
    }
    function copyDirItem(item, src, dest, opts) {
      const srcItem = path41.join(src, item);
      const destItem = path41.join(dest, item);
      const { destStat } = stat.checkPathsSync(srcItem, destItem, "copy", opts);
      return startCopy(destStat, srcItem, destItem, opts);
    }
    function onLink(destStat, src, dest, opts) {
      let resolvedSrc = fs29.readlinkSync(src);
      if (opts.dereference) {
        resolvedSrc = path41.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs29.symlinkSync(resolvedSrc, dest);
      } else {
        let resolvedDest;
        try {
          resolvedDest = fs29.readlinkSync(dest);
        } catch (err) {
          if (err.code === "EINVAL" || err.code === "UNKNOWN")
            return fs29.symlinkSync(resolvedSrc, dest);
          throw err;
        }
        if (opts.dereference) {
          resolvedDest = path41.resolve(process.cwd(), resolvedDest);
        }
        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
        }
        if (fs29.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
        }
        return copyLink(resolvedSrc, dest);
      }
    }
    function copyLink(resolvedSrc, dest) {
      fs29.unlinkSync(dest);
      return fs29.symlinkSync(resolvedSrc, dest);
    }
    module2.exports = copySync;
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/copy-sync/index.js
var require_copy_sync2 = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/copy-sync/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      copySync: require_copy_sync()
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/path-exists/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs29 = require_fs();
    function pathExists(path41) {
      return fs29.access(path41).then(() => true).catch(() => false);
    }
    module2.exports = {
      pathExists: u(pathExists),
      pathExistsSync: fs29.existsSync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/copy/copy.js
var require_copy = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/copy/copy.js"(exports, module2) {
    "use strict";
    var fs29 = require_graceful_fs();
    var path41 = require("path");
    var mkdirs = require_mkdirs().mkdirs;
    var pathExists = require_path_exists().pathExists;
    var utimesMillis = require_utimes().utimesMillis;
    var stat = require_stat();
    function copy(src, dest, opts, cb) {
      if (typeof opts === "function" && !cb) {
        cb = opts;
        opts = {};
      } else if (typeof opts === "function") {
        opts = { filter: opts };
      }
      cb = cb || function() {
      };
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
      }
      stat.checkPaths(src, dest, "copy", opts, (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, destStat } = stats;
        stat.checkParentPaths(src, srcStat, dest, "copy", (err2) => {
          if (err2)
            return cb(err2);
          if (opts.filter)
            return handleFilter(checkParentDir, destStat, src, dest, opts, cb);
          return checkParentDir(destStat, src, dest, opts, cb);
        });
      });
    }
    function checkParentDir(destStat, src, dest, opts, cb) {
      const destParent = path41.dirname(dest);
      pathExists(destParent, (err, dirExists) => {
        if (err)
          return cb(err);
        if (dirExists)
          return getStats(destStat, src, dest, opts, cb);
        mkdirs(destParent, (err2) => {
          if (err2)
            return cb(err2);
          return getStats(destStat, src, dest, opts, cb);
        });
      });
    }
    function handleFilter(onInclude, destStat, src, dest, opts, cb) {
      Promise.resolve(opts.filter(src, dest)).then((include) => {
        if (include)
          return onInclude(destStat, src, dest, opts, cb);
        return cb();
      }, (error) => cb(error));
    }
    function startCopy(destStat, src, dest, opts, cb) {
      if (opts.filter)
        return handleFilter(getStats, destStat, src, dest, opts, cb);
      return getStats(destStat, src, dest, opts, cb);
    }
    function getStats(destStat, src, dest, opts, cb) {
      const stat2 = opts.dereference ? fs29.stat : fs29.lstat;
      stat2(src, (err, srcStat) => {
        if (err)
          return cb(err);
        if (srcStat.isDirectory())
          return onDir(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
          return onFile(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isSymbolicLink())
          return onLink(destStat, src, dest, opts, cb);
        else if (srcStat.isSocket())
          return cb(new Error(`Cannot copy a socket file: ${src}`));
        else if (srcStat.isFIFO())
          return cb(new Error(`Cannot copy a FIFO pipe: ${src}`));
        return cb(new Error(`Unknown file: ${src}`));
      });
    }
    function onFile(srcStat, destStat, src, dest, opts, cb) {
      if (!destStat)
        return copyFile(srcStat, src, dest, opts, cb);
      return mayCopyFile(srcStat, src, dest, opts, cb);
    }
    function mayCopyFile(srcStat, src, dest, opts, cb) {
      if (opts.overwrite) {
        fs29.unlink(dest, (err) => {
          if (err)
            return cb(err);
          return copyFile(srcStat, src, dest, opts, cb);
        });
      } else if (opts.errorOnExist) {
        return cb(new Error(`'${dest}' already exists`));
      } else
        return cb();
    }
    function copyFile(srcStat, src, dest, opts, cb) {
      fs29.copyFile(src, dest, (err) => {
        if (err)
          return cb(err);
        if (opts.preserveTimestamps)
          return handleTimestampsAndMode(srcStat.mode, src, dest, cb);
        return setDestMode(dest, srcStat.mode, cb);
      });
    }
    function handleTimestampsAndMode(srcMode, src, dest, cb) {
      if (fileIsNotWritable(srcMode)) {
        return makeFileWritable(dest, srcMode, (err) => {
          if (err)
            return cb(err);
          return setDestTimestampsAndMode(srcMode, src, dest, cb);
        });
      }
      return setDestTimestampsAndMode(srcMode, src, dest, cb);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode, cb) {
      return setDestMode(dest, srcMode | 128, cb);
    }
    function setDestTimestampsAndMode(srcMode, src, dest, cb) {
      setDestTimestamps(src, dest, (err) => {
        if (err)
          return cb(err);
        return setDestMode(dest, srcMode, cb);
      });
    }
    function setDestMode(dest, srcMode, cb) {
      return fs29.chmod(dest, srcMode, cb);
    }
    function setDestTimestamps(src, dest, cb) {
      fs29.stat(src, (err, updatedSrcStat) => {
        if (err)
          return cb(err);
        return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
      });
    }
    function onDir(srcStat, destStat, src, dest, opts, cb) {
      if (!destStat)
        return mkDirAndCopy(srcStat.mode, src, dest, opts, cb);
      return copyDir(src, dest, opts, cb);
    }
    function mkDirAndCopy(srcMode, src, dest, opts, cb) {
      fs29.mkdir(dest, (err) => {
        if (err)
          return cb(err);
        copyDir(src, dest, opts, (err2) => {
          if (err2)
            return cb(err2);
          return setDestMode(dest, srcMode, cb);
        });
      });
    }
    function copyDir(src, dest, opts, cb) {
      fs29.readdir(src, (err, items) => {
        if (err)
          return cb(err);
        return copyDirItems(items, src, dest, opts, cb);
      });
    }
    function copyDirItems(items, src, dest, opts, cb) {
      const item = items.pop();
      if (!item)
        return cb();
      return copyDirItem(items, item, src, dest, opts, cb);
    }
    function copyDirItem(items, item, src, dest, opts, cb) {
      const srcItem = path41.join(src, item);
      const destItem = path41.join(dest, item);
      stat.checkPaths(srcItem, destItem, "copy", opts, (err, stats) => {
        if (err)
          return cb(err);
        const { destStat } = stats;
        startCopy(destStat, srcItem, destItem, opts, (err2) => {
          if (err2)
            return cb(err2);
          return copyDirItems(items, src, dest, opts, cb);
        });
      });
    }
    function onLink(destStat, src, dest, opts, cb) {
      fs29.readlink(src, (err, resolvedSrc) => {
        if (err)
          return cb(err);
        if (opts.dereference) {
          resolvedSrc = path41.resolve(process.cwd(), resolvedSrc);
        }
        if (!destStat) {
          return fs29.symlink(resolvedSrc, dest, cb);
        } else {
          fs29.readlink(dest, (err2, resolvedDest) => {
            if (err2) {
              if (err2.code === "EINVAL" || err2.code === "UNKNOWN")
                return fs29.symlink(resolvedSrc, dest, cb);
              return cb(err2);
            }
            if (opts.dereference) {
              resolvedDest = path41.resolve(process.cwd(), resolvedDest);
            }
            if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
              return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
            }
            if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
              return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
            }
            return copyLink(resolvedSrc, dest, cb);
          });
        }
      });
    }
    function copyLink(resolvedSrc, dest, cb) {
      fs29.unlink(dest, (err) => {
        if (err)
          return cb(err);
        return fs29.symlink(resolvedSrc, dest, cb);
      });
    }
    module2.exports = copy;
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/copy/index.js
var require_copy2 = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/copy/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    module2.exports = {
      copy: u(require_copy())
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/remove/rimraf.js
var require_rimraf = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/remove/rimraf.js"(exports, module2) {
    "use strict";
    var fs29 = require_graceful_fs();
    var path41 = require("path");
    var assert = require("assert");
    var isWindows3 = process.platform === "win32";
    function defaults3(options2) {
      const methods2 = [
        "unlink",
        "chmod",
        "stat",
        "lstat",
        "rmdir",
        "readdir"
      ];
      methods2.forEach((m) => {
        options2[m] = options2[m] || fs29[m];
        m = m + "Sync";
        options2[m] = options2[m] || fs29[m];
      });
      options2.maxBusyTries = options2.maxBusyTries || 3;
    }
    function rimraf(p, options2, cb) {
      let busyTries = 0;
      if (typeof options2 === "function") {
        cb = options2;
        options2 = {};
      }
      assert(p, "rimraf: missing path");
      assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
      assert.strictEqual(typeof cb, "function", "rimraf: callback function required");
      assert(options2, "rimraf: invalid options argument provided");
      assert.strictEqual(typeof options2, "object", "rimraf: options should be object");
      defaults3(options2);
      rimraf_(p, options2, function CB(er) {
        if (er) {
          if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options2.maxBusyTries) {
            busyTries++;
            const time = busyTries * 100;
            return setTimeout(() => rimraf_(p, options2, CB), time);
          }
          if (er.code === "ENOENT")
            er = null;
        }
        cb(er);
      });
    }
    function rimraf_(p, options2, cb) {
      assert(p);
      assert(options2);
      assert(typeof cb === "function");
      options2.lstat(p, (er, st) => {
        if (er && er.code === "ENOENT") {
          return cb(null);
        }
        if (er && er.code === "EPERM" && isWindows3) {
          return fixWinEPERM(p, options2, er, cb);
        }
        if (st && st.isDirectory()) {
          return rmdir(p, options2, er, cb);
        }
        options2.unlink(p, (er2) => {
          if (er2) {
            if (er2.code === "ENOENT") {
              return cb(null);
            }
            if (er2.code === "EPERM") {
              return isWindows3 ? fixWinEPERM(p, options2, er2, cb) : rmdir(p, options2, er2, cb);
            }
            if (er2.code === "EISDIR") {
              return rmdir(p, options2, er2, cb);
            }
          }
          return cb(er2);
        });
      });
    }
    function fixWinEPERM(p, options2, er, cb) {
      assert(p);
      assert(options2);
      assert(typeof cb === "function");
      options2.chmod(p, 438, (er2) => {
        if (er2) {
          cb(er2.code === "ENOENT" ? null : er);
        } else {
          options2.stat(p, (er3, stats) => {
            if (er3) {
              cb(er3.code === "ENOENT" ? null : er);
            } else if (stats.isDirectory()) {
              rmdir(p, options2, er, cb);
            } else {
              options2.unlink(p, cb);
            }
          });
        }
      });
    }
    function fixWinEPERMSync(p, options2, er) {
      let stats;
      assert(p);
      assert(options2);
      try {
        options2.chmodSync(p, 438);
      } catch (er2) {
        if (er2.code === "ENOENT") {
          return;
        } else {
          throw er;
        }
      }
      try {
        stats = options2.statSync(p);
      } catch (er3) {
        if (er3.code === "ENOENT") {
          return;
        } else {
          throw er;
        }
      }
      if (stats.isDirectory()) {
        rmdirSync(p, options2, er);
      } else {
        options2.unlinkSync(p);
      }
    }
    function rmdir(p, options2, originalEr, cb) {
      assert(p);
      assert(options2);
      assert(typeof cb === "function");
      options2.rmdir(p, (er) => {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
          rmkids(p, options2, cb);
        } else if (er && er.code === "ENOTDIR") {
          cb(originalEr);
        } else {
          cb(er);
        }
      });
    }
    function rmkids(p, options2, cb) {
      assert(p);
      assert(options2);
      assert(typeof cb === "function");
      options2.readdir(p, (er, files) => {
        if (er)
          return cb(er);
        let n = files.length;
        let errState;
        if (n === 0)
          return options2.rmdir(p, cb);
        files.forEach((f) => {
          rimraf(path41.join(p, f), options2, (er2) => {
            if (errState) {
              return;
            }
            if (er2)
              return cb(errState = er2);
            if (--n === 0) {
              options2.rmdir(p, cb);
            }
          });
        });
      });
    }
    function rimrafSync(p, options2) {
      let st;
      options2 = options2 || {};
      defaults3(options2);
      assert(p, "rimraf: missing path");
      assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
      assert(options2, "rimraf: missing options");
      assert.strictEqual(typeof options2, "object", "rimraf: options should be object");
      try {
        st = options2.lstatSync(p);
      } catch (er) {
        if (er.code === "ENOENT") {
          return;
        }
        if (er.code === "EPERM" && isWindows3) {
          fixWinEPERMSync(p, options2, er);
        }
      }
      try {
        if (st && st.isDirectory()) {
          rmdirSync(p, options2, null);
        } else {
          options2.unlinkSync(p);
        }
      } catch (er) {
        if (er.code === "ENOENT") {
          return;
        } else if (er.code === "EPERM") {
          return isWindows3 ? fixWinEPERMSync(p, options2, er) : rmdirSync(p, options2, er);
        } else if (er.code !== "EISDIR") {
          throw er;
        }
        rmdirSync(p, options2, er);
      }
    }
    function rmdirSync(p, options2, originalEr) {
      assert(p);
      assert(options2);
      try {
        options2.rmdirSync(p);
      } catch (er) {
        if (er.code === "ENOTDIR") {
          throw originalEr;
        } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
          rmkidsSync(p, options2);
        } else if (er.code !== "ENOENT") {
          throw er;
        }
      }
    }
    function rmkidsSync(p, options2) {
      assert(p);
      assert(options2);
      options2.readdirSync(p).forEach((f) => rimrafSync(path41.join(p, f), options2));
      if (isWindows3) {
        const startTime = Date.now();
        do {
          try {
            const ret = options2.rmdirSync(p, options2);
            return ret;
          } catch {
          }
        } while (Date.now() - startTime < 500);
      } else {
        const ret = options2.rmdirSync(p, options2);
        return ret;
      }
    }
    module2.exports = rimraf;
    rimraf.sync = rimrafSync;
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/remove/index.js
var require_remove = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/remove/index.js"(exports, module2) {
    "use strict";
    var fs29 = require_graceful_fs();
    var u = require_universalify().fromCallback;
    var rimraf = require_rimraf();
    function remove(path41, callback) {
      if (fs29.rm)
        return fs29.rm(path41, { recursive: true, force: true }, callback);
      rimraf(path41, callback);
    }
    function removeSync(path41) {
      if (fs29.rmSync)
        return fs29.rmSync(path41, { recursive: true, force: true });
      rimraf.sync(path41);
    }
    module2.exports = {
      remove: u(remove),
      removeSync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/empty/index.js
var require_empty = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/empty/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs29 = require_fs();
    var path41 = require("path");
    var mkdir = require_mkdirs();
    var remove = require_remove();
    var emptyDir = u(async function emptyDir2(dir) {
      let items;
      try {
        items = await fs29.readdir(dir);
      } catch {
        return mkdir.mkdirs(dir);
      }
      return Promise.all(items.map((item) => remove.remove(path41.join(dir, item))));
    });
    function emptyDirSync(dir) {
      let items;
      try {
        items = fs29.readdirSync(dir);
      } catch {
        return mkdir.mkdirsSync(dir);
      }
      items.forEach((item) => {
        item = path41.join(dir, item);
        remove.removeSync(item);
      });
    }
    module2.exports = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir,
      emptydir: emptyDir
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/ensure/file.js
var require_file = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/ensure/file.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path41 = require("path");
    var fs29 = require_graceful_fs();
    var mkdir = require_mkdirs();
    function createFile(file, callback) {
      function makeFile() {
        fs29.writeFile(file, "", (err) => {
          if (err)
            return callback(err);
          callback();
        });
      }
      fs29.stat(file, (err, stats) => {
        if (!err && stats.isFile())
          return callback();
        const dir = path41.dirname(file);
        fs29.stat(dir, (err2, stats2) => {
          if (err2) {
            if (err2.code === "ENOENT") {
              return mkdir.mkdirs(dir, (err3) => {
                if (err3)
                  return callback(err3);
                makeFile();
              });
            }
            return callback(err2);
          }
          if (stats2.isDirectory())
            makeFile();
          else {
            fs29.readdir(dir, (err3) => {
              if (err3)
                return callback(err3);
            });
          }
        });
      });
    }
    function createFileSync(file) {
      let stats;
      try {
        stats = fs29.statSync(file);
      } catch {
      }
      if (stats && stats.isFile())
        return;
      const dir = path41.dirname(file);
      try {
        if (!fs29.statSync(dir).isDirectory()) {
          fs29.readdirSync(dir);
        }
      } catch (err) {
        if (err && err.code === "ENOENT")
          mkdir.mkdirsSync(dir);
        else
          throw err;
      }
      fs29.writeFileSync(file, "");
    }
    module2.exports = {
      createFile: u(createFile),
      createFileSync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/ensure/link.js
var require_link = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/ensure/link.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path41 = require("path");
    var fs29 = require_graceful_fs();
    var mkdir = require_mkdirs();
    var pathExists = require_path_exists().pathExists;
    var { areIdentical } = require_stat();
    function createLink(srcpath, dstpath, callback) {
      function makeLink(srcpath2, dstpath2) {
        fs29.link(srcpath2, dstpath2, (err) => {
          if (err)
            return callback(err);
          callback(null);
        });
      }
      fs29.lstat(dstpath, (_, dstStat) => {
        fs29.lstat(srcpath, (err, srcStat) => {
          if (err) {
            err.message = err.message.replace("lstat", "ensureLink");
            return callback(err);
          }
          if (dstStat && areIdentical(srcStat, dstStat))
            return callback(null);
          const dir = path41.dirname(dstpath);
          pathExists(dir, (err2, dirExists) => {
            if (err2)
              return callback(err2);
            if (dirExists)
              return makeLink(srcpath, dstpath);
            mkdir.mkdirs(dir, (err3) => {
              if (err3)
                return callback(err3);
              makeLink(srcpath, dstpath);
            });
          });
        });
      });
    }
    function createLinkSync(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = fs29.lstatSync(dstpath);
      } catch {
      }
      try {
        const srcStat = fs29.lstatSync(srcpath);
        if (dstStat && areIdentical(srcStat, dstStat))
          return;
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      const dir = path41.dirname(dstpath);
      const dirExists = fs29.existsSync(dir);
      if (dirExists)
        return fs29.linkSync(srcpath, dstpath);
      mkdir.mkdirsSync(dir);
      return fs29.linkSync(srcpath, dstpath);
    }
    module2.exports = {
      createLink: u(createLink),
      createLinkSync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports, module2) {
    "use strict";
    var path41 = require("path");
    var fs29 = require_graceful_fs();
    var pathExists = require_path_exists().pathExists;
    function symlinkPaths(srcpath, dstpath, callback) {
      if (path41.isAbsolute(srcpath)) {
        return fs29.lstat(srcpath, (err) => {
          if (err) {
            err.message = err.message.replace("lstat", "ensureSymlink");
            return callback(err);
          }
          return callback(null, {
            toCwd: srcpath,
            toDst: srcpath
          });
        });
      } else {
        const dstdir = path41.dirname(dstpath);
        const relativeToDst = path41.join(dstdir, srcpath);
        return pathExists(relativeToDst, (err, exists) => {
          if (err)
            return callback(err);
          if (exists) {
            return callback(null, {
              toCwd: relativeToDst,
              toDst: srcpath
            });
          } else {
            return fs29.lstat(srcpath, (err2) => {
              if (err2) {
                err2.message = err2.message.replace("lstat", "ensureSymlink");
                return callback(err2);
              }
              return callback(null, {
                toCwd: srcpath,
                toDst: path41.relative(dstdir, srcpath)
              });
            });
          }
        });
      }
    }
    function symlinkPathsSync(srcpath, dstpath) {
      let exists;
      if (path41.isAbsolute(srcpath)) {
        exists = fs29.existsSync(srcpath);
        if (!exists)
          throw new Error("absolute srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      } else {
        const dstdir = path41.dirname(dstpath);
        const relativeToDst = path41.join(dstdir, srcpath);
        exists = fs29.existsSync(relativeToDst);
        if (exists) {
          return {
            toCwd: relativeToDst,
            toDst: srcpath
          };
        } else {
          exists = fs29.existsSync(srcpath);
          if (!exists)
            throw new Error("relative srcpath does not exist");
          return {
            toCwd: srcpath,
            toDst: path41.relative(dstdir, srcpath)
          };
        }
      }
    }
    module2.exports = {
      symlinkPaths,
      symlinkPathsSync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink-type.js"(exports, module2) {
    "use strict";
    var fs29 = require_graceful_fs();
    function symlinkType(srcpath, type, callback) {
      callback = typeof type === "function" ? type : callback;
      type = typeof type === "function" ? false : type;
      if (type)
        return callback(null, type);
      fs29.lstat(srcpath, (err, stats) => {
        if (err)
          return callback(null, "file");
        type = stats && stats.isDirectory() ? "dir" : "file";
        callback(null, type);
      });
    }
    function symlinkTypeSync(srcpath, type) {
      let stats;
      if (type)
        return type;
      try {
        stats = fs29.lstatSync(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    module2.exports = {
      symlinkType,
      symlinkTypeSync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/ensure/symlink.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path41 = require("path");
    var fs29 = require_fs();
    var _mkdirs = require_mkdirs();
    var mkdirs = _mkdirs.mkdirs;
    var mkdirsSync = _mkdirs.mkdirsSync;
    var _symlinkPaths = require_symlink_paths();
    var symlinkPaths = _symlinkPaths.symlinkPaths;
    var symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
    var _symlinkType = require_symlink_type();
    var symlinkType = _symlinkType.symlinkType;
    var symlinkTypeSync = _symlinkType.symlinkTypeSync;
    var pathExists = require_path_exists().pathExists;
    var { areIdentical } = require_stat();
    function createSymlink(srcpath, dstpath, type, callback) {
      callback = typeof type === "function" ? type : callback;
      type = typeof type === "function" ? false : type;
      fs29.lstat(dstpath, (err, stats) => {
        if (!err && stats.isSymbolicLink()) {
          Promise.all([
            fs29.stat(srcpath),
            fs29.stat(dstpath)
          ]).then(([srcStat, dstStat]) => {
            if (areIdentical(srcStat, dstStat))
              return callback(null);
            _createSymlink(srcpath, dstpath, type, callback);
          });
        } else
          _createSymlink(srcpath, dstpath, type, callback);
      });
    }
    function _createSymlink(srcpath, dstpath, type, callback) {
      symlinkPaths(srcpath, dstpath, (err, relative) => {
        if (err)
          return callback(err);
        srcpath = relative.toDst;
        symlinkType(relative.toCwd, type, (err2, type2) => {
          if (err2)
            return callback(err2);
          const dir = path41.dirname(dstpath);
          pathExists(dir, (err3, dirExists) => {
            if (err3)
              return callback(err3);
            if (dirExists)
              return fs29.symlink(srcpath, dstpath, type2, callback);
            mkdirs(dir, (err4) => {
              if (err4)
                return callback(err4);
              fs29.symlink(srcpath, dstpath, type2, callback);
            });
          });
        });
      });
    }
    function createSymlinkSync(srcpath, dstpath, type) {
      let stats;
      try {
        stats = fs29.lstatSync(dstpath);
      } catch {
      }
      if (stats && stats.isSymbolicLink()) {
        const srcStat = fs29.statSync(srcpath);
        const dstStat = fs29.statSync(dstpath);
        if (areIdentical(srcStat, dstStat))
          return;
      }
      const relative = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative.toDst;
      type = symlinkTypeSync(relative.toCwd, type);
      const dir = path41.dirname(dstpath);
      const exists = fs29.existsSync(dir);
      if (exists)
        return fs29.symlinkSync(srcpath, dstpath, type);
      mkdirsSync(dir);
      return fs29.symlinkSync(srcpath, dstpath, type);
    }
    module2.exports = {
      createSymlink: u(createSymlink),
      createSymlinkSync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/ensure/index.js
var require_ensure = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/ensure/index.js"(exports, module2) {
    "use strict";
    var file = require_file();
    var link = require_link();
    var symlink = require_symlink();
    module2.exports = {
      createFile: file.createFile,
      createFileSync: file.createFileSync,
      ensureFile: file.createFile,
      ensureFileSync: file.createFileSync,
      createLink: link.createLink,
      createLinkSync: link.createLinkSync,
      ensureLink: link.createLink,
      ensureLinkSync: link.createLinkSync,
      createSymlink: symlink.createSymlink,
      createSymlinkSync: symlink.createSymlinkSync,
      ensureSymlink: symlink.createSymlink,
      ensureSymlinkSync: symlink.createSymlinkSync
    };
  }
});

// node_modules/jsonfile/utils.js
var require_utils2 = __commonJS({
  "node_modules/jsonfile/utils.js"(exports, module2) {
    function stringify2(obj, { EOL: EOL2 = "\n", finalEOL = true, replacer = null, spaces } = {}) {
      const EOF = finalEOL ? EOL2 : "";
      const str = JSON.stringify(obj, replacer, spaces);
      return str.replace(/\n/g, EOL2) + EOF;
    }
    function stripBom(content) {
      if (Buffer.isBuffer(content))
        content = content.toString("utf8");
      return content.replace(/^\uFEFF/, "");
    }
    module2.exports = { stringify: stringify2, stripBom };
  }
});

// node_modules/jsonfile/index.js
var require_jsonfile = __commonJS({
  "node_modules/jsonfile/index.js"(exports, module2) {
    var _fs;
    try {
      _fs = require_graceful_fs();
    } catch (_) {
      _fs = require("fs");
    }
    var universalify = require_universalify();
    var { stringify: stringify2, stripBom } = require_utils2();
    async function _readFile(file, options2 = {}) {
      if (typeof options2 === "string") {
        options2 = { encoding: options2 };
      }
      const fs29 = options2.fs || _fs;
      const shouldThrow = "throws" in options2 ? options2.throws : true;
      let data = await universalify.fromCallback(fs29.readFile)(file, options2);
      data = stripBom(data);
      let obj;
      try {
        obj = JSON.parse(data, options2 ? options2.reviver : null);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
      return obj;
    }
    var readFile2 = universalify.fromPromise(_readFile);
    function readFileSync(file, options2 = {}) {
      if (typeof options2 === "string") {
        options2 = { encoding: options2 };
      }
      const fs29 = options2.fs || _fs;
      const shouldThrow = "throws" in options2 ? options2.throws : true;
      try {
        let content = fs29.readFileSync(file, options2);
        content = stripBom(content);
        return JSON.parse(content, options2.reviver);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
    }
    async function _writeFile(file, obj, options2 = {}) {
      const fs29 = options2.fs || _fs;
      const str = stringify2(obj, options2);
      await universalify.fromCallback(fs29.writeFile)(file, str, options2);
    }
    var writeFile2 = universalify.fromPromise(_writeFile);
    function writeFileSync(file, obj, options2 = {}) {
      const fs29 = options2.fs || _fs;
      const str = stringify2(obj, options2);
      return fs29.writeFileSync(file, str, options2);
    }
    var jsonfile = {
      readFile: readFile2,
      readFileSync,
      writeFile: writeFile2,
      writeFileSync
    };
    module2.exports = jsonfile;
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/json/jsonfile.js"(exports, module2) {
    "use strict";
    var jsonFile = require_jsonfile();
    module2.exports = {
      readJson: jsonFile.readFile,
      readJsonSync: jsonFile.readFileSync,
      writeJson: jsonFile.writeFile,
      writeJsonSync: jsonFile.writeFileSync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/output/index.js
var require_output = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/output/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs29 = require_graceful_fs();
    var path41 = require("path");
    var mkdir = require_mkdirs();
    var pathExists = require_path_exists().pathExists;
    function outputFile(file, data, encoding, callback) {
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = "utf8";
      }
      const dir = path41.dirname(file);
      pathExists(dir, (err, itDoes) => {
        if (err)
          return callback(err);
        if (itDoes)
          return fs29.writeFile(file, data, encoding, callback);
        mkdir.mkdirs(dir, (err2) => {
          if (err2)
            return callback(err2);
          fs29.writeFile(file, data, encoding, callback);
        });
      });
    }
    function outputFileSync(file, ...args) {
      const dir = path41.dirname(file);
      if (fs29.existsSync(dir)) {
        return fs29.writeFileSync(file, ...args);
      }
      mkdir.mkdirsSync(dir);
      fs29.writeFileSync(file, ...args);
    }
    module2.exports = {
      outputFile: u(outputFile),
      outputFileSync
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/json/output-json.js
var require_output_json = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/json/output-json.js"(exports, module2) {
    "use strict";
    var { stringify: stringify2 } = require_utils2();
    var { outputFile } = require_output();
    async function outputJson(file, data, options2 = {}) {
      const str = stringify2(data, options2);
      await outputFile(file, str, options2);
    }
    module2.exports = outputJson;
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/json/output-json-sync.js"(exports, module2) {
    "use strict";
    var { stringify: stringify2 } = require_utils2();
    var { outputFileSync } = require_output();
    function outputJsonSync(file, data, options2) {
      const str = stringify2(data, options2);
      outputFileSync(file, str, options2);
    }
    module2.exports = outputJsonSync;
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/json/index.js
var require_json = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/json/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var jsonFile = require_jsonfile2();
    jsonFile.outputJson = u(require_output_json());
    jsonFile.outputJsonSync = require_output_json_sync();
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    module2.exports = jsonFile;
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/move-sync/move-sync.js
var require_move_sync = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/move-sync/move-sync.js"(exports, module2) {
    "use strict";
    var fs29 = require_graceful_fs();
    var path41 = require("path");
    var copySync = require_copy_sync2().copySync;
    var removeSync = require_remove().removeSync;
    var mkdirpSync = require_mkdirs().mkdirpSync;
    var stat = require_stat();
    function moveSync(src, dest, opts) {
      opts = opts || {};
      const overwrite = opts.overwrite || opts.clobber || false;
      const { srcStat, isChangingCase = false } = stat.checkPathsSync(src, dest, "move", opts);
      stat.checkParentPathsSync(src, srcStat, dest, "move");
      if (!isParentRoot(dest))
        mkdirpSync(path41.dirname(dest));
      return doRename(src, dest, overwrite, isChangingCase);
    }
    function isParentRoot(dest) {
      const parent = path41.dirname(dest);
      const parsedPath = path41.parse(parent);
      return parsedPath.root === parent;
    }
    function doRename(src, dest, overwrite, isChangingCase) {
      if (isChangingCase)
        return rename(src, dest, overwrite);
      if (overwrite) {
        removeSync(dest);
        return rename(src, dest, overwrite);
      }
      if (fs29.existsSync(dest))
        throw new Error("dest already exists.");
      return rename(src, dest, overwrite);
    }
    function rename(src, dest, overwrite) {
      try {
        fs29.renameSync(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV")
          throw err;
        return moveAcrossDevice(src, dest, overwrite);
      }
    }
    function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true
      };
      copySync(src, dest, opts);
      return removeSync(src);
    }
    module2.exports = moveSync;
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/move-sync/index.js
var require_move_sync2 = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/move-sync/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      moveSync: require_move_sync()
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/move/move.js
var require_move = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/move/move.js"(exports, module2) {
    "use strict";
    var fs29 = require_graceful_fs();
    var path41 = require("path");
    var copy = require_copy2().copy;
    var remove = require_remove().remove;
    var mkdirp = require_mkdirs().mkdirp;
    var pathExists = require_path_exists().pathExists;
    var stat = require_stat();
    function move(src, dest, opts, cb) {
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      const overwrite = opts.overwrite || opts.clobber || false;
      stat.checkPaths(src, dest, "move", opts, (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, isChangingCase = false } = stats;
        stat.checkParentPaths(src, srcStat, dest, "move", (err2) => {
          if (err2)
            return cb(err2);
          if (isParentRoot(dest))
            return doRename(src, dest, overwrite, isChangingCase, cb);
          mkdirp(path41.dirname(dest), (err3) => {
            if (err3)
              return cb(err3);
            return doRename(src, dest, overwrite, isChangingCase, cb);
          });
        });
      });
    }
    function isParentRoot(dest) {
      const parent = path41.dirname(dest);
      const parsedPath = path41.parse(parent);
      return parsedPath.root === parent;
    }
    function doRename(src, dest, overwrite, isChangingCase, cb) {
      if (isChangingCase)
        return rename(src, dest, overwrite, cb);
      if (overwrite) {
        return remove(dest, (err) => {
          if (err)
            return cb(err);
          return rename(src, dest, overwrite, cb);
        });
      }
      pathExists(dest, (err, destExists) => {
        if (err)
          return cb(err);
        if (destExists)
          return cb(new Error("dest already exists."));
        return rename(src, dest, overwrite, cb);
      });
    }
    function rename(src, dest, overwrite, cb) {
      fs29.rename(src, dest, (err) => {
        if (!err)
          return cb();
        if (err.code !== "EXDEV")
          return cb(err);
        return moveAcrossDevice(src, dest, overwrite, cb);
      });
    }
    function moveAcrossDevice(src, dest, overwrite, cb) {
      const opts = {
        overwrite,
        errorOnExist: true
      };
      copy(src, dest, opts, (err) => {
        if (err)
          return cb(err);
        return remove(src, cb);
      });
    }
    module2.exports = move;
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/move/index.js
var require_move2 = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/move/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    module2.exports = {
      move: u(require_move())
    };
  }
});

// node_modules/streamroller/node_modules/fs-extra/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/streamroller/node_modules/fs-extra/lib/index.js"(exports, module2) {
    "use strict";
    module2.exports = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, require_fs()), require_copy_sync2()), require_copy2()), require_empty()), require_ensure()), require_json()), require_mkdirs()), require_move_sync2()), require_move2()), require_output()), require_path_exists()), require_remove());
  }
});

// node_modules/streamroller/lib/now.js
var require_now = __commonJS({
  "node_modules/streamroller/lib/now.js"(exports, module2) {
    module2.exports = () => new Date();
  }
});

// node_modules/streamroller/lib/fileNameFormatter.js
var require_fileNameFormatter = __commonJS({
  "node_modules/streamroller/lib/fileNameFormatter.js"(exports, module2) {
    var debug = require_src()("streamroller:fileNameFormatter");
    var path41 = require("path");
    var ZIP_EXT = ".gz";
    var DEFAULT_FILENAME_SEP = ".";
    module2.exports = ({
      file,
      keepFileExt,
      needsIndex,
      alwaysIncludeDate,
      compress,
      fileNameSep
    }) => {
      let FILENAME_SEP = fileNameSep || DEFAULT_FILENAME_SEP;
      const dirAndName = path41.join(file.dir, file.name);
      const ext = (f) => f + file.ext;
      const index = (f, i, d) => (needsIndex || !d) && i ? f + FILENAME_SEP + i : f;
      const date = (f, i, d) => {
        return (i > 0 || alwaysIncludeDate) && d ? f + FILENAME_SEP + d : f;
      };
      const gzip = (f, i) => i && compress ? f + ZIP_EXT : f;
      const parts = keepFileExt ? [date, index, ext, gzip] : [ext, date, index, gzip];
      return ({ date: date2, index: index2 }) => {
        debug(`_formatFileName: date=${date2}, index=${index2}`);
        return parts.reduce((filename, part) => part(filename, index2, date2), dirAndName);
      };
    };
  }
});

// node_modules/streamroller/lib/fileNameParser.js
var require_fileNameParser = __commonJS({
  "node_modules/streamroller/lib/fileNameParser.js"(exports, module2) {
    var debug = require_src()("streamroller:fileNameParser");
    var ZIP_EXT = ".gz";
    var format2 = require_lib();
    var DEFAULT_FILENAME_SEP = ".";
    module2.exports = ({ file, keepFileExt, pattern, fileNameSep }) => {
      let FILENAME_SEP = fileNameSep || DEFAULT_FILENAME_SEP;
      const zip = (f, p) => {
        if (f.endsWith(ZIP_EXT)) {
          debug("it is gzipped");
          p.isCompressed = true;
          return f.slice(0, -1 * ZIP_EXT.length);
        }
        return f;
      };
      const __NOT_MATCHING__ = "__NOT_MATCHING__";
      const extAtEnd = (f) => {
        if (f.startsWith(file.name) && f.endsWith(file.ext)) {
          debug("it starts and ends with the right things");
          return f.slice(file.name.length + 1, -1 * file.ext.length);
        }
        return __NOT_MATCHING__;
      };
      const extInMiddle = (f) => {
        if (f.startsWith(file.base)) {
          debug("it starts with the right things");
          return f.slice(file.base.length + 1);
        }
        return __NOT_MATCHING__;
      };
      const dateAndIndex = (f, p) => {
        const items = f.split(FILENAME_SEP);
        let indexStr = items[items.length - 1];
        debug("items: ", items, ", indexStr: ", indexStr);
        let dateStr = f;
        if (indexStr !== void 0 && indexStr.match(/^\d+$/)) {
          dateStr = f.slice(0, -1 * (indexStr.length + 1));
          debug(`dateStr is ${dateStr}`);
          if (pattern && !dateStr) {
            dateStr = indexStr;
            indexStr = "0";
          }
        } else {
          indexStr = "0";
        }
        try {
          const date = format2.parse(pattern, dateStr, new Date(0, 0));
          if (format2.asString(pattern, date) !== dateStr)
            return f;
          p.index = parseInt(indexStr, 10);
          p.date = dateStr;
          p.timestamp = date.getTime();
          return "";
        } catch (e) {
          debug(`Problem parsing ${dateStr} as ${pattern}, error was: `, e);
          return f;
        }
      };
      const index = (f, p) => {
        if (f.match(/^\d+$/)) {
          debug("it has an index");
          p.index = parseInt(f, 10);
          return "";
        }
        return f;
      };
      let parts = [
        zip,
        keepFileExt ? extAtEnd : extInMiddle,
        pattern ? dateAndIndex : index
      ];
      return (filename) => {
        let result = { filename, index: 0, isCompressed: false };
        let whatsLeftOver = parts.reduce((remains, part) => part(remains, result), filename);
        return whatsLeftOver ? null : result;
      };
    };
  }
});

// node_modules/streamroller/lib/moveAndMaybeCompressFile.js
var require_moveAndMaybeCompressFile = __commonJS({
  "node_modules/streamroller/lib/moveAndMaybeCompressFile.js"(exports, module2) {
    var debug = require_src()("streamroller:moveAndMaybeCompressFile");
    var fs29 = require_lib2();
    var zlib = require("zlib");
    var _parseOption = function(rawOptions) {
      const defaultOptions2 = {
        mode: parseInt("0600", 8),
        compress: false
      };
      const options2 = Object.assign({}, defaultOptions2, rawOptions);
      debug(`_parseOption: moveAndMaybeCompressFile called with option=${JSON.stringify(options2)}`);
      return options2;
    };
    var moveAndMaybeCompressFile = async (sourceFilePath, targetFilePath, options2) => {
      options2 = _parseOption(options2);
      if (sourceFilePath === targetFilePath) {
        debug(`moveAndMaybeCompressFile: source and target are the same, not doing anything`);
        return;
      }
      if (await fs29.pathExists(sourceFilePath)) {
        debug(`moveAndMaybeCompressFile: moving file from ${sourceFilePath} to ${targetFilePath} ${options2.compress ? "with" : "without"} compress`);
        if (options2.compress) {
          await new Promise((resolve3, reject) => {
            fs29.createReadStream(sourceFilePath).pipe(zlib.createGzip()).pipe(fs29.createWriteStream(targetFilePath, { mode: options2.mode })).on("finish", () => {
              debug(`moveAndMaybeCompressFile: finished compressing ${targetFilePath}, deleting ${sourceFilePath}`);
              fs29.unlink(sourceFilePath).then(resolve3).catch(() => {
                debug(`Deleting ${sourceFilePath} failed, truncating instead`);
                fs29.truncate(sourceFilePath).then(resolve3).catch(reject);
              });
            });
          });
        } else {
          debug(`moveAndMaybeCompressFile: deleting file=${targetFilePath}, renaming ${sourceFilePath} to ${targetFilePath}`);
          try {
            await fs29.move(sourceFilePath, targetFilePath, { overwrite: true });
          } catch (e) {
            debug(`moveAndMaybeCompressFile: error moving ${sourceFilePath} to ${targetFilePath}`, e);
            debug(`Trying copy+truncate instead`);
            await fs29.copy(sourceFilePath, targetFilePath, { overwrite: true });
            await fs29.truncate(sourceFilePath);
          }
        }
      }
    };
    module2.exports = moveAndMaybeCompressFile;
  }
});

// node_modules/streamroller/lib/RollingFileWriteStream.js
var require_RollingFileWriteStream = __commonJS({
  "node_modules/streamroller/lib/RollingFileWriteStream.js"(exports, module2) {
    var debug = require_src()("streamroller:RollingFileWriteStream");
    var fs29 = require_lib2();
    var path41 = require("path");
    var newNow = require_now();
    var format2 = require_lib();
    var { Writable } = require("stream");
    var fileNameFormatter = require_fileNameFormatter();
    var fileNameParser = require_fileNameParser();
    var moveAndMaybeCompressFile = require_moveAndMaybeCompressFile();
    var RollingFileWriteStream = class extends Writable {
      constructor(filePath, options2) {
        debug(`constructor: creating RollingFileWriteStream. path=${filePath}`);
        super(options2);
        this.options = this._parseOption(options2);
        this.fileObject = path41.parse(filePath);
        if (this.fileObject.dir === "") {
          this.fileObject = path41.parse(path41.join(process.cwd(), filePath));
        }
        this.fileFormatter = fileNameFormatter({
          file: this.fileObject,
          alwaysIncludeDate: this.options.alwaysIncludePattern,
          needsIndex: this.options.maxSize < Number.MAX_SAFE_INTEGER,
          compress: this.options.compress,
          keepFileExt: this.options.keepFileExt,
          fileNameSep: this.options.fileNameSep
        });
        this.fileNameParser = fileNameParser({
          file: this.fileObject,
          keepFileExt: this.options.keepFileExt,
          pattern: this.options.pattern,
          fileNameSep: this.options.fileNameSep
        });
        this.state = {
          currentSize: 0
        };
        if (this.options.pattern) {
          this.state.currentDate = format2(this.options.pattern, newNow());
        }
        this.filename = this.fileFormatter({
          index: 0,
          date: this.state.currentDate
        });
        if (["a", "a+", "as", "as+"].includes(this.options.flags)) {
          this._setExistingSizeAndDate();
        }
        debug(`constructor: create new file ${this.filename}, state=${JSON.stringify(this.state)}`);
        this._renewWriteStream();
      }
      _setExistingSizeAndDate() {
        try {
          const stats = fs29.statSync(this.filename);
          this.state.currentSize = stats.size;
          if (this.options.pattern) {
            this.state.currentDate = format2(this.options.pattern, stats.mtime);
          }
        } catch (e) {
          return;
        }
      }
      _parseOption(rawOptions) {
        const defaultOptions2 = {
          maxSize: Number.MAX_SAFE_INTEGER,
          numToKeep: Number.MAX_SAFE_INTEGER,
          encoding: "utf8",
          mode: parseInt("0600", 8),
          flags: "a",
          compress: false,
          keepFileExt: false,
          alwaysIncludePattern: false
        };
        const options2 = Object.assign({}, defaultOptions2, rawOptions);
        if (options2.maxSize <= 0) {
          throw new Error(`options.maxSize (${options2.maxSize}) should be > 0`);
        }
        if (options2.numBackups || options2.numBackups === 0) {
          if (options2.numBackups < 0) {
            throw new Error(`options.numBackups (${options2.numBackups}) should be >= 0`);
          } else if (options2.numBackups >= Number.MAX_SAFE_INTEGER) {
            throw new Error(`options.numBackups (${options2.numBackups}) should be < Number.MAX_SAFE_INTEGER`);
          } else {
            options2.numToKeep = options2.numBackups + 1;
          }
        } else if (options2.numToKeep <= 0) {
          throw new Error(`options.numToKeep (${options2.numToKeep}) should be > 0`);
        }
        debug(`_parseOption: creating stream with option=${JSON.stringify(options2)}`);
        return options2;
      }
      _final(callback) {
        this.currentFileStream.end("", this.options.encoding, callback);
      }
      _write(chunk, encoding, callback) {
        this._shouldRoll().then(() => {
          debug(`_write: writing chunk. file=${this.currentFileStream.path} state=${JSON.stringify(this.state)} chunk=${chunk}`);
          this.currentFileStream.write(chunk, encoding, (e) => {
            this.state.currentSize += chunk.length;
            callback(e);
          });
        });
      }
      async _shouldRoll() {
        if (this._dateChanged() || this._tooBig()) {
          debug(`_shouldRoll: rolling because dateChanged? ${this._dateChanged()} or tooBig? ${this._tooBig()}`);
          await this._roll();
        }
      }
      _dateChanged() {
        return this.state.currentDate && this.state.currentDate !== format2(this.options.pattern, newNow());
      }
      _tooBig() {
        return this.state.currentSize >= this.options.maxSize;
      }
      _roll() {
        debug(`_roll: closing the current stream`);
        return new Promise((resolve3, reject) => {
          this.currentFileStream.end("", this.options.encoding, () => {
            this._moveOldFiles().then(resolve3).catch(reject);
          });
        });
      }
      async _moveOldFiles() {
        const files = await this._getExistingFiles();
        const todaysFiles = this.state.currentDate ? files.filter((f) => f.date === this.state.currentDate) : files;
        for (let i = todaysFiles.length; i >= 0; i--) {
          debug(`_moveOldFiles: i = ${i}`);
          const sourceFilePath = this.fileFormatter({
            date: this.state.currentDate,
            index: i
          });
          const targetFilePath = this.fileFormatter({
            date: this.state.currentDate,
            index: i + 1
          });
          const moveAndCompressOptions = {
            compress: this.options.compress && i === 0,
            mode: this.options.mode
          };
          await moveAndMaybeCompressFile(sourceFilePath, targetFilePath, moveAndCompressOptions);
        }
        this.state.currentSize = 0;
        this.state.currentDate = this.state.currentDate ? format2(this.options.pattern, newNow()) : null;
        debug(`_moveOldFiles: finished rolling files. state=${JSON.stringify(this.state)}`);
        this._renewWriteStream();
        await new Promise((resolve3, reject) => {
          this.currentFileStream.write("", "utf8", () => {
            this._clean().then(resolve3).catch(reject);
          });
        });
      }
      async _getExistingFiles() {
        const files = await fs29.readdir(this.fileObject.dir).catch(() => []);
        debug(`_getExistingFiles: files=${files}`);
        const existingFileDetails = files.map((n) => this.fileNameParser(n)).filter((n) => n);
        const getKey = (n) => (n.timestamp ? n.timestamp : newNow().getTime()) - n.index;
        existingFileDetails.sort((a, b) => getKey(a) - getKey(b));
        return existingFileDetails;
      }
      _renewWriteStream() {
        fs29.ensureDirSync(this.fileObject.dir);
        const filePath = this.fileFormatter({
          date: this.state.currentDate,
          index: 0
        });
        const ops = {
          flags: this.options.flags,
          encoding: this.options.encoding,
          mode: this.options.mode
        };
        this.currentFileStream = fs29.createWriteStream(filePath, ops);
        this.currentFileStream.on("error", (e) => {
          this.emit("error", e);
        });
      }
      async _clean() {
        const existingFileDetails = await this._getExistingFiles();
        debug(`_clean: numToKeep = ${this.options.numToKeep}, existingFiles = ${existingFileDetails.length}`);
        debug("_clean: existing files are: ", existingFileDetails);
        if (this._tooManyFiles(existingFileDetails.length)) {
          const fileNamesToRemove = existingFileDetails.slice(0, existingFileDetails.length - this.options.numToKeep).map((f) => path41.format({ dir: this.fileObject.dir, base: f.filename }));
          await deleteFiles(fileNamesToRemove);
        }
      }
      _tooManyFiles(numFiles) {
        return this.options.numToKeep > 0 && numFiles > this.options.numToKeep;
      }
    };
    var deleteFiles = (fileNames) => {
      debug(`deleteFiles: files to delete: ${fileNames}`);
      return Promise.all(fileNames.map((f) => fs29.unlink(f).catch((e) => {
        debug(`deleteFiles: error when unlinking ${f}, ignoring. Error was ${e}`);
      })));
    };
    module2.exports = RollingFileWriteStream;
  }
});

// node_modules/streamroller/lib/RollingFileStream.js
var require_RollingFileStream = __commonJS({
  "node_modules/streamroller/lib/RollingFileStream.js"(exports, module2) {
    var RollingFileWriteStream = require_RollingFileWriteStream();
    var RollingFileStream = class extends RollingFileWriteStream {
      constructor(filename, size, backups, options2) {
        if (!options2) {
          options2 = {};
        }
        if (size) {
          options2.maxSize = size;
        }
        if (!options2.numBackups && options2.numBackups !== 0) {
          if (!backups && backups !== 0) {
            backups = 1;
          }
          options2.numBackups = backups;
        }
        super(filename, options2);
        this.backups = options2.numBackups;
        this.size = this.options.maxSize;
      }
      get theStream() {
        return this.currentFileStream;
      }
    };
    module2.exports = RollingFileStream;
  }
});

// node_modules/streamroller/lib/DateRollingFileStream.js
var require_DateRollingFileStream = __commonJS({
  "node_modules/streamroller/lib/DateRollingFileStream.js"(exports, module2) {
    var RollingFileWriteStream = require_RollingFileWriteStream();
    var DateRollingFileStream = class extends RollingFileWriteStream {
      constructor(filename, pattern, options2) {
        if (pattern && typeof pattern === "object") {
          options2 = pattern;
          pattern = null;
        }
        if (!options2) {
          options2 = {};
        }
        if (!pattern) {
          pattern = "yyyy-MM-dd";
        }
        options2.pattern = pattern;
        if (!options2.numBackups && options2.numBackups !== 0) {
          if (!options2.daysToKeep && options2.daysToKeep !== 0) {
            options2.daysToKeep = 1;
          } else {
            process.emitWarning("options.daysToKeep is deprecated due the confusion it causes when used together with file size rolling. Please use options.numBackups instead.", "DeprecationWarning", "StreamRoller0001");
          }
          options2.numBackups = options2.daysToKeep;
        } else {
          options2.daysToKeep = options2.numBackups;
        }
        super(filename, options2);
        this.mode = this.options.mode;
      }
      get theStream() {
        return this.currentFileStream;
      }
    };
    module2.exports = DateRollingFileStream;
  }
});

// node_modules/streamroller/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/streamroller/lib/index.js"(exports, module2) {
    module2.exports = {
      RollingFileWriteStream: require_RollingFileWriteStream(),
      RollingFileStream: require_RollingFileStream(),
      DateRollingFileStream: require_DateRollingFileStream()
    };
  }
});

// node_modules/log4js/lib/appenders/file.js
var require_file2 = __commonJS({
  "node_modules/log4js/lib/appenders/file.js"(exports, module2) {
    var debug = require_src()("log4js:file");
    var path41 = require("path");
    var streams = require_lib3();
    var os13 = require("os");
    var eol = os13.EOL;
    var mainSighupListenerStarted = false;
    var sighupListeners = /* @__PURE__ */ new Set();
    function mainSighupHandler() {
      sighupListeners.forEach((app) => {
        app.sighupHandler();
      });
    }
    function openTheStream(file, fileSize, numFiles, options2) {
      const stream = new streams.RollingFileStream(file, fileSize, numFiles, options2);
      stream.on("error", (err) => {
        console.error("log4js.fileAppender - Writing to file %s, error happened ", file, err);
      });
      stream.on("drain", () => {
        process.emit("log4js:pause", false);
      });
      return stream;
    }
    function fileAppender(file, layout, logSize, numBackups, options2, timezoneOffset) {
      file = path41.normalize(file);
      numBackups = !numBackups && numBackups !== 0 ? 5 : numBackups;
      debug("Creating file appender (", file, ", ", logSize, ", ", numBackups, ", ", options2, ", ", timezoneOffset, ")");
      let writer = openTheStream(file, logSize, numBackups, options2);
      const app = function(loggingEvent) {
        if (!writer.writable) {
          return;
        }
        if (options2.removeColor === true) {
          const regex3 = /\x1b[[0-9;]*m/g;
          loggingEvent.data = loggingEvent.data.map((d) => {
            if (typeof d === "string")
              return d.replace(regex3, "");
            return d;
          });
        }
        if (!writer.write(layout(loggingEvent, timezoneOffset) + eol, "utf8")) {
          process.emit("log4js:pause", true);
        }
      };
      app.reopen = function() {
        writer.end(() => {
          writer = openTheStream(file, logSize, numBackups, options2);
        });
      };
      app.sighupHandler = function() {
        debug("SIGHUP handler called.");
        app.reopen();
      };
      app.shutdown = function(complete) {
        sighupListeners.delete(app);
        if (sighupListeners.size === 0 && mainSighupListenerStarted) {
          process.removeListener("SIGHUP", mainSighupHandler);
          mainSighupListenerStarted = false;
        }
        writer.end("", "utf-8", complete);
      };
      sighupListeners.add(app);
      if (!mainSighupListenerStarted) {
        process.on("SIGHUP", mainSighupHandler);
        mainSighupListenerStarted = true;
      }
      return app;
    }
    function configure(config, layouts) {
      let layout = layouts.basicLayout;
      if (config.layout) {
        layout = layouts.layout(config.layout.type, config.layout);
      }
      config.mode = config.mode || 384;
      return fileAppender(config.filename, layout, config.maxLogSize, config.backups, config, config.timezoneOffset);
    }
    module2.exports.configure = configure;
  }
});

// node_modules/log4js/lib/appenders/dateFile.js
var require_dateFile = __commonJS({
  "node_modules/log4js/lib/appenders/dateFile.js"(exports, module2) {
    var streams = require_lib3();
    var os13 = require("os");
    var eol = os13.EOL;
    function openTheStream(filename, pattern, options2) {
      const stream = new streams.DateRollingFileStream(filename, pattern, options2);
      stream.on("error", (err) => {
        console.error("log4js.dateFileAppender - Writing to file %s, error happened ", filename, err);
      });
      stream.on("drain", () => {
        process.emit("log4js:pause", false);
      });
      return stream;
    }
    function appender(filename, pattern, layout, options2, timezoneOffset) {
      options2.maxSize = options2.maxLogSize;
      const writer = openTheStream(filename, pattern, options2);
      const app = function(logEvent) {
        if (!writer.writable) {
          return;
        }
        if (!writer.write(layout(logEvent, timezoneOffset) + eol, "utf8")) {
          process.emit("log4js:pause", true);
        }
      };
      app.shutdown = function(complete) {
        writer.end("", "utf-8", complete);
      };
      return app;
    }
    function configure(config, layouts) {
      let layout = layouts.basicLayout;
      if (config.layout) {
        layout = layouts.layout(config.layout.type, config.layout);
      }
      if (!config.alwaysIncludePattern) {
        config.alwaysIncludePattern = false;
      }
      config.mode = config.mode || 384;
      return appender(config.filename, config.pattern, layout, config, config.timezoneOffset);
    }
    module2.exports.configure = configure;
  }
});

// node_modules/log4js/lib/appenders/fileSync.js
var require_fileSync = __commonJS({
  "node_modules/log4js/lib/appenders/fileSync.js"(exports, module2) {
    var debug = require_src()("log4js:fileSync");
    var path41 = require("path");
    var fs29 = require("fs");
    var os13 = require("os");
    var eol = os13.EOL || "\n";
    function touchFile(file, options2) {
      if (fs29.existsSync(file)) {
        return;
      }
      const id = fs29.openSync(file, options2.flags, options2.mode);
      fs29.closeSync(id);
    }
    var RollingFileSync = class {
      constructor(filename, size, backups, options2) {
        debug("In RollingFileStream");
        function throwErrorIfArgumentsAreNotValid() {
          if (!filename || !size || size <= 0) {
            throw new Error("You must specify a filename and file size");
          }
        }
        throwErrorIfArgumentsAreNotValid();
        this.filename = filename;
        this.size = size;
        this.backups = backups;
        this.options = options2;
        this.currentSize = 0;
        function currentFileSize(file) {
          let fileSize = 0;
          try {
            fileSize = fs29.statSync(file).size;
          } catch (e) {
            touchFile(file, options2);
          }
          return fileSize;
        }
        this.currentSize = currentFileSize(this.filename);
      }
      shouldRoll() {
        debug("should roll with current size %d, and max size %d", this.currentSize, this.size);
        return this.currentSize >= this.size;
      }
      roll(filename) {
        const that = this;
        const nameMatcher = new RegExp(`^${path41.basename(filename)}`);
        function justTheseFiles(item) {
          return nameMatcher.test(item);
        }
        function index(filename_) {
          return parseInt(filename_.substring(`${path41.basename(filename)}.`.length), 10) || 0;
        }
        function byIndex(a, b) {
          if (index(a) > index(b)) {
            return 1;
          }
          if (index(a) < index(b)) {
            return -1;
          }
          return 0;
        }
        function increaseFileIndex(fileToRename) {
          const idx = index(fileToRename);
          debug(`Index of ${fileToRename} is ${idx}`);
          if (that.backups === 0) {
            fs29.truncateSync(filename, 0);
          } else if (idx < that.backups) {
            try {
              fs29.unlinkSync(`${filename}.${idx + 1}`);
            } catch (e) {
            }
            debug(`Renaming ${fileToRename} -> ${filename}.${idx + 1}`);
            fs29.renameSync(path41.join(path41.dirname(filename), fileToRename), `${filename}.${idx + 1}`);
          }
        }
        function renameTheFiles() {
          debug("Renaming the old files");
          const files = fs29.readdirSync(path41.dirname(filename));
          files.filter(justTheseFiles).sort(byIndex).reverse().forEach(increaseFileIndex);
        }
        debug("Rolling, rolling, rolling");
        renameTheFiles();
      }
      write(chunk, encoding) {
        const that = this;
        function writeTheChunk() {
          debug("writing the chunk to the file");
          that.currentSize += chunk.length;
          fs29.appendFileSync(that.filename, chunk);
        }
        debug("in write");
        if (this.shouldRoll()) {
          this.currentSize = 0;
          this.roll(this.filename);
        }
        writeTheChunk();
      }
    };
    function fileAppender(file, layout, logSize, numBackups, timezoneOffset, options2) {
      debug("fileSync appender created");
      file = path41.normalize(file);
      numBackups = !numBackups && numBackups !== 0 ? 5 : numBackups;
      function openTheStream(filePath, fileSize, numFiles) {
        let stream;
        if (fileSize) {
          stream = new RollingFileSync(filePath, fileSize, numFiles, options2);
        } else {
          stream = ((f) => {
            touchFile(f, options2);
            return {
              write(data) {
                fs29.appendFileSync(f, data);
              }
            };
          })(filePath);
        }
        return stream;
      }
      const logFile = openTheStream(file, logSize, numBackups);
      return (loggingEvent) => {
        logFile.write(layout(loggingEvent, timezoneOffset) + eol);
      };
    }
    function configure(config, layouts) {
      let layout = layouts.basicLayout;
      if (config.layout) {
        layout = layouts.layout(config.layout.type, config.layout);
      }
      const options2 = {
        flags: config.flags || "a",
        encoding: config.encoding || "utf8",
        mode: config.mode || 384
      };
      return fileAppender(config.filename, layout, config.maxLogSize, config.backups, config.timezoneOffset, options2);
    }
    module2.exports.configure = configure;
  }
});

// node_modules/log4js/lib/appenders/tcp.js
var require_tcp = __commonJS({
  "node_modules/log4js/lib/appenders/tcp.js"(exports, module2) {
    var debug = require_src()("log4js:tcp");
    var net2 = require("net");
    function appender(config, layout) {
      let canWrite = false;
      const buffer = [];
      let socket;
      let shutdownAttempts = 3;
      let endMsg = "__LOG4JS__";
      function write(loggingEvent) {
        debug("Writing log event to socket");
        canWrite = socket.write(`${layout(loggingEvent)}${endMsg}`, "utf8");
      }
      function emptyBuffer() {
        let evt;
        debug("emptying buffer");
        while (evt = buffer.shift()) {
          write(evt);
        }
      }
      function createSocket() {
        debug(`appender creating socket to ${config.host || "localhost"}:${config.port || 5e3}`);
        endMsg = `${config.endMsg || "__LOG4JS__"}`;
        socket = net2.createConnection(config.port || 5e3, config.host || "localhost");
        socket.on("connect", () => {
          debug("socket connected");
          emptyBuffer();
          canWrite = true;
        });
        socket.on("drain", () => {
          debug("drain event received, emptying buffer");
          canWrite = true;
          emptyBuffer();
        });
        socket.on("timeout", socket.end.bind(socket));
        socket.on("error", (e) => {
          debug("connection error", e);
          canWrite = false;
          emptyBuffer();
        });
        socket.on("close", createSocket);
      }
      createSocket();
      function log(loggingEvent) {
        if (canWrite) {
          write(loggingEvent);
        } else {
          debug("buffering log event because it cannot write at the moment");
          buffer.push(loggingEvent);
        }
      }
      log.shutdown = function(cb) {
        debug("shutdown called");
        if (buffer.length && shutdownAttempts) {
          debug("buffer has items, waiting 100ms to empty");
          shutdownAttempts -= 1;
          setTimeout(() => {
            log.shutdown(cb);
          }, 100);
        } else {
          socket.removeAllListeners("close");
          socket.end(cb);
        }
      };
      return log;
    }
    function configure(config, layouts) {
      debug(`configure with config = ${config}`);
      let layout = function(loggingEvent) {
        return loggingEvent.serialise();
      };
      if (config.layout) {
        layout = layouts.layout(config.layout.type, config.layout);
      }
      return appender(config, layout);
    }
    module2.exports.configure = configure;
  }
});

// env-ns:node_modules/log4js/lib/appenders
var require_appenders = __commonJS({
  "env-ns:node_modules/log4js/lib/appenders"(exports, module2) {
    var path41 = require("path");
    var debug = require_src()("log4js:appenders");
    var configuration = require_configuration();
    var clustering = require_clustering();
    var levels = require_levels();
    var layouts = require_layouts();
    var adapters = require_adapters();
    var coreAppenders = /* @__PURE__ */ new Map();
    coreAppenders.set("console", require_console());
    coreAppenders.set("stdout", require_stdout());
    coreAppenders.set("stderr", require_stderr());
    coreAppenders.set("logLevelFilter", require_logLevelFilter());
    coreAppenders.set("categoryFilter", require_categoryFilter());
    coreAppenders.set("noLogFilter", require_noLogFilter());
    coreAppenders.set("file", require_file2());
    coreAppenders.set("dateFile", require_dateFile());
    coreAppenders.set("fileSync", require_fileSync());
    coreAppenders.set("tcp", require_tcp());
    var appenders = /* @__PURE__ */ new Map();
    var tryLoading = (modulePath, config) => {
      debug("Loading module from ", modulePath);
      try {
        return require(modulePath);
      } catch (e) {
        configuration.throwExceptionIf(config, e.code !== "MODULE_NOT_FOUND", `appender "${modulePath}" could not be loaded (error was: ${e})`);
        return void 0;
      }
    };
    var loadAppenderModule = (type, config) => coreAppenders.get(type) || tryLoading(`./${type}`, config) || tryLoading(type, config) || "" || tryLoading(path41.join(process.cwd(), type), config);
    var appendersLoading = /* @__PURE__ */ new Set();
    var getAppender = (name2, config) => {
      if (appenders.has(name2))
        return appenders.get(name2);
      if (!config.appenders[name2])
        return false;
      if (appendersLoading.has(name2))
        throw new Error(`Dependency loop detected for appender ${name2}.`);
      appendersLoading.add(name2);
      debug(`Creating appender ${name2}`);
      const appender = createAppender(name2, config);
      appendersLoading.delete(name2);
      appenders.set(name2, appender);
      return appender;
    };
    var createAppender = (name2, config) => {
      const appenderConfig = config.appenders[name2];
      const appenderModule = appenderConfig.type.configure ? appenderConfig.type : loadAppenderModule(appenderConfig.type, config);
      configuration.throwExceptionIf(config, configuration.not(appenderModule), `appender "${name2}" is not valid (type "${appenderConfig.type}" could not be found)`);
      if (appenderModule.appender) {
        debug(`DEPRECATION: Appender ${appenderConfig.type} exports an appender function.`);
      }
      if (appenderModule.shutdown) {
        debug(`DEPRECATION: Appender ${appenderConfig.type} exports a shutdown function.`);
      }
      debug(`${name2}: clustering.isMaster ? ${clustering.isMaster()}`);
      debug(`${name2}: appenderModule is ${require("util").inspect(appenderModule)}`);
      return clustering.onlyOnMaster(() => {
        debug(`calling appenderModule.configure for ${name2} / ${appenderConfig.type}`);
        return appenderModule.configure(adapters.modifyConfig(appenderConfig), layouts, (appender) => getAppender(appender, config), levels);
      }, () => {
      });
    };
    var setup = (config) => {
      appenders.clear();
      appendersLoading.clear();
      const usedAppenders = [];
      Object.values(config.categories).forEach((category) => {
        usedAppenders.push(...category.appenders);
      });
      Object.keys(config.appenders).forEach((name2) => {
        if (usedAppenders.includes(name2) || config.appenders[name2].type === "tcp-server") {
          getAppender(name2, config);
        }
      });
    };
    var init = () => {
      setup({ appenders: { out: { type: "stdout" } }, categories: { default: { appenders: ["out"], level: "trace" } } });
    };
    init();
    configuration.addListener((config) => {
      configuration.throwExceptionIf(config, configuration.not(configuration.anObject(config.appenders)), 'must have a property "appenders" of type object.');
      const appenderNames = Object.keys(config.appenders);
      configuration.throwExceptionIf(config, configuration.not(appenderNames.length), "must define at least one appender.");
      appenderNames.forEach((name2) => {
        configuration.throwExceptionIf(config, configuration.not(config.appenders[name2].type), `appender "${name2}" is not valid (must be an object with property "type")`);
      });
    });
    configuration.addListener(setup);
    module2.exports = appenders;
    module2.exports.init = init;
  }
});

// node_modules/log4js/lib/categories.js
var require_categories = __commonJS({
  "node_modules/log4js/lib/categories.js"(exports, module2) {
    var debug = require_src()("log4js:categories");
    var configuration = require_configuration();
    var levels = require_levels();
    var appenders = require_appenders();
    var categories = /* @__PURE__ */ new Map();
    function inheritFromParent(config, category, categoryName) {
      if (category.inherit === false)
        return;
      const lastDotIndex = categoryName.lastIndexOf(".");
      if (lastDotIndex < 0)
        return;
      const parentCategoryName = categoryName.substring(0, lastDotIndex);
      let parentCategory = config.categories[parentCategoryName];
      if (!parentCategory) {
        parentCategory = { inherit: true, appenders: [] };
      }
      inheritFromParent(config, parentCategory, parentCategoryName);
      if (!config.categories[parentCategoryName] && parentCategory.appenders && parentCategory.appenders.length && parentCategory.level) {
        config.categories[parentCategoryName] = parentCategory;
      }
      category.appenders = category.appenders || [];
      category.level = category.level || parentCategory.level;
      parentCategory.appenders.forEach((ap) => {
        if (!category.appenders.includes(ap)) {
          category.appenders.push(ap);
        }
      });
      category.parent = parentCategory;
    }
    function addCategoryInheritance(config) {
      if (!config.categories)
        return;
      const categoryNames = Object.keys(config.categories);
      categoryNames.forEach((name2) => {
        const category = config.categories[name2];
        inheritFromParent(config, category, name2);
      });
    }
    configuration.addPreProcessingListener((config) => addCategoryInheritance(config));
    configuration.addListener((config) => {
      configuration.throwExceptionIf(config, configuration.not(configuration.anObject(config.categories)), 'must have a property "categories" of type object.');
      const categoryNames = Object.keys(config.categories);
      configuration.throwExceptionIf(config, configuration.not(categoryNames.length), "must define at least one category.");
      categoryNames.forEach((name2) => {
        const category = config.categories[name2];
        configuration.throwExceptionIf(config, [
          configuration.not(category.appenders),
          configuration.not(category.level)
        ], `category "${name2}" is not valid (must be an object with properties "appenders" and "level")`);
        configuration.throwExceptionIf(config, configuration.not(Array.isArray(category.appenders)), `category "${name2}" is not valid (appenders must be an array of appender names)`);
        configuration.throwExceptionIf(config, configuration.not(category.appenders.length), `category "${name2}" is not valid (appenders must contain at least one appender name)`);
        if (Object.prototype.hasOwnProperty.call(category, "enableCallStack")) {
          configuration.throwExceptionIf(config, typeof category.enableCallStack !== "boolean", `category "${name2}" is not valid (enableCallStack must be boolean type)`);
        }
        category.appenders.forEach((appender) => {
          configuration.throwExceptionIf(config, configuration.not(appenders.get(appender)), `category "${name2}" is not valid (appender "${appender}" is not defined)`);
        });
        configuration.throwExceptionIf(config, configuration.not(levels.getLevel(category.level)), `category "${name2}" is not valid (level "${category.level}" not recognised; valid levels are ${levels.levels.join(", ")})`);
      });
      configuration.throwExceptionIf(config, configuration.not(config.categories.default), 'must define a "default" category.');
    });
    var setup = (config) => {
      categories.clear();
      const categoryNames = Object.keys(config.categories);
      categoryNames.forEach((name2) => {
        const category = config.categories[name2];
        const categoryAppenders = [];
        category.appenders.forEach((appender) => {
          categoryAppenders.push(appenders.get(appender));
          debug(`Creating category ${name2}`);
          categories.set(name2, {
            appenders: categoryAppenders,
            level: levels.getLevel(category.level),
            enableCallStack: category.enableCallStack || false
          });
        });
      });
    };
    var init = () => {
      setup({ categories: { default: { appenders: ["out"], level: "OFF" } } });
    };
    init();
    configuration.addListener(setup);
    var configForCategory = (category) => {
      debug(`configForCategory: searching for config for ${category}`);
      if (categories.has(category)) {
        debug(`configForCategory: ${category} exists in config, returning it`);
        return categories.get(category);
      }
      if (category.indexOf(".") > 0) {
        debug(`configForCategory: ${category} has hierarchy, searching for parents`);
        return configForCategory(category.substring(0, category.lastIndexOf(".")));
      }
      debug("configForCategory: returning config for default category");
      return configForCategory("default");
    };
    var appendersForCategory = (category) => configForCategory(category).appenders;
    var getLevelForCategory = (category) => configForCategory(category).level;
    var setLevelForCategory = (category, level) => {
      let categoryConfig = categories.get(category);
      debug(`setLevelForCategory: found ${categoryConfig} for ${category}`);
      if (!categoryConfig) {
        const sourceCategoryConfig = configForCategory(category);
        debug(`setLevelForCategory: no config found for category, found ${sourceCategoryConfig} for parents of ${category}`);
        categoryConfig = { appenders: sourceCategoryConfig.appenders };
      }
      categoryConfig.level = level;
      categories.set(category, categoryConfig);
    };
    var getEnableCallStackForCategory = (category) => configForCategory(category).enableCallStack === true;
    var setEnableCallStackForCategory = (category, useCallStack) => {
      configForCategory(category).enableCallStack = useCallStack;
    };
    module2.exports = categories;
    module2.exports = Object.assign(module2.exports, {
      appendersForCategory,
      getLevelForCategory,
      setLevelForCategory,
      getEnableCallStackForCategory,
      setEnableCallStackForCategory,
      init
    });
  }
});

// node_modules/log4js/lib/logger.js
var require_logger = __commonJS({
  "node_modules/log4js/lib/logger.js"(exports, module2) {
    var debug = require_src()("log4js:logger");
    var LoggingEvent = require_LoggingEvent();
    var levels = require_levels();
    var clustering = require_clustering();
    var categories = require_categories();
    var configuration = require_configuration();
    var stackReg = /at (?:(.+)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/;
    function defaultParseCallStack(data, skipIdx = 4) {
      const stacklines = data.stack.split("\n").slice(skipIdx);
      const lineMatch = stackReg.exec(stacklines[0]);
      if (lineMatch && lineMatch.length === 6) {
        return {
          functionName: lineMatch[1],
          fileName: lineMatch[2],
          lineNumber: parseInt(lineMatch[3], 10),
          columnNumber: parseInt(lineMatch[4], 10),
          callStack: stacklines.join("\n")
        };
      }
      return null;
    }
    var Logger = class {
      constructor(name2) {
        if (!name2) {
          throw new Error("No category provided.");
        }
        this.category = name2;
        this.context = {};
        this.parseCallStack = defaultParseCallStack;
        debug(`Logger created (${this.category}, ${this.level})`);
      }
      get level() {
        return levels.getLevel(categories.getLevelForCategory(this.category), levels.TRACE);
      }
      set level(level) {
        categories.setLevelForCategory(this.category, levels.getLevel(level, this.level));
      }
      get useCallStack() {
        return categories.getEnableCallStackForCategory(this.category);
      }
      set useCallStack(bool) {
        categories.setEnableCallStackForCategory(this.category, bool === true);
      }
      log(level, ...args) {
        let logLevel = levels.getLevel(level);
        if (!logLevel) {
          this._log(levels.WARN, "log4js:logger.log: invalid value for log-level as first parameter given: ", level);
          logLevel = levels.INFO;
        }
        if (this.isLevelEnabled(logLevel)) {
          this._log(logLevel, args);
        }
      }
      isLevelEnabled(otherLevel) {
        return this.level.isLessThanOrEqualTo(otherLevel);
      }
      _log(level, data) {
        debug(`sending log data (${level}) to appenders`);
        const loggingEvent = new LoggingEvent(this.category, level, data, this.context, this.useCallStack && this.parseCallStack(new Error()));
        clustering.send(loggingEvent);
      }
      addContext(key, value) {
        this.context[key] = value;
      }
      removeContext(key) {
        delete this.context[key];
      }
      clearContext() {
        this.context = {};
      }
      setParseCallStackFunction(parseFunction) {
        this.parseCallStack = parseFunction;
      }
    };
    function addLevelMethods(target) {
      const level = levels.getLevel(target);
      const levelStrLower = level.toString().toLowerCase();
      const levelMethod = levelStrLower.replace(/_([a-z])/g, (g) => g[1].toUpperCase());
      const isLevelMethod = levelMethod[0].toUpperCase() + levelMethod.slice(1);
      Logger.prototype[`is${isLevelMethod}Enabled`] = function() {
        return this.isLevelEnabled(level);
      };
      Logger.prototype[levelMethod] = function(...args) {
        this.log(level, ...args);
      };
    }
    levels.levels.forEach(addLevelMethods);
    configuration.addListener(() => {
      levels.levels.forEach(addLevelMethods);
    });
    module2.exports = Logger;
  }
});

// node_modules/log4js/lib/connect-logger.js
var require_connect_logger = __commonJS({
  "node_modules/log4js/lib/connect-logger.js"(exports, module2) {
    var levels = require_levels();
    var DEFAULT_FORMAT = ':remote-addr - - ":method :url HTTP/:http-version" :status :content-length ":referrer" ":user-agent"';
    function getUrl(req) {
      return req.originalUrl || req.url;
    }
    function assembleTokens(req, res, customTokens) {
      const arrayUniqueTokens = (array) => {
        const a = array.concat();
        for (let i = 0; i < a.length; ++i) {
          for (let j = i + 1; j < a.length; ++j) {
            if (a[i].token == a[j].token) {
              a.splice(j--, 1);
            }
          }
        }
        return a;
      };
      const defaultTokens = [];
      defaultTokens.push({ token: ":url", replacement: getUrl(req) });
      defaultTokens.push({ token: ":protocol", replacement: req.protocol });
      defaultTokens.push({ token: ":hostname", replacement: req.hostname });
      defaultTokens.push({ token: ":method", replacement: req.method });
      defaultTokens.push({
        token: ":status",
        replacement: res.__statusCode || res.statusCode
      });
      defaultTokens.push({
        token: ":response-time",
        replacement: res.responseTime
      });
      defaultTokens.push({ token: ":date", replacement: new Date().toUTCString() });
      defaultTokens.push({
        token: ":referrer",
        replacement: req.headers.referer || req.headers.referrer || ""
      });
      defaultTokens.push({
        token: ":http-version",
        replacement: `${req.httpVersionMajor}.${req.httpVersionMinor}`
      });
      defaultTokens.push({
        token: ":remote-addr",
        replacement: req.headers["x-forwarded-for"] || req.ip || req._remoteAddress || req.socket && (req.socket.remoteAddress || req.socket.socket && req.socket.socket.remoteAddress)
      });
      defaultTokens.push({
        token: ":user-agent",
        replacement: req.headers["user-agent"]
      });
      defaultTokens.push({
        token: ":content-length",
        replacement: res.getHeader("content-length") || res.__headers && res.__headers["Content-Length"] || "-"
      });
      defaultTokens.push({
        token: /:req\[([^\]]+)]/g,
        replacement(_, field) {
          return req.headers[field.toLowerCase()];
        }
      });
      defaultTokens.push({
        token: /:res\[([^\]]+)]/g,
        replacement(_, field) {
          return res.getHeader(field.toLowerCase()) || res.__headers && res.__headers[field];
        }
      });
      return arrayUniqueTokens(customTokens.concat(defaultTokens));
    }
    function format2(str, tokens) {
      for (let i = 0; i < tokens.length; i++) {
        str = str.replace(tokens[i].token, tokens[i].replacement);
      }
      return str;
    }
    function createNoLogCondition(nolog) {
      let regexp = null;
      if (nolog instanceof RegExp) {
        regexp = nolog;
      }
      if (typeof nolog === "string") {
        regexp = new RegExp(nolog);
      }
      if (Array.isArray(nolog)) {
        const regexpsAsStrings = nolog.map((reg) => reg.source ? reg.source : reg);
        regexp = new RegExp(regexpsAsStrings.join("|"));
      }
      return regexp;
    }
    function matchRules(statusCode, currentLevel, ruleSet) {
      let level = currentLevel;
      if (ruleSet) {
        const matchedRule = ruleSet.find((rule) => {
          let ruleMatched = false;
          if (rule.from && rule.to) {
            ruleMatched = statusCode >= rule.from && statusCode <= rule.to;
          } else {
            ruleMatched = rule.codes.indexOf(statusCode) !== -1;
          }
          return ruleMatched;
        });
        if (matchedRule) {
          level = levels.getLevel(matchedRule.level, level);
        }
      }
      return level;
    }
    module2.exports = function getLogger(logger4js, options2) {
      if (typeof options2 === "string" || typeof options2 === "function") {
        options2 = { format: options2 };
      } else {
        options2 = options2 || {};
      }
      const thisLogger = logger4js;
      let level = levels.getLevel(options2.level, levels.INFO);
      const fmt = options2.format || DEFAULT_FORMAT;
      const nolog = createNoLogCondition(options2.nolog);
      return (req, res, next) => {
        if (req._logging)
          return next();
        if (nolog && nolog.test(req.originalUrl))
          return next();
        if (thisLogger.isLevelEnabled(level) || options2.level === "auto") {
          const start = new Date();
          const { writeHead } = res;
          req._logging = true;
          res.writeHead = (code, headers) => {
            res.writeHead = writeHead;
            res.writeHead(code, headers);
            res.__statusCode = code;
            res.__headers = headers || {};
          };
          res.on("finish", () => {
            res.responseTime = new Date() - start;
            if (res.statusCode && options2.level === "auto") {
              level = levels.INFO;
              if (res.statusCode >= 300)
                level = levels.WARN;
              if (res.statusCode >= 400)
                level = levels.ERROR;
            }
            level = matchRules(res.statusCode, level, options2.statusRules);
            const combinedTokens = assembleTokens(req, res, options2.tokens || []);
            if (options2.context)
              thisLogger.addContext("res", res);
            if (typeof fmt === "function") {
              const line = fmt(req, res, (str) => format2(str, combinedTokens));
              if (line)
                thisLogger.log(level, line);
            } else {
              thisLogger.log(level, format2(fmt, combinedTokens));
            }
            if (options2.context)
              thisLogger.removeContext("res");
          });
        }
        return next();
      };
    };
  }
});

// node_modules/log4js/lib/appenders/recording.js
var require_recording = __commonJS({
  "node_modules/log4js/lib/appenders/recording.js"(exports, module2) {
    var debug = require_src()("log4js:recording");
    var recordedEvents = [];
    function configure() {
      return function(logEvent) {
        debug(`received logEvent, number of events now ${recordedEvents.length + 1}`);
        debug("log event was ", logEvent);
        recordedEvents.push(logEvent);
      };
    }
    function replay() {
      return recordedEvents.slice();
    }
    function reset() {
      recordedEvents.length = 0;
    }
    module2.exports = {
      configure,
      replay,
      playback: replay,
      reset,
      erase: reset
    };
  }
});

// node_modules/log4js/lib/log4js.js
var require_log4js = __commonJS({
  "node_modules/log4js/lib/log4js.js"(exports, module2) {
    var debug = require_src()("log4js:main");
    var fs29 = require("fs");
    var deepClone2 = require_rfdc()({ proto: true });
    var configuration = require_configuration();
    var layouts = require_layouts();
    var levels = require_levels();
    var appenders = require_appenders();
    var categories = require_categories();
    var Logger = require_logger();
    var clustering = require_clustering();
    var connectLogger = require_connect_logger();
    var recordingModule = require_recording();
    var enabled = false;
    function sendLogEventToAppender(logEvent) {
      if (!enabled)
        return;
      debug("Received log event ", logEvent);
      const categoryAppenders = categories.appendersForCategory(logEvent.categoryName);
      categoryAppenders.forEach((appender) => {
        appender(logEvent);
      });
    }
    function loadConfigurationFile(filename) {
      debug(`Loading configuration from ${filename}`);
      try {
        return JSON.parse(fs29.readFileSync(filename, "utf8"));
      } catch (e) {
        throw new Error(`Problem reading config from file "${filename}". Error was ${e.message}`, e);
      }
    }
    function configure(configurationFileOrObject) {
      if (enabled) {
        shutdown();
      }
      let configObject = configurationFileOrObject;
      if (typeof configObject === "string") {
        configObject = loadConfigurationFile(configurationFileOrObject);
      }
      debug(`Configuration is ${configObject}`);
      configuration.configure(deepClone2(configObject));
      clustering.onMessage(sendLogEventToAppender);
      enabled = true;
      return log4js2;
    }
    function recording() {
      return recordingModule;
    }
    function shutdown(cb) {
      debug("Shutdown called. Disabling all log writing.");
      enabled = false;
      const appendersToCheck = Array.from(appenders.values());
      appenders.init();
      categories.init();
      const shutdownFunctions = appendersToCheck.reduceRight((accum, next) => next.shutdown ? accum + 1 : accum, 0);
      if (shutdownFunctions === 0) {
        debug("No appenders with shutdown functions found.");
        return cb !== void 0 && cb();
      }
      let completed = 0;
      let error;
      debug(`Found ${shutdownFunctions} appenders with shutdown functions.`);
      function complete(err) {
        error = error || err;
        completed += 1;
        debug(`Appender shutdowns complete: ${completed} / ${shutdownFunctions}`);
        if (completed >= shutdownFunctions) {
          debug("All shutdown functions completed.");
          if (cb) {
            cb(error);
          }
        }
      }
      appendersToCheck.filter((a) => a.shutdown).forEach((a) => a.shutdown(complete));
      return null;
    }
    function getLogger(category) {
      if (!enabled) {
        configure(process.env.LOG4JS_CONFIG || {
          appenders: { out: { type: "stdout" } },
          categories: { default: { appenders: ["out"], level: "OFF" } }
        });
      }
      return new Logger(category || "default");
    }
    var log4js2 = {
      getLogger,
      configure,
      shutdown,
      connectLogger,
      levels,
      addLayout: layouts.addLayout,
      recording
    };
    module2.exports = log4js2;
  }
});

// node_modules/fs-extra/lib/fs/index.js
var require_fs2 = __commonJS({
  "node_modules/fs-extra/lib/fs/index.js"(exports) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs29 = require_graceful_fs();
    var api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchmod",
      "lchown",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => {
      return typeof fs29[key] === "function";
    });
    Object.keys(fs29).forEach((key) => {
      if (key === "promises") {
        return;
      }
      exports[key] = fs29[key];
    });
    api.forEach((method) => {
      exports[method] = u(fs29[method]);
    });
    exports.exists = function(filename, callback) {
      if (typeof callback === "function") {
        return fs29.exists(filename, callback);
      }
      return new Promise((resolve3) => {
        return fs29.exists(filename, resolve3);
      });
    };
    exports.read = function(fd, buffer, offset, length, position, callback) {
      if (typeof callback === "function") {
        return fs29.read(fd, buffer, offset, length, position, callback);
      }
      return new Promise((resolve3, reject) => {
        fs29.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
          if (err)
            return reject(err);
          resolve3({ bytesRead, buffer: buffer2 });
        });
      });
    };
    exports.write = function(fd, buffer, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs29.write(fd, buffer, ...args);
      }
      return new Promise((resolve3, reject) => {
        fs29.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
          if (err)
            return reject(err);
          resolve3({ bytesWritten, buffer: buffer2 });
        });
      });
    };
    if (typeof fs29.writev === "function") {
      exports.writev = function(fd, buffers, ...args) {
        if (typeof args[args.length - 1] === "function") {
          return fs29.writev(fd, buffers, ...args);
        }
        return new Promise((resolve3, reject) => {
          fs29.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
            if (err)
              return reject(err);
            resolve3({ bytesWritten, buffers: buffers2 });
          });
        });
      };
    }
    if (typeof fs29.realpath.native === "function") {
      exports.realpath.native = u(fs29.realpath.native);
    }
  }
});

// node_modules/at-least-node/index.js
var require_at_least_node = __commonJS({
  "node_modules/at-least-node/index.js"(exports, module2) {
    module2.exports = (r) => {
      const n = process.versions.node.split(".").map((x) => parseInt(x, 10));
      r = r.split(".").map((x) => parseInt(x, 10));
      return n[0] > r[0] || n[0] === r[0] && (n[1] > r[1] || n[1] === r[1] && n[2] >= r[2]);
    };
  }
});

// node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir2 = __commonJS({
  "node_modules/fs-extra/lib/mkdirs/make-dir.js"(exports, module2) {
    "use strict";
    var fs29 = require_fs2();
    var path41 = require("path");
    var atLeastNode = require_at_least_node();
    var useNativeRecursiveOption = atLeastNode("10.12.0");
    var checkPath = (pth) => {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path41.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const error = new Error(`Path contains invalid characters: ${pth}`);
          error.code = "EINVAL";
          throw error;
        }
      }
    };
    var processOptions = (options2) => {
      const defaults3 = { mode: 511 };
      if (typeof options2 === "number")
        options2 = { mode: options2 };
      return __spreadValues(__spreadValues({}, defaults3), options2);
    };
    var permissionError = (pth) => {
      const error = new Error(`operation not permitted, mkdir '${pth}'`);
      error.code = "EPERM";
      error.errno = -4048;
      error.path = pth;
      error.syscall = "mkdir";
      return error;
    };
    module2.exports.makeDir = async (input, options2) => {
      checkPath(input);
      options2 = processOptions(options2);
      if (useNativeRecursiveOption) {
        const pth = path41.resolve(input);
        return fs29.mkdir(pth, {
          mode: options2.mode,
          recursive: true
        });
      }
      const make = async (pth) => {
        try {
          await fs29.mkdir(pth, options2.mode);
        } catch (error) {
          if (error.code === "EPERM") {
            throw error;
          }
          if (error.code === "ENOENT") {
            if (path41.dirname(pth) === pth) {
              throw permissionError(pth);
            }
            if (error.message.includes("null bytes")) {
              throw error;
            }
            await make(path41.dirname(pth));
            return make(pth);
          }
          try {
            const stats = await fs29.stat(pth);
            if (!stats.isDirectory()) {
              throw new Error("The path is not a directory");
            }
          } catch {
            throw error;
          }
        }
      };
      return make(path41.resolve(input));
    };
    module2.exports.makeDirSync = (input, options2) => {
      checkPath(input);
      options2 = processOptions(options2);
      if (useNativeRecursiveOption) {
        const pth = path41.resolve(input);
        return fs29.mkdirSync(pth, {
          mode: options2.mode,
          recursive: true
        });
      }
      const make = (pth) => {
        try {
          fs29.mkdirSync(pth, options2.mode);
        } catch (error) {
          if (error.code === "EPERM") {
            throw error;
          }
          if (error.code === "ENOENT") {
            if (path41.dirname(pth) === pth) {
              throw permissionError(pth);
            }
            if (error.message.includes("null bytes")) {
              throw error;
            }
            make(path41.dirname(pth));
            return make(pth);
          }
          try {
            if (!fs29.statSync(pth).isDirectory()) {
              throw new Error("The path is not a directory");
            }
          } catch {
            throw error;
          }
        }
      };
      return make(path41.resolve(input));
    };
  }
});

// node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs2 = __commonJS({
  "node_modules/fs-extra/lib/mkdirs/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var { makeDir: _makeDir, makeDirSync } = require_make_dir2();
    var makeDir = u(_makeDir);
    module2.exports = {
      mkdirs: makeDir,
      mkdirsSync: makeDirSync,
      mkdirp: makeDir,
      mkdirpSync: makeDirSync,
      ensureDir: makeDir,
      ensureDirSync: makeDirSync
    };
  }
});

// node_modules/fs-extra/lib/util/utimes.js
var require_utimes2 = __commonJS({
  "node_modules/fs-extra/lib/util/utimes.js"(exports, module2) {
    "use strict";
    var fs29 = require_graceful_fs();
    function utimesMillis(path41, atime, mtime, callback) {
      fs29.open(path41, "r+", (err, fd) => {
        if (err)
          return callback(err);
        fs29.futimes(fd, atime, mtime, (futimesErr) => {
          fs29.close(fd, (closeErr) => {
            if (callback)
              callback(futimesErr || closeErr);
          });
        });
      });
    }
    function utimesMillisSync(path41, atime, mtime) {
      const fd = fs29.openSync(path41, "r+");
      fs29.futimesSync(fd, atime, mtime);
      return fs29.closeSync(fd);
    }
    module2.exports = {
      utimesMillis,
      utimesMillisSync
    };
  }
});

// node_modules/fs-extra/lib/util/stat.js
var require_stat2 = __commonJS({
  "node_modules/fs-extra/lib/util/stat.js"(exports, module2) {
    "use strict";
    var fs29 = require_fs2();
    var path41 = require("path");
    var util4 = require("util");
    var atLeastNode = require_at_least_node();
    var nodeSupportsBigInt = atLeastNode("10.5.0");
    var stat = (file) => nodeSupportsBigInt ? fs29.stat(file, { bigint: true }) : fs29.stat(file);
    var statSync = (file) => nodeSupportsBigInt ? fs29.statSync(file, { bigint: true }) : fs29.statSync(file);
    function getStats(src, dest) {
      return Promise.all([
        stat(src),
        stat(dest).catch((err) => {
          if (err.code === "ENOENT")
            return null;
          throw err;
        })
      ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
    }
    function getStatsSync(src, dest) {
      let destStat;
      const srcStat = statSync(src);
      try {
        destStat = statSync(dest);
      } catch (err) {
        if (err.code === "ENOENT")
          return { srcStat, destStat: null };
        throw err;
      }
      return { srcStat, destStat };
    }
    function checkPaths(src, dest, funcName, cb) {
      util4.callbackify(getStats)(src, dest, (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, destStat } = stats;
        if (destStat && areIdentical(srcStat, destStat)) {
          return cb(new Error("Source and destination must not be the same."));
        }
        if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
          return cb(new Error(errMsg(src, dest, funcName)));
        }
        return cb(null, { srcStat, destStat });
      });
    }
    function checkPathsSync(src, dest, funcName) {
      const { srcStat, destStat } = getStatsSync(src, dest);
      if (destStat && areIdentical(srcStat, destStat)) {
        throw new Error("Source and destination must not be the same.");
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }
    function checkParentPaths(src, srcStat, dest, funcName, cb) {
      const srcParent = path41.resolve(path41.dirname(src));
      const destParent = path41.resolve(path41.dirname(dest));
      if (destParent === srcParent || destParent === path41.parse(destParent).root)
        return cb();
      const callback = (err, destStat) => {
        if (err) {
          if (err.code === "ENOENT")
            return cb();
          return cb(err);
        }
        if (areIdentical(srcStat, destStat)) {
          return cb(new Error(errMsg(src, dest, funcName)));
        }
        return checkParentPaths(src, srcStat, destParent, funcName, cb);
      };
      if (nodeSupportsBigInt)
        fs29.stat(destParent, { bigint: true }, callback);
      else
        fs29.stat(destParent, callback);
    }
    function checkParentPathsSync(src, srcStat, dest, funcName) {
      const srcParent = path41.resolve(path41.dirname(src));
      const destParent = path41.resolve(path41.dirname(dest));
      if (destParent === srcParent || destParent === path41.parse(destParent).root)
        return;
      let destStat;
      try {
        destStat = statSync(destParent);
      } catch (err) {
        if (err.code === "ENOENT")
          return;
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPathsSync(src, srcStat, destParent, funcName);
    }
    function areIdentical(srcStat, destStat) {
      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
        if (nodeSupportsBigInt || destStat.ino < Number.MAX_SAFE_INTEGER) {
          return true;
        }
        if (destStat.size === srcStat.size && destStat.mode === srcStat.mode && destStat.nlink === srcStat.nlink && destStat.atimeMs === srcStat.atimeMs && destStat.mtimeMs === srcStat.mtimeMs && destStat.ctimeMs === srcStat.ctimeMs && destStat.birthtimeMs === srcStat.birthtimeMs) {
          return true;
        }
      }
      return false;
    }
    function isSrcSubdir(src, dest) {
      const srcArr = path41.resolve(src).split(path41.sep).filter((i) => i);
      const destArr = path41.resolve(dest).split(path41.sep).filter((i) => i);
      return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);
    }
    function errMsg(src, dest, funcName) {
      return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
    }
    module2.exports = {
      checkPaths,
      checkPathsSync,
      checkParentPaths,
      checkParentPathsSync,
      isSrcSubdir
    };
  }
});

// node_modules/fs-extra/lib/copy-sync/copy-sync.js
var require_copy_sync3 = __commonJS({
  "node_modules/fs-extra/lib/copy-sync/copy-sync.js"(exports, module2) {
    "use strict";
    var fs29 = require_graceful_fs();
    var path41 = require("path");
    var mkdirsSync = require_mkdirs2().mkdirsSync;
    var utimesMillisSync = require_utimes2().utimesMillisSync;
    var stat = require_stat2();
    function copySync(src, dest, opts) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
      }
      const { srcStat, destStat } = stat.checkPathsSync(src, dest, "copy");
      stat.checkParentPathsSync(src, srcStat, dest, "copy");
      return handleFilterAndCopy(destStat, src, dest, opts);
    }
    function handleFilterAndCopy(destStat, src, dest, opts) {
      if (opts.filter && !opts.filter(src, dest))
        return;
      const destParent = path41.dirname(dest);
      if (!fs29.existsSync(destParent))
        mkdirsSync(destParent);
      return startCopy(destStat, src, dest, opts);
    }
    function startCopy(destStat, src, dest, opts) {
      if (opts.filter && !opts.filter(src, dest))
        return;
      return getStats(destStat, src, dest, opts);
    }
    function getStats(destStat, src, dest, opts) {
      const statSync = opts.dereference ? fs29.statSync : fs29.lstatSync;
      const srcStat = statSync(src);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src, dest, opts);
      else if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts);
    }
    function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return copyFile(srcStat, src, dest, opts);
      return mayCopyFile(srcStat, src, dest, opts);
    }
    function mayCopyFile(srcStat, src, dest, opts) {
      if (opts.overwrite) {
        fs29.unlinkSync(dest);
        return copyFile(srcStat, src, dest, opts);
      } else if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    function copyFile(srcStat, src, dest, opts) {
      fs29.copyFileSync(src, dest);
      if (opts.preserveTimestamps)
        handleTimestamps(srcStat.mode, src, dest);
      return setDestMode(dest, srcStat.mode);
    }
    function handleTimestamps(srcMode, src, dest) {
      if (fileIsNotWritable(srcMode))
        makeFileWritable(dest, srcMode);
      return setDestTimestamps(src, dest);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return setDestMode(dest, srcMode | 128);
    }
    function setDestMode(dest, srcMode) {
      return fs29.chmodSync(dest, srcMode);
    }
    function setDestTimestamps(src, dest) {
      const updatedSrcStat = fs29.statSync(src);
      return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return mkDirAndCopy(srcStat.mode, src, dest, opts);
      if (destStat && !destStat.isDirectory()) {
        throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
      }
      return copyDir(src, dest, opts);
    }
    function mkDirAndCopy(srcMode, src, dest, opts) {
      fs29.mkdirSync(dest);
      copyDir(src, dest, opts);
      return setDestMode(dest, srcMode);
    }
    function copyDir(src, dest, opts) {
      fs29.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
    }
    function copyDirItem(item, src, dest, opts) {
      const srcItem = path41.join(src, item);
      const destItem = path41.join(dest, item);
      const { destStat } = stat.checkPathsSync(srcItem, destItem, "copy");
      return startCopy(destStat, srcItem, destItem, opts);
    }
    function onLink(destStat, src, dest, opts) {
      let resolvedSrc = fs29.readlinkSync(src);
      if (opts.dereference) {
        resolvedSrc = path41.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs29.symlinkSync(resolvedSrc, dest);
      } else {
        let resolvedDest;
        try {
          resolvedDest = fs29.readlinkSync(dest);
        } catch (err) {
          if (err.code === "EINVAL" || err.code === "UNKNOWN")
            return fs29.symlinkSync(resolvedSrc, dest);
          throw err;
        }
        if (opts.dereference) {
          resolvedDest = path41.resolve(process.cwd(), resolvedDest);
        }
        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
        }
        if (fs29.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
        }
        return copyLink(resolvedSrc, dest);
      }
    }
    function copyLink(resolvedSrc, dest) {
      fs29.unlinkSync(dest);
      return fs29.symlinkSync(resolvedSrc, dest);
    }
    module2.exports = copySync;
  }
});

// node_modules/fs-extra/lib/copy-sync/index.js
var require_copy_sync4 = __commonJS({
  "node_modules/fs-extra/lib/copy-sync/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      copySync: require_copy_sync3()
    };
  }
});

// node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists2 = __commonJS({
  "node_modules/fs-extra/lib/path-exists/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs29 = require_fs2();
    function pathExists(path41) {
      return fs29.access(path41).then(() => true).catch(() => false);
    }
    module2.exports = {
      pathExists: u(pathExists),
      pathExistsSync: fs29.existsSync
    };
  }
});

// node_modules/fs-extra/lib/copy/copy.js
var require_copy3 = __commonJS({
  "node_modules/fs-extra/lib/copy/copy.js"(exports, module2) {
    "use strict";
    var fs29 = require_graceful_fs();
    var path41 = require("path");
    var mkdirs = require_mkdirs2().mkdirs;
    var pathExists = require_path_exists2().pathExists;
    var utimesMillis = require_utimes2().utimesMillis;
    var stat = require_stat2();
    function copy(src, dest, opts, cb) {
      if (typeof opts === "function" && !cb) {
        cb = opts;
        opts = {};
      } else if (typeof opts === "function") {
        opts = { filter: opts };
      }
      cb = cb || function() {
      };
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
      }
      stat.checkPaths(src, dest, "copy", (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, destStat } = stats;
        stat.checkParentPaths(src, srcStat, dest, "copy", (err2) => {
          if (err2)
            return cb(err2);
          if (opts.filter)
            return handleFilter(checkParentDir, destStat, src, dest, opts, cb);
          return checkParentDir(destStat, src, dest, opts, cb);
        });
      });
    }
    function checkParentDir(destStat, src, dest, opts, cb) {
      const destParent = path41.dirname(dest);
      pathExists(destParent, (err, dirExists) => {
        if (err)
          return cb(err);
        if (dirExists)
          return startCopy(destStat, src, dest, opts, cb);
        mkdirs(destParent, (err2) => {
          if (err2)
            return cb(err2);
          return startCopy(destStat, src, dest, opts, cb);
        });
      });
    }
    function handleFilter(onInclude, destStat, src, dest, opts, cb) {
      Promise.resolve(opts.filter(src, dest)).then((include) => {
        if (include)
          return onInclude(destStat, src, dest, opts, cb);
        return cb();
      }, (error) => cb(error));
    }
    function startCopy(destStat, src, dest, opts, cb) {
      if (opts.filter)
        return handleFilter(getStats, destStat, src, dest, opts, cb);
      return getStats(destStat, src, dest, opts, cb);
    }
    function getStats(destStat, src, dest, opts, cb) {
      const stat2 = opts.dereference ? fs29.stat : fs29.lstat;
      stat2(src, (err, srcStat) => {
        if (err)
          return cb(err);
        if (srcStat.isDirectory())
          return onDir(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
          return onFile(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isSymbolicLink())
          return onLink(destStat, src, dest, opts, cb);
      });
    }
    function onFile(srcStat, destStat, src, dest, opts, cb) {
      if (!destStat)
        return copyFile(srcStat, src, dest, opts, cb);
      return mayCopyFile(srcStat, src, dest, opts, cb);
    }
    function mayCopyFile(srcStat, src, dest, opts, cb) {
      if (opts.overwrite) {
        fs29.unlink(dest, (err) => {
          if (err)
            return cb(err);
          return copyFile(srcStat, src, dest, opts, cb);
        });
      } else if (opts.errorOnExist) {
        return cb(new Error(`'${dest}' already exists`));
      } else
        return cb();
    }
    function copyFile(srcStat, src, dest, opts, cb) {
      fs29.copyFile(src, dest, (err) => {
        if (err)
          return cb(err);
        if (opts.preserveTimestamps)
          return handleTimestampsAndMode(srcStat.mode, src, dest, cb);
        return setDestMode(dest, srcStat.mode, cb);
      });
    }
    function handleTimestampsAndMode(srcMode, src, dest, cb) {
      if (fileIsNotWritable(srcMode)) {
        return makeFileWritable(dest, srcMode, (err) => {
          if (err)
            return cb(err);
          return setDestTimestampsAndMode(srcMode, src, dest, cb);
        });
      }
      return setDestTimestampsAndMode(srcMode, src, dest, cb);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode, cb) {
      return setDestMode(dest, srcMode | 128, cb);
    }
    function setDestTimestampsAndMode(srcMode, src, dest, cb) {
      setDestTimestamps(src, dest, (err) => {
        if (err)
          return cb(err);
        return setDestMode(dest, srcMode, cb);
      });
    }
    function setDestMode(dest, srcMode, cb) {
      return fs29.chmod(dest, srcMode, cb);
    }
    function setDestTimestamps(src, dest, cb) {
      fs29.stat(src, (err, updatedSrcStat) => {
        if (err)
          return cb(err);
        return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
      });
    }
    function onDir(srcStat, destStat, src, dest, opts, cb) {
      if (!destStat)
        return mkDirAndCopy(srcStat.mode, src, dest, opts, cb);
      if (destStat && !destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
      }
      return copyDir(src, dest, opts, cb);
    }
    function mkDirAndCopy(srcMode, src, dest, opts, cb) {
      fs29.mkdir(dest, (err) => {
        if (err)
          return cb(err);
        copyDir(src, dest, opts, (err2) => {
          if (err2)
            return cb(err2);
          return setDestMode(dest, srcMode, cb);
        });
      });
    }
    function copyDir(src, dest, opts, cb) {
      fs29.readdir(src, (err, items) => {
        if (err)
          return cb(err);
        return copyDirItems(items, src, dest, opts, cb);
      });
    }
    function copyDirItems(items, src, dest, opts, cb) {
      const item = items.pop();
      if (!item)
        return cb();
      return copyDirItem(items, item, src, dest, opts, cb);
    }
    function copyDirItem(items, item, src, dest, opts, cb) {
      const srcItem = path41.join(src, item);
      const destItem = path41.join(dest, item);
      stat.checkPaths(srcItem, destItem, "copy", (err, stats) => {
        if (err)
          return cb(err);
        const { destStat } = stats;
        startCopy(destStat, srcItem, destItem, opts, (err2) => {
          if (err2)
            return cb(err2);
          return copyDirItems(items, src, dest, opts, cb);
        });
      });
    }
    function onLink(destStat, src, dest, opts, cb) {
      fs29.readlink(src, (err, resolvedSrc) => {
        if (err)
          return cb(err);
        if (opts.dereference) {
          resolvedSrc = path41.resolve(process.cwd(), resolvedSrc);
        }
        if (!destStat) {
          return fs29.symlink(resolvedSrc, dest, cb);
        } else {
          fs29.readlink(dest, (err2, resolvedDest) => {
            if (err2) {
              if (err2.code === "EINVAL" || err2.code === "UNKNOWN")
                return fs29.symlink(resolvedSrc, dest, cb);
              return cb(err2);
            }
            if (opts.dereference) {
              resolvedDest = path41.resolve(process.cwd(), resolvedDest);
            }
            if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
              return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
            }
            if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
              return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
            }
            return copyLink(resolvedSrc, dest, cb);
          });
        }
      });
    }
    function copyLink(resolvedSrc, dest, cb) {
      fs29.unlink(dest, (err) => {
        if (err)
          return cb(err);
        return fs29.symlink(resolvedSrc, dest, cb);
      });
    }
    module2.exports = copy;
  }
});

// node_modules/fs-extra/lib/copy/index.js
var require_copy4 = __commonJS({
  "node_modules/fs-extra/lib/copy/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    module2.exports = {
      copy: u(require_copy3())
    };
  }
});

// node_modules/fs-extra/lib/remove/rimraf.js
var require_rimraf2 = __commonJS({
  "node_modules/fs-extra/lib/remove/rimraf.js"(exports, module2) {
    "use strict";
    var fs29 = require_graceful_fs();
    var path41 = require("path");
    var assert = require("assert");
    var isWindows3 = process.platform === "win32";
    function defaults3(options2) {
      const methods2 = [
        "unlink",
        "chmod",
        "stat",
        "lstat",
        "rmdir",
        "readdir"
      ];
      methods2.forEach((m) => {
        options2[m] = options2[m] || fs29[m];
        m = m + "Sync";
        options2[m] = options2[m] || fs29[m];
      });
      options2.maxBusyTries = options2.maxBusyTries || 3;
    }
    function rimraf(p, options2, cb) {
      let busyTries = 0;
      if (typeof options2 === "function") {
        cb = options2;
        options2 = {};
      }
      assert(p, "rimraf: missing path");
      assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
      assert.strictEqual(typeof cb, "function", "rimraf: callback function required");
      assert(options2, "rimraf: invalid options argument provided");
      assert.strictEqual(typeof options2, "object", "rimraf: options should be object");
      defaults3(options2);
      rimraf_(p, options2, function CB(er) {
        if (er) {
          if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options2.maxBusyTries) {
            busyTries++;
            const time = busyTries * 100;
            return setTimeout(() => rimraf_(p, options2, CB), time);
          }
          if (er.code === "ENOENT")
            er = null;
        }
        cb(er);
      });
    }
    function rimraf_(p, options2, cb) {
      assert(p);
      assert(options2);
      assert(typeof cb === "function");
      options2.lstat(p, (er, st) => {
        if (er && er.code === "ENOENT") {
          return cb(null);
        }
        if (er && er.code === "EPERM" && isWindows3) {
          return fixWinEPERM(p, options2, er, cb);
        }
        if (st && st.isDirectory()) {
          return rmdir(p, options2, er, cb);
        }
        options2.unlink(p, (er2) => {
          if (er2) {
            if (er2.code === "ENOENT") {
              return cb(null);
            }
            if (er2.code === "EPERM") {
              return isWindows3 ? fixWinEPERM(p, options2, er2, cb) : rmdir(p, options2, er2, cb);
            }
            if (er2.code === "EISDIR") {
              return rmdir(p, options2, er2, cb);
            }
          }
          return cb(er2);
        });
      });
    }
    function fixWinEPERM(p, options2, er, cb) {
      assert(p);
      assert(options2);
      assert(typeof cb === "function");
      options2.chmod(p, 438, (er2) => {
        if (er2) {
          cb(er2.code === "ENOENT" ? null : er);
        } else {
          options2.stat(p, (er3, stats) => {
            if (er3) {
              cb(er3.code === "ENOENT" ? null : er);
            } else if (stats.isDirectory()) {
              rmdir(p, options2, er, cb);
            } else {
              options2.unlink(p, cb);
            }
          });
        }
      });
    }
    function fixWinEPERMSync(p, options2, er) {
      let stats;
      assert(p);
      assert(options2);
      try {
        options2.chmodSync(p, 438);
      } catch (er2) {
        if (er2.code === "ENOENT") {
          return;
        } else {
          throw er;
        }
      }
      try {
        stats = options2.statSync(p);
      } catch (er3) {
        if (er3.code === "ENOENT") {
          return;
        } else {
          throw er;
        }
      }
      if (stats.isDirectory()) {
        rmdirSync(p, options2, er);
      } else {
        options2.unlinkSync(p);
      }
    }
    function rmdir(p, options2, originalEr, cb) {
      assert(p);
      assert(options2);
      assert(typeof cb === "function");
      options2.rmdir(p, (er) => {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
          rmkids(p, options2, cb);
        } else if (er && er.code === "ENOTDIR") {
          cb(originalEr);
        } else {
          cb(er);
        }
      });
    }
    function rmkids(p, options2, cb) {
      assert(p);
      assert(options2);
      assert(typeof cb === "function");
      options2.readdir(p, (er, files) => {
        if (er)
          return cb(er);
        let n = files.length;
        let errState;
        if (n === 0)
          return options2.rmdir(p, cb);
        files.forEach((f) => {
          rimraf(path41.join(p, f), options2, (er2) => {
            if (errState) {
              return;
            }
            if (er2)
              return cb(errState = er2);
            if (--n === 0) {
              options2.rmdir(p, cb);
            }
          });
        });
      });
    }
    function rimrafSync(p, options2) {
      let st;
      options2 = options2 || {};
      defaults3(options2);
      assert(p, "rimraf: missing path");
      assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
      assert(options2, "rimraf: missing options");
      assert.strictEqual(typeof options2, "object", "rimraf: options should be object");
      try {
        st = options2.lstatSync(p);
      } catch (er) {
        if (er.code === "ENOENT") {
          return;
        }
        if (er.code === "EPERM" && isWindows3) {
          fixWinEPERMSync(p, options2, er);
        }
      }
      try {
        if (st && st.isDirectory()) {
          rmdirSync(p, options2, null);
        } else {
          options2.unlinkSync(p);
        }
      } catch (er) {
        if (er.code === "ENOENT") {
          return;
        } else if (er.code === "EPERM") {
          return isWindows3 ? fixWinEPERMSync(p, options2, er) : rmdirSync(p, options2, er);
        } else if (er.code !== "EISDIR") {
          throw er;
        }
        rmdirSync(p, options2, er);
      }
    }
    function rmdirSync(p, options2, originalEr) {
      assert(p);
      assert(options2);
      try {
        options2.rmdirSync(p);
      } catch (er) {
        if (er.code === "ENOTDIR") {
          throw originalEr;
        } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
          rmkidsSync(p, options2);
        } else if (er.code !== "ENOENT") {
          throw er;
        }
      }
    }
    function rmkidsSync(p, options2) {
      assert(p);
      assert(options2);
      options2.readdirSync(p).forEach((f) => rimrafSync(path41.join(p, f), options2));
      if (isWindows3) {
        const startTime = Date.now();
        do {
          try {
            const ret = options2.rmdirSync(p, options2);
            return ret;
          } catch {
          }
        } while (Date.now() - startTime < 500);
      } else {
        const ret = options2.rmdirSync(p, options2);
        return ret;
      }
    }
    module2.exports = rimraf;
    rimraf.sync = rimrafSync;
  }
});

// node_modules/fs-extra/lib/remove/index.js
var require_remove2 = __commonJS({
  "node_modules/fs-extra/lib/remove/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var rimraf = require_rimraf2();
    module2.exports = {
      remove: u(rimraf),
      removeSync: rimraf.sync
    };
  }
});

// node_modules/fs-extra/lib/empty/index.js
var require_empty2 = __commonJS({
  "node_modules/fs-extra/lib/empty/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs29 = require_graceful_fs();
    var path41 = require("path");
    var mkdir = require_mkdirs2();
    var remove = require_remove2();
    var emptyDir = u(function emptyDir2(dir, callback) {
      callback = callback || function() {
      };
      fs29.readdir(dir, (err, items) => {
        if (err)
          return mkdir.mkdirs(dir, callback);
        items = items.map((item) => path41.join(dir, item));
        deleteItem();
        function deleteItem() {
          const item = items.pop();
          if (!item)
            return callback();
          remove.remove(item, (err2) => {
            if (err2)
              return callback(err2);
            deleteItem();
          });
        }
      });
    });
    function emptyDirSync(dir) {
      let items;
      try {
        items = fs29.readdirSync(dir);
      } catch {
        return mkdir.mkdirsSync(dir);
      }
      items.forEach((item) => {
        item = path41.join(dir, item);
        remove.removeSync(item);
      });
    }
    module2.exports = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir,
      emptydir: emptyDir
    };
  }
});

// node_modules/fs-extra/lib/ensure/file.js
var require_file3 = __commonJS({
  "node_modules/fs-extra/lib/ensure/file.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path41 = require("path");
    var fs29 = require_graceful_fs();
    var mkdir = require_mkdirs2();
    function createFile(file, callback) {
      function makeFile() {
        fs29.writeFile(file, "", (err) => {
          if (err)
            return callback(err);
          callback();
        });
      }
      fs29.stat(file, (err, stats) => {
        if (!err && stats.isFile())
          return callback();
        const dir = path41.dirname(file);
        fs29.stat(dir, (err2, stats2) => {
          if (err2) {
            if (err2.code === "ENOENT") {
              return mkdir.mkdirs(dir, (err3) => {
                if (err3)
                  return callback(err3);
                makeFile();
              });
            }
            return callback(err2);
          }
          if (stats2.isDirectory())
            makeFile();
          else {
            fs29.readdir(dir, (err3) => {
              if (err3)
                return callback(err3);
            });
          }
        });
      });
    }
    function createFileSync(file) {
      let stats;
      try {
        stats = fs29.statSync(file);
      } catch {
      }
      if (stats && stats.isFile())
        return;
      const dir = path41.dirname(file);
      try {
        if (!fs29.statSync(dir).isDirectory()) {
          fs29.readdirSync(dir);
        }
      } catch (err) {
        if (err && err.code === "ENOENT")
          mkdir.mkdirsSync(dir);
        else
          throw err;
      }
      fs29.writeFileSync(file, "");
    }
    module2.exports = {
      createFile: u(createFile),
      createFileSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/link.js
var require_link2 = __commonJS({
  "node_modules/fs-extra/lib/ensure/link.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path41 = require("path");
    var fs29 = require_graceful_fs();
    var mkdir = require_mkdirs2();
    var pathExists = require_path_exists2().pathExists;
    function createLink(srcpath, dstpath, callback) {
      function makeLink(srcpath2, dstpath2) {
        fs29.link(srcpath2, dstpath2, (err) => {
          if (err)
            return callback(err);
          callback(null);
        });
      }
      pathExists(dstpath, (err, destinationExists) => {
        if (err)
          return callback(err);
        if (destinationExists)
          return callback(null);
        fs29.lstat(srcpath, (err2) => {
          if (err2) {
            err2.message = err2.message.replace("lstat", "ensureLink");
            return callback(err2);
          }
          const dir = path41.dirname(dstpath);
          pathExists(dir, (err3, dirExists) => {
            if (err3)
              return callback(err3);
            if (dirExists)
              return makeLink(srcpath, dstpath);
            mkdir.mkdirs(dir, (err4) => {
              if (err4)
                return callback(err4);
              makeLink(srcpath, dstpath);
            });
          });
        });
      });
    }
    function createLinkSync(srcpath, dstpath) {
      const destinationExists = fs29.existsSync(dstpath);
      if (destinationExists)
        return void 0;
      try {
        fs29.lstatSync(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      const dir = path41.dirname(dstpath);
      const dirExists = fs29.existsSync(dir);
      if (dirExists)
        return fs29.linkSync(srcpath, dstpath);
      mkdir.mkdirsSync(dir);
      return fs29.linkSync(srcpath, dstpath);
    }
    module2.exports = {
      createLink: u(createLink),
      createLinkSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths2 = __commonJS({
  "node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports, module2) {
    "use strict";
    var path41 = require("path");
    var fs29 = require_graceful_fs();
    var pathExists = require_path_exists2().pathExists;
    function symlinkPaths(srcpath, dstpath, callback) {
      if (path41.isAbsolute(srcpath)) {
        return fs29.lstat(srcpath, (err) => {
          if (err) {
            err.message = err.message.replace("lstat", "ensureSymlink");
            return callback(err);
          }
          return callback(null, {
            toCwd: srcpath,
            toDst: srcpath
          });
        });
      } else {
        const dstdir = path41.dirname(dstpath);
        const relativeToDst = path41.join(dstdir, srcpath);
        return pathExists(relativeToDst, (err, exists) => {
          if (err)
            return callback(err);
          if (exists) {
            return callback(null, {
              toCwd: relativeToDst,
              toDst: srcpath
            });
          } else {
            return fs29.lstat(srcpath, (err2) => {
              if (err2) {
                err2.message = err2.message.replace("lstat", "ensureSymlink");
                return callback(err2);
              }
              return callback(null, {
                toCwd: srcpath,
                toDst: path41.relative(dstdir, srcpath)
              });
            });
          }
        });
      }
    }
    function symlinkPathsSync(srcpath, dstpath) {
      let exists;
      if (path41.isAbsolute(srcpath)) {
        exists = fs29.existsSync(srcpath);
        if (!exists)
          throw new Error("absolute srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      } else {
        const dstdir = path41.dirname(dstpath);
        const relativeToDst = path41.join(dstdir, srcpath);
        exists = fs29.existsSync(relativeToDst);
        if (exists) {
          return {
            toCwd: relativeToDst,
            toDst: srcpath
          };
        } else {
          exists = fs29.existsSync(srcpath);
          if (!exists)
            throw new Error("relative srcpath does not exist");
          return {
            toCwd: srcpath,
            toDst: path41.relative(dstdir, srcpath)
          };
        }
      }
    }
    module2.exports = {
      symlinkPaths,
      symlinkPathsSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type2 = __commonJS({
  "node_modules/fs-extra/lib/ensure/symlink-type.js"(exports, module2) {
    "use strict";
    var fs29 = require_graceful_fs();
    function symlinkType(srcpath, type, callback) {
      callback = typeof type === "function" ? type : callback;
      type = typeof type === "function" ? false : type;
      if (type)
        return callback(null, type);
      fs29.lstat(srcpath, (err, stats) => {
        if (err)
          return callback(null, "file");
        type = stats && stats.isDirectory() ? "dir" : "file";
        callback(null, type);
      });
    }
    function symlinkTypeSync(srcpath, type) {
      let stats;
      if (type)
        return type;
      try {
        stats = fs29.lstatSync(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    module2.exports = {
      symlinkType,
      symlinkTypeSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink2 = __commonJS({
  "node_modules/fs-extra/lib/ensure/symlink.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path41 = require("path");
    var fs29 = require_graceful_fs();
    var _mkdirs = require_mkdirs2();
    var mkdirs = _mkdirs.mkdirs;
    var mkdirsSync = _mkdirs.mkdirsSync;
    var _symlinkPaths = require_symlink_paths2();
    var symlinkPaths = _symlinkPaths.symlinkPaths;
    var symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
    var _symlinkType = require_symlink_type2();
    var symlinkType = _symlinkType.symlinkType;
    var symlinkTypeSync = _symlinkType.symlinkTypeSync;
    var pathExists = require_path_exists2().pathExists;
    function createSymlink(srcpath, dstpath, type, callback) {
      callback = typeof type === "function" ? type : callback;
      type = typeof type === "function" ? false : type;
      pathExists(dstpath, (err, destinationExists) => {
        if (err)
          return callback(err);
        if (destinationExists)
          return callback(null);
        symlinkPaths(srcpath, dstpath, (err2, relative) => {
          if (err2)
            return callback(err2);
          srcpath = relative.toDst;
          symlinkType(relative.toCwd, type, (err3, type2) => {
            if (err3)
              return callback(err3);
            const dir = path41.dirname(dstpath);
            pathExists(dir, (err4, dirExists) => {
              if (err4)
                return callback(err4);
              if (dirExists)
                return fs29.symlink(srcpath, dstpath, type2, callback);
              mkdirs(dir, (err5) => {
                if (err5)
                  return callback(err5);
                fs29.symlink(srcpath, dstpath, type2, callback);
              });
            });
          });
        });
      });
    }
    function createSymlinkSync(srcpath, dstpath, type) {
      const destinationExists = fs29.existsSync(dstpath);
      if (destinationExists)
        return void 0;
      const relative = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative.toDst;
      type = symlinkTypeSync(relative.toCwd, type);
      const dir = path41.dirname(dstpath);
      const exists = fs29.existsSync(dir);
      if (exists)
        return fs29.symlinkSync(srcpath, dstpath, type);
      mkdirsSync(dir);
      return fs29.symlinkSync(srcpath, dstpath, type);
    }
    module2.exports = {
      createSymlink: u(createSymlink),
      createSymlinkSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/index.js
var require_ensure2 = __commonJS({
  "node_modules/fs-extra/lib/ensure/index.js"(exports, module2) {
    "use strict";
    var file = require_file3();
    var link = require_link2();
    var symlink = require_symlink2();
    module2.exports = {
      createFile: file.createFile,
      createFileSync: file.createFileSync,
      ensureFile: file.createFile,
      ensureFileSync: file.createFileSync,
      createLink: link.createLink,
      createLinkSync: link.createLinkSync,
      ensureLink: link.createLink,
      ensureLinkSync: link.createLinkSync,
      createSymlink: symlink.createSymlink,
      createSymlinkSync: symlink.createSymlinkSync,
      ensureSymlink: symlink.createSymlink,
      ensureSymlinkSync: symlink.createSymlinkSync
    };
  }
});

// node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile3 = __commonJS({
  "node_modules/fs-extra/lib/json/jsonfile.js"(exports, module2) {
    "use strict";
    var jsonFile = require_jsonfile();
    module2.exports = {
      readJson: jsonFile.readFile,
      readJsonSync: jsonFile.readFileSync,
      writeJson: jsonFile.writeFile,
      writeJsonSync: jsonFile.writeFileSync
    };
  }
});

// node_modules/fs-extra/lib/output/index.js
var require_output2 = __commonJS({
  "node_modules/fs-extra/lib/output/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs29 = require_graceful_fs();
    var path41 = require("path");
    var mkdir = require_mkdirs2();
    var pathExists = require_path_exists2().pathExists;
    function outputFile(file, data, encoding, callback) {
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = "utf8";
      }
      const dir = path41.dirname(file);
      pathExists(dir, (err, itDoes) => {
        if (err)
          return callback(err);
        if (itDoes)
          return fs29.writeFile(file, data, encoding, callback);
        mkdir.mkdirs(dir, (err2) => {
          if (err2)
            return callback(err2);
          fs29.writeFile(file, data, encoding, callback);
        });
      });
    }
    function outputFileSync(file, ...args) {
      const dir = path41.dirname(file);
      if (fs29.existsSync(dir)) {
        return fs29.writeFileSync(file, ...args);
      }
      mkdir.mkdirsSync(dir);
      fs29.writeFileSync(file, ...args);
    }
    module2.exports = {
      outputFile: u(outputFile),
      outputFileSync
    };
  }
});

// node_modules/fs-extra/lib/json/output-json.js
var require_output_json2 = __commonJS({
  "node_modules/fs-extra/lib/json/output-json.js"(exports, module2) {
    "use strict";
    var { stringify: stringify2 } = require_utils2();
    var { outputFile } = require_output2();
    async function outputJson(file, data, options2 = {}) {
      const str = stringify2(data, options2);
      await outputFile(file, str, options2);
    }
    module2.exports = outputJson;
  }
});

// node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync2 = __commonJS({
  "node_modules/fs-extra/lib/json/output-json-sync.js"(exports, module2) {
    "use strict";
    var { stringify: stringify2 } = require_utils2();
    var { outputFileSync } = require_output2();
    function outputJsonSync(file, data, options2) {
      const str = stringify2(data, options2);
      outputFileSync(file, str, options2);
    }
    module2.exports = outputJsonSync;
  }
});

// node_modules/fs-extra/lib/json/index.js
var require_json2 = __commonJS({
  "node_modules/fs-extra/lib/json/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var jsonFile = require_jsonfile3();
    jsonFile.outputJson = u(require_output_json2());
    jsonFile.outputJsonSync = require_output_json_sync2();
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    module2.exports = jsonFile;
  }
});

// node_modules/fs-extra/lib/move-sync/move-sync.js
var require_move_sync3 = __commonJS({
  "node_modules/fs-extra/lib/move-sync/move-sync.js"(exports, module2) {
    "use strict";
    var fs29 = require_graceful_fs();
    var path41 = require("path");
    var copySync = require_copy_sync4().copySync;
    var removeSync = require_remove2().removeSync;
    var mkdirpSync = require_mkdirs2().mkdirpSync;
    var stat = require_stat2();
    function moveSync(src, dest, opts) {
      opts = opts || {};
      const overwrite = opts.overwrite || opts.clobber || false;
      const { srcStat } = stat.checkPathsSync(src, dest, "move");
      stat.checkParentPathsSync(src, srcStat, dest, "move");
      mkdirpSync(path41.dirname(dest));
      return doRename(src, dest, overwrite);
    }
    function doRename(src, dest, overwrite) {
      if (overwrite) {
        removeSync(dest);
        return rename(src, dest, overwrite);
      }
      if (fs29.existsSync(dest))
        throw new Error("dest already exists.");
      return rename(src, dest, overwrite);
    }
    function rename(src, dest, overwrite) {
      try {
        fs29.renameSync(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV")
          throw err;
        return moveAcrossDevice(src, dest, overwrite);
      }
    }
    function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true
      };
      copySync(src, dest, opts);
      return removeSync(src);
    }
    module2.exports = moveSync;
  }
});

// node_modules/fs-extra/lib/move-sync/index.js
var require_move_sync4 = __commonJS({
  "node_modules/fs-extra/lib/move-sync/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      moveSync: require_move_sync3()
    };
  }
});

// node_modules/fs-extra/lib/move/move.js
var require_move3 = __commonJS({
  "node_modules/fs-extra/lib/move/move.js"(exports, module2) {
    "use strict";
    var fs29 = require_graceful_fs();
    var path41 = require("path");
    var copy = require_copy4().copy;
    var remove = require_remove2().remove;
    var mkdirp = require_mkdirs2().mkdirp;
    var pathExists = require_path_exists2().pathExists;
    var stat = require_stat2();
    function move(src, dest, opts, cb) {
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      const overwrite = opts.overwrite || opts.clobber || false;
      stat.checkPaths(src, dest, "move", (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat } = stats;
        stat.checkParentPaths(src, srcStat, dest, "move", (err2) => {
          if (err2)
            return cb(err2);
          mkdirp(path41.dirname(dest), (err3) => {
            if (err3)
              return cb(err3);
            return doRename(src, dest, overwrite, cb);
          });
        });
      });
    }
    function doRename(src, dest, overwrite, cb) {
      if (overwrite) {
        return remove(dest, (err) => {
          if (err)
            return cb(err);
          return rename(src, dest, overwrite, cb);
        });
      }
      pathExists(dest, (err, destExists) => {
        if (err)
          return cb(err);
        if (destExists)
          return cb(new Error("dest already exists."));
        return rename(src, dest, overwrite, cb);
      });
    }
    function rename(src, dest, overwrite, cb) {
      fs29.rename(src, dest, (err) => {
        if (!err)
          return cb();
        if (err.code !== "EXDEV")
          return cb(err);
        return moveAcrossDevice(src, dest, overwrite, cb);
      });
    }
    function moveAcrossDevice(src, dest, overwrite, cb) {
      const opts = {
        overwrite,
        errorOnExist: true
      };
      copy(src, dest, opts, (err) => {
        if (err)
          return cb(err);
        return remove(src, cb);
      });
    }
    module2.exports = move;
  }
});

// node_modules/fs-extra/lib/move/index.js
var require_move4 = __commonJS({
  "node_modules/fs-extra/lib/move/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    module2.exports = {
      move: u(require_move3())
    };
  }
});

// node_modules/fs-extra/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/fs-extra/lib/index.js"(exports, module2) {
    "use strict";
    module2.exports = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, require_fs2()), require_copy_sync4()), require_copy4()), require_empty2()), require_ensure2()), require_json2()), require_mkdirs2()), require_move_sync4()), require_move4()), require_output2()), require_path_exists2()), require_remove2());
    var fs29 = require("fs");
    if (Object.getOwnPropertyDescriptor(fs29, "promises")) {
      Object.defineProperty(module2.exports, "promises", {
        get() {
          return fs29.promises;
        }
      });
    }
  }
});

// src/util/logger.ts
var require_logger2 = __commonJS({
  "src/util/logger.ts"(exports, module2) {
    "use strict";
    var import_fs48 = __toESM(require("fs"));
    var import_log4js2 = __toESM(require_log4js());
    var import_path43 = __toESM(require("path"));
    var import_os13 = __toESM(require("os"));
    var import_fs_extra12 = __toESM(require_lib4());
    function getLogFile() {
      let file = process.env.NVIM_COC_LOG_FILE;
      if (file)
        return file;
      let dir = process.env.XDG_RUNTIME_DIR;
      if (dir) {
        try {
          import_fs48.default.accessSync(dir, import_fs48.default.constants.R_OK | import_fs48.default.constants.W_OK);
          return import_path43.default.join(dir, `coc-nvim-${process.pid}.log`);
        } catch (err) {
        }
      }
      let tmpdir = import_os13.default.tmpdir();
      dir = import_path43.default.join(tmpdir, `coc.nvim-${process.pid}`);
      if (!import_fs48.default.existsSync(dir))
        (0, import_fs_extra12.mkdirpSync)(dir);
      return import_path43.default.join(dir, `coc-nvim.log`);
    }
    var MAX_LOG_SIZE = 1024 * 1024;
    var MAX_LOG_BACKUPS = 10;
    var logfile = getLogFile();
    var level = process.env.NVIM_COC_LOG_LEVEL || "info";
    if (import_fs48.default.existsSync(logfile)) {
      try {
        import_fs48.default.writeFileSync(logfile, "", { encoding: "utf8", mode: 438 });
      } catch (e) {
      }
    }
    exports.getLogFile = getLogFile;
    import_log4js2.default.configure({
      disableClustering: true,
      appenders: {
        out: {
          type: "file",
          mode: 438,
          filename: logfile,
          maxLogSize: MAX_LOG_SIZE,
          backups: MAX_LOG_BACKUPS,
          layout: {
            type: "pattern",
            pattern: `%d{ISO8601} %p (pid:${process.pid}) [%c] - %m`
          }
        }
      },
      categories: {
        default: { appenders: ["out"], level }
      }
    });
    module2.exports = (name2 = "coc-nvim") => {
      let logger138 = import_log4js2.default.getLogger(name2);
      return Object.assign(logger138, {
        getLogFile,
        logfile
      });
    };
  }
});

// src/util/extensions.ts
var init_extensions = __esm({
  "src/util/extensions.ts"() {
    "use strict";
    Promise.prototype.logError = function() {
      this.catch((e) => {
        require_logger2()("util-extensions").error(e);
      });
    };
  }
});

// node_modules/msgpack-lite/lib/buffer-global.js
var require_buffer_global = __commonJS({
  "node_modules/msgpack-lite/lib/buffer-global.js"(exports, module2) {
    module2.exports = c(typeof Buffer !== "undefined" && Buffer) || c(exports.Buffer) || c(typeof window !== "undefined" && window.Buffer) || exports.Buffer;
    function c(B) {
      return B && B.isBuffer && B;
    }
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports, module2) {
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/msgpack-lite/lib/bufferish-array.js
var require_bufferish_array = __commonJS({
  "node_modules/msgpack-lite/lib/bufferish-array.js"(exports, module2) {
    var Bufferish = require_bufferish();
    var exports = module2.exports = alloc(0);
    exports.alloc = alloc;
    exports.concat = Bufferish.concat;
    exports.from = from;
    function alloc(size) {
      return new Array(size);
    }
    function from(value) {
      if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {
        value = Bufferish.Uint8Array.from(value);
      } else if (Bufferish.isArrayBuffer(value)) {
        value = new Uint8Array(value);
      } else if (typeof value === "string") {
        return Bufferish.from.call(exports, value);
      } else if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      return Array.prototype.slice.call(value);
    }
  }
});

// node_modules/msgpack-lite/lib/bufferish-buffer.js
var require_bufferish_buffer = __commonJS({
  "node_modules/msgpack-lite/lib/bufferish-buffer.js"(exports, module2) {
    var Bufferish = require_bufferish();
    var Buffer3 = Bufferish.global;
    var exports = module2.exports = Bufferish.hasBuffer ? alloc(0) : [];
    exports.alloc = Bufferish.hasBuffer && Buffer3.alloc || alloc;
    exports.concat = Bufferish.concat;
    exports.from = from;
    function alloc(size) {
      return new Buffer3(size);
    }
    function from(value) {
      if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {
        value = Bufferish.Uint8Array.from(value);
      } else if (Bufferish.isArrayBuffer(value)) {
        value = new Uint8Array(value);
      } else if (typeof value === "string") {
        return Bufferish.from.call(exports, value);
      } else if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      if (Buffer3.from && Buffer3.from.length !== 1) {
        return Buffer3.from(value);
      } else {
        return new Buffer3(value);
      }
    }
  }
});

// node_modules/msgpack-lite/lib/bufferish-uint8array.js
var require_bufferish_uint8array = __commonJS({
  "node_modules/msgpack-lite/lib/bufferish-uint8array.js"(exports, module2) {
    var Bufferish = require_bufferish();
    var exports = module2.exports = Bufferish.hasArrayBuffer ? alloc(0) : [];
    exports.alloc = alloc;
    exports.concat = Bufferish.concat;
    exports.from = from;
    function alloc(size) {
      return new Uint8Array(size);
    }
    function from(value) {
      if (Bufferish.isView(value)) {
        var byteOffset = value.byteOffset;
        var byteLength2 = value.byteLength;
        value = value.buffer;
        if (value.byteLength !== byteLength2) {
          if (value.slice) {
            value = value.slice(byteOffset, byteOffset + byteLength2);
          } else {
            value = new Uint8Array(value);
            if (value.byteLength !== byteLength2) {
              value = Array.prototype.slice.call(value, byteOffset, byteOffset + byteLength2);
            }
          }
        }
      } else if (typeof value === "string") {
        return Bufferish.from.call(exports, value);
      } else if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      return new Uint8Array(value);
    }
  }
});

// node_modules/msgpack-lite/lib/buffer-lite.js
var require_buffer_lite = __commonJS({
  "node_modules/msgpack-lite/lib/buffer-lite.js"(exports) {
    exports.copy = copy;
    exports.toString = toString;
    exports.write = write;
    function write(string2, offset) {
      var buffer = this;
      var index = offset || (offset |= 0);
      var length = string2.length;
      var chr = 0;
      var i = 0;
      while (i < length) {
        chr = string2.charCodeAt(i++);
        if (chr < 128) {
          buffer[index++] = chr;
        } else if (chr < 2048) {
          buffer[index++] = 192 | chr >>> 6;
          buffer[index++] = 128 | chr & 63;
        } else if (chr < 55296 || chr > 57343) {
          buffer[index++] = 224 | chr >>> 12;
          buffer[index++] = 128 | chr >>> 6 & 63;
          buffer[index++] = 128 | chr & 63;
        } else {
          chr = (chr - 55296 << 10 | string2.charCodeAt(i++) - 56320) + 65536;
          buffer[index++] = 240 | chr >>> 18;
          buffer[index++] = 128 | chr >>> 12 & 63;
          buffer[index++] = 128 | chr >>> 6 & 63;
          buffer[index++] = 128 | chr & 63;
        }
      }
      return index - offset;
    }
    function toString(encoding, start, end) {
      var buffer = this;
      var index = start | 0;
      if (!end)
        end = buffer.length;
      var string2 = "";
      var chr = 0;
      while (index < end) {
        chr = buffer[index++];
        if (chr < 128) {
          string2 += String.fromCharCode(chr);
          continue;
        }
        if ((chr & 224) === 192) {
          chr = (chr & 31) << 6 | buffer[index++] & 63;
        } else if ((chr & 240) === 224) {
          chr = (chr & 15) << 12 | (buffer[index++] & 63) << 6 | buffer[index++] & 63;
        } else if ((chr & 248) === 240) {
          chr = (chr & 7) << 18 | (buffer[index++] & 63) << 12 | (buffer[index++] & 63) << 6 | buffer[index++] & 63;
        }
        if (chr >= 65536) {
          chr -= 65536;
          string2 += String.fromCharCode((chr >>> 10) + 55296, (chr & 1023) + 56320);
        } else {
          string2 += String.fromCharCode(chr);
        }
      }
      return string2;
    }
    function copy(target, targetStart, start, end) {
      var i;
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (!targetStart)
        targetStart = 0;
      var len = end - start;
      if (target === this && start < targetStart && targetStart < end) {
        for (i = len - 1; i >= 0; i--) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        for (i = 0; i < len; i++) {
          target[i + targetStart] = this[i + start];
        }
      }
      return len;
    }
  }
});

// node_modules/msgpack-lite/lib/bufferish-proto.js
var require_bufferish_proto = __commonJS({
  "node_modules/msgpack-lite/lib/bufferish-proto.js"(exports) {
    var BufferLite = require_buffer_lite();
    exports.copy = copy;
    exports.slice = slice;
    exports.toString = toString;
    exports.write = gen("write");
    var Bufferish = require_bufferish();
    var Buffer3 = Bufferish.global;
    var isBufferShim = Bufferish.hasBuffer && "TYPED_ARRAY_SUPPORT" in Buffer3;
    var brokenTypedArray = isBufferShim && !Buffer3.TYPED_ARRAY_SUPPORT;
    function copy(target, targetStart, start, end) {
      var thisIsBuffer = Bufferish.isBuffer(this);
      var targetIsBuffer = Bufferish.isBuffer(target);
      if (thisIsBuffer && targetIsBuffer) {
        return this.copy(target, targetStart, start, end);
      } else if (!brokenTypedArray && !thisIsBuffer && !targetIsBuffer && Bufferish.isView(this) && Bufferish.isView(target)) {
        var buffer = start || end != null ? slice.call(this, start, end) : this;
        target.set(buffer, targetStart);
        return buffer.length;
      } else {
        return BufferLite.copy.call(this, target, targetStart, start, end);
      }
    }
    function slice(start, end) {
      var f = this.slice || !brokenTypedArray && this.subarray;
      if (f)
        return f.call(this, start, end);
      var target = Bufferish.alloc.call(this, end - start);
      copy.call(this, target, 0, start, end);
      return target;
    }
    function toString(encoding, start, end) {
      var f = !isBufferShim && Bufferish.isBuffer(this) ? this.toString : BufferLite.toString;
      return f.apply(this, arguments);
    }
    function gen(method) {
      return wrap;
      function wrap() {
        var f = this[method] || BufferLite[method];
        return f.apply(this, arguments);
      }
    }
  }
});

// node_modules/msgpack-lite/lib/bufferish.js
var require_bufferish = __commonJS({
  "node_modules/msgpack-lite/lib/bufferish.js"(exports) {
    var Buffer3 = exports.global = require_buffer_global();
    var hasBuffer = exports.hasBuffer = Buffer3 && !!Buffer3.isBuffer;
    var hasArrayBuffer = exports.hasArrayBuffer = typeof ArrayBuffer !== "undefined";
    var isArray = exports.isArray = require_isarray();
    exports.isArrayBuffer = hasArrayBuffer ? isArrayBuffer : _false;
    var isBuffer = exports.isBuffer = hasBuffer ? Buffer3.isBuffer : _false;
    var isView = exports.isView = hasArrayBuffer ? ArrayBuffer.isView || _is("ArrayBuffer", "buffer") : _false;
    exports.alloc = alloc;
    exports.concat = concat;
    exports.from = from;
    var BufferArray = exports.Array = require_bufferish_array();
    var BufferBuffer = exports.Buffer = require_bufferish_buffer();
    var BufferUint8Array = exports.Uint8Array = require_bufferish_uint8array();
    var BufferProto = exports.prototype = require_bufferish_proto();
    function from(value) {
      if (typeof value === "string") {
        return fromString.call(this, value);
      } else {
        return auto(this).from(value);
      }
    }
    function alloc(size) {
      return auto(this).alloc(size);
    }
    function concat(list2, length) {
      if (!length) {
        length = 0;
        Array.prototype.forEach.call(list2, dryrun);
      }
      var ref = this !== exports && this || list2[0];
      var result = alloc.call(ref, length);
      var offset = 0;
      Array.prototype.forEach.call(list2, append);
      return result;
      function dryrun(buffer) {
        length += buffer.length;
      }
      function append(buffer) {
        offset += BufferProto.copy.call(buffer, result, offset);
      }
    }
    var _isArrayBuffer = _is("ArrayBuffer");
    function isArrayBuffer(value) {
      return value instanceof ArrayBuffer || _isArrayBuffer(value);
    }
    function fromString(value) {
      var expected = value.length * 3;
      var that = alloc.call(this, expected);
      var actual = BufferProto.write.call(that, value);
      if (expected !== actual) {
        that = BufferProto.slice.call(that, 0, actual);
      }
      return that;
    }
    function auto(that) {
      return isBuffer(that) ? BufferBuffer : isView(that) ? BufferUint8Array : isArray(that) ? BufferArray : hasBuffer ? BufferBuffer : hasArrayBuffer ? BufferUint8Array : BufferArray;
    }
    function _false() {
      return false;
    }
    function _is(name2, key) {
      name2 = "[object " + name2 + "]";
      return function(value) {
        return value != null && {}.toString.call(key ? value[key] : value) === name2;
      };
    }
  }
});

// node_modules/msgpack-lite/lib/ext-buffer.js
var require_ext_buffer = __commonJS({
  "node_modules/msgpack-lite/lib/ext-buffer.js"(exports) {
    exports.ExtBuffer = ExtBuffer;
    var Bufferish = require_bufferish();
    function ExtBuffer(buffer, type) {
      if (!(this instanceof ExtBuffer))
        return new ExtBuffer(buffer, type);
      this.buffer = Bufferish.from(buffer);
      this.type = type;
    }
  }
});

// node_modules/msgpack-lite/lib/ext-packer.js
var require_ext_packer = __commonJS({
  "node_modules/msgpack-lite/lib/ext-packer.js"(exports) {
    exports.setExtPackers = setExtPackers;
    var Bufferish = require_bufferish();
    var Buffer3 = Bufferish.global;
    var packTypedArray = Bufferish.Uint8Array.from;
    var _encode;
    var ERROR_COLUMNS = { name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1 };
    function setExtPackers(codec) {
      codec.addExtPacker(14, Error, [packError, encode]);
      codec.addExtPacker(1, EvalError, [packError, encode]);
      codec.addExtPacker(2, RangeError, [packError, encode]);
      codec.addExtPacker(3, ReferenceError, [packError, encode]);
      codec.addExtPacker(4, SyntaxError, [packError, encode]);
      codec.addExtPacker(5, TypeError, [packError, encode]);
      codec.addExtPacker(6, URIError, [packError, encode]);
      codec.addExtPacker(10, RegExp, [packRegExp, encode]);
      codec.addExtPacker(11, Boolean, [packValueOf, encode]);
      codec.addExtPacker(12, String, [packValueOf, encode]);
      codec.addExtPacker(13, Date, [Number, encode]);
      codec.addExtPacker(15, Number, [packValueOf, encode]);
      if (typeof Uint8Array !== "undefined") {
        codec.addExtPacker(17, Int8Array, packTypedArray);
        codec.addExtPacker(18, Uint8Array, packTypedArray);
        codec.addExtPacker(19, Int16Array, packTypedArray);
        codec.addExtPacker(20, Uint16Array, packTypedArray);
        codec.addExtPacker(21, Int32Array, packTypedArray);
        codec.addExtPacker(22, Uint32Array, packTypedArray);
        codec.addExtPacker(23, Float32Array, packTypedArray);
        if (typeof Float64Array !== "undefined") {
          codec.addExtPacker(24, Float64Array, packTypedArray);
        }
        if (typeof Uint8ClampedArray !== "undefined") {
          codec.addExtPacker(25, Uint8ClampedArray, packTypedArray);
        }
        codec.addExtPacker(26, ArrayBuffer, packTypedArray);
        codec.addExtPacker(29, DataView, packTypedArray);
      }
      if (Bufferish.hasBuffer) {
        codec.addExtPacker(27, Buffer3, Bufferish.from);
      }
    }
    function encode(input) {
      if (!_encode)
        _encode = require_encode().encode;
      return _encode(input);
    }
    function packValueOf(value) {
      return value.valueOf();
    }
    function packRegExp(value) {
      value = RegExp.prototype.toString.call(value).split("/");
      value.shift();
      var out = [value.pop()];
      out.unshift(value.join("/"));
      return out;
    }
    function packError(value) {
      var out = {};
      for (var key in ERROR_COLUMNS) {
        out[key] = value[key];
      }
      return out;
    }
  }
});

// node_modules/int64-buffer/int64-buffer.js
var require_int64_buffer = __commonJS({
  "node_modules/int64-buffer/int64-buffer.js"(exports) {
    var Uint64BE;
    var Int64BE;
    var Uint64LE;
    var Int64LE;
    !function(exports2) {
      var UNDEFINED = "undefined";
      var BUFFER = UNDEFINED !== typeof Buffer && Buffer;
      var UINT8ARRAY = UNDEFINED !== typeof Uint8Array && Uint8Array;
      var ARRAYBUFFER = UNDEFINED !== typeof ArrayBuffer && ArrayBuffer;
      var ZERO = [0, 0, 0, 0, 0, 0, 0, 0];
      var isArray = Array.isArray || _isArray;
      var BIT32 = 4294967296;
      var BIT24 = 16777216;
      var storage;
      Uint64BE = factory("Uint64BE", true, true);
      Int64BE = factory("Int64BE", true, false);
      Uint64LE = factory("Uint64LE", false, true);
      Int64LE = factory("Int64LE", false, false);
      function factory(name2, bigendian, unsigned) {
        var posH = bigendian ? 0 : 4;
        var posL = bigendian ? 4 : 0;
        var pos0 = bigendian ? 0 : 3;
        var pos1 = bigendian ? 1 : 2;
        var pos2 = bigendian ? 2 : 1;
        var pos3 = bigendian ? 3 : 0;
        var fromPositive = bigendian ? fromPositiveBE : fromPositiveLE;
        var fromNegative = bigendian ? fromNegativeBE : fromNegativeLE;
        var proto = Int64.prototype;
        var isName = "is" + name2;
        var _isInt64 = "_" + isName;
        proto.buffer = void 0;
        proto.offset = 0;
        proto[_isInt64] = true;
        proto.toNumber = toNumber;
        proto.toString = toString;
        proto.toJSON = toNumber;
        proto.toArray = toArray;
        if (BUFFER)
          proto.toBuffer = toBuffer;
        if (UINT8ARRAY)
          proto.toArrayBuffer = toArrayBuffer;
        Int64[isName] = isInt64;
        exports2[name2] = Int64;
        return Int64;
        function Int64(buffer, offset, value, raddix) {
          if (!(this instanceof Int64))
            return new Int64(buffer, offset, value, raddix);
          return init(this, buffer, offset, value, raddix);
        }
        function isInt64(b) {
          return !!(b && b[_isInt64]);
        }
        function init(that, buffer, offset, value, raddix) {
          if (UINT8ARRAY && ARRAYBUFFER) {
            if (buffer instanceof ARRAYBUFFER)
              buffer = new UINT8ARRAY(buffer);
            if (value instanceof ARRAYBUFFER)
              value = new UINT8ARRAY(value);
          }
          if (!buffer && !offset && !value && !storage) {
            that.buffer = newArray(ZERO, 0);
            return;
          }
          if (!isValidBuffer(buffer, offset)) {
            var _storage = storage || Array;
            raddix = offset;
            value = buffer;
            offset = 0;
            buffer = new _storage(8);
          }
          that.buffer = buffer;
          that.offset = offset |= 0;
          if (UNDEFINED === typeof value)
            return;
          if (typeof value === "string") {
            fromString(buffer, offset, value, raddix || 10);
          } else if (isValidBuffer(value, raddix)) {
            fromArray(buffer, offset, value, raddix);
          } else if (typeof raddix === "number") {
            writeInt32(buffer, offset + posH, value);
            writeInt32(buffer, offset + posL, raddix);
          } else if (value > 0) {
            fromPositive(buffer, offset, value);
          } else if (value < 0) {
            fromNegative(buffer, offset, value);
          } else {
            fromArray(buffer, offset, ZERO, 0);
          }
        }
        function fromString(buffer, offset, str, raddix) {
          var pos = 0;
          var len = str.length;
          var high = 0;
          var low = 0;
          if (str[0] === "-")
            pos++;
          var sign = pos;
          while (pos < len) {
            var chr = parseInt(str[pos++], raddix);
            if (!(chr >= 0))
              break;
            low = low * raddix + chr;
            high = high * raddix + Math.floor(low / BIT32);
            low %= BIT32;
          }
          if (sign) {
            high = ~high;
            if (low) {
              low = BIT32 - low;
            } else {
              high++;
            }
          }
          writeInt32(buffer, offset + posH, high);
          writeInt32(buffer, offset + posL, low);
        }
        function toNumber() {
          var buffer = this.buffer;
          var offset = this.offset;
          var high = readInt32(buffer, offset + posH);
          var low = readInt32(buffer, offset + posL);
          if (!unsigned)
            high |= 0;
          return high ? high * BIT32 + low : low;
        }
        function toString(radix) {
          var buffer = this.buffer;
          var offset = this.offset;
          var high = readInt32(buffer, offset + posH);
          var low = readInt32(buffer, offset + posL);
          var str = "";
          var sign = !unsigned && high & 2147483648;
          if (sign) {
            high = ~high;
            low = BIT32 - low;
          }
          radix = radix || 10;
          while (1) {
            var mod = high % radix * BIT32 + low;
            high = Math.floor(high / radix);
            low = Math.floor(mod / radix);
            str = (mod % radix).toString(radix) + str;
            if (!high && !low)
              break;
          }
          if (sign) {
            str = "-" + str;
          }
          return str;
        }
        function writeInt32(buffer, offset, value) {
          buffer[offset + pos3] = value & 255;
          value = value >> 8;
          buffer[offset + pos2] = value & 255;
          value = value >> 8;
          buffer[offset + pos1] = value & 255;
          value = value >> 8;
          buffer[offset + pos0] = value & 255;
        }
        function readInt32(buffer, offset) {
          return buffer[offset + pos0] * BIT24 + (buffer[offset + pos1] << 16) + (buffer[offset + pos2] << 8) + buffer[offset + pos3];
        }
      }
      function toArray(raw) {
        var buffer = this.buffer;
        var offset = this.offset;
        storage = null;
        if (raw !== false && offset === 0 && buffer.length === 8 && isArray(buffer))
          return buffer;
        return newArray(buffer, offset);
      }
      function toBuffer(raw) {
        var buffer = this.buffer;
        var offset = this.offset;
        storage = BUFFER;
        if (raw !== false && offset === 0 && buffer.length === 8 && Buffer.isBuffer(buffer))
          return buffer;
        var dest = new BUFFER(8);
        fromArray(dest, 0, buffer, offset);
        return dest;
      }
      function toArrayBuffer(raw) {
        var buffer = this.buffer;
        var offset = this.offset;
        var arrbuf = buffer.buffer;
        storage = UINT8ARRAY;
        if (raw !== false && offset === 0 && arrbuf instanceof ARRAYBUFFER && arrbuf.byteLength === 8)
          return arrbuf;
        var dest = new UINT8ARRAY(8);
        fromArray(dest, 0, buffer, offset);
        return dest.buffer;
      }
      function isValidBuffer(buffer, offset) {
        var len = buffer && buffer.length;
        offset |= 0;
        return len && offset + 8 <= len && typeof buffer[offset] !== "string";
      }
      function fromArray(destbuf, destoff, srcbuf, srcoff) {
        destoff |= 0;
        srcoff |= 0;
        for (var i = 0; i < 8; i++) {
          destbuf[destoff++] = srcbuf[srcoff++] & 255;
        }
      }
      function newArray(buffer, offset) {
        return Array.prototype.slice.call(buffer, offset, offset + 8);
      }
      function fromPositiveBE(buffer, offset, value) {
        var pos = offset + 8;
        while (pos > offset) {
          buffer[--pos] = value & 255;
          value /= 256;
        }
      }
      function fromNegativeBE(buffer, offset, value) {
        var pos = offset + 8;
        value++;
        while (pos > offset) {
          buffer[--pos] = -value & 255 ^ 255;
          value /= 256;
        }
      }
      function fromPositiveLE(buffer, offset, value) {
        var end = offset + 8;
        while (offset < end) {
          buffer[offset++] = value & 255;
          value /= 256;
        }
      }
      function fromNegativeLE(buffer, offset, value) {
        var end = offset + 8;
        value++;
        while (offset < end) {
          buffer[offset++] = -value & 255 ^ 255;
          value /= 256;
        }
      }
      function _isArray(val) {
        return !!val && Object.prototype.toString.call(val) == "[object Array]";
      }
    }(typeof exports === "object" && typeof exports.nodeName !== "string" ? exports : exports || {});
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/msgpack-lite/lib/write-uint8.js
var require_write_uint8 = __commonJS({
  "node_modules/msgpack-lite/lib/write-uint8.js"(exports) {
    var constant = exports.uint8 = new Array(256);
    for (i = 0; i <= 255; i++) {
      constant[i] = write0(i);
    }
    var i;
    function write0(type) {
      return function(encoder) {
        var offset = encoder.reserve(1);
        encoder.buffer[offset] = type;
      };
    }
  }
});

// node_modules/msgpack-lite/lib/write-token.js
var require_write_token = __commonJS({
  "node_modules/msgpack-lite/lib/write-token.js"(exports) {
    var ieee754 = require_ieee754();
    var Int64Buffer = require_int64_buffer();
    var Uint64BE = Int64Buffer.Uint64BE;
    var Int64BE = Int64Buffer.Int64BE;
    var uint8 = require_write_uint8().uint8;
    var Bufferish = require_bufferish();
    var Buffer3 = Bufferish.global;
    var IS_BUFFER_SHIM = Bufferish.hasBuffer && "TYPED_ARRAY_SUPPORT" in Buffer3;
    var NO_TYPED_ARRAY = IS_BUFFER_SHIM && !Buffer3.TYPED_ARRAY_SUPPORT;
    var Buffer_prototype = Bufferish.hasBuffer && Buffer3.prototype || {};
    exports.getWriteToken = getWriteToken;
    function getWriteToken(options2) {
      if (options2 && options2.uint8array) {
        return init_uint8array();
      } else if (NO_TYPED_ARRAY || Bufferish.hasBuffer && options2 && options2.safe) {
        return init_safe();
      } else {
        return init_token();
      }
    }
    function init_uint8array() {
      var token = init_token();
      token[202] = writeN(202, 4, writeFloatBE);
      token[203] = writeN(203, 8, writeDoubleBE);
      return token;
    }
    function init_token() {
      var token = uint8.slice();
      token[196] = write1(196);
      token[197] = write2(197);
      token[198] = write4(198);
      token[199] = write1(199);
      token[200] = write2(200);
      token[201] = write4(201);
      token[202] = writeN(202, 4, Buffer_prototype.writeFloatBE || writeFloatBE, true);
      token[203] = writeN(203, 8, Buffer_prototype.writeDoubleBE || writeDoubleBE, true);
      token[204] = write1(204);
      token[205] = write2(205);
      token[206] = write4(206);
      token[207] = writeN(207, 8, writeUInt64BE);
      token[208] = write1(208);
      token[209] = write2(209);
      token[210] = write4(210);
      token[211] = writeN(211, 8, writeInt64BE);
      token[217] = write1(217);
      token[218] = write2(218);
      token[219] = write4(219);
      token[220] = write2(220);
      token[221] = write4(221);
      token[222] = write2(222);
      token[223] = write4(223);
      return token;
    }
    function init_safe() {
      var token = uint8.slice();
      token[196] = writeN(196, 1, Buffer3.prototype.writeUInt8);
      token[197] = writeN(197, 2, Buffer3.prototype.writeUInt16BE);
      token[198] = writeN(198, 4, Buffer3.prototype.writeUInt32BE);
      token[199] = writeN(199, 1, Buffer3.prototype.writeUInt8);
      token[200] = writeN(200, 2, Buffer3.prototype.writeUInt16BE);
      token[201] = writeN(201, 4, Buffer3.prototype.writeUInt32BE);
      token[202] = writeN(202, 4, Buffer3.prototype.writeFloatBE);
      token[203] = writeN(203, 8, Buffer3.prototype.writeDoubleBE);
      token[204] = writeN(204, 1, Buffer3.prototype.writeUInt8);
      token[205] = writeN(205, 2, Buffer3.prototype.writeUInt16BE);
      token[206] = writeN(206, 4, Buffer3.prototype.writeUInt32BE);
      token[207] = writeN(207, 8, writeUInt64BE);
      token[208] = writeN(208, 1, Buffer3.prototype.writeInt8);
      token[209] = writeN(209, 2, Buffer3.prototype.writeInt16BE);
      token[210] = writeN(210, 4, Buffer3.prototype.writeInt32BE);
      token[211] = writeN(211, 8, writeInt64BE);
      token[217] = writeN(217, 1, Buffer3.prototype.writeUInt8);
      token[218] = writeN(218, 2, Buffer3.prototype.writeUInt16BE);
      token[219] = writeN(219, 4, Buffer3.prototype.writeUInt32BE);
      token[220] = writeN(220, 2, Buffer3.prototype.writeUInt16BE);
      token[221] = writeN(221, 4, Buffer3.prototype.writeUInt32BE);
      token[222] = writeN(222, 2, Buffer3.prototype.writeUInt16BE);
      token[223] = writeN(223, 4, Buffer3.prototype.writeUInt32BE);
      return token;
    }
    function write1(type) {
      return function(encoder, value) {
        var offset = encoder.reserve(2);
        var buffer = encoder.buffer;
        buffer[offset++] = type;
        buffer[offset] = value;
      };
    }
    function write2(type) {
      return function(encoder, value) {
        var offset = encoder.reserve(3);
        var buffer = encoder.buffer;
        buffer[offset++] = type;
        buffer[offset++] = value >>> 8;
        buffer[offset] = value;
      };
    }
    function write4(type) {
      return function(encoder, value) {
        var offset = encoder.reserve(5);
        var buffer = encoder.buffer;
        buffer[offset++] = type;
        buffer[offset++] = value >>> 24;
        buffer[offset++] = value >>> 16;
        buffer[offset++] = value >>> 8;
        buffer[offset] = value;
      };
    }
    function writeN(type, len, method, noAssert) {
      return function(encoder, value) {
        var offset = encoder.reserve(len + 1);
        encoder.buffer[offset++] = type;
        method.call(encoder.buffer, value, offset, noAssert);
      };
    }
    function writeUInt64BE(value, offset) {
      new Uint64BE(this, offset, value);
    }
    function writeInt64BE(value, offset) {
      new Int64BE(this, offset, value);
    }
    function writeFloatBE(value, offset) {
      ieee754.write(this, value, offset, false, 23, 4);
    }
    function writeDoubleBE(value, offset) {
      ieee754.write(this, value, offset, false, 52, 8);
    }
  }
});

// node_modules/msgpack-lite/lib/write-type.js
var require_write_type = __commonJS({
  "node_modules/msgpack-lite/lib/write-type.js"(exports) {
    var IS_ARRAY = require_isarray();
    var Int64Buffer = require_int64_buffer();
    var Uint64BE = Int64Buffer.Uint64BE;
    var Int64BE = Int64Buffer.Int64BE;
    var Bufferish = require_bufferish();
    var BufferProto = require_bufferish_proto();
    var WriteToken = require_write_token();
    var uint8 = require_write_uint8().uint8;
    var ExtBuffer = require_ext_buffer().ExtBuffer;
    var HAS_UINT8ARRAY = typeof Uint8Array !== "undefined";
    var HAS_MAP = typeof Map !== "undefined";
    var extmap = [];
    extmap[1] = 212;
    extmap[2] = 213;
    extmap[4] = 214;
    extmap[8] = 215;
    extmap[16] = 216;
    exports.getWriteType = getWriteType;
    function getWriteType(options2) {
      var token = WriteToken.getWriteToken(options2);
      var useraw = options2 && options2.useraw;
      var binarraybuffer = HAS_UINT8ARRAY && options2 && options2.binarraybuffer;
      var isBuffer = binarraybuffer ? Bufferish.isArrayBuffer : Bufferish.isBuffer;
      var bin = binarraybuffer ? bin_arraybuffer : bin_buffer;
      var usemap = HAS_MAP && options2 && options2.usemap;
      var map = usemap ? map_to_map : obj_to_map;
      var writeType = {
        "boolean": bool,
        "function": nil,
        "number": number2,
        "object": useraw ? object_raw : object,
        "string": _string(useraw ? raw_head_size : str_head_size),
        "symbol": nil,
        "undefined": nil
      };
      return writeType;
      function bool(encoder, value) {
        var type = value ? 195 : 194;
        token[type](encoder, value);
      }
      function number2(encoder, value) {
        var ivalue = value | 0;
        var type;
        if (value !== ivalue) {
          type = 203;
          token[type](encoder, value);
          return;
        } else if (-32 <= ivalue && ivalue <= 127) {
          type = ivalue & 255;
        } else if (0 <= ivalue) {
          type = ivalue <= 255 ? 204 : ivalue <= 65535 ? 205 : 206;
        } else {
          type = -128 <= ivalue ? 208 : -32768 <= ivalue ? 209 : 210;
        }
        token[type](encoder, ivalue);
      }
      function uint64(encoder, value) {
        var type = 207;
        token[type](encoder, value.toArray());
      }
      function int64(encoder, value) {
        var type = 211;
        token[type](encoder, value.toArray());
      }
      function str_head_size(length) {
        return length < 32 ? 1 : length <= 255 ? 2 : length <= 65535 ? 3 : 5;
      }
      function raw_head_size(length) {
        return length < 32 ? 1 : length <= 65535 ? 3 : 5;
      }
      function _string(head_size) {
        return string2;
        function string2(encoder, value) {
          var length = value.length;
          var maxsize = 5 + length * 3;
          encoder.offset = encoder.reserve(maxsize);
          var buffer = encoder.buffer;
          var expected = head_size(length);
          var start = encoder.offset + expected;
          length = BufferProto.write.call(buffer, value, start);
          var actual = head_size(length);
          if (expected !== actual) {
            var targetStart = start + actual - expected;
            var end = start + length;
            BufferProto.copy.call(buffer, buffer, targetStart, start, end);
          }
          var type = actual === 1 ? 160 + length : actual <= 3 ? 215 + actual : 219;
          token[type](encoder, length);
          encoder.offset += length;
        }
      }
      function object(encoder, value) {
        if (value === null)
          return nil(encoder, value);
        if (isBuffer(value))
          return bin(encoder, value);
        if (IS_ARRAY(value))
          return array(encoder, value);
        if (Uint64BE.isUint64BE(value))
          return uint64(encoder, value);
        if (Int64BE.isInt64BE(value))
          return int64(encoder, value);
        var packer = encoder.codec.getExtPacker(value);
        if (packer)
          value = packer(value);
        if (value instanceof ExtBuffer)
          return ext(encoder, value);
        map(encoder, value);
      }
      function object_raw(encoder, value) {
        if (isBuffer(value))
          return raw(encoder, value);
        object(encoder, value);
      }
      function nil(encoder, value) {
        var type = 192;
        token[type](encoder, value);
      }
      function array(encoder, value) {
        var length = value.length;
        var type = length < 16 ? 144 + length : length <= 65535 ? 220 : 221;
        token[type](encoder, length);
        var encode = encoder.codec.encode;
        for (var i = 0; i < length; i++) {
          encode(encoder, value[i]);
        }
      }
      function bin_buffer(encoder, value) {
        var length = value.length;
        var type = length < 255 ? 196 : length <= 65535 ? 197 : 198;
        token[type](encoder, length);
        encoder.send(value);
      }
      function bin_arraybuffer(encoder, value) {
        bin_buffer(encoder, new Uint8Array(value));
      }
      function ext(encoder, value) {
        var buffer = value.buffer;
        var length = buffer.length;
        var type = extmap[length] || (length < 255 ? 199 : length <= 65535 ? 200 : 201);
        token[type](encoder, length);
        uint8[value.type](encoder);
        encoder.send(buffer);
      }
      function obj_to_map(encoder, value) {
        var keys = Object.keys(value);
        var length = keys.length;
        var type = length < 16 ? 128 + length : length <= 65535 ? 222 : 223;
        token[type](encoder, length);
        var encode = encoder.codec.encode;
        keys.forEach(function(key) {
          encode(encoder, key);
          encode(encoder, value[key]);
        });
      }
      function map_to_map(encoder, value) {
        if (!(value instanceof Map))
          return obj_to_map(encoder, value);
        var length = value.size;
        var type = length < 16 ? 128 + length : length <= 65535 ? 222 : 223;
        token[type](encoder, length);
        var encode = encoder.codec.encode;
        value.forEach(function(val, key, m) {
          encode(encoder, key);
          encode(encoder, val);
        });
      }
      function raw(encoder, value) {
        var length = value.length;
        var type = length < 32 ? 160 + length : length <= 65535 ? 218 : 219;
        token[type](encoder, length);
        encoder.send(value);
      }
    }
  }
});

// node_modules/msgpack-lite/lib/codec-base.js
var require_codec_base = __commonJS({
  "node_modules/msgpack-lite/lib/codec-base.js"(exports) {
    var IS_ARRAY = require_isarray();
    exports.createCodec = createCodec;
    exports.install = install;
    exports.filter = filter2;
    var Bufferish = require_bufferish();
    function Codec(options2) {
      if (!(this instanceof Codec))
        return new Codec(options2);
      this.options = options2;
      this.init();
    }
    Codec.prototype.init = function() {
      var options2 = this.options;
      if (options2 && options2.uint8array) {
        this.bufferish = Bufferish.Uint8Array;
      }
      return this;
    };
    function install(props) {
      for (var key in props) {
        Codec.prototype[key] = add(Codec.prototype[key], props[key]);
      }
    }
    function add(a, b) {
      return a && b ? ab : a || b;
      function ab() {
        a.apply(this, arguments);
        return b.apply(this, arguments);
      }
    }
    function join2(filters) {
      filters = filters.slice();
      return function(value) {
        return filters.reduce(iterator, value);
      };
      function iterator(value, filter3) {
        return filter3(value);
      }
    }
    function filter2(filter3) {
      return IS_ARRAY(filter3) ? join2(filter3) : filter3;
    }
    function createCodec(options2) {
      return new Codec(options2);
    }
    exports.preset = createCodec({ preset: true });
  }
});

// node_modules/msgpack-lite/lib/write-core.js
var require_write_core = __commonJS({
  "node_modules/msgpack-lite/lib/write-core.js"(exports) {
    var ExtBuffer = require_ext_buffer().ExtBuffer;
    var ExtPacker = require_ext_packer();
    var WriteType = require_write_type();
    var CodecBase = require_codec_base();
    CodecBase.install({
      addExtPacker,
      getExtPacker,
      init
    });
    exports.preset = init.call(CodecBase.preset);
    function getEncoder(options2) {
      var writeType = WriteType.getWriteType(options2);
      return encode;
      function encode(encoder, value) {
        var func2 = writeType[typeof value];
        if (!func2)
          throw new Error('Unsupported type "' + typeof value + '": ' + value);
        func2(encoder, value);
      }
    }
    function init() {
      var options2 = this.options;
      this.encode = getEncoder(options2);
      if (options2 && options2.preset) {
        ExtPacker.setExtPackers(this);
      }
      return this;
    }
    function addExtPacker(etype, Class, packer) {
      packer = CodecBase.filter(packer);
      var name2 = Class.name;
      if (name2 && name2 !== "Object") {
        var packers = this.extPackers || (this.extPackers = {});
        packers[name2] = extPacker;
      } else {
        var list2 = this.extEncoderList || (this.extEncoderList = []);
        list2.unshift([Class, extPacker]);
      }
      function extPacker(value) {
        if (packer)
          value = packer(value);
        return new ExtBuffer(value, etype);
      }
    }
    function getExtPacker(value) {
      var packers = this.extPackers || (this.extPackers = {});
      var c = value.constructor;
      var e = c && c.name && packers[c.name];
      if (e)
        return e;
      var list2 = this.extEncoderList || (this.extEncoderList = []);
      var len = list2.length;
      for (var i = 0; i < len; i++) {
        var pair = list2[i];
        if (c === pair[0])
          return pair[1];
      }
    }
  }
});

// node_modules/msgpack-lite/lib/flex-buffer.js
var require_flex_buffer = __commonJS({
  "node_modules/msgpack-lite/lib/flex-buffer.js"(exports) {
    exports.FlexDecoder = FlexDecoder;
    exports.FlexEncoder = FlexEncoder;
    var Bufferish = require_bufferish();
    var MIN_BUFFER_SIZE = 2048;
    var MAX_BUFFER_SIZE = 65536;
    var BUFFER_SHORTAGE = "BUFFER_SHORTAGE";
    function FlexDecoder() {
      if (!(this instanceof FlexDecoder))
        return new FlexDecoder();
    }
    function FlexEncoder() {
      if (!(this instanceof FlexEncoder))
        return new FlexEncoder();
    }
    FlexDecoder.mixin = mixinFactory(getDecoderMethods());
    FlexDecoder.mixin(FlexDecoder.prototype);
    FlexEncoder.mixin = mixinFactory(getEncoderMethods());
    FlexEncoder.mixin(FlexEncoder.prototype);
    function getDecoderMethods() {
      return {
        bufferish: Bufferish,
        write: write2,
        fetch: fetch2,
        flush,
        push,
        pull,
        read,
        reserve,
        offset: 0
      };
      function write2(chunk) {
        var prev = this.offset ? Bufferish.prototype.slice.call(this.buffer, this.offset) : this.buffer;
        this.buffer = prev ? chunk ? this.bufferish.concat([prev, chunk]) : prev : chunk;
        this.offset = 0;
      }
      function flush() {
        while (this.offset < this.buffer.length) {
          var start = this.offset;
          var value;
          try {
            value = this.fetch();
          } catch (e) {
            if (e && e.message != BUFFER_SHORTAGE)
              throw e;
            this.offset = start;
            break;
          }
          this.push(value);
        }
      }
      function reserve(length) {
        var start = this.offset;
        var end = start + length;
        if (end > this.buffer.length)
          throw new Error(BUFFER_SHORTAGE);
        this.offset = end;
        return start;
      }
    }
    function getEncoderMethods() {
      return {
        bufferish: Bufferish,
        write,
        fetch: fetch3,
        flush,
        push,
        pull: pull2,
        read,
        reserve,
        send,
        maxBufferSize: MAX_BUFFER_SIZE,
        minBufferSize: MIN_BUFFER_SIZE,
        offset: 0,
        start: 0
      };
      function fetch3() {
        var start = this.start;
        if (start < this.offset) {
          var end = this.start = this.offset;
          return Bufferish.prototype.slice.call(this.buffer, start, end);
        }
      }
      function flush() {
        while (this.start < this.offset) {
          var value = this.fetch();
          if (value)
            this.push(value);
        }
      }
      function pull2() {
        var buffers = this.buffers || (this.buffers = []);
        var chunk = buffers.length > 1 ? this.bufferish.concat(buffers) : buffers[0];
        buffers.length = 0;
        return chunk;
      }
      function reserve(length) {
        var req = length | 0;
        if (this.buffer) {
          var size = this.buffer.length;
          var start = this.offset | 0;
          var end = start + req;
          if (end < size) {
            this.offset = end;
            return start;
          }
          this.flush();
          length = Math.max(length, Math.min(size * 2, this.maxBufferSize));
        }
        length = Math.max(length, this.minBufferSize);
        this.buffer = this.bufferish.alloc(length);
        this.start = 0;
        this.offset = req;
        return 0;
      }
      function send(buffer) {
        var length = buffer.length;
        if (length > this.minBufferSize) {
          this.flush();
          this.push(buffer);
        } else {
          var offset = this.reserve(length);
          Bufferish.prototype.copy.call(buffer, this.buffer, offset);
        }
      }
    }
    function write() {
      throw new Error("method not implemented: write()");
    }
    function fetch2() {
      throw new Error("method not implemented: fetch()");
    }
    function read() {
      var length = this.buffers && this.buffers.length;
      if (!length)
        return this.fetch();
      this.flush();
      return this.pull();
    }
    function push(chunk) {
      var buffers = this.buffers || (this.buffers = []);
      buffers.push(chunk);
    }
    function pull() {
      var buffers = this.buffers || (this.buffers = []);
      return buffers.shift();
    }
    function mixinFactory(source) {
      return mixin2;
      function mixin2(target) {
        for (var key in source) {
          target[key] = source[key];
        }
        return target;
      }
    }
  }
});

// node_modules/msgpack-lite/lib/encode-buffer.js
var require_encode_buffer = __commonJS({
  "node_modules/msgpack-lite/lib/encode-buffer.js"(exports) {
    exports.EncodeBuffer = EncodeBuffer;
    var preset = require_write_core().preset;
    var FlexEncoder = require_flex_buffer().FlexEncoder;
    FlexEncoder.mixin(EncodeBuffer.prototype);
    function EncodeBuffer(options2) {
      if (!(this instanceof EncodeBuffer))
        return new EncodeBuffer(options2);
      if (options2) {
        this.options = options2;
        if (options2.codec) {
          var codec = this.codec = options2.codec;
          if (codec.bufferish)
            this.bufferish = codec.bufferish;
        }
      }
    }
    EncodeBuffer.prototype.codec = preset;
    EncodeBuffer.prototype.write = function(input) {
      this.codec.encode(this, input);
    };
  }
});

// node_modules/msgpack-lite/lib/encode.js
var require_encode = __commonJS({
  "node_modules/msgpack-lite/lib/encode.js"(exports) {
    exports.encode = encode;
    var EncodeBuffer = require_encode_buffer().EncodeBuffer;
    function encode(input, options2) {
      var encoder = new EncodeBuffer(options2);
      encoder.write(input);
      return encoder.read();
    }
  }
});

// node_modules/msgpack-lite/lib/ext-unpacker.js
var require_ext_unpacker = __commonJS({
  "node_modules/msgpack-lite/lib/ext-unpacker.js"(exports) {
    exports.setExtUnpackers = setExtUnpackers;
    var Bufferish = require_bufferish();
    var Buffer3 = Bufferish.global;
    var _decode;
    var ERROR_COLUMNS = { name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1 };
    function setExtUnpackers(codec) {
      codec.addExtUnpacker(14, [decode, unpackError(Error)]);
      codec.addExtUnpacker(1, [decode, unpackError(EvalError)]);
      codec.addExtUnpacker(2, [decode, unpackError(RangeError)]);
      codec.addExtUnpacker(3, [decode, unpackError(ReferenceError)]);
      codec.addExtUnpacker(4, [decode, unpackError(SyntaxError)]);
      codec.addExtUnpacker(5, [decode, unpackError(TypeError)]);
      codec.addExtUnpacker(6, [decode, unpackError(URIError)]);
      codec.addExtUnpacker(10, [decode, unpackRegExp]);
      codec.addExtUnpacker(11, [decode, unpackClass(Boolean)]);
      codec.addExtUnpacker(12, [decode, unpackClass(String)]);
      codec.addExtUnpacker(13, [decode, unpackClass(Date)]);
      codec.addExtUnpacker(15, [decode, unpackClass(Number)]);
      if (typeof Uint8Array !== "undefined") {
        codec.addExtUnpacker(17, unpackClass(Int8Array));
        codec.addExtUnpacker(18, unpackClass(Uint8Array));
        codec.addExtUnpacker(19, [unpackArrayBuffer, unpackClass(Int16Array)]);
        codec.addExtUnpacker(20, [unpackArrayBuffer, unpackClass(Uint16Array)]);
        codec.addExtUnpacker(21, [unpackArrayBuffer, unpackClass(Int32Array)]);
        codec.addExtUnpacker(22, [unpackArrayBuffer, unpackClass(Uint32Array)]);
        codec.addExtUnpacker(23, [unpackArrayBuffer, unpackClass(Float32Array)]);
        if (typeof Float64Array !== "undefined") {
          codec.addExtUnpacker(24, [unpackArrayBuffer, unpackClass(Float64Array)]);
        }
        if (typeof Uint8ClampedArray !== "undefined") {
          codec.addExtUnpacker(25, unpackClass(Uint8ClampedArray));
        }
        codec.addExtUnpacker(26, unpackArrayBuffer);
        codec.addExtUnpacker(29, [unpackArrayBuffer, unpackClass(DataView)]);
      }
      if (Bufferish.hasBuffer) {
        codec.addExtUnpacker(27, unpackClass(Buffer3));
      }
    }
    function decode(input) {
      if (!_decode)
        _decode = require_decode().decode;
      return _decode(input);
    }
    function unpackRegExp(value) {
      return RegExp.apply(null, value);
    }
    function unpackError(Class) {
      return function(value) {
        var out = new Class();
        for (var key in ERROR_COLUMNS) {
          out[key] = value[key];
        }
        return out;
      };
    }
    function unpackClass(Class) {
      return function(value) {
        return new Class(value);
      };
    }
    function unpackArrayBuffer(value) {
      return new Uint8Array(value).buffer;
    }
  }
});

// node_modules/msgpack-lite/lib/read-format.js
var require_read_format = __commonJS({
  "node_modules/msgpack-lite/lib/read-format.js"(exports) {
    var ieee754 = require_ieee754();
    var Int64Buffer = require_int64_buffer();
    var Uint64BE = Int64Buffer.Uint64BE;
    var Int64BE = Int64Buffer.Int64BE;
    exports.getReadFormat = getReadFormat;
    exports.readUint8 = uint8;
    var Bufferish = require_bufferish();
    var BufferProto = require_bufferish_proto();
    var HAS_MAP = typeof Map !== "undefined";
    var NO_ASSERT = true;
    function getReadFormat(options2) {
      var binarraybuffer = Bufferish.hasArrayBuffer && options2 && options2.binarraybuffer;
      var int64 = options2 && options2.int64;
      var usemap = HAS_MAP && options2 && options2.usemap;
      var readFormat = {
        map: usemap ? map_to_map : map_to_obj,
        array,
        str,
        bin: binarraybuffer ? bin_arraybuffer : bin_buffer,
        ext,
        uint8,
        uint16,
        uint32,
        uint64: read(8, int64 ? readUInt64BE_int64 : readUInt64BE),
        int8,
        int16,
        int32,
        int64: read(8, int64 ? readInt64BE_int64 : readInt64BE),
        float32: read(4, readFloatBE),
        float64: read(8, readDoubleBE)
      };
      return readFormat;
    }
    function map_to_obj(decoder, len) {
      var value = {};
      var i;
      var k = new Array(len);
      var v = new Array(len);
      var decode = decoder.codec.decode;
      for (i = 0; i < len; i++) {
        k[i] = decode(decoder);
        v[i] = decode(decoder);
      }
      for (i = 0; i < len; i++) {
        value[k[i]] = v[i];
      }
      return value;
    }
    function map_to_map(decoder, len) {
      var value = /* @__PURE__ */ new Map();
      var i;
      var k = new Array(len);
      var v = new Array(len);
      var decode = decoder.codec.decode;
      for (i = 0; i < len; i++) {
        k[i] = decode(decoder);
        v[i] = decode(decoder);
      }
      for (i = 0; i < len; i++) {
        value.set(k[i], v[i]);
      }
      return value;
    }
    function array(decoder, len) {
      var value = new Array(len);
      var decode = decoder.codec.decode;
      for (var i = 0; i < len; i++) {
        value[i] = decode(decoder);
      }
      return value;
    }
    function str(decoder, len) {
      var start = decoder.reserve(len);
      var end = start + len;
      return BufferProto.toString.call(decoder.buffer, "utf-8", start, end);
    }
    function bin_buffer(decoder, len) {
      var start = decoder.reserve(len);
      var end = start + len;
      var buf = BufferProto.slice.call(decoder.buffer, start, end);
      return Bufferish.from(buf);
    }
    function bin_arraybuffer(decoder, len) {
      var start = decoder.reserve(len);
      var end = start + len;
      var buf = BufferProto.slice.call(decoder.buffer, start, end);
      return Bufferish.Uint8Array.from(buf).buffer;
    }
    function ext(decoder, len) {
      var start = decoder.reserve(len + 1);
      var type = decoder.buffer[start++];
      var end = start + len;
      var unpack = decoder.codec.getExtUnpacker(type);
      if (!unpack)
        throw new Error("Invalid ext type: " + (type ? "0x" + type.toString(16) : type));
      var buf = BufferProto.slice.call(decoder.buffer, start, end);
      return unpack(buf);
    }
    function uint8(decoder) {
      var start = decoder.reserve(1);
      return decoder.buffer[start];
    }
    function int8(decoder) {
      var start = decoder.reserve(1);
      var value = decoder.buffer[start];
      return value & 128 ? value - 256 : value;
    }
    function uint16(decoder) {
      var start = decoder.reserve(2);
      var buffer = decoder.buffer;
      return buffer[start++] << 8 | buffer[start];
    }
    function int16(decoder) {
      var start = decoder.reserve(2);
      var buffer = decoder.buffer;
      var value = buffer[start++] << 8 | buffer[start];
      return value & 32768 ? value - 65536 : value;
    }
    function uint32(decoder) {
      var start = decoder.reserve(4);
      var buffer = decoder.buffer;
      return buffer[start++] * 16777216 + (buffer[start++] << 16) + (buffer[start++] << 8) + buffer[start];
    }
    function int32(decoder) {
      var start = decoder.reserve(4);
      var buffer = decoder.buffer;
      return buffer[start++] << 24 | buffer[start++] << 16 | buffer[start++] << 8 | buffer[start];
    }
    function read(len, method) {
      return function(decoder) {
        var start = decoder.reserve(len);
        return method.call(decoder.buffer, start, NO_ASSERT);
      };
    }
    function readUInt64BE(start) {
      return new Uint64BE(this, start).toNumber();
    }
    function readInt64BE(start) {
      return new Int64BE(this, start).toNumber();
    }
    function readUInt64BE_int64(start) {
      return new Uint64BE(this, start);
    }
    function readInt64BE_int64(start) {
      return new Int64BE(this, start);
    }
    function readFloatBE(start) {
      return ieee754.read(this, start, false, 23, 4);
    }
    function readDoubleBE(start) {
      return ieee754.read(this, start, false, 52, 8);
    }
  }
});

// node_modules/msgpack-lite/lib/read-token.js
var require_read_token = __commonJS({
  "node_modules/msgpack-lite/lib/read-token.js"(exports) {
    var ReadFormat = require_read_format();
    exports.getReadToken = getReadToken;
    function getReadToken(options2) {
      var format2 = ReadFormat.getReadFormat(options2);
      if (options2 && options2.useraw) {
        return init_useraw(format2);
      } else {
        return init_token(format2);
      }
    }
    function init_token(format2) {
      var i;
      var token = new Array(256);
      for (i = 0; i <= 127; i++) {
        token[i] = constant(i);
      }
      for (i = 128; i <= 143; i++) {
        token[i] = fix(i - 128, format2.map);
      }
      for (i = 144; i <= 159; i++) {
        token[i] = fix(i - 144, format2.array);
      }
      for (i = 160; i <= 191; i++) {
        token[i] = fix(i - 160, format2.str);
      }
      token[192] = constant(null);
      token[193] = null;
      token[194] = constant(false);
      token[195] = constant(true);
      token[196] = flex(format2.uint8, format2.bin);
      token[197] = flex(format2.uint16, format2.bin);
      token[198] = flex(format2.uint32, format2.bin);
      token[199] = flex(format2.uint8, format2.ext);
      token[200] = flex(format2.uint16, format2.ext);
      token[201] = flex(format2.uint32, format2.ext);
      token[202] = format2.float32;
      token[203] = format2.float64;
      token[204] = format2.uint8;
      token[205] = format2.uint16;
      token[206] = format2.uint32;
      token[207] = format2.uint64;
      token[208] = format2.int8;
      token[209] = format2.int16;
      token[210] = format2.int32;
      token[211] = format2.int64;
      token[212] = fix(1, format2.ext);
      token[213] = fix(2, format2.ext);
      token[214] = fix(4, format2.ext);
      token[215] = fix(8, format2.ext);
      token[216] = fix(16, format2.ext);
      token[217] = flex(format2.uint8, format2.str);
      token[218] = flex(format2.uint16, format2.str);
      token[219] = flex(format2.uint32, format2.str);
      token[220] = flex(format2.uint16, format2.array);
      token[221] = flex(format2.uint32, format2.array);
      token[222] = flex(format2.uint16, format2.map);
      token[223] = flex(format2.uint32, format2.map);
      for (i = 224; i <= 255; i++) {
        token[i] = constant(i - 256);
      }
      return token;
    }
    function init_useraw(format2) {
      var i;
      var token = init_token(format2).slice();
      token[217] = token[196];
      token[218] = token[197];
      token[219] = token[198];
      for (i = 160; i <= 191; i++) {
        token[i] = fix(i - 160, format2.bin);
      }
      return token;
    }
    function constant(value) {
      return function() {
        return value;
      };
    }
    function flex(lenFunc, decodeFunc) {
      return function(decoder) {
        var len = lenFunc(decoder);
        return decodeFunc(decoder, len);
      };
    }
    function fix(len, method) {
      return function(decoder) {
        return method(decoder, len);
      };
    }
  }
});

// node_modules/msgpack-lite/lib/read-core.js
var require_read_core = __commonJS({
  "node_modules/msgpack-lite/lib/read-core.js"(exports) {
    var ExtBuffer = require_ext_buffer().ExtBuffer;
    var ExtUnpacker = require_ext_unpacker();
    var readUint8 = require_read_format().readUint8;
    var ReadToken = require_read_token();
    var CodecBase = require_codec_base();
    CodecBase.install({
      addExtUnpacker,
      getExtUnpacker,
      init
    });
    exports.preset = init.call(CodecBase.preset);
    function getDecoder(options2) {
      var readToken = ReadToken.getReadToken(options2);
      return decode;
      function decode(decoder) {
        var type = readUint8(decoder);
        var func2 = readToken[type];
        if (!func2)
          throw new Error("Invalid type: " + (type ? "0x" + type.toString(16) : type));
        return func2(decoder);
      }
    }
    function init() {
      var options2 = this.options;
      this.decode = getDecoder(options2);
      if (options2 && options2.preset) {
        ExtUnpacker.setExtUnpackers(this);
      }
      return this;
    }
    function addExtUnpacker(etype, unpacker) {
      var unpackers = this.extUnpackers || (this.extUnpackers = []);
      unpackers[etype] = CodecBase.filter(unpacker);
    }
    function getExtUnpacker(type) {
      var unpackers = this.extUnpackers || (this.extUnpackers = []);
      return unpackers[type] || extUnpacker;
      function extUnpacker(buffer) {
        return new ExtBuffer(buffer, type);
      }
    }
  }
});

// node_modules/msgpack-lite/lib/decode-buffer.js
var require_decode_buffer = __commonJS({
  "node_modules/msgpack-lite/lib/decode-buffer.js"(exports) {
    exports.DecodeBuffer = DecodeBuffer;
    var preset = require_read_core().preset;
    var FlexDecoder = require_flex_buffer().FlexDecoder;
    FlexDecoder.mixin(DecodeBuffer.prototype);
    function DecodeBuffer(options2) {
      if (!(this instanceof DecodeBuffer))
        return new DecodeBuffer(options2);
      if (options2) {
        this.options = options2;
        if (options2.codec) {
          var codec = this.codec = options2.codec;
          if (codec.bufferish)
            this.bufferish = codec.bufferish;
        }
      }
    }
    DecodeBuffer.prototype.codec = preset;
    DecodeBuffer.prototype.fetch = function() {
      return this.codec.decode(this);
    };
  }
});

// node_modules/msgpack-lite/lib/decode.js
var require_decode = __commonJS({
  "node_modules/msgpack-lite/lib/decode.js"(exports) {
    exports.decode = decode;
    var DecodeBuffer = require_decode_buffer().DecodeBuffer;
    function decode(input, options2) {
      var decoder = new DecodeBuffer(options2);
      decoder.write(input);
      return decoder.read();
    }
  }
});

// node_modules/event-lite/event-lite.js
var require_event_lite = __commonJS({
  "node_modules/event-lite/event-lite.js"(exports, module2) {
    function EventLite() {
      if (!(this instanceof EventLite))
        return new EventLite();
    }
    (function(EventLite2) {
      if (typeof module2 !== "undefined")
        module2.exports = EventLite2;
      var LISTENERS = "listeners";
      var methods2 = {
        on,
        once,
        off,
        emit
      };
      mixin2(EventLite2.prototype);
      EventLite2.mixin = mixin2;
      function mixin2(target) {
        for (var key in methods2) {
          target[key] = methods2[key];
        }
        return target;
      }
      function on(type, func2) {
        getListeners(this, type).push(func2);
        return this;
      }
      function once(type, func2) {
        var that = this;
        wrap.originalListener = func2;
        getListeners(that, type).push(wrap);
        return that;
        function wrap() {
          off.call(that, type, wrap);
          func2.apply(this, arguments);
        }
      }
      function off(type, func2) {
        var that = this;
        var listners;
        if (!arguments.length) {
          delete that[LISTENERS];
        } else if (!func2) {
          listners = that[LISTENERS];
          if (listners) {
            delete listners[type];
            if (!Object.keys(listners).length)
              return off.call(that);
          }
        } else {
          listners = getListeners(that, type, true);
          if (listners) {
            listners = listners.filter(ne);
            if (!listners.length)
              return off.call(that, type);
            that[LISTENERS][type] = listners;
          }
        }
        return that;
        function ne(test) {
          return test !== func2 && test.originalListener !== func2;
        }
      }
      function emit(type, value) {
        var that = this;
        var listeners = getListeners(that, type, true);
        if (!listeners)
          return false;
        var arglen = arguments.length;
        if (arglen === 1) {
          listeners.forEach(zeroarg);
        } else if (arglen === 2) {
          listeners.forEach(onearg);
        } else {
          var args = Array.prototype.slice.call(arguments, 1);
          listeners.forEach(moreargs);
        }
        return !!listeners.length;
        function zeroarg(func2) {
          func2.call(that);
        }
        function onearg(func2) {
          func2.call(that, value);
        }
        function moreargs(func2) {
          func2.apply(that, args);
        }
      }
      function getListeners(that, type, readonly) {
        if (readonly && !that[LISTENERS])
          return;
        var listeners = that[LISTENERS] || (that[LISTENERS] = {});
        return listeners[type] || (listeners[type] = []);
      }
    })(EventLite);
  }
});

// node_modules/msgpack-lite/lib/encoder.js
var require_encoder = __commonJS({
  "node_modules/msgpack-lite/lib/encoder.js"(exports) {
    exports.Encoder = Encoder;
    var EventLite = require_event_lite();
    var EncodeBuffer = require_encode_buffer().EncodeBuffer;
    function Encoder(options2) {
      if (!(this instanceof Encoder))
        return new Encoder(options2);
      EncodeBuffer.call(this, options2);
    }
    Encoder.prototype = new EncodeBuffer();
    EventLite.mixin(Encoder.prototype);
    Encoder.prototype.encode = function(chunk) {
      this.write(chunk);
      this.emit("data", this.read());
    };
    Encoder.prototype.end = function(chunk) {
      if (arguments.length)
        this.encode(chunk);
      this.flush();
      this.emit("end");
    };
  }
});

// node_modules/msgpack-lite/lib/decoder.js
var require_decoder = __commonJS({
  "node_modules/msgpack-lite/lib/decoder.js"(exports) {
    exports.Decoder = Decoder;
    var EventLite = require_event_lite();
    var DecodeBuffer = require_decode_buffer().DecodeBuffer;
    function Decoder(options2) {
      if (!(this instanceof Decoder))
        return new Decoder(options2);
      DecodeBuffer.call(this, options2);
    }
    Decoder.prototype = new DecodeBuffer();
    EventLite.mixin(Decoder.prototype);
    Decoder.prototype.decode = function(chunk) {
      if (arguments.length)
        this.write(chunk);
      this.flush();
    };
    Decoder.prototype.push = function(chunk) {
      this.emit("data", chunk);
    };
    Decoder.prototype.end = function(chunk) {
      this.decode(chunk);
      this.emit("end");
    };
  }
});

// node_modules/msgpack-lite/lib/encode-stream.js
var require_encode_stream = __commonJS({
  "node_modules/msgpack-lite/lib/encode-stream.js"(exports) {
    exports.createEncodeStream = EncodeStream;
    var util4 = require("util");
    var Transform2 = require("stream").Transform;
    var EncodeBuffer = require_encode_buffer().EncodeBuffer;
    util4.inherits(EncodeStream, Transform2);
    var DEFAULT_OPTIONS = { objectMode: true };
    function EncodeStream(options2) {
      if (!(this instanceof EncodeStream))
        return new EncodeStream(options2);
      if (options2) {
        options2.objectMode = true;
      } else {
        options2 = DEFAULT_OPTIONS;
      }
      Transform2.call(this, options2);
      var stream = this;
      var encoder = this.encoder = new EncodeBuffer(options2);
      encoder.push = function(chunk) {
        stream.push(chunk);
      };
    }
    EncodeStream.prototype._transform = function(chunk, encoding, callback) {
      this.encoder.write(chunk);
      if (callback)
        callback();
    };
    EncodeStream.prototype._flush = function(callback) {
      this.encoder.flush();
      if (callback)
        callback();
    };
  }
});

// node_modules/msgpack-lite/lib/decode-stream.js
var require_decode_stream = __commonJS({
  "node_modules/msgpack-lite/lib/decode-stream.js"(exports) {
    exports.createDecodeStream = DecodeStream;
    var util4 = require("util");
    var Transform2 = require("stream").Transform;
    var DecodeBuffer = require_decode_buffer().DecodeBuffer;
    util4.inherits(DecodeStream, Transform2);
    var DEFAULT_OPTIONS = { objectMode: true };
    function DecodeStream(options2) {
      if (!(this instanceof DecodeStream))
        return new DecodeStream(options2);
      if (options2) {
        options2.objectMode = true;
      } else {
        options2 = DEFAULT_OPTIONS;
      }
      Transform2.call(this, options2);
      var stream = this;
      var decoder = this.decoder = new DecodeBuffer(options2);
      decoder.push = function(chunk) {
        stream.push(chunk);
      };
    }
    DecodeStream.prototype._transform = function(chunk, encoding, callback) {
      this.decoder.write(chunk);
      this.decoder.flush();
      if (callback)
        callback();
    };
  }
});

// node_modules/msgpack-lite/lib/ext.js
var require_ext = __commonJS({
  "node_modules/msgpack-lite/lib/ext.js"(exports) {
    require_read_core();
    require_write_core();
    exports.createCodec = require_codec_base().createCodec;
  }
});

// node_modules/msgpack-lite/lib/codec.js
var require_codec = __commonJS({
  "node_modules/msgpack-lite/lib/codec.js"(exports) {
    require_read_core();
    require_write_core();
    exports.codec = {
      preset: require_codec_base().preset
    };
  }
});

// node_modules/msgpack-lite/index.js
var require_msgpack_lite = __commonJS({
  "node_modules/msgpack-lite/index.js"(exports) {
    exports.encode = require_encode().encode;
    exports.decode = require_decode().decode;
    exports.Encoder = require_encoder().Encoder;
    exports.Decoder = require_decoder().Decoder;
    exports.createEncodeStream = require_encode_stream().createEncodeStream;
    exports.createDecodeStream = require_decode_stream().createDecodeStream;
    exports.createCodec = require_ext().createCodec;
    exports.codec = require_codec().codec;
  }
});

// node_modules/@chemzqm/neovim/lib/utils/buffered.js
var require_buffered = __commonJS({
  "node_modules/@chemzqm/neovim/lib/utils/buffered.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stream_1 = require("stream");
    var Buffered = class extends stream_1.Transform {
      constructor() {
        super({
          readableHighWaterMark: 10 * 1024 * 1024,
          writableHighWaterMark: 10 * 1024 * 1024
        });
        this.chunks = null;
        this.timer = null;
      }
      sendData() {
        const { chunks } = this;
        if (chunks) {
          this.chunks = null;
          const buf = Buffer.concat(chunks);
          this.push(buf);
        }
      }
      _transform(chunk, _encoding, callback) {
        const { chunks, timer } = this;
        const MIN_SIZE = Buffer.poolSize;
        if (timer)
          clearTimeout(timer);
        if (chunk.length < MIN_SIZE) {
          if (!chunks)
            return callback(null, chunk);
          chunks.push(chunk);
          this.sendData();
          callback();
        } else {
          if (!chunks) {
            this.chunks = [chunk];
          } else {
            chunks.push(chunk);
          }
          this.timer = setTimeout(this.sendData.bind(this), 20);
          callback();
        }
      }
      _flush(callback) {
        const { chunks } = this;
        if (chunks) {
          this.chunks = null;
          const buf = Buffer.concat(chunks);
          callback(null, buf);
        } else {
          callback();
        }
      }
    };
    exports.default = Buffered;
  }
});

// node_modules/@chemzqm/neovim/lib/api/Base.js
var require_Base = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/Base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseApi = void 0;
    var events_1 = require("events");
    var isVim6 = process.env.VIM_NODE_RPC == "1";
    var BaseApi = class extends events_1.EventEmitter {
      constructor({ transport, data, client }) {
        super();
        this.setTransport(transport);
        this.data = data;
        this.client = client;
      }
      setTransport(transport) {
        this.transport = transport;
      }
      equals(other) {
        try {
          return String(this.data) === String(other.data);
        } catch (e) {
          return false;
        }
      }
      async request(name2, args = []) {
        let stack = Error().stack;
        return new Promise((resolve3, reject) => {
          this.transport.request(name2, this.getArgsByPrefix(args), (err, res) => {
            if (err) {
              let e = new Error(`${err[1].split(/\r?\n/)[0]}`);
              e.stack = `Error: request error on ${name2} - ${err[1]}
` + stack.split(/\r?\n/).slice(3).join("\n");
              if (!name2.endsWith("get_var")) {
                this.client.logError(`request error on "${name2}"`, args, err[1], stack);
              }
              reject(e);
            } else {
              resolve3(res);
            }
          });
        });
      }
      getArgsByPrefix(args) {
        if (this.prefix !== "nvim_" && args[0] != this) {
          let id = isVim6 ? this.data : this;
          return [id, ...args];
        }
        return args;
      }
      getVar(name2) {
        return this.request(`${this.prefix}get_var`, [name2]).then((res) => res, (_err) => {
          return null;
        });
      }
      setVar(name2, value, isNotify = false) {
        if (isNotify) {
          this.notify(`${this.prefix}set_var`, [name2, value]);
          return;
        }
        return this.request(`${this.prefix}set_var`, [name2, value]);
      }
      deleteVar(name2) {
        this.notify(`${this.prefix}del_var`, [name2]);
      }
      getOption(name2) {
        return this.request(`${this.prefix}get_option`, [name2]);
      }
      setOption(name2, value, isNotify) {
        if (isNotify) {
          this.notify(`${this.prefix}set_option`, [name2, value]);
          return;
        }
        return this.request(`${this.prefix}set_option`, [name2, value]);
      }
      notify(name2, args = []) {
        this.transport.notify(name2, this.getArgsByPrefix(args));
      }
    };
    exports.BaseApi = BaseApi;
  }
});

// node_modules/@chemzqm/neovim/lib/api/Buffer.js
var require_Buffer = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/Buffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Buffer = void 0;
    var Base_1 = require_Base();
    var Buffer3 = class extends Base_1.BaseApi {
      constructor() {
        super(...arguments);
        this.prefix = "nvim_buf_";
      }
      async attach(sendBuffer = false, options2 = {}) {
        return await this.request(`${this.prefix}attach`, [sendBuffer, options2]);
      }
      async detach() {
        return await this.request(`${this.prefix}detach`, []);
      }
      get id() {
        return this.data;
      }
      get length() {
        return this.request(`${this.prefix}line_count`, []);
      }
      get lines() {
        return this.getLines();
      }
      get changedtick() {
        return this.request(`${this.prefix}get_changedtick`, []);
      }
      get commands() {
        return this.getCommands();
      }
      getCommands(options2 = {}) {
        return this.request(`${this.prefix}get_commands`, [options2]);
      }
      getLines({ start, end, strictIndexing } = { start: 0, end: -1, strictIndexing: true }) {
        const indexing = typeof strictIndexing === "undefined" ? true : strictIndexing;
        return this.request(`${this.prefix}get_lines`, [
          start,
          end,
          indexing
        ]);
      }
      setLines(lines, opts, notify = false) {
        let { start, end, strictIndexing } = opts !== null && opts !== void 0 ? opts : {};
        start = start !== null && start !== void 0 ? start : 0;
        end = end !== null && end !== void 0 ? end : start + 1;
        const indexing = strictIndexing !== null && strictIndexing !== void 0 ? strictIndexing : true;
        const method = notify ? "notify" : "request";
        return this[method](`${this.prefix}set_lines`, [
          start,
          end,
          indexing,
          typeof lines === "string" ? [lines] : lines
        ]);
      }
      setVirtualText(src_id, line, chunks, opts = {}) {
        this.client.call("coc#vtext#add", [this.id, src_id, line, chunks, opts], true);
        return Promise.resolve(src_id);
      }
      deleteExtMark(ns_id, id) {
        if (this.client.isVim)
          return;
        this.notify(`${this.prefix}del_extmark`, [
          ns_id,
          id
        ]);
      }
      async getExtMarkById(ns_id, id, opts = {}) {
        if (this.client.isVim)
          return Promise.resolve([]);
        return this.request(`${this.prefix}get_extmark_by_id`, [ns_id, id, opts]);
      }
      async getExtMarks(ns_id, start, end, opts = {}) {
        if (this.client.isVim)
          return Promise.resolve([]);
        return this.request(`${this.prefix}get_extmarks`, [ns_id, start, end, opts]);
      }
      setExtMark(ns_id, line, col, opts = {}) {
        if (this.client.isVim)
          return;
        this.notify(`${this.prefix}set_extmark`, [
          ns_id,
          line,
          col,
          opts
        ]);
      }
      insert(lines, start) {
        return this.setLines(lines, {
          start,
          end: start,
          strictIndexing: true
        });
      }
      replace(_lines, start) {
        const lines = typeof _lines === "string" ? [_lines] : _lines;
        return this.setLines(lines, {
          start,
          end: start + lines.length,
          strictIndexing: false
        });
      }
      remove(start, end, strictIndexing = false) {
        return this.setLines([], { start, end, strictIndexing });
      }
      append(lines) {
        return this.setLines(lines, {
          start: -1,
          end: -1,
          strictIndexing: false
        });
      }
      get name() {
        return this.request(`${this.prefix}get_name`, []);
      }
      setName(value) {
        return this.request(`${this.prefix}set_name`, [value]);
      }
      get valid() {
        return this.request(`${this.prefix}is_valid`, []);
      }
      mark(name2) {
        return this.request(`${this.prefix}get_mark`, [name2]);
      }
      getKeymap(mode) {
        return this.request(`${this.prefix}get_keymap`, [mode]);
      }
      setKeymap(mode, lhs, rhs, opts = {}) {
        this.client.call("coc#compat#buf_add_keymap", [this.id, mode, lhs, rhs, opts], true);
      }
      get loaded() {
        return this.request(`${this.prefix}is_loaded`, []);
      }
      getOffset(index) {
        return this.request(`${this.prefix}get_offset`, [index]);
      }
      addHighlight({ hlGroup, line, colStart: _start, colEnd: _end, srcId: _srcId }) {
        if (!hlGroup)
          throw new Error("hlGroup should not empty");
        const colEnd = typeof _end !== "undefined" ? _end : -1;
        const colStart = typeof _start !== "undefined" ? _start : -0;
        const srcId2 = typeof _srcId !== "undefined" ? _srcId : -1;
        const method = srcId2 == 0 ? "request" : "notify";
        let res = this[method](`${this.prefix}add_highlight`, [
          srcId2,
          hlGroup,
          line,
          colStart,
          colEnd
        ]);
        return method === "request" ? res : Promise.resolve(null);
      }
      clearHighlight(args = {}) {
        const defaults3 = {
          srcId: -1,
          lineStart: 0,
          lineEnd: -1
        };
        const { srcId: srcId2, lineStart, lineEnd } = Object.assign({}, defaults3, args);
        return this.notify(`${this.prefix}clear_highlight`, [
          srcId2,
          lineStart,
          lineEnd
        ]);
      }
      highlightRanges(srcId2, hlGroup, ranges) {
        this.client.call("coc#highlight#ranges", [this.id, srcId2, hlGroup, ranges], true);
      }
      clearNamespace(key, lineStart = 0, lineEnd = -1) {
        this.client.call("coc#highlight#clear_highlight", [this.id, key, lineStart, lineEnd], true);
      }
      placeSign(sign) {
        let opts = { lnum: sign.lnum };
        if (typeof sign.priority === "number")
          opts.priority = sign.priority;
        this.client.call("sign_place", [sign.id || 0, sign.group || "", sign.name, this.id, opts], true);
      }
      unplaceSign(opts) {
        let details = { buffer: this.id };
        if (opts.id != null)
          details.id = opts.id;
        this.client.call("sign_unplace", [opts.group || "", details], true);
      }
      async getSigns(opts) {
        let res = await this.client.call("sign_getplaced", [this.id, opts || {}]);
        return res[0].signs;
      }
      async getHighlights(ns, start = 0, end = -1) {
        let res = [];
        let arr = await this.client.call("coc#highlight#get_highlights", [this.id, ns, start, end]);
        for (let item of arr) {
          res.push({
            hlGroup: item[0],
            lnum: item[1],
            colStart: item[2],
            colEnd: item[3],
            id: item[4]
          });
        }
        return res;
      }
      updateHighlights(ns, highlights, opts = {}) {
        if (typeof opts === "number") {
          this.client.logError("Bad option for buffer.updateHighlights()", new Error().stack);
          return;
        }
        let start = typeof opts.start === "number" ? opts.start : 0;
        let end = typeof opts.end === "number" ? opts.end : -1;
        let changedtick = typeof opts.changedtick === "number" ? opts.changedtick : null;
        let priority = typeof opts.priority === "number" ? opts.priority : null;
        if (start == 0 && end == -1) {
          let arr = highlights.map((o) => [o.hlGroup, o.lnum, o.colStart, o.colEnd, o.combine === false ? 0 : 1, o.start_incl ? 1 : 0, o.end_incl ? 1 : 0]);
          this.client.call("coc#highlight#buffer_update", [this.id, ns, arr, priority, changedtick], true);
          return;
        }
        this.client.call("coc#highlight#update_highlights", [this.id, ns, highlights, start, end, priority, changedtick], true);
      }
      listen(eventName, cb, disposables) {
        this.client.attachBufferEvent(this, eventName, cb);
        if (disposables) {
          disposables.push({
            dispose: () => {
              this.client.detachBufferEvent(this, eventName, cb);
            }
          });
        }
      }
    };
    exports.Buffer = Buffer3;
  }
});

// node_modules/@chemzqm/neovim/lib/api/Window.js
var require_Window = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/Window.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Window = void 0;
    var Base_1 = require_Base();
    var timers_1 = require("timers");
    var Window2 = class extends Base_1.BaseApi {
      constructor() {
        super(...arguments);
        this.prefix = "nvim_win_";
      }
      get id() {
        return this.data;
      }
      get buffer() {
        return this.request(`${this.prefix}get_buf`, []);
      }
      get tabpage() {
        return this.request(`${this.prefix}get_tabpage`, []);
      }
      get cursor() {
        return this.request(`${this.prefix}get_cursor`, []);
      }
      setCursor(pos, isNotify = false) {
        let method = isNotify ? "notify" : "request";
        return this[method](`${this.prefix}set_cursor`, [pos]);
      }
      get height() {
        return this.request(`${this.prefix}get_height`, []);
      }
      setHeight(height, isNotify = false) {
        let method = isNotify ? "notify" : "request";
        return this[method](`${this.prefix}set_height`, [height]);
      }
      get width() {
        return this.request(`${this.prefix}get_width`, []);
      }
      setWidth(width, isNotify = false) {
        let method = isNotify ? "notify" : "request";
        return this[method](`${this.prefix}set_height`, [width]);
      }
      get position() {
        return this.request(`${this.prefix}get_position`, []);
      }
      get row() {
        return this.request(`${this.prefix}get_position`, []).then((position) => position[0]);
      }
      get col() {
        return this.request(`${this.prefix}get_position`, []).then((position) => position[1]);
      }
      get valid() {
        return this.request(`${this.prefix}is_valid`, []);
      }
      get number() {
        return this.request(`${this.prefix}get_number`, []);
      }
      setConfig(options2, isNotify) {
        let method = isNotify ? "notify" : "request";
        return this[method](`${this.prefix}set_config`, [options2]);
      }
      getConfig() {
        return this.request(`${this.prefix}get_config`, []);
      }
      close(force, isNotify) {
        if (isNotify) {
          this.notify(`${this.prefix}close`, [force]);
          let count = 0;
          let interval = setInterval(() => {
            if (count == 5)
              return (0, timers_1.clearInterval)(interval);
            this.request(`${this.prefix}is_valid`, []).then((valid) => {
              if (!valid) {
                (0, timers_1.clearInterval)(interval);
              } else {
                this.notify(`${this.prefix}close`, [force]);
              }
            }, () => {
              (0, timers_1.clearInterval)(interval);
            });
            count++;
          }, 50);
          return null;
        }
        return this.request(`${this.prefix}close`, [force]);
      }
      highlightRanges(hlGroup, ranges, priority = 10, isNotify) {
        if (isNotify) {
          this.client.call("coc#highlight#match_ranges", [this.id, 0, ranges, hlGroup, priority], true);
          return void 0;
        }
        return this.client.call("coc#highlight#match_ranges", [this.id, 0, ranges, hlGroup, priority]);
      }
      clearMatchGroup(hlGroup) {
        this.client.call("coc#highlight#clear_match_group", [this.id, hlGroup], true);
      }
      clearMatches(ids) {
        this.client.call("coc#highlight#clear_matches", [this.id, ids], true);
      }
    };
    exports.Window = Window2;
  }
});

// node_modules/@chemzqm/neovim/lib/api/Tabpage.js
var require_Tabpage = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/Tabpage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tabpage = void 0;
    var Base_1 = require_Base();
    var Tabpage = class extends Base_1.BaseApi {
      constructor() {
        super(...arguments);
        this.prefix = "nvim_tabpage_";
      }
      get windows() {
        return this.request(`${this.prefix}list_wins`, []);
      }
      get window() {
        return this.request(`${this.prefix}get_win`, []);
      }
      get valid() {
        return this.request(`${this.prefix}is_valid`, []);
      }
      get number() {
        return this.request(`${this.prefix}get_number`, []);
      }
      getOption() {
        throw new Error("Tabpage does not have `getOption`");
      }
      setOption() {
        throw new Error("Tabpage does not have `setOption`");
      }
    };
    exports.Tabpage = Tabpage;
  }
});

// node_modules/@chemzqm/neovim/lib/api/types.js
var require_types = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Metadata = exports.ExtType = void 0;
    var Buffer_1 = require_Buffer();
    var Window_1 = require_Window();
    var Tabpage_1 = require_Tabpage();
    var ExtType;
    (function(ExtType2) {
      ExtType2[ExtType2["Buffer"] = 0] = "Buffer";
      ExtType2[ExtType2["Window"] = 1] = "Window";
      ExtType2[ExtType2["Tabpage"] = 2] = "Tabpage";
    })(ExtType = exports.ExtType || (exports.ExtType = {}));
    exports.Metadata = [
      {
        constructor: Buffer_1.Buffer,
        name: "Buffer",
        prefix: "nvim_buf_"
      },
      {
        constructor: Window_1.Window,
        name: "Window",
        prefix: "nvim_win_"
      },
      {
        constructor: Tabpage_1.Tabpage,
        name: "Tabpage",
        prefix: "nvim_tabpage_"
      }
    ];
  }
});

// node_modules/@chemzqm/neovim/lib/utils/logger.js
var require_logger3 = __commonJS({
  "node_modules/@chemzqm/neovim/lib/utils/logger.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createLogger = exports.nullLogger = void 0;
    var fs_1 = __importDefault(require("fs"));
    var os_1 = __importDefault(require("os"));
    var path_1 = __importDefault(require("path"));
    exports.nullLogger = {
      debug: () => {
      },
      info: () => {
      },
      warn: () => {
      },
      error: () => {
      },
      trace: () => {
      }
    };
    function getLogFile() {
      let file = process.env.NODE_CLIENT_LOG_FILE;
      if (file)
        return file;
      let dir = process.env.XDG_RUNTIME_DIR;
      if (dir)
        return path_1.default.join(dir, "node-client.log");
      return path_1.default.join(os_1.default.tmpdir(), `node-client-${process.pid}.log`);
    }
    var LOG_FILE_PATH = getLogFile();
    var level = process.env.NODE_CLIENT_LOG_LEVEL || "info";
    var invalid = process.getuid && process.getuid() == 0;
    if (!invalid) {
      try {
        fs_1.default.mkdirSync(path_1.default.dirname(LOG_FILE_PATH), { recursive: true });
        fs_1.default.writeFileSync(LOG_FILE_PATH, "", { encoding: "utf8", mode: 438 });
      } catch (_e) {
        invalid = true;
      }
    }
    function toObject(arg) {
      if (arg == null) {
        return arg;
      }
      if (Array.isArray(arg)) {
        return arg.map((o) => toObject(o));
      }
      if (typeof arg == "object" && typeof arg.prefix == "string" && typeof arg.data == "number") {
        return "[" + arg.prefix + arg.data + "]";
      }
      return arg;
    }
    function toString(arg) {
      if (arg == null)
        return String(arg);
      if (typeof arg == "object")
        return JSON.stringify(arg, null, 2);
      return String(arg);
    }
    function toTimeString(d) {
      return `${d.getHours()}:${d.getMinutes()}:${d.getSeconds()}.${d.getMilliseconds()}`;
    }
    var Logger = class {
      constructor(name2) {
        this.name = name2;
      }
      get stream() {
        if (invalid)
          return null;
        if (this._stream)
          return this._stream;
        this._stream = fs_1.default.createWriteStream(LOG_FILE_PATH, { encoding: "utf8" });
        return this._stream;
      }
      getText(level2, data, meta) {
        let more = "";
        if (meta.length) {
          let arr = toObject(meta);
          more = " " + arr.map((o) => toString(o));
        }
        return `${toTimeString(new Date())} ${level2.toUpperCase()} [${this.name}] - ${data}${more}
`;
      }
      debug(data, ...meta) {
        if (level != "debug" || this.stream == null)
          return;
        this.stream.write(this.getText("debug", data, meta));
      }
      info(data, ...meta) {
        if (this.stream == null)
          return;
        this.stream.write(this.getText("info", data, meta));
      }
      warn(data, ...meta) {
        if (this.stream == null)
          return;
        this.stream.write(this.getText("warn", data, meta));
      }
      error(data, ...meta) {
        if (this.stream == null)
          return;
        this.stream.write(this.getText("error", data, meta));
      }
      trace(data, ...meta) {
        if (level != "trace" || this.stream == null)
          return;
        this.stream.write(this.getText("trace", data, meta));
      }
    };
    function createLogger3(name2) {
      return new Logger(name2);
    }
    exports.createLogger = createLogger3;
  }
});

// node_modules/@chemzqm/neovim/lib/transport/base.js
var require_base = __commonJS({
  "node_modules/@chemzqm/neovim/lib/transport/base.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var events_1 = require("events");
    var logger_1 = require_logger3();
    var debug = process.env.NODE_CLIENT_LOG_LEVEL == "debug";
    var logger138 = (0, logger_1.createLogger)("transport");
    var Transport3 = class extends events_1.EventEmitter {
      constructor(logger139) {
        super();
        this.logger = logger139;
        this.pauseLevel = 0;
        this.paused = /* @__PURE__ */ new Map();
      }
      debug(key, ...meta) {
        if (!debug)
          return;
        logger138.debug(key, ...meta);
      }
      info(key, ...meta) {
        logger138.info(key, ...meta);
      }
      debugMessage(msg) {
        if (!debug)
          return;
        const msgType = msg[0];
        if (msgType == 0) {
          logger138.debug("receive request:", msg.slice(1));
        } else if (msgType == 1) {
        } else if (msgType == 2) {
          logger138.debug("receive notification:", msg.slice(1));
        } else {
          logger138.debug("unknown message:", msg);
        }
      }
      pauseNotification() {
        this.pauseLevel = this.pauseLevel + 1;
        this.paused.set(this.pauseLevel, []);
      }
      cancelNotification() {
        let { pauseLevel } = this;
        if (pauseLevel > 0) {
          this.paused.delete(pauseLevel);
          this.pauseLevel = pauseLevel - 1;
        }
      }
      resumeNotification(isNotify = false) {
        let { pauseLevel } = this;
        if (pauseLevel == 0)
          return isNotify ? null : Promise.resolve([[], null]);
        let stack = Error().stack;
        this.pauseLevel = pauseLevel - 1;
        let list2 = this.paused.get(pauseLevel);
        this.paused.delete(pauseLevel);
        if (list2 && list2.length) {
          return new Promise((resolve3, reject) => {
            if (!isNotify) {
              return this.request("nvim_call_atomic", [list2], (err, res) => {
                if (err) {
                  let e = new Error(`call_atomic error: ${err[1]}`);
                  e.stack = stack;
                  return reject(e);
                }
                if (Array.isArray(res) && res[1] != null) {
                  let [index, errType, message] = res[1];
                  let [fname, args] = list2[index];
                  let e = new Error(`call_atomic request error on "${fname}": ${message}`);
                  e.stack = stack;
                  this.logger.error(`call_atomic request error ${errType} on "${fname}"`, args, message, stack);
                  return reject(e);
                }
                resolve3(res);
              });
            }
            this.notify("nvim_call_atomic", [list2]);
            resolve3(void 0);
          });
        }
        return isNotify ? null : Promise.resolve([[], void 0]);
      }
    };
    exports.default = Transport3;
  }
});

// node_modules/@chemzqm/neovim/lib/transport/nvim.js
var require_nvim = __commonJS({
  "node_modules/@chemzqm/neovim/lib/transport/nvim.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NvimTransport = void 0;
    var msgpack = __importStar(require_msgpack_lite());
    var buffered_1 = __importDefault(require_buffered());
    var types_1 = require_types();
    var base_1 = __importDefault(require_base());
    var NvimTransport = class extends base_1.default {
      constructor(logger138) {
        super(logger138);
        this.pending = /* @__PURE__ */ new Map();
        this.nextRequestId = 1;
        this.attached = false;
        const codec = this.setupCodec();
        this.encodeStream = msgpack.createEncodeStream({ codec });
        this.decodeStream = msgpack.createDecodeStream({ codec });
        this.decodeStream.on("data", (msg) => {
          this.parseMessage(msg);
        });
        this.decodeStream.on("end", () => {
          this.detach();
          this.emit("detach");
        });
      }
      parseMessage(msg) {
        const msgType = msg[0];
        this.debugMessage(msg);
        if (msgType === 0) {
          this.emit("request", msg[2].toString(), msg[3], this.createResponse(msg[1]));
        } else if (msgType === 1) {
          const id = msg[1];
          const handler = this.pending.get(id);
          if (handler) {
            this.pending.delete(id);
            let err = msg[2];
            if (err && err.length != 2) {
              err = [0, err instanceof Error ? err.message : err];
            }
            handler(err, msg[3]);
          }
        } else if (msgType === 2) {
          this.emit("notification", msg[1].toString(), msg[2]);
        } else {
          console.error(`Invalid message type ${msgType}`);
        }
      }
      setupCodec() {
        const codec = msgpack.createCodec();
        types_1.Metadata.forEach(({ constructor }, id) => {
          codec.addExtPacker(id, constructor, (obj) => msgpack.encode(obj.data));
          codec.addExtUnpacker(id, (data) => new constructor({
            transport: this,
            client: this.client,
            data: msgpack.decode(data)
          }));
        });
        this.codec = codec;
        return this.codec;
      }
      attach(writer, reader, client) {
        this.encodeStream = this.encodeStream.pipe(writer);
        const buffered = new buffered_1.default();
        reader.pipe(buffered).pipe(this.decodeStream);
        this.writer = writer;
        this.reader = reader;
        this.client = client;
        this.attached = true;
      }
      detach() {
        if (!this.attached)
          return;
        this.attached = false;
        this.encodeStream.unpipe(this.writer);
        this.reader.unpipe(this.decodeStream);
      }
      request(method, args, cb) {
        if (!this.attached)
          return;
        let id = this.nextRequestId;
        this.nextRequestId = this.nextRequestId + 1;
        let startTs = Date.now();
        this.debug("request to nvim:", id, method, args);
        this.encodeStream.write(msgpack.encode([0, id, method, args], {
          codec: this.codec
        }));
        let stack = Error().stack;
        let timer = setTimeout(() => {
          this.debug(`request to vim blocked more than 1s: ${method}`, args, stack);
        }, 1e3);
        this.pending.set(id, (err, res) => {
          clearTimeout(timer);
          this.debug("response of nvim:", id, `${Date.now() - startTs}ms`, res, err);
          cb(err, res);
        });
      }
      notify(method, args) {
        if (!this.attached)
          return;
        if (this.pauseLevel != 0) {
          let arr = this.paused.get(this.pauseLevel);
          if (arr) {
            arr.push([method, args]);
            return;
          }
        }
        this.debug("nvim notification:", method, args);
        this.encodeStream.write(msgpack.encode([2, method, args], {
          codec: this.codec
        }));
      }
      send(arr) {
        this.encodeStream.write(msgpack.encode(arr, {
          codec: this.codec
        }));
      }
      createResponse(requestId) {
        let { encodeStream } = this;
        let startTs = Date.now();
        let called = false;
        let timer = setTimeout(() => {
          this.debug(`request to client cost more than 1s`, requestId);
        }, 1e3);
        return {
          send: (resp, isError) => {
            clearTimeout(timer);
            if (called || !this.attached)
              return;
            this.debug("response of client:", requestId, `${Date.now() - startTs}ms`, resp, isError == true);
            called = true;
            encodeStream.write(msgpack.encode([
              1,
              requestId,
              isError ? resp : null,
              !isError ? resp : null
            ]));
          }
        };
      }
    };
    exports.NvimTransport = NvimTransport;
  }
});

// node_modules/@chemzqm/neovim/lib/transport/connection.js
var require_connection = __commonJS({
  "node_modules/@chemzqm/neovim/lib/transport/connection.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var events_1 = __importDefault(require("events"));
    var readline_1 = __importDefault(require("readline"));
    var logger_1 = require_logger3();
    var logger138 = (0, logger_1.createLogger)("connection");
    var Connection2 = class extends events_1.default {
      constructor(readable, writeable) {
        super();
        this.readable = readable;
        this.writeable = writeable;
        const rl = readline_1.default.createInterface(this.readable);
        rl.on("line", (line) => {
          this.parseData(line);
        });
        rl.on("close", () => {
          logger138.error("connection closed");
          process.exit(0);
        });
      }
      parseData(str) {
        if (str.length == 0)
          return;
        let arr;
        try {
          arr = JSON.parse(str);
        } catch (e) {
          console.error(`Invalid data from vim: ${str}`);
          return;
        }
        let [id, obj] = arr;
        if (id > 0) {
          logger138.debug("received request:", id, obj);
          this.emit("request", id, obj);
        } else if (id == 0) {
          logger138.debug("received notification:", obj);
          this.emit("notification", obj);
        } else {
          logger138.debug("received response:", id, obj);
          this.emit("response", id, obj);
        }
      }
      response(requestId, data) {
        this.send([requestId, data || null]);
      }
      notify(event, data) {
        this.send([0, [event, data || null]]);
      }
      send(arr) {
        logger138.debug("send to vim:", arr);
        try {
          this.writeable.write(JSON.stringify(arr) + "\n");
        } catch (e) {
          logger138.error("Send error:", arr);
        }
      }
      redraw(force) {
        this.send(["redraw", force ? "force" : ""]);
      }
      command(cmd) {
        this.send(["ex", cmd]);
      }
      expr(expr) {
        this.send(["expr", expr]);
      }
      call(func2, args, requestId) {
        if (!requestId) {
          this.send(["call", func2, args]);
          return;
        }
        this.send(["call", func2, args, requestId]);
      }
      dispose() {
        this.removeAllListeners();
      }
    };
    exports.default = Connection2;
  }
});

// node_modules/@chemzqm/neovim/lib/transport/request.js
var require_request = __commonJS({
  "node_modules/@chemzqm/neovim/lib/transport/request.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var logger_1 = require_logger3();
    var logger138 = (0, logger_1.createLogger)("request");
    var func2 = process.env.COC_NVIM == "1" ? "coc#api#call" : "nvim#api#call";
    var Request = class {
      constructor(connection, cb, id) {
        this.connection = connection;
        this.cb = cb;
        this.id = id;
      }
      request(method, args = []) {
        this.method = method;
        this.connection.call(func2, [method.slice(5), args], this.id);
      }
      callback(client, err, result) {
        let { method, cb } = this;
        if (err)
          return cb([0, err.toString()]);
        switch (method) {
          case "nvim_list_wins":
          case "nvim_tabpage_list_wins":
            return cb(null, result.map((o) => client.createWindow(o)));
          case "nvim_tabpage_get_win":
          case "nvim_get_current_win":
          case "nvim_open_win":
            return cb(null, client.createWindow(result));
          case "nvim_list_bufs":
            return cb(null, result.map((o) => client.createBuffer(o)));
          case "nvim_win_get_buf":
          case "nvim_create_buf":
          case "nvim_get_current_buf":
            return cb(null, client.createBuffer(result));
          case "nvim_list_tabpages":
            return cb(null, result.map((o) => client.createTabpage(o)));
          case "nvim_get_current_tabpage":
            return cb(null, client.createTabpage(result));
          default:
            return cb(null, result);
        }
      }
    };
    exports.default = Request;
  }
});

// node_modules/@chemzqm/neovim/lib/transport/vim.js
var require_vim = __commonJS({
  "node_modules/@chemzqm/neovim/lib/transport/vim.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VimTransport = void 0;
    var base_1 = __importDefault(require_base());
    var connection_1 = __importDefault(require_connection());
    var request_1 = __importDefault(require_request());
    var VimTransport = class extends base_1.default {
      constructor(logger138) {
        super(logger138);
        this.pending = /* @__PURE__ */ new Map();
        this.nextRequestId = -1;
        this.attached = false;
        this.errText = "";
        this.outText = "";
        this.notifyMethod = process.env.COC_NVIM == "1" ? "coc#api#notify" : "nvim#api#notify";
      }
      attach(writer, reader, client) {
        let connection = this.connection = new connection_1.default(reader, writer);
        this.attached = true;
        this.client = client;
        connection.on("request", (id, obj) => {
          let [method, args] = obj;
          this.emit("request", method, args, this.createResponse(id));
        });
        connection.on("notification", (obj) => {
          let [event, args] = obj;
          this.emit("notification", event.toString(), args);
        });
        connection.on("response", (id, obj) => {
          let req = this.pending.get(id);
          if (req) {
            this.pending.delete(id);
            let err = null;
            let result = null;
            if (!Array.isArray(obj)) {
              err = obj;
            } else {
              err = obj[0];
              result = obj[1];
            }
            req.callback(this.client, err, result);
          }
        });
      }
      send(arr) {
        this.connection.send(arr);
      }
      detach() {
        if (!this.attached)
          return;
        this.attached = false;
        this.connection.dispose();
      }
      request(method, args, cb) {
        if (!this.attached)
          return cb([0, "transport disconnected"]);
        let id = this.nextRequestId;
        this.nextRequestId = this.nextRequestId - 1;
        let startTs = Date.now();
        this.debug("request to vim:", id, method, args);
        let timer = setTimeout(() => {
          this.debug(`request to vim cost more than 1s`, method, args);
        }, 1e3);
        let req = new request_1.default(this.connection, (err, res) => {
          clearTimeout(timer);
          this.debug(`response from vim cost:`, id, `${Date.now() - startTs}ms`);
          cb(err, res);
        }, id);
        this.pending.set(id, req);
        req.request(method, args);
      }
      notify(method, args) {
        if (!this.attached)
          return;
        if (this.pauseLevel != 0) {
          let arr = this.paused.get(this.pauseLevel);
          if (arr) {
            arr.push([method, args]);
            return;
          }
        }
        let fname = method.slice(5);
        if (fname == "err_write") {
          this.errText = this.errText + args[0].toString();
          return;
        }
        if (fname == "out_write") {
          let msg = args[0].toString() || "";
          if (!msg.includes("\n")) {
            this.outText = this.outText + msg;
          } else {
            let text = this.outText + args[0].toString();
            this.outText = "";
            this.connection.call(this.notifyMethod, [fname, [text]]);
          }
          return;
        }
        if (fname == "err_writeln") {
          let text = this.errText + args[0].toString();
          this.errText = "";
          this.connection.call(this.notifyMethod, [fname, [text]]);
          return;
        }
        this.connection.call(this.notifyMethod, [fname, args]);
      }
      createResponse(requestId) {
        let called = false;
        let { connection } = this;
        let startTs = Date.now();
        let timer = setTimeout(() => {
          this.debug(`request to client cost more than 1s`, requestId);
        }, 1e3);
        return {
          send: (resp, isError) => {
            clearTimeout(timer);
            if (called || !this.attached)
              return;
            called = true;
            let err = null;
            if (isError)
              err = typeof resp === "string" ? resp : resp.toString();
            this.debug("response of client cost:", requestId, `${Date.now() - startTs}ms`);
            connection.response(requestId, [err, isError ? null : resp]);
          }
        };
      }
    };
    exports.VimTransport = VimTransport;
  }
});

// node_modules/@chemzqm/neovim/lib/api/Neovim.js
var require_Neovim = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/Neovim.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Neovim = void 0;
    var Base_1 = require_Base();
    var Buffer_1 = require_Buffer();
    var Tabpage_1 = require_Tabpage();
    var Window_1 = require_Window();
    var isVim6 = process.env.VIM_NODE_RPC == "1";
    var Neovim = class extends Base_1.BaseApi {
      constructor() {
        super(...arguments);
        this.prefix = "nvim_";
        this.Buffer = Buffer_1.Buffer;
        this.Window = Window_1.Window;
        this.Tabpage = Tabpage_1.Tabpage;
      }
      getArgs(args) {
        if (!args)
          return [];
        if (Array.isArray(args))
          return args;
        return [args];
      }
      get apiInfo() {
        return this.request(`${this.prefix}get_api_info`);
      }
      get buffers() {
        return this.request(`${this.prefix}list_bufs`);
      }
      get buffer() {
        return this.request(`${this.prefix}get_current_buf`);
      }
      async setBuffer(buffer) {
        await this.request(`${this.prefix}set_current_buf`, [buffer]);
      }
      get chans() {
        return this.request(`${this.prefix}list_chans`);
      }
      getChanInfo(chan) {
        return this.request(`${this.prefix}get_chan_info`, [chan]);
      }
      createNamespace(name2 = "") {
        if (process.env.COC_NVIM == "1") {
          name2 = name2.startsWith("coc-") ? name2.slice(4) : name2;
          return this.request(`${this.prefix}call_function`, ["coc#highlight#create_namespace", [name2]]);
        }
        return this.request(`${this.prefix}create_namespace`, [name2]);
      }
      get namespaces() {
        return this.request(`${this.prefix}get_namespaces`, []);
      }
      get commands() {
        return this.getCommands();
      }
      getCommands(options2 = {}) {
        return this.request(`${this.prefix}get_commands`, [options2]);
      }
      get tabpages() {
        return this.request(`${this.prefix}list_tabpages`);
      }
      get tabpage() {
        return this.request(`${this.prefix}get_current_tabpage`);
      }
      async setTabpage(tabpage) {
        await this.request(`${this.prefix}set_current_tabpage`, [tabpage]);
      }
      get windows() {
        return this.getWindows();
      }
      get window() {
        return this.request(`${this.prefix}get_current_win`);
      }
      getWindows() {
        return this.request(`${this.prefix}list_wins`);
      }
      async setWindow(win) {
        await this.request(`${this.prefix}set_current_win`, [win]);
      }
      get runtimePaths() {
        return this.request(`${this.prefix}list_runtime_paths`);
      }
      setDirectory(dir) {
        return this.request(`${this.prefix}set_current_dir`, [dir]);
      }
      get line() {
        return this.getLine();
      }
      createNewBuffer(listed = false, scratch = false) {
        return this.request(`${this.prefix}create_buf`, [listed, scratch]);
      }
      openFloatWindow(buffer, enter, options2) {
        return this.request(`${this.prefix}open_win`, [buffer, enter, options2]);
      }
      getLine() {
        return this.request(`${this.prefix}get_current_line`);
      }
      setLine(line) {
        return this.request(`${this.prefix}set_current_line`, [line]);
      }
      getKeymap(mode) {
        return this.request(`${this.prefix}get_keymap`, [mode]);
      }
      get mode() {
        return this.request(`${this.prefix}get_mode`);
      }
      get colorMap() {
        return this.request(`${this.prefix}get_color_map`);
      }
      getColorByName(name2) {
        return this.request(`${this.prefix}get_color_by_name`, [name2]);
      }
      getHighlight(nameOrId, isRgb = true) {
        const functionName = typeof nameOrId === "string" ? "by_name" : "by_id";
        return this.request(`${this.prefix}get_hl_${functionName}`, [
          nameOrId,
          isRgb
        ]);
      }
      getHighlightByName(name2, isRgb = true) {
        return this.request(`${this.prefix}get_hl_by_name`, [name2, isRgb]);
      }
      getHighlightById(id, isRgb = true) {
        return this.request(`${this.prefix}get_hl_by_id`, [id, isRgb]);
      }
      deleteCurrentLine() {
        return this.request(`${this.prefix}del_current_line`);
      }
      eval(expr) {
        return this.request(`${this.prefix}eval`, [expr]);
      }
      lua(code, args = []) {
        return this.request(`${this.prefix}exec_lua`, [code, args]);
      }
      executeLua(code, args = []) {
        const _args = this.getArgs(args);
        return this.lua(code, _args);
      }
      callDictFunction(dict, fname, args = []) {
        const _args = this.getArgs(args);
        return this.request(`${this.prefix}call_dict_function`, [
          dict,
          fname,
          _args
        ]);
      }
      call(fname, args = [], isNotify) {
        const _args = this.getArgs(args);
        if (isNotify) {
          this.notify(`${this.prefix}call_function`, [fname, _args]);
          return null;
        }
        return this.request(`${this.prefix}call_function`, [fname, _args]);
      }
      callTimer(fname, args = [], isNotify) {
        const _args = this.getArgs(args);
        if (isNotify) {
          this.notify(`${this.prefix}call_function`, ["coc#util#timer", [fname, _args]]);
          return null;
        }
        if (isVim6) {
          this.notify(`${this.prefix}call_function`, ["coc#util#timer", [fname, _args]]);
          return new Promise((resolve3) => {
            setTimeout(() => {
              resolve3(null);
            }, 20);
          });
        }
        return this.request(`${this.prefix}call_function`, ["coc#util#timer", [fname, _args]]);
      }
      callAsync(fname, args = []) {
        const _args = this.getArgs(args);
        return this.client.sendAsyncRequest(fname, _args);
      }
      callFunction(fname, args = []) {
        return this.call(fname, args);
      }
      callAtomic(calls) {
        return this.request(`${this.prefix}call_atomic`, [calls]);
      }
      command(arg, isNotify) {
        if (isNotify) {
          this.notify(`${this.prefix}command`, [arg]);
          return null;
        }
        return this.request(`${this.prefix}command`, [arg]);
      }
      commandOutput(arg) {
        return this.request(`${this.prefix}command_output`, [arg]);
      }
      exec(src, output = false) {
        return this.request(`${this.prefix}exec`, [src, output]);
      }
      getVvar(name2) {
        return this.request(`${this.prefix}get_vvar`, [name2]);
      }
      feedKeys(keys, mode, escapeCsi) {
        return this.request(`${this.prefix}feedkeys`, [keys, mode, escapeCsi]);
      }
      input(keys) {
        return this.request(`${this.prefix}input`, [keys]);
      }
      parseExpression(expr, flags, highlight) {
        return this.request(`${this.prefix}parse_expression`, [
          expr,
          flags,
          highlight
        ]);
      }
      getProc(pid) {
        return this.request(`${this.prefix}get_proc`, [pid]);
      }
      getProcChildren(pid) {
        return this.request(`${this.prefix}get_proc_children`, [pid]);
      }
      replaceTermcodes(str, fromPart, doIt, special) {
        return this.request(`${this.prefix}replace_termcodes`, [
          str,
          fromPart,
          doIt,
          special
        ]);
      }
      strWidth(str) {
        return this.request(`${this.prefix}strwidth`, [str]);
      }
      outWrite(str) {
        this.notify(`${this.prefix}out_write`, [str]);
      }
      outWriteLine(str) {
        this.outWrite(`${str}
`);
      }
      errWrite(str) {
        this.notify(`${this.prefix}err_write`, [str]);
      }
      errWriteLine(str) {
        this.notify(`${this.prefix}err_writeln`, [str]);
      }
      get uis() {
        return this.request(`${this.prefix}list_uis`);
      }
      uiAttach(width, height, options2) {
        return this.request(`${this.prefix}ui_attach`, [width, height, options2]);
      }
      uiDetach() {
        return this.request(`${this.prefix}ui_detach`, []);
      }
      uiTryResize(width, height) {
        return this.request(`${this.prefix}ui_try_resize`, [width, height]);
      }
      uiSetOption(name2, value) {
        return this.request(`${this.prefix}ui_set_option`, [name2, value]);
      }
      subscribe(event) {
        return this.request(`${this.prefix}subscribe`, [event]);
      }
      unsubscribe(event) {
        return this.request(`${this.prefix}unsubscribe`, [event]);
      }
      setClientInfo(name2, version2, type, methods2, attributes) {
        this.notify(`${this.prefix}set_client_info`, [
          name2,
          version2,
          type,
          methods2,
          attributes
        ]);
      }
      async quit() {
        this.command("qa!", true);
        if (this.transport) {
          this.transport.detach();
        }
      }
    };
    exports.Neovim = Neovim;
  }
});

// node_modules/@chemzqm/neovim/lib/api/client.js
var require_client = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/client.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NeovimClient = exports.AsyncResponse = void 0;
    var nvim_1 = require_nvim();
    var vim_1 = require_vim();
    var Neovim_1 = require_Neovim();
    var Buffer_1 = require_Buffer();
    var Window_1 = require_Window();
    var Tabpage_1 = require_Tabpage();
    var logger_1 = require_logger3();
    var logger138 = (0, logger_1.createLogger)("client");
    var isVim6 = process.env.VIM_NODE_RPC == "1";
    var AsyncResponse = class {
      constructor(requestId, cb) {
        this.requestId = requestId;
        this.cb = cb;
        this.finished = false;
      }
      finish(err, res) {
        if (this.finished)
          return;
        this.finished = true;
        if (err) {
          this.cb(new Error(err));
          return;
        }
        this.cb(null, res);
      }
    };
    exports.AsyncResponse = AsyncResponse;
    var NeovimClient2 = class extends Neovim_1.Neovim {
      constructor(logger139) {
        super({});
        this.logger = logger139;
        this.requestId = 1;
        this.responses = /* @__PURE__ */ new Map();
        this.attachedBuffers = /* @__PURE__ */ new Map();
        this.isVim = isVim6;
        Object.defineProperty(this, "client", {
          value: this
        });
        let transport = isVim6 ? new vim_1.VimTransport(logger139) : new nvim_1.NvimTransport(logger139);
        this.setTransport(transport);
        this.transportAttached = false;
        this.handleRequest = this.handleRequest.bind(this);
        this.handleNotification = this.handleNotification.bind(this);
      }
      echoError(msg) {
        let prefix = process.env.COC_NVIM == "1" ? "[coc.nvim] " : "";
        if (msg instanceof Error) {
          this.errWriteLine(prefix + msg.message + " use :CocOpenLog for details");
          this.logError(msg.message || "Unknown error", msg.stack);
        } else {
          this.errWriteLine(prefix + msg);
          this.logError(msg.toString(), Error().stack);
        }
      }
      logError(msg, ...args) {
        if (!this.logger)
          return;
        this.logger.error(msg, ...args);
      }
      createBuffer(id) {
        return new Buffer_1.Buffer({
          transport: this.transport,
          data: id,
          client: this
        });
      }
      createWindow(id) {
        return new Window_1.Window({
          transport: this.transport,
          data: id,
          client: this
        });
      }
      createTabpage(id) {
        return new Tabpage_1.Tabpage({
          transport: this.transport,
          data: id,
          client: this
        });
      }
      send(arr) {
        this.transport.send(arr);
      }
      redrawVim(force) {
        if (!isVim6)
          return;
        this.transport.notify("nvim_command", ["redraw" + (force ? "!" : "")]);
      }
      attach({ reader, writer }, requestApi = true) {
        this.transport.attach(writer, reader, this);
        this.transportAttached = true;
        this.setupTransport(requestApi);
      }
      detach() {
        this.transport.detach();
        this.transportAttached = false;
      }
      get isApiReady() {
        return this.transportAttached && typeof this._channelId !== "undefined";
      }
      get channelId() {
        return this._isReady.then(() => {
          return this._channelId;
        });
      }
      isAttached(bufnr) {
        return this.attachedBuffers.has(bufnr);
      }
      handleRequest(method, args, resp) {
        this.emit("request", method, args, resp);
      }
      sendAsyncRequest(method, args) {
        let id = this.requestId;
        this.requestId = id + 1;
        this.notify("nvim_call_function", ["coc#rpc#async_request", [id, method, args || []]]);
        return new Promise((resolve3, reject) => {
          let response = new AsyncResponse(id, (err, res) => {
            if (err)
              return reject(err);
            resolve3(res);
          });
          this.responses.set(id, response);
        });
      }
      emitNotification(method, args) {
        if (method.endsWith("_event")) {
          if (method.startsWith("nvim_buf_")) {
            const shortName = method.replace(/nvim_buf_(.*)_event/, "$1");
            const { id } = args[0];
            if (!this.attachedBuffers.has(id))
              return;
            const bufferMap = this.attachedBuffers.get(id);
            const cbs = bufferMap.get(shortName) || [];
            cbs.forEach((cb) => cb(...args));
            if (shortName === "detach") {
              this.attachedBuffers.delete(id);
            }
            return;
          }
          if (method.startsWith("nvim_async_request")) {
            const [id, method2, arr] = args;
            this.handleRequest(method2, arr, {
              send: (resp, isError) => {
                this.notify("nvim_call_function", ["coc#rpc#async_response", [id, resp, isError]]);
              }
            });
            return;
          }
          if (method.startsWith("nvim_async_response")) {
            const [id, err, res] = args;
            const response = this.responses.get(id);
            if (!response) {
              console.error(`Response not found for request ${id}`);
              return;
            }
            this.responses.delete(id);
            response.finish(err, res);
            return;
          }
          if (method === "nvim_error_event") {
            this.logger.error(`Error event from nvim:`, args[0], args[1]);
            return;
          }
          this.logger.debug(`Unhandled event: ${method}`, args);
        } else {
          this.emit("notification", method, args);
        }
      }
      handleNotification(method, args) {
        this.emitNotification(method, args);
      }
      setupTransport(requestApi = true) {
        if (!this.transportAttached) {
          throw new Error("Not attached to input/output");
        }
        this.transport.on("request", this.handleRequest);
        this.transport.on("notification", this.handleNotification);
        this.transport.on("detach", () => {
          this.emit("disconnect");
          this.transport.removeAllListeners("request");
          this.transport.removeAllListeners("notification");
          this.transport.removeAllListeners("detach");
        });
        if (requestApi) {
          this._isReady = this.generateApi();
        } else {
          this._channelId = 0;
          this._isReady = Promise.resolve(true);
        }
      }
      requestApi() {
        return new Promise((resolve3, reject) => {
          this.transport.request("nvim_get_api_info", [], (err, res) => {
            if (err) {
              reject(new Error(Array.isArray(err) ? err[1] : err.message || err.toString()));
            } else {
              resolve3(res);
            }
          });
        });
      }
      async generateApi() {
        let results;
        try {
          results = await this.requestApi();
        } catch (err) {
          console.error("Could not get vim api results");
          logger138.error(err);
        }
        if (results) {
          try {
            const [channelId, metadata] = results;
            this.functions = metadata.functions.map((f) => f.name);
            this._channelId = channelId;
            return true;
          } catch (err) {
            logger138.error(err.stack);
            return null;
          }
        }
        return null;
      }
      attachBufferEvent(buffer, eventName, cb) {
        const bufferMap = this.attachedBuffers.get(buffer.id) || /* @__PURE__ */ new Map();
        const cbs = bufferMap.get(eventName) || [];
        if (cbs.includes(cb))
          return;
        cbs.push(cb);
        bufferMap.set(eventName, cbs);
        this.attachedBuffers.set(buffer.id, bufferMap);
        return;
      }
      detachBufferEvent(buffer, eventName, cb) {
        const bufferMap = this.attachedBuffers.get(buffer.id);
        if (!bufferMap || !bufferMap.has(eventName))
          return;
        const handlers = bufferMap.get(eventName).filter((handler) => handler !== cb);
        bufferMap.set(eventName, handlers);
      }
      pauseNotification() {
        let stack = Error().stack;
        if (this.transport.pauseLevel != 0) {
          this.logError(`Nested nvim.pauseNotification() detected, please avoid it:`, stack);
        }
        this.transport.pauseNotification();
        process.nextTick(() => {
          if (this.transport.pauseLevel > 0) {
            this.logError(`resumeNotification not called within same tick:`, stack);
          }
        });
      }
      resumeNotification(redrawVim, notify) {
        if (isVim6 && redrawVim) {
          this.transport.notify("nvim_command", ["redraw"]);
        }
        if (notify) {
          this.transport.resumeNotification(true);
          return Promise.resolve(null);
        }
        return this.transport.resumeNotification();
      }
      hasFunction(name2) {
        if (!this.functions)
          return true;
        return this.functions.includes(name2);
      }
    };
    exports.NeovimClient = NeovimClient2;
  }
});

// node_modules/@chemzqm/neovim/lib/attach/attach.js
var require_attach = __commonJS({
  "node_modules/@chemzqm/neovim/lib/attach/attach.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.attach = void 0;
    var net_1 = require("net");
    var client_1 = require_client();
    var logger_1 = require_logger3();
    function attach2({ reader: _reader, writer: _writer, proc, socket }, logger138 = null, requestApi = true) {
      let writer;
      let reader;
      let neovim;
      if (!logger138)
        logger138 = logger_1.nullLogger;
      if (socket) {
        const client = (0, net_1.createConnection)(socket);
        writer = client;
        reader = client;
        client.once("close", () => {
          neovim.detach();
        });
      } else if (_reader && _writer) {
        writer = _writer;
        reader = _reader;
      } else if (proc) {
        writer = proc.stdin;
        reader = proc.stdout;
        proc.once("disconnect", () => {
          neovim.detach();
        });
      }
      writer.on("error", (err) => {
        if (err.code == "EPIPE") {
          neovim.detach();
        }
      });
      if (writer && reader) {
        neovim = new client_1.NeovimClient(logger138);
        neovim.attach({
          writer,
          reader
        }, requestApi);
        return neovim;
      }
      throw new Error("Invalid arguments, could not attach");
    }
    exports.attach = attach2;
  }
});

// node_modules/@chemzqm/neovim/lib/api/index.js
var require_api = __commonJS({
  "node_modules/@chemzqm/neovim/lib/api/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tabpage = exports.Window = exports.Buffer = exports.NeovimClient = exports.Neovim = void 0;
    var client_1 = require_client();
    Object.defineProperty(exports, "Neovim", { enumerable: true, get: function() {
      return client_1.NeovimClient;
    } });
    var client_2 = require_client();
    Object.defineProperty(exports, "NeovimClient", { enumerable: true, get: function() {
      return client_2.NeovimClient;
    } });
    var Buffer_1 = require_Buffer();
    Object.defineProperty(exports, "Buffer", { enumerable: true, get: function() {
      return Buffer_1.Buffer;
    } });
    var Window_1 = require_Window();
    Object.defineProperty(exports, "Window", { enumerable: true, get: function() {
      return Window_1.Window;
    } });
    var Tabpage_1 = require_Tabpage();
    Object.defineProperty(exports, "Tabpage", { enumerable: true, get: function() {
      return Tabpage_1.Tabpage;
    } });
  }
});

// node_modules/@chemzqm/neovim/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/@chemzqm/neovim/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Window = exports.Tabpage = exports.Buffer = exports.NeovimClient = exports.Neovim = exports.attach = void 0;
    var attach_1 = require_attach();
    Object.defineProperty(exports, "attach", { enumerable: true, get: function() {
      return attach_1.attach;
    } });
    var index_1 = require_api();
    Object.defineProperty(exports, "Neovim", { enumerable: true, get: function() {
      return index_1.Neovim;
    } });
    Object.defineProperty(exports, "NeovimClient", { enumerable: true, get: function() {
      return index_1.NeovimClient;
    } });
    Object.defineProperty(exports, "Buffer", { enumerable: true, get: function() {
      return index_1.Buffer;
    } });
    Object.defineProperty(exports, "Tabpage", { enumerable: true, get: function() {
      return index_1.Tabpage;
    } });
    Object.defineProperty(exports, "Window", { enumerable: true, get: function() {
      return index_1.Window;
    } });
  }
});

// node_modules/vscode-jsonrpc/lib/common/ral.js
var require_ral = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/ral.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var _ral;
    function RAL2() {
      if (_ral === void 0) {
        throw new Error(`No runtime abstraction layer installed`);
      }
      return _ral;
    }
    (function(RAL3) {
      function install(ral) {
        if (ral === void 0) {
          throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
      }
      RAL3.install = install;
    })(RAL2 || (RAL2 = {}));
    exports.default = RAL2;
  }
});

// node_modules/vscode-jsonrpc/lib/common/disposable.js
var require_disposable = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Disposable = void 0;
    var Disposable96;
    (function(Disposable97) {
      function create(func2) {
        return {
          dispose: func2
        };
      }
      Disposable97.create = create;
    })(Disposable96 = exports.Disposable || (exports.Disposable = {}));
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
var require_messageBuffer = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractMessageBuffer = void 0;
    var CR = 13;
    var LF = 10;
    var CRLF = "\r\n";
    var AbstractMessageBuffer = class {
      constructor(encoding = "utf-8") {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
      }
      get encoding() {
        return this._encoding;
      }
      append(chunk) {
        const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
      }
      tryReadHeaders() {
        if (this._chunks.length === 0) {
          return void 0;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row:
          while (chunkIndex < this._chunks.length) {
            const chunk = this._chunks[chunkIndex];
            offset = 0;
            column:
              while (offset < chunk.length) {
                const value = chunk[offset];
                switch (value) {
                  case CR:
                    switch (state) {
                      case 0:
                        state = 1;
                        break;
                      case 2:
                        state = 3;
                        break;
                      default:
                        state = 0;
                    }
                    break;
                  case LF:
                    switch (state) {
                      case 1:
                        state = 2;
                        break;
                      case 3:
                        state = 4;
                        offset++;
                        break row;
                      default:
                        state = 0;
                    }
                    break;
                  default:
                    state = 0;
                }
                offset++;
              }
            chunkBytesRead += chunk.byteLength;
            chunkIndex++;
          }
        if (state !== 4) {
          return void 0;
        }
        const buffer = this._read(chunkBytesRead + offset);
        const result = /* @__PURE__ */ new Map();
        const headers = this.toString(buffer, "ascii").split(CRLF);
        if (headers.length < 2) {
          return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
          const header = headers[i];
          const index = header.indexOf(":");
          if (index === -1) {
            throw new Error("Message header must separate key and value using :");
          }
          const key = header.substr(0, index);
          const value = header.substr(index + 1).trim();
          result.set(key, value);
        }
        return result;
      }
      tryReadBody(length) {
        if (this._totalLength < length) {
          return void 0;
        }
        return this._read(length);
      }
      get numberOfBytes() {
        return this._totalLength;
      }
      _read(byteCount) {
        if (byteCount === 0) {
          return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
          throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
          const chunk = this._chunks[0];
          this._chunks.shift();
          this._totalLength -= byteCount;
          return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
          const chunk = this._chunks[0];
          const result2 = this.asNative(chunk, byteCount);
          this._chunks[0] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
          return result2;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
          const chunk = this._chunks[chunkIndex];
          if (chunk.byteLength > byteCount) {
            const chunkPart = chunk.slice(0, byteCount);
            result.set(chunkPart, resultOffset);
            resultOffset += byteCount;
            this._chunks[chunkIndex] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            byteCount -= byteCount;
          } else {
            result.set(chunk, resultOffset);
            resultOffset += chunk.byteLength;
            this._chunks.shift();
            this._totalLength -= chunk.byteLength;
            byteCount -= chunk.byteLength;
          }
        }
        return result;
      }
    };
    exports.AbstractMessageBuffer = AbstractMessageBuffer;
  }
});

// node_modules/vscode-jsonrpc/lib/node/ril.js
var require_ril = __commonJS({
  "node_modules/vscode-jsonrpc/lib/node/ril.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ral_1 = require_ral();
    var util_1 = require("util");
    var disposable_1 = require_disposable();
    var messageBuffer_1 = require_messageBuffer();
    var MessageBuffer = class extends messageBuffer_1.AbstractMessageBuffer {
      constructor(encoding = "utf-8") {
        super(encoding);
      }
      emptyBuffer() {
        return MessageBuffer.emptyBuffer;
      }
      fromString(value, encoding) {
        return Buffer.from(value, encoding);
      }
      toString(value, encoding) {
        if (value instanceof Buffer) {
          return value.toString(encoding);
        } else {
          return new util_1.TextDecoder(encoding).decode(value);
        }
      }
      asNative(buffer, length) {
        if (length === void 0) {
          return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        } else {
          return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
      }
      allocNative(length) {
        return Buffer.allocUnsafe(length);
      }
    };
    MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
    var ReadableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return disposable_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return disposable_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return disposable_1.Disposable.create(() => this.stream.off("end", listener));
      }
      onData(listener) {
        this.stream.on("data", listener);
        return disposable_1.Disposable.create(() => this.stream.off("data", listener));
      }
    };
    var WritableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return disposable_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return disposable_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return disposable_1.Disposable.create(() => this.stream.off("end", listener));
      }
      write(data, encoding) {
        return new Promise((resolve3, reject) => {
          const callback = (error) => {
            if (error === void 0 || error === null) {
              resolve3();
            } else {
              reject(error);
            }
          };
          if (typeof data === "string") {
            this.stream.write(data, encoding, callback);
          } else {
            this.stream.write(data, callback);
          }
        });
      }
      end() {
        this.stream.end();
      }
    };
    var _ril = Object.freeze({
      messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
      }),
      applicationJson: Object.freeze({
        encoder: Object.freeze({
          name: "application/json",
          encode: (msg, options2) => {
            try {
              return Promise.resolve(Buffer.from(JSON.stringify(msg, void 0, 0), options2.charset));
            } catch (err) {
              return Promise.reject(err);
            }
          }
        }),
        decoder: Object.freeze({
          name: "application/json",
          decode: (buffer, options2) => {
            try {
              if (buffer instanceof Buffer) {
                return Promise.resolve(JSON.parse(buffer.toString(options2.charset)));
              } else {
                return Promise.resolve(JSON.parse(new util_1.TextDecoder(options2.charset).decode(buffer)));
              }
            } catch (err) {
              return Promise.reject(err);
            }
          }
        })
      }),
      stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
      }),
      console,
      timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
          const handle = setTimeout(callback, ms, ...args);
          return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
          const handle = setImmediate(callback, ...args);
          return { dispose: () => clearImmediate(handle) };
        },
        setInterval(callback, ms, ...args) {
          const handle = setInterval(callback, ms, ...args);
          return { dispose: () => clearInterval(handle) };
        }
      })
    });
    function RIL() {
      return _ril;
    }
    (function(RIL2) {
      function install() {
        ral_1.default.install(_ril);
      }
      RIL2.install = install;
    })(RIL || (RIL = {}));
    exports.default = RIL;
  }
});

// node_modules/vscode-jsonrpc/lib/common/is.js
var require_is = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
    function boolean2(value) {
      return value === true || value === false;
    }
    exports.boolean = boolean2;
    function string2(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports.string = string2;
    function number2(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports.number = number2;
    function error(value) {
      return value instanceof Error;
    }
    exports.error = error;
    function func2(value) {
      return typeof value === "function";
    }
    exports.func = func2;
    function array(value) {
      return Array.isArray(value);
    }
    exports.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string2(elem));
    }
    exports.stringArray = stringArray;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messages.js
var require_messages = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Message = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;
    var is = require_is();
    var ErrorCodes2;
    (function(ErrorCodes3) {
      ErrorCodes3.ParseError = -32700;
      ErrorCodes3.InvalidRequest = -32600;
      ErrorCodes3.MethodNotFound = -32601;
      ErrorCodes3.InvalidParams = -32602;
      ErrorCodes3.InternalError = -32603;
      ErrorCodes3.jsonrpcReservedErrorRangeStart = -32099;
      ErrorCodes3.serverErrorStart = -32099;
      ErrorCodes3.MessageWriteError = -32099;
      ErrorCodes3.MessageReadError = -32098;
      ErrorCodes3.PendingResponseRejected = -32097;
      ErrorCodes3.ConnectionInactive = -32096;
      ErrorCodes3.ServerNotInitialized = -32002;
      ErrorCodes3.UnknownErrorCode = -32001;
      ErrorCodes3.jsonrpcReservedErrorRangeEnd = -32e3;
      ErrorCodes3.serverErrorEnd = -32e3;
    })(ErrorCodes2 = exports.ErrorCodes || (exports.ErrorCodes = {}));
    var ResponseError2 = class extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes2.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError2.prototype);
      }
      toJson() {
        const result = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          result.data = this.data;
        }
        return result;
      }
    };
    exports.ResponseError = ResponseError2;
    var ParameterStructures = class {
      constructor(kind) {
        this.kind = kind;
      }
      static is(value) {
        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
      }
      toString() {
        return this.kind;
      }
    };
    exports.ParameterStructures = ParameterStructures;
    ParameterStructures.auto = new ParameterStructures("auto");
    ParameterStructures.byPosition = new ParameterStructures("byPosition");
    ParameterStructures.byName = new ParameterStructures("byName");
    var AbstractMessageSignature = class {
      constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
      }
      get parameterStructures() {
        return ParameterStructures.auto;
      }
    };
    exports.AbstractMessageSignature = AbstractMessageSignature;
    var RequestType03 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports.RequestType0 = RequestType03;
    var RequestType3 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.RequestType = RequestType3;
    var RequestType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.RequestType1 = RequestType1;
    var RequestType22 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports.RequestType2 = RequestType22;
    var RequestType32 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports.RequestType3 = RequestType32;
    var RequestType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports.RequestType4 = RequestType4;
    var RequestType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports.RequestType5 = RequestType5;
    var RequestType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports.RequestType6 = RequestType6;
    var RequestType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports.RequestType7 = RequestType7;
    var RequestType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports.RequestType8 = RequestType8;
    var RequestType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports.RequestType9 = RequestType9;
    var NotificationType3 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.NotificationType = NotificationType3;
    var NotificationType03 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports.NotificationType0 = NotificationType03;
    var NotificationType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports.NotificationType1 = NotificationType1;
    var NotificationType22 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports.NotificationType2 = NotificationType22;
    var NotificationType32 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports.NotificationType3 = NotificationType32;
    var NotificationType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports.NotificationType4 = NotificationType4;
    var NotificationType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports.NotificationType5 = NotificationType5;
    var NotificationType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports.NotificationType6 = NotificationType6;
    var NotificationType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports.NotificationType7 = NotificationType7;
    var NotificationType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports.NotificationType8 = NotificationType8;
    var NotificationType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports.NotificationType9 = NotificationType9;
    var Message2;
    (function(Message3) {
      function isRequest(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
      }
      Message3.isRequest = isRequest;
      function isNotification(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && message.id === void 0;
      }
      Message3.isNotification = isNotification;
      function isResponse(message) {
        const candidate = message;
        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
      }
      Message3.isResponse = isResponse;
    })(Message2 = exports.Message || (exports.Message = {}));
  }
});

// node_modules/vscode-jsonrpc/lib/common/linkedMap.js
var require_linkedMap = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports) {
    "use strict";
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LRUCache = exports.LinkedMap = exports.Touch = void 0;
    var Touch2;
    (function(Touch3) {
      Touch3.None = 0;
      Touch3.First = 1;
      Touch3.AsOld = Touch3.First;
      Touch3.Last = 2;
      Touch3.AsNew = Touch3.Last;
    })(Touch2 = exports.Touch || (exports.Touch = {}));
    var LinkedMap2 = class {
      constructor() {
        this[_a] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        var _a2;
        return (_a2 = this._head) == null ? void 0 : _a2.value;
      }
      get last() {
        var _a2;
        return (_a2 = this._tail) == null ? void 0 : _a2.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = Touch2.None) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== Touch2.None) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = Touch2.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch2.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch2.None:
              this.addItemLast(item);
              break;
            case Touch2.First:
              this.addItemFirst(item);
              break;
            case Touch2.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          if (!item.next) {
            throw new Error("Invalid list");
          }
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          if (!item.previous) {
            throw new Error("Invalid list");
          }
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch2.First && touch !== Touch2.Last) {
          return;
        }
        if (touch === Touch2.First) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === Touch2.Last) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    };
    exports.LinkedMap = LinkedMap2;
    var LRUCache = class extends LinkedMap2 {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = Touch2.AsNew) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(key, Touch2.None);
      }
      set(key, value) {
        super.set(key, value, Touch2.Last);
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    };
    exports.LRUCache = LRUCache;
  }
});

// node_modules/vscode-jsonrpc/lib/common/events.js
var require_events = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Emitter = exports.Event = void 0;
    var ral_1 = require_ral();
    var Event41;
    (function(Event42) {
      const _disposable = { dispose() {
      } };
      Event42.None = function() {
        return _disposable;
      };
    })(Event41 = exports.Event || (exports.Event = {}));
    var CallbackList = class {
      add(callback, context = null, bucket) {
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: () => this.remove(callback, context) });
        }
      }
      remove(callback, context = null) {
        if (!this._callbacks) {
          return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      }
      invoke(...args) {
        if (!this._callbacks) {
          return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            (0, ral_1.default)().console.error(e);
          }
        }
        return ret;
      }
      isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
      }
      dispose() {
        this._callbacks = void 0;
        this._contexts = void 0;
      }
    };
    var Emitter46 = class {
      constructor(_options) {
        this._options = _options;
      }
      get event() {
        if (!this._event) {
          this._event = (listener, thisArgs, disposables) => {
            if (!this._callbacks) {
              this._callbacks = new CallbackList();
            }
            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
              this._options.onFirstListenerAdd(this);
            }
            this._callbacks.add(listener, thisArgs);
            const result = {
              dispose: () => {
                if (!this._callbacks) {
                  return;
                }
                this._callbacks.remove(listener, thisArgs);
                result.dispose = Emitter46._noop;
                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                  this._options.onLastListenerRemove(this);
                }
              }
            };
            if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
        }
        return this._event;
      }
      fire(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      }
      dispose() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      }
    };
    exports.Emitter = Emitter46;
    Emitter46._noop = function() {
    };
  }
});

// node_modules/vscode-jsonrpc/lib/common/cancellation.js
var require_cancellation = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CancellationTokenSource = exports.CancellationToken = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is();
    var events_1 = require_events();
    var CancellationToken60;
    (function(CancellationToken61) {
      CancellationToken61.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken61.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken61.None || candidate === CancellationToken61.Cancelled || Is2.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken61.is = is;
    })(CancellationToken60 = exports.CancellationToken || (exports.CancellationToken = {}));
    var shortcutEvent = Object.freeze(function(callback, context) {
      const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
      return { dispose() {
        handle.dispose();
      } };
    });
    var MutableToken = class {
      constructor() {
        this._isCancelled = false;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this.dispose();
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
      }
      dispose() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = void 0;
        }
      }
    };
    var CancellationTokenSource32 = class {
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken60.Cancelled;
        } else {
          this._token.cancel();
        }
      }
      dispose() {
        if (!this._token) {
          this._token = CancellationToken60.None;
        } else if (this._token instanceof MutableToken) {
          this._token.dispose();
        }
      }
    };
    exports.CancellationTokenSource = CancellationTokenSource32;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageReader.js
var require_messageReader = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is();
    var events_1 = require_events();
    var MessageReader2;
    (function(MessageReader3) {
      function is(value) {
        let candidate = value;
        return candidate && Is2.func(candidate.listen) && Is2.func(candidate.dispose) && Is2.func(candidate.onError) && Is2.func(candidate.onClose) && Is2.func(candidate.onPartialMessage);
      }
      MessageReader3.is = is;
    })(MessageReader2 = exports.MessageReader || (exports.MessageReader = {}));
    var AbstractMessageReader = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error) {
        this.errorEmitter.fire(this.asError(error));
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      get onPartialMessage() {
        return this.partialMessageEmitter.event;
      }
      firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Reader received error. Reason: ${Is2.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports.AbstractMessageReader = AbstractMessageReader;
    var ResolvedMessageReaderOptions;
    (function(ResolvedMessageReaderOptions2) {
      function fromOptions(options2) {
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = /* @__PURE__ */ new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = /* @__PURE__ */ new Map();
        if (options2 === void 0 || typeof options2 === "string") {
          charset = options2 ?? "utf-8";
        } else {
          charset = options2.charset ?? "utf-8";
          if (options2.contentDecoder !== void 0) {
            contentDecoder = options2.contentDecoder;
            contentDecoders.set(contentDecoder.name, contentDecoder);
          }
          if (options2.contentDecoders !== void 0) {
            for (const decoder of options2.contentDecoders) {
              contentDecoders.set(decoder.name, decoder);
            }
          }
          if (options2.contentTypeDecoder !== void 0) {
            contentTypeDecoder = options2.contentTypeDecoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          if (options2.contentTypeDecoders !== void 0) {
            for (const decoder of options2.contentTypeDecoders) {
              contentTypeDecoders.set(decoder.name, decoder);
            }
          }
        }
        if (contentTypeDecoder === void 0) {
          contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
          contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
      }
      ResolvedMessageReaderOptions2.fromOptions = fromOptions;
    })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
    var ReadableStreamMessageReader = class extends AbstractMessageReader {
      constructor(readable, options2) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options2);
        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 1e4;
        this.nextMessageLength = -1;
        this.messageToken = 0;
      }
      set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
      }
      get partialMessageTimeout() {
        return this._partialMessageTimeout;
      }
      listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback;
        const result = this.readable.onData((data) => {
          this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
      }
      onData(data) {
        this.buffer.append(data);
        while (true) {
          if (this.nextMessageLength === -1) {
            const headers = this.buffer.tryReadHeaders();
            if (!headers) {
              return;
            }
            const contentLength = headers.get("Content-Length");
            if (!contentLength) {
              throw new Error("Header must provide a Content-Length property.");
            }
            const length = parseInt(contentLength);
            if (isNaN(length)) {
              throw new Error("Content-Length value must be a number.");
            }
            this.nextMessageLength = length;
          }
          const body = this.buffer.tryReadBody(this.nextMessageLength);
          if (body === void 0) {
            this.setPartialMessageTimer();
            return;
          }
          this.clearPartialMessageTimer();
          this.nextMessageLength = -1;
          let p;
          if (this.options.contentDecoder !== void 0) {
            p = this.options.contentDecoder.decode(body);
          } else {
            p = Promise.resolve(body);
          }
          p.then((value) => {
            this.options.contentTypeDecoder.decode(value, this.options).then((msg) => {
              this.callback(msg);
            }, (error) => {
              this.fireError(error);
            });
          }, (error) => {
            this.fireError(error);
          });
        }
      }
      clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
          this.partialMessageTimer.dispose();
          this.partialMessageTimer = void 0;
        }
      }
      setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
          this.partialMessageTimer = void 0;
          if (token === this.messageToken) {
            this.firePartialMessage({ messageToken: token, waitingTime: timeout });
            this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      }
    };
    exports.ReadableStreamMessageReader = ReadableStreamMessageReader;
  }
});

// node_modules/vscode-jsonrpc/lib/common/semaphore.js
var require_semaphore = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Semaphore = void 0;
    var ral_1 = require_ral();
    var Semaphore = class {
      constructor(capacity = 1) {
        if (capacity <= 0) {
          throw new Error("Capacity must be greater than 0");
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
      }
      lock(thunk) {
        return new Promise((resolve3, reject) => {
          this._waiting.push({ thunk, resolve: resolve3, reject });
          this.runNext();
        });
      }
      get active() {
        return this._active;
      }
      runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
      }
      doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
          throw new Error(`To many thunks active`);
        }
        try {
          const result = next.thunk();
          if (result instanceof Promise) {
            result.then((value) => {
              this._active--;
              next.resolve(value);
              this.runNext();
            }, (err) => {
              this._active--;
              next.reject(err);
              this.runNext();
            });
          } else {
            this._active--;
            next.resolve(result);
            this.runNext();
          }
        } catch (err) {
          this._active--;
          next.reject(err);
          this.runNext();
        }
      }
    };
    exports.Semaphore = Semaphore;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageWriter.js
var require_messageWriter = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is();
    var semaphore_1 = require_semaphore();
    var events_1 = require_events();
    var ContentLength = "Content-Length: ";
    var CRLF = "\r\n";
    var MessageWriter2;
    (function(MessageWriter3) {
      function is(value) {
        let candidate = value;
        return candidate && Is2.func(candidate.dispose) && Is2.func(candidate.onClose) && Is2.func(candidate.onError) && Is2.func(candidate.write);
      }
      MessageWriter3.is = is;
    })(MessageWriter2 = exports.MessageWriter || (exports.MessageWriter = {}));
    var AbstractMessageWriter = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Writer received error. Reason: ${Is2.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports.AbstractMessageWriter = AbstractMessageWriter;
    var ResolvedMessageWriterOptions;
    (function(ResolvedMessageWriterOptions2) {
      function fromOptions(options2) {
        if (options2 === void 0 || typeof options2 === "string") {
          return { charset: options2 ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
        } else {
          return { charset: options2.charset ?? "utf-8", contentEncoder: options2.contentEncoder, contentTypeEncoder: options2.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
        }
      }
      ResolvedMessageWriterOptions2.fromOptions = fromOptions;
    })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
    var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
      constructor(writable, options2) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options2);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
      }
      async write(msg) {
        return this.writeSemaphore.lock(async () => {
          const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
            if (this.options.contentEncoder !== void 0) {
              return this.options.contentEncoder.encode(buffer);
            } else {
              return buffer;
            }
          });
          return payload.then((buffer) => {
            const headers = [];
            headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
            headers.push(CRLF);
            return this.doWrite(msg, headers, buffer);
          }, (error) => {
            this.fireError(error);
            throw error;
          });
        });
      }
      async doWrite(msg, headers, data) {
        try {
          await this.writable.write(headers.join(""), "ascii");
          return this.writable.write(data);
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
        this.writable.end();
      }
    };
    exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
  }
});

// node_modules/vscode-jsonrpc/lib/common/connection.js
var require_connection2 = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/connection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMessageConnection = exports.ConnectionOptions = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = exports.NullLogger = exports.ProgressType = exports.ProgressToken = void 0;
    var ral_1 = require_ral();
    var Is2 = require_is();
    var messages_1 = require_messages();
    var linkedMap_1 = require_linkedMap();
    var events_1 = require_events();
    var cancellation_1 = require_cancellation();
    var CancelNotification;
    (function(CancelNotification2) {
      CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
    })(CancelNotification || (CancelNotification = {}));
    var ProgressToken3;
    (function(ProgressToken4) {
      function is(value) {
        return typeof value === "string" || typeof value === "number";
      }
      ProgressToken4.is = is;
    })(ProgressToken3 = exports.ProgressToken || (exports.ProgressToken = {}));
    var ProgressNotification2;
    (function(ProgressNotification3) {
      ProgressNotification3.type = new messages_1.NotificationType("$/progress");
    })(ProgressNotification2 || (ProgressNotification2 = {}));
    var ProgressType4 = class {
      constructor() {
      }
    };
    exports.ProgressType = ProgressType4;
    var StarRequestHandler;
    (function(StarRequestHandler2) {
      function is(value) {
        return Is2.func(value);
      }
      StarRequestHandler2.is = is;
    })(StarRequestHandler || (StarRequestHandler = {}));
    exports.NullLogger = Object.freeze({
      error: () => {
      },
      warn: () => {
      },
      info: () => {
      },
      log: () => {
      }
    });
    var Trace3;
    (function(Trace4) {
      Trace4[Trace4["Off"] = 0] = "Off";
      Trace4[Trace4["Messages"] = 1] = "Messages";
      Trace4[Trace4["Compact"] = 2] = "Compact";
      Trace4[Trace4["Verbose"] = 3] = "Verbose";
    })(Trace3 = exports.Trace || (exports.Trace = {}));
    var TraceValues;
    (function(TraceValues2) {
      TraceValues2.Off = "off";
      TraceValues2.Messages = "messages";
      TraceValues2.Compact = "compact";
      TraceValues2.Verbose = "verbose";
    })(TraceValues = exports.TraceValues || (exports.TraceValues = {}));
    (function(Trace4) {
      function fromString(value) {
        if (!Is2.string(value)) {
          return Trace4.Off;
        }
        value = value.toLowerCase();
        switch (value) {
          case "off":
            return Trace4.Off;
          case "messages":
            return Trace4.Messages;
          case "compact":
            return Trace4.Compact;
          case "verbose":
            return Trace4.Verbose;
          default:
            return Trace4.Off;
        }
      }
      Trace4.fromString = fromString;
      function toString(value) {
        switch (value) {
          case Trace4.Off:
            return "off";
          case Trace4.Messages:
            return "messages";
          case Trace4.Compact:
            return "compact";
          case Trace4.Verbose:
            return "verbose";
          default:
            return "off";
        }
      }
      Trace4.toString = toString;
    })(Trace3 = exports.Trace || (exports.Trace = {}));
    var TraceFormat2;
    (function(TraceFormat3) {
      TraceFormat3["Text"] = "text";
      TraceFormat3["JSON"] = "json";
    })(TraceFormat2 = exports.TraceFormat || (exports.TraceFormat = {}));
    (function(TraceFormat3) {
      function fromString(value) {
        if (!Is2.string(value)) {
          return TraceFormat3.Text;
        }
        value = value.toLowerCase();
        if (value === "json") {
          return TraceFormat3.JSON;
        } else {
          return TraceFormat3.Text;
        }
      }
      TraceFormat3.fromString = fromString;
    })(TraceFormat2 = exports.TraceFormat || (exports.TraceFormat = {}));
    var SetTraceNotification;
    (function(SetTraceNotification2) {
      SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
    })(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));
    var LogTraceNotification;
    (function(LogTraceNotification2) {
      LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
    })(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));
    var ConnectionErrors;
    (function(ConnectionErrors2) {
      ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
      ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
      ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
    })(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));
    var ConnectionError = class extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ConnectionError.prototype);
      }
    };
    exports.ConnectionError = ConnectionError;
    var ConnectionStrategy;
    (function(ConnectionStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is2.func(candidate.cancelUndispatched);
      }
      ConnectionStrategy2.is = is;
    })(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));
    var CancellationReceiverStrategy;
    (function(CancellationReceiverStrategy2) {
      CancellationReceiverStrategy2.Message = Object.freeze({
        createCancellationTokenSource(_) {
          return new cancellation_1.CancellationTokenSource();
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is2.func(candidate.createCancellationTokenSource);
      }
      CancellationReceiverStrategy2.is = is;
    })(CancellationReceiverStrategy = exports.CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = {}));
    var CancellationSenderStrategy;
    (function(CancellationSenderStrategy2) {
      CancellationSenderStrategy2.Message = Object.freeze({
        sendCancellation(conn, id) {
          return conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) {
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is2.func(candidate.sendCancellation) && Is2.func(candidate.cleanup);
      }
      CancellationSenderStrategy2.is = is;
    })(CancellationSenderStrategy = exports.CancellationSenderStrategy || (exports.CancellationSenderStrategy = {}));
    var CancellationStrategy2;
    (function(CancellationStrategy3) {
      CancellationStrategy3.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
      });
      function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
      }
      CancellationStrategy3.is = is;
    })(CancellationStrategy2 = exports.CancellationStrategy || (exports.CancellationStrategy = {}));
    var ConnectionOptions;
    (function(ConnectionOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy2.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy));
      }
      ConnectionOptions2.is = is;
    })(ConnectionOptions = exports.ConnectionOptions || (exports.ConnectionOptions = {}));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["New"] = 1] = "New";
      ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
      ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
      ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function createMessageConnection(messageReader, messageWriter, _logger, options2) {
      const logger138 = _logger !== void 0 ? _logger : exports.NullLogger;
      let sequenceNumber = 0;
      let notificationSequenceNumber = 0;
      let unknownResponseSequenceNumber = 0;
      const version2 = "2.0";
      let starRequestHandler = void 0;
      const requestHandlers = /* @__PURE__ */ new Map();
      let starNotificationHandler = void 0;
      const notificationHandlers = /* @__PURE__ */ new Map();
      const progressHandlers = /* @__PURE__ */ new Map();
      let timer;
      let messageQueue = new linkedMap_1.LinkedMap();
      let responsePromises = /* @__PURE__ */ new Map();
      let knownCanceledRequests = /* @__PURE__ */ new Set();
      let requestTokens = /* @__PURE__ */ new Map();
      let trace = Trace3.Off;
      let traceFormat = TraceFormat2.Text;
      let tracer;
      let state = ConnectionState.New;
      const errorEmitter = new events_1.Emitter();
      const closeEmitter = new events_1.Emitter();
      const unhandledNotificationEmitter = new events_1.Emitter();
      const unhandledProgressEmitter = new events_1.Emitter();
      const disposeEmitter = new events_1.Emitter();
      const cancellationStrategy = options2 && options2.cancellationStrategy ? options2.cancellationStrategy : CancellationStrategy2.Message;
      function createRequestQueueKey(id) {
        if (id === null) {
          throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return "req-" + id.toString();
      }
      function createResponseQueueKey(id) {
        if (id === null) {
          return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
        } else {
          return "res-" + id.toString();
        }
      }
      function createNotificationQueueKey() {
        return "not-" + (++notificationSequenceNumber).toString();
      }
      function addMessageToQueue(queue, message) {
        if (messages_1.Message.isRequest(message)) {
          queue.set(createRequestQueueKey(message.id), message);
        } else if (messages_1.Message.isResponse(message)) {
          queue.set(createResponseQueueKey(message.id), message);
        } else {
          queue.set(createNotificationQueueKey(), message);
        }
      }
      function cancelUndispatched(_message) {
        return void 0;
      }
      function isListening() {
        return state === ConnectionState.Listening;
      }
      function isClosed() {
        return state === ConnectionState.Closed;
      }
      function isDisposed() {
        return state === ConnectionState.Disposed;
      }
      function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
          state = ConnectionState.Closed;
          closeEmitter.fire(void 0);
        }
      }
      function readErrorHandler(error) {
        errorEmitter.fire([error, void 0, void 0]);
      }
      function writeErrorHandler(data) {
        errorEmitter.fire(data);
      }
      messageReader.onClose(closeHandler);
      messageReader.onError(readErrorHandler);
      messageWriter.onClose(closeHandler);
      messageWriter.onError(writeErrorHandler);
      function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
          return;
        }
        timer = (0, ral_1.default)().timer.setImmediate(() => {
          timer = void 0;
          processMessageQueue();
        });
      }
      function processMessageQueue() {
        if (messageQueue.size === 0) {
          return;
        }
        const message = messageQueue.shift();
        try {
          if (messages_1.Message.isRequest(message)) {
            handleRequest(message);
          } else if (messages_1.Message.isNotification(message)) {
            handleNotification(message);
          } else if (messages_1.Message.isResponse(message)) {
            handleResponse(message);
          } else {
            handleInvalidMessage(message);
          }
        } finally {
          triggerMessageQueue();
        }
      }
      const callback = (message) => {
        try {
          if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            const key = createRequestQueueKey(cancelId);
            const toCancel = messageQueue.get(key);
            if (messages_1.Message.isRequest(toCancel)) {
              const strategy = options2 == null ? void 0 : options2.connectionStrategy;
              const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
              if (response && (response.error !== void 0 || response.result !== void 0)) {
                messageQueue.delete(key);
                requestTokens.delete(cancelId);
                response.id = toCancel.id;
                traceSendingResponse(response, message.method, Date.now());
                messageWriter.write(response).catch(() => logger138.error(`Sending response for canceled message failed.`));
                return;
              }
            }
            const cancellationToken = requestTokens.get(cancelId);
            if (cancellationToken !== void 0) {
              cancellationToken.cancel();
              traceReceivedNotification(message);
              return;
            } else {
              knownCanceledRequests.add(cancelId);
            }
          }
          addMessageToQueue(messageQueue, message);
        } finally {
          triggerMessageQueue();
        }
      };
      function handleRequest(requestMessage) {
        if (isDisposed()) {
          return;
        }
        function reply(resultOrError, method, startTime2) {
          const message = {
            jsonrpc: version2,
            id: requestMessage.id
          };
          if (resultOrError instanceof messages_1.ResponseError) {
            message.error = resultOrError.toJson();
          } else {
            message.result = resultOrError === void 0 ? null : resultOrError;
          }
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger138.error(`Sending response failed.`));
        }
        function replyError(error, method, startTime2) {
          const message = {
            jsonrpc: version2,
            id: requestMessage.id,
            error: error.toJson()
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger138.error(`Sending response failed.`));
        }
        function replySuccess(result, method, startTime2) {
          if (result === void 0) {
            result = null;
          }
          const message = {
            jsonrpc: version2,
            id: requestMessage.id,
            result
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger138.error(`Sending response failed.`));
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers.get(requestMessage.method);
        let type;
        let requestHandler;
        if (element) {
          type = element.type;
          requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
          const tokenKey = requestMessage.id ?? String(Date.now());
          const cancellationSource = cancellationStrategy.receiver.createCancellationTokenSource(tokenKey);
          if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
            cancellationSource.cancel();
          }
          if (requestMessage.id !== null) {
            requestTokens.set(tokenKey, cancellationSource);
          }
          try {
            let handlerResult;
            if (requestHandler) {
              if (requestMessage.params === void 0) {
                if (type !== void 0 && type.numberOfParams !== 0) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(cancellationSource.token);
              } else if (Array.isArray(requestMessage.params)) {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
              }
            } else if (starRequestHandler) {
              handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
            }
            const promise = handlerResult;
            if (!handlerResult) {
              requestTokens.delete(tokenKey);
              replySuccess(handlerResult, requestMessage.method, startTime);
            } else if (promise.then) {
              promise.then((resultOrError) => {
                requestTokens.delete(tokenKey);
                reply(resultOrError, requestMessage.method, startTime);
              }, (error) => {
                requestTokens.delete(tokenKey);
                if (error instanceof messages_1.ResponseError) {
                  replyError(error, requestMessage.method, startTime);
                } else if (error && Is2.string(error.message)) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                } else {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
              });
            } else {
              requestTokens.delete(tokenKey);
              reply(handlerResult, requestMessage.method, startTime);
            }
          } catch (error) {
            requestTokens.delete(tokenKey);
            if (error instanceof messages_1.ResponseError) {
              reply(error, requestMessage.method, startTime);
            } else if (error && Is2.string(error.message)) {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
            } else {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
            }
          }
        } else {
          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
      }
      function handleResponse(responseMessage) {
        if (isDisposed()) {
          return;
        }
        if (responseMessage.id === null) {
          if (responseMessage.error) {
            logger138.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
          } else {
            logger138.error(`Received response message without id. No further error information provided.`);
          }
        } else {
          const key = responseMessage.id;
          const responsePromise = responsePromises.get(key);
          traceReceivedResponse(responseMessage, responsePromise);
          if (responsePromise !== void 0) {
            responsePromises.delete(key);
            try {
              if (responseMessage.error) {
                const error = responseMessage.error;
                responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
              } else if (responseMessage.result !== void 0) {
                responsePromise.resolve(responseMessage.result);
              } else {
                throw new Error("Should never happen.");
              }
            } catch (error) {
              if (error.message) {
                logger138.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
              } else {
                logger138.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
              }
            }
          }
        }
      }
      function handleNotification(message) {
        if (isDisposed()) {
          return;
        }
        let type = void 0;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
          const cancelId = message.params.id;
          knownCanceledRequests.delete(cancelId);
          traceReceivedNotification(message);
          return;
        } else {
          const element = notificationHandlers.get(message.method);
          if (element) {
            notificationHandler = element.handler;
            type = element.type;
          }
        }
        if (notificationHandler || starNotificationHandler) {
          try {
            traceReceivedNotification(message);
            if (notificationHandler) {
              if (message.params === void 0) {
                if (type !== void 0) {
                  if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                    logger138.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                  }
                }
                notificationHandler();
              } else if (Array.isArray(message.params)) {
                const params = message.params;
                if (message.method === ProgressNotification2.type.method && params.length === 2 && ProgressToken3.is(params[0])) {
                  notificationHandler({ token: params[0], value: params[1] });
                } else {
                  if (type !== void 0) {
                    if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                      logger138.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                    }
                    if (type.numberOfParams !== message.params.length) {
                      logger138.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                    }
                  }
                  notificationHandler(...params);
                }
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  logger138.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                }
                notificationHandler(message.params);
              }
            } else if (starNotificationHandler) {
              starNotificationHandler(message.method, message.params);
            }
          } catch (error) {
            if (error.message) {
              logger138.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
            } else {
              logger138.error(`Notification handler '${message.method}' failed unexpectedly.`);
            }
          }
        } else {
          unhandledNotificationEmitter.fire(message);
        }
      }
      function handleInvalidMessage(message) {
        if (!message) {
          logger138.error("Received empty message.");
          return;
        }
        logger138.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
        const responseMessage = message;
        if (Is2.string(responseMessage.id) || Is2.number(responseMessage.id)) {
          const key = responseMessage.id;
          const responseHandler = responsePromises.get(key);
          if (responseHandler) {
            responseHandler.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
      }
      function stringifyTrace(params) {
        if (params === void 0 || params === null) {
          return void 0;
        }
        switch (trace) {
          case Trace3.Verbose:
            return JSON.stringify(params, null, 4);
          case Trace3.Compact:
            return JSON.stringify(params);
          default:
            return void 0;
        }
      }
      function traceSendingRequest(message) {
        if (trace === Trace3.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat2.Text) {
          let data = void 0;
          if ((trace === Trace3.Verbose || trace === Trace3.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("send-request", message);
        }
      }
      function traceSendingNotification(message) {
        if (trace === Trace3.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat2.Text) {
          let data = void 0;
          if (trace === Trace3.Verbose || trace === Trace3.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Sending notification '${message.method}'.`, data);
        } else {
          logLSPMessage("send-notification", message);
        }
      }
      function traceSendingResponse(message, method, startTime) {
        if (trace === Trace3.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat2.Text) {
          let data = void 0;
          if (trace === Trace3.Verbose || trace === Trace3.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        } else {
          logLSPMessage("send-response", message);
        }
      }
      function traceReceivedRequest(message) {
        if (trace === Trace3.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat2.Text) {
          let data = void 0;
          if ((trace === Trace3.Verbose || trace === Trace3.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("receive-request", message);
        }
      }
      function traceReceivedNotification(message) {
        if (trace === Trace3.Off || !tracer || message.method === LogTraceNotification.type.method) {
          return;
        }
        if (traceFormat === TraceFormat2.Text) {
          let data = void 0;
          if (trace === Trace3.Verbose || trace === Trace3.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Received notification '${message.method}'.`, data);
        } else {
          logLSPMessage("receive-notification", message);
        }
      }
      function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace3.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat2.Text) {
          let data = void 0;
          if (trace === Trace3.Verbose || trace === Trace3.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          if (responsePromise) {
            const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
            tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
          } else {
            tracer.log(`Received response ${message.id} without active response promise.`, data);
          }
        } else {
          logLSPMessage("receive-response", message);
        }
      }
      function logLSPMessage(type, message) {
        if (!tracer || trace === Trace3.Off) {
          return;
        }
        const lspMessage = {
          isLSPMessage: true,
          type,
          message,
          timestamp: Date.now()
        };
        tracer.log(lspMessage);
      }
      function throwIfClosedOrDisposed() {
        if (isClosed()) {
          throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
        }
        if (isDisposed()) {
          throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
        }
      }
      function throwIfListening() {
        if (isListening()) {
          throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
        }
      }
      function throwIfNotListening() {
        if (!isListening()) {
          throw new Error("Call listen() first.");
        }
      }
      function undefinedToNull(param) {
        if (param === void 0) {
          return null;
        } else {
          return param;
        }
      }
      function nullToUndefined(param) {
        if (param === null) {
          return void 0;
        } else {
          return param;
        }
      }
      function isNamedParam(param) {
        return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
      }
      function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
          case messages_1.ParameterStructures.auto:
            if (isNamedParam(param)) {
              return nullToUndefined(param);
            } else {
              return [undefinedToNull(param)];
            }
          case messages_1.ParameterStructures.byName:
            if (!isNamedParam(param)) {
              throw new Error(`Received parameters by name but param is not an object literal.`);
            }
            return nullToUndefined(param);
          case messages_1.ParameterStructures.byPosition:
            return [undefinedToNull(param)];
          default:
            throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
      }
      function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
          case 0:
            result = void 0;
            break;
          case 1:
            result = computeSingleParam(type.parameterStructures, params[0]);
            break;
          default:
            result = [];
            for (let i = 0; i < params.length && i < numberOfParams; i++) {
              result.push(undefinedToNull(params[i]));
            }
            if (params.length < numberOfParams) {
              for (let i = params.length; i < numberOfParams; i++) {
                result.push(null);
              }
            }
            break;
        }
        return result;
      }
      const connection = {
        sendNotification: (type, ...args) => {
          throwIfClosedOrDisposed();
          let method;
          let messageParams;
          if (Is2.string(type)) {
            method = type;
            const first = args[0];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
          }
          const notificationMessage = {
            jsonrpc: version2,
            method,
            params: messageParams
          };
          traceSendingNotification(notificationMessage);
          return messageWriter.write(notificationMessage).catch(() => logger138.error(`Sending notification failed.`));
        },
        onNotification: (type, handler) => {
          throwIfClosedOrDisposed();
          let method;
          if (Is2.func(type)) {
            starNotificationHandler = type;
          } else if (handler) {
            if (Is2.string(type)) {
              method = type;
              notificationHandlers.set(type, { type: void 0, handler });
            } else {
              method = type.method;
              notificationHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method !== void 0) {
                notificationHandlers.delete(method);
              } else {
                starNotificationHandler = void 0;
              }
            }
          };
        },
        onProgress: (_type, token, handler) => {
          if (progressHandlers.has(token)) {
            throw new Error(`Progress handler for token ${token} already registered`);
          }
          progressHandlers.set(token, handler);
          return {
            dispose: () => {
              progressHandlers.delete(token);
            }
          };
        },
        sendProgress: (_type, token, value) => {
          return connection.sendNotification(ProgressNotification2.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
          throwIfClosedOrDisposed();
          throwIfNotListening();
          let method;
          let messageParams;
          let token = void 0;
          if (Is2.string(type)) {
            method = type;
            const first = args[0];
            const last = args[args.length - 1];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            if (cancellation_1.CancellationToken.is(last)) {
              paramEnd = paramEnd - 1;
              token = last;
            }
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
            const numberOfParams = type.numberOfParams;
            token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
          }
          const id = sequenceNumber++;
          let disposable;
          if (token) {
            disposable = token.onCancellationRequested(() => {
              const p = cancellationStrategy.sender.sendCancellation(connection, id);
              if (p === void 0) {
                logger138.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                return Promise.resolve();
              } else {
                return p.catch(() => {
                  logger138.log(`Sending cancellation messages for id ${id} failed`);
                });
              }
            });
          }
          const result = new Promise((resolve3, reject) => {
            const requestMessage = {
              jsonrpc: version2,
              id,
              method,
              params: messageParams
            };
            const resolveWithCleanup = (r) => {
              resolve3(r);
              cancellationStrategy.sender.cleanup(id);
              disposable == null ? void 0 : disposable.dispose();
            };
            const rejectWithCleanup = (r) => {
              reject(r);
              cancellationStrategy.sender.cleanup(id);
              disposable == null ? void 0 : disposable.dispose();
            };
            let responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
            traceSendingRequest(requestMessage);
            try {
              messageWriter.write(requestMessage).catch(() => logger138.error(`Sending request failed.`));
            } catch (e) {
              responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : "Unknown reason"));
              responsePromise = null;
            }
            if (responsePromise) {
              responsePromises.set(id, responsePromise);
            }
          });
          return result;
        },
        onRequest: (type, handler) => {
          throwIfClosedOrDisposed();
          let method = null;
          if (StarRequestHandler.is(type)) {
            method = void 0;
            starRequestHandler = type;
          } else if (Is2.string(type)) {
            method = null;
            if (handler !== void 0) {
              method = type;
              requestHandlers.set(type, { handler, type: void 0 });
            }
          } else {
            if (handler !== void 0) {
              method = type.method;
              requestHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method === null) {
                return;
              }
              if (method !== void 0) {
                requestHandlers.delete(method);
              } else {
                starRequestHandler = void 0;
              }
            }
          };
        },
        hasPendingResponse: () => {
          return responsePromises.size > 0;
        },
        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
          let _sendNotification = false;
          let _traceFormat = TraceFormat2.Text;
          if (sendNotificationOrTraceOptions !== void 0) {
            if (Is2.boolean(sendNotificationOrTraceOptions)) {
              _sendNotification = sendNotificationOrTraceOptions;
            } else {
              _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
              _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat2.Text;
            }
          }
          trace = _value;
          traceFormat = _traceFormat;
          if (trace === Trace3.Off) {
            tracer = void 0;
          } else {
            tracer = _tracer;
          }
          if (_sendNotification && !isClosed() && !isDisposed()) {
            await connection.sendNotification(SetTraceNotification.type, { value: Trace3.toString(_value) });
          }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
          messageWriter.end();
        },
        dispose: () => {
          if (isDisposed()) {
            return;
          }
          state = ConnectionState.Disposed;
          disposeEmitter.fire(void 0);
          const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
          for (const promise of responsePromises.values()) {
            promise.reject(error);
          }
          responsePromises = /* @__PURE__ */ new Map();
          requestTokens = /* @__PURE__ */ new Map();
          knownCanceledRequests = /* @__PURE__ */ new Set();
          messageQueue = new linkedMap_1.LinkedMap();
          if (Is2.func(messageWriter.dispose)) {
            messageWriter.dispose();
          }
          if (Is2.func(messageReader.dispose)) {
            messageReader.dispose();
          }
        },
        listen: () => {
          throwIfClosedOrDisposed();
          throwIfListening();
          state = ConnectionState.Listening;
          messageReader.listen(callback);
        },
        inspect: () => {
          (0, ral_1.default)().console.log("inspect");
        }
      };
      connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace3.Off || !tracer) {
          return;
        }
        const verbose = trace === Trace3.Verbose || trace === Trace3.Compact;
        tracer.log(params.message, verbose ? params.verbose : void 0);
      });
      connection.onNotification(ProgressNotification2.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
          handler(params.value);
        } else {
          unhandledProgressEmitter.fire(params);
        }
      });
      return connection;
    }
    exports.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-jsonrpc/lib/common/api.js
var require_api2 = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/api.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TraceFormat = exports.TraceValues = exports.Trace = exports.ProgressType = exports.ProgressToken = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.LRUCache = exports.Touch = exports.LinkedMap = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.Message = exports.RAL = void 0;
    exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = void 0;
    var messages_1 = require_messages();
    Object.defineProperty(exports, "Message", { enumerable: true, get: function() {
      return messages_1.Message;
    } });
    Object.defineProperty(exports, "RequestType", { enumerable: true, get: function() {
      return messages_1.RequestType;
    } });
    Object.defineProperty(exports, "RequestType0", { enumerable: true, get: function() {
      return messages_1.RequestType0;
    } });
    Object.defineProperty(exports, "RequestType1", { enumerable: true, get: function() {
      return messages_1.RequestType1;
    } });
    Object.defineProperty(exports, "RequestType2", { enumerable: true, get: function() {
      return messages_1.RequestType2;
    } });
    Object.defineProperty(exports, "RequestType3", { enumerable: true, get: function() {
      return messages_1.RequestType3;
    } });
    Object.defineProperty(exports, "RequestType4", { enumerable: true, get: function() {
      return messages_1.RequestType4;
    } });
    Object.defineProperty(exports, "RequestType5", { enumerable: true, get: function() {
      return messages_1.RequestType5;
    } });
    Object.defineProperty(exports, "RequestType6", { enumerable: true, get: function() {
      return messages_1.RequestType6;
    } });
    Object.defineProperty(exports, "RequestType7", { enumerable: true, get: function() {
      return messages_1.RequestType7;
    } });
    Object.defineProperty(exports, "RequestType8", { enumerable: true, get: function() {
      return messages_1.RequestType8;
    } });
    Object.defineProperty(exports, "RequestType9", { enumerable: true, get: function() {
      return messages_1.RequestType9;
    } });
    Object.defineProperty(exports, "ResponseError", { enumerable: true, get: function() {
      return messages_1.ResponseError;
    } });
    Object.defineProperty(exports, "ErrorCodes", { enumerable: true, get: function() {
      return messages_1.ErrorCodes;
    } });
    Object.defineProperty(exports, "NotificationType", { enumerable: true, get: function() {
      return messages_1.NotificationType;
    } });
    Object.defineProperty(exports, "NotificationType0", { enumerable: true, get: function() {
      return messages_1.NotificationType0;
    } });
    Object.defineProperty(exports, "NotificationType1", { enumerable: true, get: function() {
      return messages_1.NotificationType1;
    } });
    Object.defineProperty(exports, "NotificationType2", { enumerable: true, get: function() {
      return messages_1.NotificationType2;
    } });
    Object.defineProperty(exports, "NotificationType3", { enumerable: true, get: function() {
      return messages_1.NotificationType3;
    } });
    Object.defineProperty(exports, "NotificationType4", { enumerable: true, get: function() {
      return messages_1.NotificationType4;
    } });
    Object.defineProperty(exports, "NotificationType5", { enumerable: true, get: function() {
      return messages_1.NotificationType5;
    } });
    Object.defineProperty(exports, "NotificationType6", { enumerable: true, get: function() {
      return messages_1.NotificationType6;
    } });
    Object.defineProperty(exports, "NotificationType7", { enumerable: true, get: function() {
      return messages_1.NotificationType7;
    } });
    Object.defineProperty(exports, "NotificationType8", { enumerable: true, get: function() {
      return messages_1.NotificationType8;
    } });
    Object.defineProperty(exports, "NotificationType9", { enumerable: true, get: function() {
      return messages_1.NotificationType9;
    } });
    Object.defineProperty(exports, "ParameterStructures", { enumerable: true, get: function() {
      return messages_1.ParameterStructures;
    } });
    var linkedMap_1 = require_linkedMap();
    Object.defineProperty(exports, "LinkedMap", { enumerable: true, get: function() {
      return linkedMap_1.LinkedMap;
    } });
    Object.defineProperty(exports, "LRUCache", { enumerable: true, get: function() {
      return linkedMap_1.LRUCache;
    } });
    Object.defineProperty(exports, "Touch", { enumerable: true, get: function() {
      return linkedMap_1.Touch;
    } });
    var disposable_1 = require_disposable();
    Object.defineProperty(exports, "Disposable", { enumerable: true, get: function() {
      return disposable_1.Disposable;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports, "Event", { enumerable: true, get: function() {
      return events_1.Event;
    } });
    Object.defineProperty(exports, "Emitter", { enumerable: true, get: function() {
      return events_1.Emitter;
    } });
    var cancellation_1 = require_cancellation();
    Object.defineProperty(exports, "CancellationTokenSource", { enumerable: true, get: function() {
      return cancellation_1.CancellationTokenSource;
    } });
    Object.defineProperty(exports, "CancellationToken", { enumerable: true, get: function() {
      return cancellation_1.CancellationToken;
    } });
    var messageReader_1 = require_messageReader();
    Object.defineProperty(exports, "MessageReader", { enumerable: true, get: function() {
      return messageReader_1.MessageReader;
    } });
    Object.defineProperty(exports, "AbstractMessageReader", { enumerable: true, get: function() {
      return messageReader_1.AbstractMessageReader;
    } });
    Object.defineProperty(exports, "ReadableStreamMessageReader", { enumerable: true, get: function() {
      return messageReader_1.ReadableStreamMessageReader;
    } });
    var messageWriter_1 = require_messageWriter();
    Object.defineProperty(exports, "MessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.MessageWriter;
    } });
    Object.defineProperty(exports, "AbstractMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.AbstractMessageWriter;
    } });
    Object.defineProperty(exports, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.WriteableStreamMessageWriter;
    } });
    var connection_1 = require_connection2();
    Object.defineProperty(exports, "ConnectionStrategy", { enumerable: true, get: function() {
      return connection_1.ConnectionStrategy;
    } });
    Object.defineProperty(exports, "ConnectionOptions", { enumerable: true, get: function() {
      return connection_1.ConnectionOptions;
    } });
    Object.defineProperty(exports, "NullLogger", { enumerable: true, get: function() {
      return connection_1.NullLogger;
    } });
    Object.defineProperty(exports, "createMessageConnection", { enumerable: true, get: function() {
      return connection_1.createMessageConnection;
    } });
    Object.defineProperty(exports, "ProgressToken", { enumerable: true, get: function() {
      return connection_1.ProgressToken;
    } });
    Object.defineProperty(exports, "ProgressType", { enumerable: true, get: function() {
      return connection_1.ProgressType;
    } });
    Object.defineProperty(exports, "Trace", { enumerable: true, get: function() {
      return connection_1.Trace;
    } });
    Object.defineProperty(exports, "TraceValues", { enumerable: true, get: function() {
      return connection_1.TraceValues;
    } });
    Object.defineProperty(exports, "TraceFormat", { enumerable: true, get: function() {
      return connection_1.TraceFormat;
    } });
    Object.defineProperty(exports, "SetTraceNotification", { enumerable: true, get: function() {
      return connection_1.SetTraceNotification;
    } });
    Object.defineProperty(exports, "LogTraceNotification", { enumerable: true, get: function() {
      return connection_1.LogTraceNotification;
    } });
    Object.defineProperty(exports, "ConnectionErrors", { enumerable: true, get: function() {
      return connection_1.ConnectionErrors;
    } });
    Object.defineProperty(exports, "ConnectionError", { enumerable: true, get: function() {
      return connection_1.ConnectionError;
    } });
    Object.defineProperty(exports, "CancellationReceiverStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationReceiverStrategy;
    } });
    Object.defineProperty(exports, "CancellationSenderStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationSenderStrategy;
    } });
    Object.defineProperty(exports, "CancellationStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationStrategy;
    } });
    var ral_1 = require_ral();
    exports.RAL = ral_1.default;
  }
});

// node_modules/vscode-jsonrpc/lib/node/main.js
var require_main = __commonJS({
  "node_modules/vscode-jsonrpc/lib/node/main.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createMessageConnection = exports.createServerSocketTransport = exports.createClientSocketTransport = exports.createServerPipeTransport = exports.createClientPipeTransport = exports.generateRandomPipeName = exports.StreamMessageWriter = exports.StreamMessageReader = exports.SocketMessageWriter = exports.SocketMessageReader = exports.IPCMessageWriter = exports.IPCMessageReader = void 0;
    var ril_1 = require_ril();
    ril_1.default.install();
    var api_1 = require_api2();
    var path41 = require("path");
    var os13 = require("os");
    var crypto_1 = require("crypto");
    var net_1 = require("net");
    __exportStar(require_api2(), exports);
    var IPCMessageReader2 = class extends api_1.AbstractMessageReader {
      constructor(process2) {
        super();
        this.process = process2;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose());
      }
      listen(callback) {
        this.process.on("message", callback);
        return api_1.Disposable.create(() => this.process.off("message", callback));
      }
    };
    exports.IPCMessageReader = IPCMessageReader2;
    var IPCMessageWriter2 = class extends api_1.AbstractMessageWriter {
      constructor(process2) {
        super();
        this.process = process2;
        this.errorCount = 0;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose);
      }
      write(msg) {
        try {
          if (typeof this.process.send === "function") {
            this.process.send(msg, void 0, void 0, (error) => {
              if (error) {
                this.errorCount++;
                this.handleError(error, msg);
              } else {
                this.errorCount = 0;
              }
            });
          }
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports.IPCMessageWriter = IPCMessageWriter2;
    var SocketMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(socket, encoding = "utf-8") {
        super((0, ril_1.default)().stream.asReadableStream(socket), encoding);
      }
    };
    exports.SocketMessageReader = SocketMessageReader;
    var SocketMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(socket, options2) {
        super((0, ril_1.default)().stream.asWritableStream(socket), options2);
        this.socket = socket;
      }
      dispose() {
        super.dispose();
        this.socket.destroy();
      }
    };
    exports.SocketMessageWriter = SocketMessageWriter;
    var StreamMessageReader2 = class extends api_1.ReadableStreamMessageReader {
      constructor(readble, encoding) {
        super((0, ril_1.default)().stream.asReadableStream(readble), encoding);
      }
    };
    exports.StreamMessageReader = StreamMessageReader2;
    var StreamMessageWriter2 = class extends api_1.WriteableStreamMessageWriter {
      constructor(writable, options2) {
        super((0, ril_1.default)().stream.asWritableStream(writable), options2);
      }
    };
    exports.StreamMessageWriter = StreamMessageWriter2;
    var XDG_RUNTIME_DIR = process.env["XDG_RUNTIME_DIR"];
    var safeIpcPathLengths = /* @__PURE__ */ new Map([
      ["linux", 107],
      ["darwin", 103]
    ]);
    function generateRandomPipeName2() {
      const randomSuffix = (0, crypto_1.randomBytes)(21).toString("hex");
      if (process.platform === "win32") {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
      }
      let result;
      if (XDG_RUNTIME_DIR) {
        result = path41.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
      } else {
        result = path41.join(os13.tmpdir(), `vscode-${randomSuffix}.sock`);
      }
      const limit = safeIpcPathLengths.get(process.platform);
      if (limit !== void 0 && result.length >= limit) {
        (0, ril_1.default)().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
      }
      return result;
    }
    exports.generateRandomPipeName = generateRandomPipeName2;
    function createClientPipeTransport2(pipeName, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve3, _reject) => {
        connectResolve = resolve3;
      });
      return new Promise((resolve3, reject) => {
        let server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(pipeName, () => {
          server.removeListener("error", reject);
          resolve3({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports.createClientPipeTransport = createClientPipeTransport2;
    function createServerPipeTransport(pipeName, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(pipeName);
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports.createServerPipeTransport = createServerPipeTransport;
    function createClientSocketTransport2(port, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve3, _reject) => {
        connectResolve = resolve3;
      });
      return new Promise((resolve3, reject) => {
        const server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(port, "127.0.0.1", () => {
          server.removeListener("error", reject);
          resolve3({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports.createClientSocketTransport = createClientSocketTransport2;
    function createServerSocketTransport(port, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(port, "127.0.0.1");
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports.createServerSocketTransport = createServerSocketTransport;
    function isReadableStream(value) {
      const candidate = value;
      return candidate.read !== void 0 && candidate.addListener !== void 0;
    }
    function isWritableStream(value) {
      const candidate = value;
      return candidate.write !== void 0 && candidate.addListener !== void 0;
    }
    function createMessageConnection(input, output, logger138, options2) {
      if (!logger138) {
        logger138 = api_1.NullLogger;
      }
      const reader = isReadableStream(input) ? new StreamMessageReader2(input) : input;
      const writer = isWritableStream(output) ? new StreamMessageWriter2(output) : output;
      if (api_1.ConnectionStrategy.is(options2)) {
        options2 = { connectionStrategy: options2 };
      }
      return (0, api_1.createMessageConnection)(reader, writer, logger138, options2);
    }
    exports.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-jsonrpc/node.js
var require_node2 = __commonJS({
  "node_modules/vscode-jsonrpc/node.js"(exports, module2) {
    "use strict";
    module2.exports = require_main();
  }
});

// node_modules/vscode-languageserver-types/lib/esm/main.js
var main_exports = {};
__export(main_exports, {
  AnnotatedTextEdit: () => AnnotatedTextEdit,
  ChangeAnnotation: () => ChangeAnnotation,
  ChangeAnnotationIdentifier: () => ChangeAnnotationIdentifier,
  CodeAction: () => CodeAction,
  CodeActionContext: () => CodeActionContext,
  CodeActionKind: () => CodeActionKind,
  CodeActionTriggerKind: () => CodeActionTriggerKind,
  CodeDescription: () => CodeDescription,
  CodeLens: () => CodeLens,
  Color: () => Color,
  ColorInformation: () => ColorInformation,
  ColorPresentation: () => ColorPresentation,
  Command: () => Command,
  CompletionItem: () => CompletionItem,
  CompletionItemKind: () => CompletionItemKind,
  CompletionItemLabelDetails: () => CompletionItemLabelDetails,
  CompletionItemTag: () => CompletionItemTag,
  CompletionList: () => CompletionList,
  CreateFile: () => CreateFile,
  DeleteFile: () => DeleteFile,
  Diagnostic: () => Diagnostic,
  DiagnosticRelatedInformation: () => DiagnosticRelatedInformation,
  DiagnosticSeverity: () => DiagnosticSeverity,
  DiagnosticTag: () => DiagnosticTag,
  DocumentHighlight: () => DocumentHighlight,
  DocumentHighlightKind: () => DocumentHighlightKind,
  DocumentLink: () => DocumentLink,
  DocumentSymbol: () => DocumentSymbol,
  DocumentUri: () => DocumentUri,
  EOL: () => EOL,
  FoldingRange: () => FoldingRange,
  FoldingRangeKind: () => FoldingRangeKind,
  FormattingOptions: () => FormattingOptions,
  Hover: () => Hover,
  InlayHint: () => InlayHint,
  InlayHintKind: () => InlayHintKind,
  InlayHintLabelPart: () => InlayHintLabelPart,
  InlineValueContext: () => InlineValueContext,
  InlineValueEvaluatableExpression: () => InlineValueEvaluatableExpression,
  InlineValueText: () => InlineValueText,
  InlineValueVariableLookup: () => InlineValueVariableLookup,
  InsertReplaceEdit: () => InsertReplaceEdit,
  InsertTextFormat: () => InsertTextFormat,
  InsertTextMode: () => InsertTextMode,
  Location: () => Location,
  LocationLink: () => LocationLink,
  MarkedString: () => MarkedString,
  MarkupContent: () => MarkupContent,
  MarkupKind: () => MarkupKind,
  OptionalVersionedTextDocumentIdentifier: () => OptionalVersionedTextDocumentIdentifier,
  ParameterInformation: () => ParameterInformation,
  Position: () => Position,
  Range: () => Range,
  RenameFile: () => RenameFile,
  SelectionRange: () => SelectionRange,
  SemanticTokenModifiers: () => SemanticTokenModifiers,
  SemanticTokenTypes: () => SemanticTokenTypes,
  SemanticTokens: () => SemanticTokens,
  SignatureInformation: () => SignatureInformation,
  SymbolInformation: () => SymbolInformation,
  SymbolKind: () => SymbolKind,
  SymbolTag: () => SymbolTag,
  TextDocument: () => TextDocument,
  TextDocumentEdit: () => TextDocumentEdit,
  TextDocumentIdentifier: () => TextDocumentIdentifier,
  TextDocumentItem: () => TextDocumentItem,
  TextEdit: () => TextEdit,
  URI: () => URI,
  VersionedTextDocumentIdentifier: () => VersionedTextDocumentIdentifier,
  WorkspaceChange: () => WorkspaceChange,
  WorkspaceEdit: () => WorkspaceEdit,
  WorkspaceFolder: () => WorkspaceFolder,
  WorkspaceSymbol: () => WorkspaceSymbol,
  integer: () => integer,
  uinteger: () => uinteger
});
var DocumentUri, URI, integer, uinteger, Position, Range, Location, LocationLink, Color, ColorInformation, ColorPresentation, FoldingRangeKind, FoldingRange, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag, CodeDescription, Diagnostic, Command, TextEdit, ChangeAnnotation, ChangeAnnotationIdentifier, AnnotatedTextEdit, TextDocumentEdit, CreateFile, RenameFile, DeleteFile, WorkspaceEdit, TextEditChangeImpl, ChangeAnnotations, WorkspaceChange, TextDocumentIdentifier, VersionedTextDocumentIdentifier, OptionalVersionedTextDocumentIdentifier, TextDocumentItem, MarkupKind, MarkupContent, CompletionItemKind, InsertTextFormat, CompletionItemTag, InsertReplaceEdit, InsertTextMode, CompletionItemLabelDetails, CompletionItem, CompletionList, MarkedString, Hover, ParameterInformation, SignatureInformation, DocumentHighlightKind, DocumentHighlight, SymbolKind, SymbolTag, SymbolInformation, WorkspaceSymbol, DocumentSymbol, CodeActionKind, CodeActionTriggerKind, CodeActionContext, CodeAction, CodeLens, FormattingOptions, DocumentLink, SelectionRange, SemanticTokenTypes, SemanticTokenModifiers, SemanticTokens, InlineValueText, InlineValueVariableLookup, InlineValueEvaluatableExpression, InlineValueContext, InlayHintKind, InlayHintLabelPart, InlayHint, WorkspaceFolder, EOL, TextDocument, FullTextDocument, Is;
var init_main = __esm({
  "node_modules/vscode-languageserver-types/lib/esm/main.js"() {
    "use strict";
    (function(DocumentUri2) {
      function is(value) {
        return typeof value === "string";
      }
      DocumentUri2.is = is;
    })(DocumentUri || (DocumentUri = {}));
    (function(URI3) {
      function is(value) {
        return typeof value === "string";
      }
      URI3.is = is;
    })(URI || (URI = {}));
    (function(integer2) {
      integer2.MIN_VALUE = -2147483648;
      integer2.MAX_VALUE = 2147483647;
      function is(value) {
        return typeof value === "number" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;
      }
      integer2.is = is;
    })(integer || (integer = {}));
    (function(uinteger3) {
      uinteger3.MIN_VALUE = 0;
      uinteger3.MAX_VALUE = 2147483647;
      function is(value) {
        return typeof value === "number" && uinteger3.MIN_VALUE <= value && value <= uinteger3.MAX_VALUE;
      }
      uinteger3.is = is;
    })(uinteger || (uinteger = {}));
    (function(Position49) {
      function create(line, character) {
        if (line === Number.MAX_VALUE) {
          line = uinteger.MAX_VALUE;
        }
        if (character === Number.MAX_VALUE) {
          character = uinteger.MAX_VALUE;
        }
        return { line, character };
      }
      Position49.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
      }
      Position49.is = is;
    })(Position || (Position = {}));
    (function(Range53) {
      function create(one, two, three, four) {
        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
          return { start: Position.create(one, two), end: Position.create(three, four) };
        } else if (Position.is(one) && Position.is(two)) {
          return { start: one, end: two };
        } else {
          throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
        }
      }
      Range53.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
      }
      Range53.is = is;
    })(Range || (Range = {}));
    (function(Location14) {
      function create(uri, range2) {
        return { uri, range: range2 };
      }
      Location14.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
      }
      Location14.is = is;
    })(Location || (Location = {}));
    (function(LocationLink6) {
      function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
      }
      LocationLink6.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
      }
      LocationLink6.is = is;
    })(LocationLink || (LocationLink = {}));
    (function(Color4) {
      function create(red, green, blue2, alpha) {
        return {
          red,
          green,
          blue: blue2,
          alpha
        };
      }
      Color4.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
      }
      Color4.is = is;
    })(Color || (Color = {}));
    (function(ColorInformation6) {
      function create(range2, color) {
        return {
          range: range2,
          color
        };
      }
      ColorInformation6.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
      }
      ColorInformation6.is = is;
    })(ColorInformation || (ColorInformation = {}));
    (function(ColorPresentation4) {
      function create(label, textEdit, additionalTextEdits) {
        return {
          label,
          textEdit,
          additionalTextEdits
        };
      }
      ColorPresentation4.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
      }
      ColorPresentation4.is = is;
    })(ColorPresentation || (ColorPresentation = {}));
    (function(FoldingRangeKind3) {
      FoldingRangeKind3.Comment = "comment";
      FoldingRangeKind3.Imports = "imports";
      FoldingRangeKind3.Region = "region";
    })(FoldingRangeKind || (FoldingRangeKind = {}));
    (function(FoldingRange4) {
      function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
        var result = {
          startLine,
          endLine
        };
        if (Is.defined(startCharacter)) {
          result.startCharacter = startCharacter;
        }
        if (Is.defined(endCharacter)) {
          result.endCharacter = endCharacter;
        }
        if (Is.defined(kind)) {
          result.kind = kind;
        }
        if (Is.defined(collapsedText)) {
          result.collapsedText = collapsedText;
        }
        return result;
      }
      FoldingRange4.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
      }
      FoldingRange4.is = is;
    })(FoldingRange || (FoldingRange = {}));
    (function(DiagnosticRelatedInformation2) {
      function create(location, message) {
        return {
          location,
          message
        };
      }
      DiagnosticRelatedInformation2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
      }
      DiagnosticRelatedInformation2.is = is;
    })(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
    (function(DiagnosticSeverity7) {
      DiagnosticSeverity7.Error = 1;
      DiagnosticSeverity7.Warning = 2;
      DiagnosticSeverity7.Information = 3;
      DiagnosticSeverity7.Hint = 4;
    })(DiagnosticSeverity || (DiagnosticSeverity = {}));
    (function(DiagnosticTag6) {
      DiagnosticTag6.Unnecessary = 1;
      DiagnosticTag6.Deprecated = 2;
    })(DiagnosticTag || (DiagnosticTag = {}));
    (function(CodeDescription2) {
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.href);
      }
      CodeDescription2.is = is;
    })(CodeDescription || (CodeDescription = {}));
    (function(Diagnostic8) {
      function create(range2, message, severity, code, source, relatedInformation) {
        var result = { range: range2, message };
        if (Is.defined(severity)) {
          result.severity = severity;
        }
        if (Is.defined(code)) {
          result.code = code;
        }
        if (Is.defined(source)) {
          result.source = source;
        }
        if (Is.defined(relatedInformation)) {
          result.relatedInformation = relatedInformation;
        }
        return result;
      }
      Diagnostic8.create = create;
      function is(value) {
        var _a;
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
      }
      Diagnostic8.is = is;
    })(Diagnostic || (Diagnostic = {}));
    (function(Command5) {
      function create(title, command) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var result = { title, command };
        if (Is.defined(args) && args.length > 0) {
          result.arguments = args;
        }
        return result;
      }
      Command5.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
      }
      Command5.is = is;
    })(Command || (Command = {}));
    (function(TextEdit23) {
      function replace(range2, newText) {
        return { range: range2, newText };
      }
      TextEdit23.replace = replace;
      function insert(position, newText) {
        return { range: { start: position, end: position }, newText };
      }
      TextEdit23.insert = insert;
      function del(range2) {
        return { range: range2, newText: "" };
      }
      TextEdit23.del = del;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
      }
      TextEdit23.is = is;
    })(TextEdit || (TextEdit = {}));
    (function(ChangeAnnotation4) {
      function create(label, needsConfirmation, description) {
        var result = { label };
        if (needsConfirmation !== void 0) {
          result.needsConfirmation = needsConfirmation;
        }
        if (description !== void 0) {
          result.description = description;
        }
        return result;
      }
      ChangeAnnotation4.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
      }
      ChangeAnnotation4.is = is;
    })(ChangeAnnotation || (ChangeAnnotation = {}));
    (function(ChangeAnnotationIdentifier2) {
      function is(value) {
        var candidate = value;
        return Is.string(candidate);
      }
      ChangeAnnotationIdentifier2.is = is;
    })(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
    (function(AnnotatedTextEdit3) {
      function replace(range2, newText, annotation) {
        return { range: range2, newText, annotationId: annotation };
      }
      AnnotatedTextEdit3.replace = replace;
      function insert(position, newText, annotation) {
        return { range: { start: position, end: position }, newText, annotationId: annotation };
      }
      AnnotatedTextEdit3.insert = insert;
      function del(range2, annotation) {
        return { range: range2, newText: "", annotationId: annotation };
      }
      AnnotatedTextEdit3.del = del;
      function is(value) {
        var candidate = value;
        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      AnnotatedTextEdit3.is = is;
    })(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
    (function(TextDocumentEdit7) {
      function create(textDocument, edits) {
        return { textDocument, edits };
      }
      TextDocumentEdit7.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
      }
      TextDocumentEdit7.is = is;
    })(TextDocumentEdit || (TextDocumentEdit = {}));
    (function(CreateFile3) {
      function create(uri, options2, annotation) {
        var result = {
          kind: "create",
          uri
        };
        if (options2 !== void 0 && (options2.overwrite !== void 0 || options2.ignoreIfExists !== void 0)) {
          result.options = options2;
        }
        if (annotation !== void 0) {
          result.annotationId = annotation;
        }
        return result;
      }
      CreateFile3.create = create;
      function is(value) {
        var candidate = value;
        return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      CreateFile3.is = is;
    })(CreateFile || (CreateFile = {}));
    (function(RenameFile3) {
      function create(oldUri, newUri, options2, annotation) {
        var result = {
          kind: "rename",
          oldUri,
          newUri
        };
        if (options2 !== void 0 && (options2.overwrite !== void 0 || options2.ignoreIfExists !== void 0)) {
          result.options = options2;
        }
        if (annotation !== void 0) {
          result.annotationId = annotation;
        }
        return result;
      }
      RenameFile3.create = create;
      function is(value) {
        var candidate = value;
        return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      RenameFile3.is = is;
    })(RenameFile || (RenameFile = {}));
    (function(DeleteFile3) {
      function create(uri, options2, annotation) {
        var result = {
          kind: "delete",
          uri
        };
        if (options2 !== void 0 && (options2.recursive !== void 0 || options2.ignoreIfNotExists !== void 0)) {
          result.options = options2;
        }
        if (annotation !== void 0) {
          result.annotationId = annotation;
        }
        return result;
      }
      DeleteFile3.create = create;
      function is(value) {
        var candidate = value;
        return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      DeleteFile3.is = is;
    })(DeleteFile || (DeleteFile = {}));
    (function(WorkspaceEdit12) {
      function is(value) {
        var candidate = value;
        return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
          if (Is.string(change.kind)) {
            return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
          } else {
            return TextDocumentEdit.is(change);
          }
        }));
      }
      WorkspaceEdit12.is = is;
    })(WorkspaceEdit || (WorkspaceEdit = {}));
    TextEditChangeImpl = function() {
      function TextEditChangeImpl2(edits, changeAnnotations) {
        this.edits = edits;
        this.changeAnnotations = changeAnnotations;
      }
      TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {
        var edit2;
        var id;
        if (annotation === void 0) {
          edit2 = TextEdit.insert(position, newText);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id = annotation;
          edit2 = AnnotatedTextEdit.insert(position, newText, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit2 = AnnotatedTextEdit.insert(position, newText, id);
        }
        this.edits.push(edit2);
        if (id !== void 0) {
          return id;
        }
      };
      TextEditChangeImpl2.prototype.replace = function(range2, newText, annotation) {
        var edit2;
        var id;
        if (annotation === void 0) {
          edit2 = TextEdit.replace(range2, newText);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id = annotation;
          edit2 = AnnotatedTextEdit.replace(range2, newText, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit2 = AnnotatedTextEdit.replace(range2, newText, id);
        }
        this.edits.push(edit2);
        if (id !== void 0) {
          return id;
        }
      };
      TextEditChangeImpl2.prototype.delete = function(range2, annotation) {
        var edit2;
        var id;
        if (annotation === void 0) {
          edit2 = TextEdit.del(range2);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id = annotation;
          edit2 = AnnotatedTextEdit.del(range2, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit2 = AnnotatedTextEdit.del(range2, id);
        }
        this.edits.push(edit2);
        if (id !== void 0) {
          return id;
        }
      };
      TextEditChangeImpl2.prototype.add = function(edit2) {
        this.edits.push(edit2);
      };
      TextEditChangeImpl2.prototype.all = function() {
        return this.edits;
      };
      TextEditChangeImpl2.prototype.clear = function() {
        this.edits.splice(0, this.edits.length);
      };
      TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value) {
        if (value === void 0) {
          throw new Error("Text edit change is not configured to manage change annotations.");
        }
      };
      return TextEditChangeImpl2;
    }();
    ChangeAnnotations = function() {
      function ChangeAnnotations2(annotations) {
        this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
        this._counter = 0;
        this._size = 0;
      }
      ChangeAnnotations2.prototype.all = function() {
        return this._annotations;
      };
      Object.defineProperty(ChangeAnnotations2.prototype, "size", {
        get: function() {
          return this._size;
        },
        enumerable: false,
        configurable: true
      });
      ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {
        var id;
        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
          id = idOrAnnotation;
        } else {
          id = this.nextId();
          annotation = idOrAnnotation;
        }
        if (this._annotations[id] !== void 0) {
          throw new Error("Id ".concat(id, " is already in use."));
        }
        if (annotation === void 0) {
          throw new Error("No annotation provided for id ".concat(id));
        }
        this._annotations[id] = annotation;
        this._size++;
        return id;
      };
      ChangeAnnotations2.prototype.nextId = function() {
        this._counter++;
        return this._counter.toString();
      };
      return ChangeAnnotations2;
    }();
    WorkspaceChange = function() {
      function WorkspaceChange2(workspaceEdit) {
        var _this = this;
        this._textEditChanges = /* @__PURE__ */ Object.create(null);
        if (workspaceEdit !== void 0) {
          this._workspaceEdit = workspaceEdit;
          if (workspaceEdit.documentChanges) {
            this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
            workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            workspaceEdit.documentChanges.forEach(function(change) {
              if (TextDocumentEdit.is(change)) {
                var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                _this._textEditChanges[change.textDocument.uri] = textEditChange;
              }
            });
          } else if (workspaceEdit.changes) {
            Object.keys(workspaceEdit.changes).forEach(function(key) {
              var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
              _this._textEditChanges[key] = textEditChange;
            });
          }
        } else {
          this._workspaceEdit = {};
        }
      }
      Object.defineProperty(WorkspaceChange2.prototype, "edit", {
        get: function() {
          this.initDocumentChanges();
          if (this._changeAnnotations !== void 0) {
            if (this._changeAnnotations.size === 0) {
              this._workspaceEdit.changeAnnotations = void 0;
            } else {
              this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
          }
          return this._workspaceEdit;
        },
        enumerable: false,
        configurable: true
      });
      WorkspaceChange2.prototype.getTextEditChange = function(key) {
        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          var textDocument = { uri: key.uri, version: key.version };
          var result = this._textEditChanges[textDocument.uri];
          if (!result) {
            var edits = [];
            var textDocumentEdit = {
              textDocument,
              edits
            };
            this._workspaceEdit.documentChanges.push(textDocumentEdit);
            result = new TextEditChangeImpl(edits, this._changeAnnotations);
            this._textEditChanges[textDocument.uri] = result;
          }
          return result;
        } else {
          this.initChanges();
          if (this._workspaceEdit.changes === void 0) {
            throw new Error("Workspace edit is not configured for normal text edit changes.");
          }
          var result = this._textEditChanges[key];
          if (!result) {
            var edits = [];
            this._workspaceEdit.changes[key] = edits;
            result = new TextEditChangeImpl(edits);
            this._textEditChanges[key] = result;
          }
          return result;
        }
      };
      WorkspaceChange2.prototype.initDocumentChanges = function() {
        if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
          this._changeAnnotations = new ChangeAnnotations();
          this._workspaceEdit.documentChanges = [];
          this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        }
      };
      WorkspaceChange2.prototype.initChanges = function() {
        if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
          this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
        }
      };
      WorkspaceChange2.prototype.createFile = function(uri, optionsOrAnnotation, options2) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options2 = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === void 0) {
          operation = CreateFile.create(uri, options2);
        } else {
          id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = CreateFile.create(uri, options2, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== void 0) {
          return id;
        }
      };
      WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options2) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options2 = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === void 0) {
          operation = RenameFile.create(oldUri, newUri, options2);
        } else {
          id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = RenameFile.create(oldUri, newUri, options2, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== void 0) {
          return id;
        }
      };
      WorkspaceChange2.prototype.deleteFile = function(uri, optionsOrAnnotation, options2) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options2 = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === void 0) {
          operation = DeleteFile.create(uri, options2);
        } else {
          id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = DeleteFile.create(uri, options2, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== void 0) {
          return id;
        }
      };
      return WorkspaceChange2;
    }();
    (function(TextDocumentIdentifier2) {
      function create(uri) {
        return { uri };
      }
      TextDocumentIdentifier2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri);
      }
      TextDocumentIdentifier2.is = is;
    })(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
    (function(VersionedTextDocumentIdentifier2) {
      function create(uri, version2) {
        return { uri, version: version2 };
      }
      VersionedTextDocumentIdentifier2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
      }
      VersionedTextDocumentIdentifier2.is = is;
    })(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
    (function(OptionalVersionedTextDocumentIdentifier2) {
      function create(uri, version2) {
        return { uri, version: version2 };
      }
      OptionalVersionedTextDocumentIdentifier2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
      }
      OptionalVersionedTextDocumentIdentifier2.is = is;
    })(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
    (function(TextDocumentItem2) {
      function create(uri, languageId, version2, text) {
        return { uri, languageId, version: version2, text };
      }
      TextDocumentItem2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
      }
      TextDocumentItem2.is = is;
    })(TextDocumentItem || (TextDocumentItem = {}));
    (function(MarkupKind6) {
      MarkupKind6.PlainText = "plaintext";
      MarkupKind6.Markdown = "markdown";
      function is(value) {
        var candidate = value;
        return candidate === MarkupKind6.PlainText || candidate === MarkupKind6.Markdown;
      }
      MarkupKind6.is = is;
    })(MarkupKind || (MarkupKind = {}));
    (function(MarkupContent7) {
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
      }
      MarkupContent7.is = is;
    })(MarkupContent || (MarkupContent = {}));
    (function(CompletionItemKind5) {
      CompletionItemKind5.Text = 1;
      CompletionItemKind5.Method = 2;
      CompletionItemKind5.Function = 3;
      CompletionItemKind5.Constructor = 4;
      CompletionItemKind5.Field = 5;
      CompletionItemKind5.Variable = 6;
      CompletionItemKind5.Class = 7;
      CompletionItemKind5.Interface = 8;
      CompletionItemKind5.Module = 9;
      CompletionItemKind5.Property = 10;
      CompletionItemKind5.Unit = 11;
      CompletionItemKind5.Value = 12;
      CompletionItemKind5.Enum = 13;
      CompletionItemKind5.Keyword = 14;
      CompletionItemKind5.Snippet = 15;
      CompletionItemKind5.Color = 16;
      CompletionItemKind5.File = 17;
      CompletionItemKind5.Reference = 18;
      CompletionItemKind5.Folder = 19;
      CompletionItemKind5.EnumMember = 20;
      CompletionItemKind5.Constant = 21;
      CompletionItemKind5.Struct = 22;
      CompletionItemKind5.Event = 23;
      CompletionItemKind5.Operator = 24;
      CompletionItemKind5.TypeParameter = 25;
    })(CompletionItemKind || (CompletionItemKind = {}));
    (function(InsertTextFormat3) {
      InsertTextFormat3.PlainText = 1;
      InsertTextFormat3.Snippet = 2;
    })(InsertTextFormat || (InsertTextFormat = {}));
    (function(CompletionItemTag4) {
      CompletionItemTag4.Deprecated = 1;
    })(CompletionItemTag || (CompletionItemTag = {}));
    (function(InsertReplaceEdit3) {
      function create(newText, insert, replace) {
        return { newText, insert, replace };
      }
      InsertReplaceEdit3.create = create;
      function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
      }
      InsertReplaceEdit3.is = is;
    })(InsertReplaceEdit || (InsertReplaceEdit = {}));
    (function(InsertTextMode6) {
      InsertTextMode6.asIs = 1;
      InsertTextMode6.adjustIndentation = 2;
    })(InsertTextMode || (InsertTextMode = {}));
    (function(CompletionItemLabelDetails2) {
      function is(value) {
        var candidate = value;
        return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
      }
      CompletionItemLabelDetails2.is = is;
    })(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
    (function(CompletionItem4) {
      function create(label) {
        return { label };
      }
      CompletionItem4.create = create;
    })(CompletionItem || (CompletionItem = {}));
    (function(CompletionList4) {
      function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
      }
      CompletionList4.create = create;
    })(CompletionList || (CompletionList = {}));
    (function(MarkedString3) {
      function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
      }
      MarkedString3.fromPlainText = fromPlainText;
      function is(value) {
        var candidate = value;
        return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
      }
      MarkedString3.is = is;
    })(MarkedString || (MarkedString = {}));
    (function(Hover6) {
      function is(value) {
        var candidate = value;
        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));
      }
      Hover6.is = is;
    })(Hover || (Hover = {}));
    (function(ParameterInformation2) {
      function create(label, documentation) {
        return documentation ? { label, documentation } : { label };
      }
      ParameterInformation2.create = create;
    })(ParameterInformation || (ParameterInformation = {}));
    (function(SignatureInformation2) {
      function create(label, documentation) {
        var parameters = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          parameters[_i - 2] = arguments[_i];
        }
        var result = { label };
        if (Is.defined(documentation)) {
          result.documentation = documentation;
        }
        if (Is.defined(parameters)) {
          result.parameters = parameters;
        } else {
          result.parameters = [];
        }
        return result;
      }
      SignatureInformation2.create = create;
    })(SignatureInformation || (SignatureInformation = {}));
    (function(DocumentHighlightKind3) {
      DocumentHighlightKind3.Text = 1;
      DocumentHighlightKind3.Read = 2;
      DocumentHighlightKind3.Write = 3;
    })(DocumentHighlightKind || (DocumentHighlightKind = {}));
    (function(DocumentHighlight5) {
      function create(range2, kind) {
        var result = { range: range2 };
        if (Is.number(kind)) {
          result.kind = kind;
        }
        return result;
      }
      DocumentHighlight5.create = create;
    })(DocumentHighlight || (DocumentHighlight = {}));
    (function(SymbolKind6) {
      SymbolKind6.File = 1;
      SymbolKind6.Module = 2;
      SymbolKind6.Namespace = 3;
      SymbolKind6.Package = 4;
      SymbolKind6.Class = 5;
      SymbolKind6.Method = 6;
      SymbolKind6.Property = 7;
      SymbolKind6.Field = 8;
      SymbolKind6.Constructor = 9;
      SymbolKind6.Enum = 10;
      SymbolKind6.Interface = 11;
      SymbolKind6.Function = 12;
      SymbolKind6.Variable = 13;
      SymbolKind6.Constant = 14;
      SymbolKind6.String = 15;
      SymbolKind6.Number = 16;
      SymbolKind6.Boolean = 17;
      SymbolKind6.Array = 18;
      SymbolKind6.Object = 19;
      SymbolKind6.Key = 20;
      SymbolKind6.Null = 21;
      SymbolKind6.EnumMember = 22;
      SymbolKind6.Struct = 23;
      SymbolKind6.Event = 24;
      SymbolKind6.Operator = 25;
      SymbolKind6.TypeParameter = 26;
    })(SymbolKind || (SymbolKind = {}));
    (function(SymbolTag7) {
      SymbolTag7.Deprecated = 1;
    })(SymbolTag || (SymbolTag = {}));
    (function(SymbolInformation8) {
      function create(name2, kind, range2, uri, containerName) {
        var result = {
          name: name2,
          kind,
          location: { uri, range: range2 }
        };
        if (containerName) {
          result.containerName = containerName;
        }
        return result;
      }
      SymbolInformation8.create = create;
    })(SymbolInformation || (SymbolInformation = {}));
    (function(WorkspaceSymbol2) {
      function create(name2, kind, uri, range2) {
        return range2 !== void 0 ? { name: name2, kind, location: { uri, range: range2 } } : { name: name2, kind, location: { uri } };
      }
      WorkspaceSymbol2.create = create;
    })(WorkspaceSymbol || (WorkspaceSymbol = {}));
    (function(DocumentSymbol8) {
      function create(name2, detail, kind, range2, selectionRange, children) {
        var result = {
          name: name2,
          detail,
          kind,
          range: range2,
          selectionRange
        };
        if (children !== void 0) {
          result.children = children;
        }
        return result;
      }
      DocumentSymbol8.create = create;
      function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
      }
      DocumentSymbol8.is = is;
    })(DocumentSymbol || (DocumentSymbol = {}));
    (function(CodeActionKind9) {
      CodeActionKind9.Empty = "";
      CodeActionKind9.QuickFix = "quickfix";
      CodeActionKind9.Refactor = "refactor";
      CodeActionKind9.RefactorExtract = "refactor.extract";
      CodeActionKind9.RefactorInline = "refactor.inline";
      CodeActionKind9.RefactorRewrite = "refactor.rewrite";
      CodeActionKind9.Source = "source";
      CodeActionKind9.SourceOrganizeImports = "source.organizeImports";
      CodeActionKind9.SourceFixAll = "source.fixAll";
    })(CodeActionKind || (CodeActionKind = {}));
    (function(CodeActionTriggerKind2) {
      CodeActionTriggerKind2.Invoked = 1;
      CodeActionTriggerKind2.Automatic = 2;
    })(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
    (function(CodeActionContext6) {
      function create(diagnostics, only, triggerKind) {
        var result = { diagnostics };
        if (only !== void 0 && only !== null) {
          result.only = only;
        }
        if (triggerKind !== void 0 && triggerKind !== null) {
          result.triggerKind = triggerKind;
        }
        return result;
      }
      CodeActionContext6.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
      }
      CodeActionContext6.is = is;
    })(CodeActionContext || (CodeActionContext = {}));
    (function(CodeAction6) {
      function create(title, kindOrCommandOrEdit, kind) {
        var result = { title };
        var checkKind = true;
        if (typeof kindOrCommandOrEdit === "string") {
          checkKind = false;
          result.kind = kindOrCommandOrEdit;
        } else if (Command.is(kindOrCommandOrEdit)) {
          result.command = kindOrCommandOrEdit;
        } else {
          result.edit = kindOrCommandOrEdit;
        }
        if (checkKind && kind !== void 0) {
          result.kind = kind;
        }
        return result;
      }
      CodeAction6.create = create;
      function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
      }
      CodeAction6.is = is;
    })(CodeAction || (CodeAction = {}));
    (function(CodeLens5) {
      function create(range2, data) {
        var result = { range: range2 };
        if (Is.defined(data)) {
          result.data = data;
        }
        return result;
      }
      CodeLens5.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
      }
      CodeLens5.is = is;
    })(CodeLens || (CodeLens = {}));
    (function(FormattingOptions5) {
      function create(tabSize, insertSpaces) {
        return { tabSize, insertSpaces };
      }
      FormattingOptions5.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
      }
      FormattingOptions5.is = is;
    })(FormattingOptions || (FormattingOptions = {}));
    (function(DocumentLink6) {
      function create(range2, target, data) {
        return { range: range2, target, data };
      }
      DocumentLink6.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
      }
      DocumentLink6.is = is;
    })(DocumentLink || (DocumentLink = {}));
    (function(SelectionRange5) {
      function create(range2, parent) {
        return { range: range2, parent };
      }
      SelectionRange5.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === void 0 || SelectionRange5.is(candidate.parent));
      }
      SelectionRange5.is = is;
    })(SelectionRange || (SelectionRange = {}));
    (function(SemanticTokenTypes3) {
      SemanticTokenTypes3["namespace"] = "namespace";
      SemanticTokenTypes3["type"] = "type";
      SemanticTokenTypes3["class"] = "class";
      SemanticTokenTypes3["enum"] = "enum";
      SemanticTokenTypes3["interface"] = "interface";
      SemanticTokenTypes3["struct"] = "struct";
      SemanticTokenTypes3["typeParameter"] = "typeParameter";
      SemanticTokenTypes3["parameter"] = "parameter";
      SemanticTokenTypes3["variable"] = "variable";
      SemanticTokenTypes3["property"] = "property";
      SemanticTokenTypes3["enumMember"] = "enumMember";
      SemanticTokenTypes3["event"] = "event";
      SemanticTokenTypes3["function"] = "function";
      SemanticTokenTypes3["method"] = "method";
      SemanticTokenTypes3["macro"] = "macro";
      SemanticTokenTypes3["keyword"] = "keyword";
      SemanticTokenTypes3["modifier"] = "modifier";
      SemanticTokenTypes3["comment"] = "comment";
      SemanticTokenTypes3["string"] = "string";
      SemanticTokenTypes3["number"] = "number";
      SemanticTokenTypes3["regexp"] = "regexp";
      SemanticTokenTypes3["operator"] = "operator";
      SemanticTokenTypes3["decorator"] = "decorator";
    })(SemanticTokenTypes || (SemanticTokenTypes = {}));
    (function(SemanticTokenModifiers3) {
      SemanticTokenModifiers3["declaration"] = "declaration";
      SemanticTokenModifiers3["definition"] = "definition";
      SemanticTokenModifiers3["readonly"] = "readonly";
      SemanticTokenModifiers3["static"] = "static";
      SemanticTokenModifiers3["deprecated"] = "deprecated";
      SemanticTokenModifiers3["abstract"] = "abstract";
      SemanticTokenModifiers3["async"] = "async";
      SemanticTokenModifiers3["modification"] = "modification";
      SemanticTokenModifiers3["documentation"] = "documentation";
      SemanticTokenModifiers3["defaultLibrary"] = "defaultLibrary";
    })(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
    (function(SemanticTokens7) {
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
      }
      SemanticTokens7.is = is;
    })(SemanticTokens || (SemanticTokens = {}));
    (function(InlineValueText2) {
      function create(range2, text) {
        return { range: range2, text };
      }
      InlineValueText2.create = create;
      function is(value) {
        var candidate = value;
        return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
      }
      InlineValueText2.is = is;
    })(InlineValueText || (InlineValueText = {}));
    (function(InlineValueVariableLookup2) {
      function create(range2, variableName, caseSensitiveLookup) {
        return { range: range2, variableName, caseSensitiveLookup };
      }
      InlineValueVariableLookup2.create = create;
      function is(value) {
        var candidate = value;
        return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
      }
      InlineValueVariableLookup2.is = is;
    })(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
    (function(InlineValueEvaluatableExpression2) {
      function create(range2, expression) {
        return { range: range2, expression };
      }
      InlineValueEvaluatableExpression2.create = create;
      function is(value) {
        var candidate = value;
        return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
      }
      InlineValueEvaluatableExpression2.is = is;
    })(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
    (function(InlineValueContext4) {
      function create(frameId, stoppedLocation) {
        return { frameId, stoppedLocation };
      }
      InlineValueContext4.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(value.stoppedLocation);
      }
      InlineValueContext4.is = is;
    })(InlineValueContext || (InlineValueContext = {}));
    (function(InlayHintKind3) {
      InlayHintKind3.Type = 1;
      InlayHintKind3.Parameter = 2;
      function is(value) {
        return value === 1 || value === 2;
      }
      InlayHintKind3.is = is;
    })(InlayHintKind || (InlayHintKind = {}));
    (function(InlayHintLabelPart2) {
      function create(value) {
        return { value };
      }
      InlayHintLabelPart2.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command.is(candidate.command));
      }
      InlayHintLabelPart2.is = is;
    })(InlayHintLabelPart || (InlayHintLabelPart = {}));
    (function(InlayHint4) {
      function create(position, label, kind) {
        var result = { position, label };
        if (kind !== void 0) {
          result.kind = kind;
        }
        return result;
      }
      InlayHint4.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));
      }
      InlayHint4.is = is;
    })(InlayHint || (InlayHint = {}));
    (function(WorkspaceFolder6) {
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
      }
      WorkspaceFolder6.is = is;
    })(WorkspaceFolder || (WorkspaceFolder = {}));
    EOL = ["\n", "\r\n", "\r"];
    (function(TextDocument4) {
      function create(uri, languageId, version2, content) {
        return new FullTextDocument(uri, languageId, version2, content);
      }
      TextDocument4.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
      }
      TextDocument4.is = is;
      function applyEdits3(document2, edits) {
        var text = document2.getText();
        var sortedEdits = mergeSort3(edits, function(a, b) {
          var diff = a.range.start.line - b.range.start.line;
          if (diff === 0) {
            return a.range.start.character - b.range.start.character;
          }
          return diff;
        });
        var lastModifiedOffset = text.length;
        for (var i = sortedEdits.length - 1; i >= 0; i--) {
          var e = sortedEdits[i];
          var startOffset = document2.offsetAt(e.range.start);
          var endOffset = document2.offsetAt(e.range.end);
          if (endOffset <= lastModifiedOffset) {
            text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
          } else {
            throw new Error("Overlapping edit");
          }
          lastModifiedOffset = startOffset;
        }
        return text;
      }
      TextDocument4.applyEdits = applyEdits3;
      function mergeSort3(data, compare) {
        if (data.length <= 1) {
          return data;
        }
        var p = data.length / 2 | 0;
        var left = data.slice(0, p);
        var right = data.slice(p);
        mergeSort3(left, compare);
        mergeSort3(right, compare);
        var leftIdx = 0;
        var rightIdx = 0;
        var i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
          var ret = compare(left[leftIdx], right[rightIdx]);
          if (ret <= 0) {
            data[i++] = left[leftIdx++];
          } else {
            data[i++] = right[rightIdx++];
          }
        }
        while (leftIdx < left.length) {
          data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
          data[i++] = right[rightIdx++];
        }
        return data;
      }
    })(TextDocument || (TextDocument = {}));
    FullTextDocument = function() {
      function FullTextDocument3(uri, languageId, version2, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version2;
        this._content = content;
        this._lineOffsets = void 0;
      }
      Object.defineProperty(FullTextDocument3.prototype, "uri", {
        get: function() {
          return this._uri;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FullTextDocument3.prototype, "languageId", {
        get: function() {
          return this._languageId;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FullTextDocument3.prototype, "version", {
        get: function() {
          return this._version;
        },
        enumerable: false,
        configurable: true
      });
      FullTextDocument3.prototype.getText = function(range2) {
        if (range2) {
          var start = this.offsetAt(range2.start);
          var end = this.offsetAt(range2.end);
          return this._content.substring(start, end);
        }
        return this._content;
      };
      FullTextDocument3.prototype.update = function(event, version2) {
        this._content = event.text;
        this._version = version2;
        this._lineOffsets = void 0;
      };
      FullTextDocument3.prototype.getLineOffsets = function() {
        if (this._lineOffsets === void 0) {
          var lineOffsets = [];
          var text = this._content;
          var isLineStart = true;
          for (var i = 0; i < text.length; i++) {
            if (isLineStart) {
              lineOffsets.push(i);
              isLineStart = false;
            }
            var ch = text.charAt(i);
            isLineStart = ch === "\r" || ch === "\n";
            if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
              i++;
            }
          }
          if (isLineStart && text.length > 0) {
            lineOffsets.push(text.length);
          }
          this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
      };
      FullTextDocument3.prototype.positionAt = function(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
          return Position.create(0, offset);
        }
        while (low < high) {
          var mid = Math.floor((low + high) / 2);
          if (lineOffsets[mid] > offset) {
            high = mid;
          } else {
            low = mid + 1;
          }
        }
        var line = low - 1;
        return Position.create(line, offset - lineOffsets[line]);
      };
      FullTextDocument3.prototype.offsetAt = function(position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
          return this._content.length;
        } else if (position.line < 0) {
          return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
      };
      Object.defineProperty(FullTextDocument3.prototype, "lineCount", {
        get: function() {
          return this.getLineOffsets().length;
        },
        enumerable: false,
        configurable: true
      });
      return FullTextDocument3;
    }();
    (function(Is2) {
      var toString = Object.prototype.toString;
      function defined(value) {
        return typeof value !== "undefined";
      }
      Is2.defined = defined;
      function undefined2(value) {
        return typeof value === "undefined";
      }
      Is2.undefined = undefined2;
      function boolean2(value) {
        return value === true || value === false;
      }
      Is2.boolean = boolean2;
      function string2(value) {
        return toString.call(value) === "[object String]";
      }
      Is2.string = string2;
      function number2(value) {
        return toString.call(value) === "[object Number]";
      }
      Is2.number = number2;
      function numberRange(value, min, max) {
        return toString.call(value) === "[object Number]" && min <= value && value <= max;
      }
      Is2.numberRange = numberRange;
      function integer2(value) {
        return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
      }
      Is2.integer = integer2;
      function uinteger3(value) {
        return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
      }
      Is2.uinteger = uinteger3;
      function func2(value) {
        return toString.call(value) === "[object Function]";
      }
      Is2.func = func2;
      function objectLiteral2(value) {
        return value !== null && typeof value === "object";
      }
      Is2.objectLiteral = objectLiteral2;
      function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
      }
      Is2.typedArray = typedArray;
    })(Is || (Is = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/messages.js
var require_messages2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/messages.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProtocolNotificationType = exports.ProtocolNotificationType0 = exports.ProtocolRequestType = exports.ProtocolRequestType0 = exports.RegistrationType = exports.MessageDirection = void 0;
    var vscode_jsonrpc_1 = require_main();
    var MessageDirection;
    (function(MessageDirection2) {
      MessageDirection2["clientToServer"] = "clientToServer";
      MessageDirection2["serverToClient"] = "serverToClient";
      MessageDirection2["both"] = "both";
    })(MessageDirection = exports.MessageDirection || (exports.MessageDirection = {}));
    var RegistrationType9 = class {
      constructor(method) {
        this.method = method;
      }
    };
    exports.RegistrationType = RegistrationType9;
    var ProtocolRequestType03 = class extends vscode_jsonrpc_1.RequestType0 {
      constructor(method) {
        super(method);
      }
    };
    exports.ProtocolRequestType0 = ProtocolRequestType03;
    var ProtocolRequestType4 = class extends vscode_jsonrpc_1.RequestType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports.ProtocolRequestType = ProtocolRequestType4;
    var ProtocolNotificationType03 = class extends vscode_jsonrpc_1.NotificationType0 {
      constructor(method) {
        super(method);
      }
    };
    exports.ProtocolNotificationType0 = ProtocolNotificationType03;
    var ProtocolNotificationType6 = class extends vscode_jsonrpc_1.NotificationType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports.ProtocolNotificationType = ProtocolNotificationType6;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
var require_is2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/utils/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.objectLiteral = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
    function boolean2(value) {
      return value === true || value === false;
    }
    exports.boolean = boolean2;
    function string2(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports.string = string2;
    function number2(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports.number = number2;
    function error(value) {
      return value instanceof Error;
    }
    exports.error = error;
    function func2(value) {
      return typeof value === "function";
    }
    exports.func = func2;
    function array(value) {
      return Array.isArray(value);
    }
    exports.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string2(elem));
    }
    exports.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports.typedArray = typedArray;
    function objectLiteral2(value) {
      return value !== null && typeof value === "object";
    }
    exports.objectLiteral = objectLiteral2;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
var require_protocol_implementation = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImplementationRequest = void 0;
    var messages_1 = require_messages2();
    var ImplementationRequest4;
    (function(ImplementationRequest5) {
      ImplementationRequest5.method = "textDocument/implementation";
      ImplementationRequest5.messageDirection = messages_1.MessageDirection.clientToServer;
      ImplementationRequest5.type = new messages_1.ProtocolRequestType(ImplementationRequest5.method);
    })(ImplementationRequest4 = exports.ImplementationRequest || (exports.ImplementationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
var require_protocol_typeDefinition = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeDefinitionRequest = void 0;
    var messages_1 = require_messages2();
    var TypeDefinitionRequest4;
    (function(TypeDefinitionRequest5) {
      TypeDefinitionRequest5.method = "textDocument/typeDefinition";
      TypeDefinitionRequest5.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeDefinitionRequest5.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest5.method);
    })(TypeDefinitionRequest4 = exports.TypeDefinitionRequest || (exports.TypeDefinitionRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js
var require_protocol_workspaceFolder = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = void 0;
    var messages_1 = require_messages2();
    var WorkspaceFoldersRequest2;
    (function(WorkspaceFoldersRequest3) {
      WorkspaceFoldersRequest3.method = "workspace/workspaceFolders";
      WorkspaceFoldersRequest3.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkspaceFoldersRequest3.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest3.method);
    })(WorkspaceFoldersRequest2 = exports.WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = {}));
    var DidChangeWorkspaceFoldersNotification4;
    (function(DidChangeWorkspaceFoldersNotification5) {
      DidChangeWorkspaceFoldersNotification5.method = "workspace/didChangeWorkspaceFolders";
      DidChangeWorkspaceFoldersNotification5.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWorkspaceFoldersNotification5.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification5.method);
    })(DidChangeWorkspaceFoldersNotification4 = exports.DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
var require_protocol_configuration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConfigurationRequest = void 0;
    var messages_1 = require_messages2();
    var ConfigurationRequest3;
    (function(ConfigurationRequest4) {
      ConfigurationRequest4.method = "workspace/configuration";
      ConfigurationRequest4.messageDirection = messages_1.MessageDirection.serverToClient;
      ConfigurationRequest4.type = new messages_1.ProtocolRequestType(ConfigurationRequest4.method);
    })(ConfigurationRequest3 = exports.ConfigurationRequest || (exports.ConfigurationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
var require_protocol_colorProvider = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ColorPresentationRequest = exports.DocumentColorRequest = void 0;
    var messages_1 = require_messages2();
    var DocumentColorRequest4;
    (function(DocumentColorRequest5) {
      DocumentColorRequest5.method = "textDocument/documentColor";
      DocumentColorRequest5.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentColorRequest5.type = new messages_1.ProtocolRequestType(DocumentColorRequest5.method);
    })(DocumentColorRequest4 = exports.DocumentColorRequest || (exports.DocumentColorRequest = {}));
    var ColorPresentationRequest2;
    (function(ColorPresentationRequest3) {
      ColorPresentationRequest3.method = "textDocument/colorPresentation";
      ColorPresentationRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      ColorPresentationRequest3.type = new messages_1.ProtocolRequestType(ColorPresentationRequest3.method);
    })(ColorPresentationRequest2 = exports.ColorPresentationRequest || (exports.ColorPresentationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
var require_protocol_foldingRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FoldingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var FoldingRangeRequest4;
    (function(FoldingRangeRequest5) {
      FoldingRangeRequest5.method = "textDocument/foldingRange";
      FoldingRangeRequest5.messageDirection = messages_1.MessageDirection.clientToServer;
      FoldingRangeRequest5.type = new messages_1.ProtocolRequestType(FoldingRangeRequest5.method);
    })(FoldingRangeRequest4 = exports.FoldingRangeRequest || (exports.FoldingRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
var require_protocol_declaration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DeclarationRequest = void 0;
    var messages_1 = require_messages2();
    var DeclarationRequest4;
    (function(DeclarationRequest5) {
      DeclarationRequest5.method = "textDocument/declaration";
      DeclarationRequest5.messageDirection = messages_1.MessageDirection.clientToServer;
      DeclarationRequest5.type = new messages_1.ProtocolRequestType(DeclarationRequest5.method);
    })(DeclarationRequest4 = exports.DeclarationRequest || (exports.DeclarationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
var require_protocol_selectionRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SelectionRangeRequest = void 0;
    var messages_1 = require_messages2();
    var SelectionRangeRequest4;
    (function(SelectionRangeRequest5) {
      SelectionRangeRequest5.method = "textDocument/selectionRange";
      SelectionRangeRequest5.messageDirection = messages_1.MessageDirection.clientToServer;
      SelectionRangeRequest5.type = new messages_1.ProtocolRequestType(SelectionRangeRequest5.method);
    })(SelectionRangeRequest4 = exports.SelectionRangeRequest || (exports.SelectionRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
var require_protocol_progress = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = void 0;
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var WorkDoneProgress3;
    (function(WorkDoneProgress4) {
      WorkDoneProgress4.type = new vscode_jsonrpc_1.ProgressType();
      function is(value) {
        return value === WorkDoneProgress4.type;
      }
      WorkDoneProgress4.is = is;
    })(WorkDoneProgress3 = exports.WorkDoneProgress || (exports.WorkDoneProgress = {}));
    var WorkDoneProgressCreateRequest3;
    (function(WorkDoneProgressCreateRequest4) {
      WorkDoneProgressCreateRequest4.method = "window/workDoneProgress/create";
      WorkDoneProgressCreateRequest4.messageDirection = messages_1.MessageDirection.serverToClient;
      WorkDoneProgressCreateRequest4.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest4.method);
    })(WorkDoneProgressCreateRequest3 = exports.WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = {}));
    var WorkDoneProgressCancelNotification2;
    (function(WorkDoneProgressCancelNotification3) {
      WorkDoneProgressCancelNotification3.method = "window/workDoneProgress/cancel";
      WorkDoneProgressCancelNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkDoneProgressCancelNotification3.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification3.method);
    })(WorkDoneProgressCancelNotification2 = exports.WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
var require_protocol_callHierarchy = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.CallHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var CallHierarchyPrepareRequest4;
    (function(CallHierarchyPrepareRequest5) {
      CallHierarchyPrepareRequest5.method = "textDocument/prepareCallHierarchy";
      CallHierarchyPrepareRequest5.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyPrepareRequest5.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest5.method);
    })(CallHierarchyPrepareRequest4 = exports.CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = {}));
    var CallHierarchyIncomingCallsRequest2;
    (function(CallHierarchyIncomingCallsRequest3) {
      CallHierarchyIncomingCallsRequest3.method = "callHierarchy/incomingCalls";
      CallHierarchyIncomingCallsRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyIncomingCallsRequest3.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest3.method);
    })(CallHierarchyIncomingCallsRequest2 = exports.CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = {}));
    var CallHierarchyOutgoingCallsRequest2;
    (function(CallHierarchyOutgoingCallsRequest3) {
      CallHierarchyOutgoingCallsRequest3.method = "callHierarchy/outgoingCalls";
      CallHierarchyOutgoingCallsRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      CallHierarchyOutgoingCallsRequest3.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest3.method);
    })(CallHierarchyOutgoingCallsRequest2 = exports.CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
var require_protocol_semanticTokens = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.SemanticTokensRegistrationType = exports.TokenFormat = void 0;
    var messages_1 = require_messages2();
    var TokenFormat2;
    (function(TokenFormat3) {
      TokenFormat3.Relative = "relative";
    })(TokenFormat2 = exports.TokenFormat || (exports.TokenFormat = {}));
    var SemanticTokensRegistrationType4;
    (function(SemanticTokensRegistrationType5) {
      SemanticTokensRegistrationType5.method = "textDocument/semanticTokens";
      SemanticTokensRegistrationType5.type = new messages_1.RegistrationType(SemanticTokensRegistrationType5.method);
    })(SemanticTokensRegistrationType4 = exports.SemanticTokensRegistrationType || (exports.SemanticTokensRegistrationType = {}));
    var SemanticTokensRequest3;
    (function(SemanticTokensRequest4) {
      SemanticTokensRequest4.method = "textDocument/semanticTokens/full";
      SemanticTokensRequest4.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRequest4.type = new messages_1.ProtocolRequestType(SemanticTokensRequest4.method);
      SemanticTokensRequest4.registrationMethod = SemanticTokensRegistrationType4.method;
    })(SemanticTokensRequest3 = exports.SemanticTokensRequest || (exports.SemanticTokensRequest = {}));
    var SemanticTokensDeltaRequest3;
    (function(SemanticTokensDeltaRequest4) {
      SemanticTokensDeltaRequest4.method = "textDocument/semanticTokens/full/delta";
      SemanticTokensDeltaRequest4.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensDeltaRequest4.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest4.method);
      SemanticTokensDeltaRequest4.registrationMethod = SemanticTokensRegistrationType4.method;
    })(SemanticTokensDeltaRequest3 = exports.SemanticTokensDeltaRequest || (exports.SemanticTokensDeltaRequest = {}));
    var SemanticTokensRangeRequest3;
    (function(SemanticTokensRangeRequest4) {
      SemanticTokensRangeRequest4.method = "textDocument/semanticTokens/range";
      SemanticTokensRangeRequest4.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRangeRequest4.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest4.method);
      SemanticTokensRangeRequest4.registrationMethod = SemanticTokensRegistrationType4.method;
    })(SemanticTokensRangeRequest3 = exports.SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = {}));
    var SemanticTokensRefreshRequest2;
    (function(SemanticTokensRefreshRequest3) {
      SemanticTokensRefreshRequest3.method = `workspace/semanticTokens/refresh`;
      SemanticTokensRefreshRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      SemanticTokensRefreshRequest3.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest3.method);
    })(SemanticTokensRefreshRequest2 = exports.SemanticTokensRefreshRequest || (exports.SemanticTokensRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
var require_protocol_showDocument = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ShowDocumentRequest = void 0;
    var messages_1 = require_messages2();
    var ShowDocumentRequest2;
    (function(ShowDocumentRequest3) {
      ShowDocumentRequest3.method = "window/showDocument";
      ShowDocumentRequest3.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowDocumentRequest3.type = new messages_1.ProtocolRequestType(ShowDocumentRequest3.method);
    })(ShowDocumentRequest2 = exports.ShowDocumentRequest || (exports.ShowDocumentRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
var require_protocol_linkedEditingRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LinkedEditingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var LinkedEditingRangeRequest4;
    (function(LinkedEditingRangeRequest5) {
      LinkedEditingRangeRequest5.method = "textDocument/linkedEditingRange";
      LinkedEditingRangeRequest5.messageDirection = messages_1.MessageDirection.clientToServer;
      LinkedEditingRangeRequest5.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest5.method);
    })(LinkedEditingRangeRequest4 = exports.LinkedEditingRangeRequest || (exports.LinkedEditingRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
var require_protocol_fileOperations = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.DidRenameFilesNotification = exports.WillRenameFilesRequest = exports.DidCreateFilesNotification = exports.WillCreateFilesRequest = exports.FileOperationPatternKind = void 0;
    var messages_1 = require_messages2();
    var FileOperationPatternKind2;
    (function(FileOperationPatternKind3) {
      FileOperationPatternKind3.file = "file";
      FileOperationPatternKind3.folder = "folder";
    })(FileOperationPatternKind2 = exports.FileOperationPatternKind || (exports.FileOperationPatternKind = {}));
    var WillCreateFilesRequest4;
    (function(WillCreateFilesRequest5) {
      WillCreateFilesRequest5.method = "workspace/willCreateFiles";
      WillCreateFilesRequest5.messageDirection = messages_1.MessageDirection.clientToServer;
      WillCreateFilesRequest5.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest5.method);
    })(WillCreateFilesRequest4 = exports.WillCreateFilesRequest || (exports.WillCreateFilesRequest = {}));
    var DidCreateFilesNotification4;
    (function(DidCreateFilesNotification5) {
      DidCreateFilesNotification5.method = "workspace/didCreateFiles";
      DidCreateFilesNotification5.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCreateFilesNotification5.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification5.method);
    })(DidCreateFilesNotification4 = exports.DidCreateFilesNotification || (exports.DidCreateFilesNotification = {}));
    var WillRenameFilesRequest4;
    (function(WillRenameFilesRequest5) {
      WillRenameFilesRequest5.method = "workspace/willRenameFiles";
      WillRenameFilesRequest5.messageDirection = messages_1.MessageDirection.clientToServer;
      WillRenameFilesRequest5.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest5.method);
    })(WillRenameFilesRequest4 = exports.WillRenameFilesRequest || (exports.WillRenameFilesRequest = {}));
    var DidRenameFilesNotification4;
    (function(DidRenameFilesNotification5) {
      DidRenameFilesNotification5.method = "workspace/didRenameFiles";
      DidRenameFilesNotification5.messageDirection = messages_1.MessageDirection.clientToServer;
      DidRenameFilesNotification5.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification5.method);
    })(DidRenameFilesNotification4 = exports.DidRenameFilesNotification || (exports.DidRenameFilesNotification = {}));
    var DidDeleteFilesNotification4;
    (function(DidDeleteFilesNotification5) {
      DidDeleteFilesNotification5.method = "workspace/didDeleteFiles";
      DidDeleteFilesNotification5.messageDirection = messages_1.MessageDirection.clientToServer;
      DidDeleteFilesNotification5.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification5.method);
    })(DidDeleteFilesNotification4 = exports.DidDeleteFilesNotification || (exports.DidDeleteFilesNotification = {}));
    var WillDeleteFilesRequest4;
    (function(WillDeleteFilesRequest5) {
      WillDeleteFilesRequest5.method = "workspace/willDeleteFiles";
      WillDeleteFilesRequest5.messageDirection = messages_1.MessageDirection.clientToServer;
      WillDeleteFilesRequest5.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest5.method);
    })(WillDeleteFilesRequest4 = exports.WillDeleteFilesRequest || (exports.WillDeleteFilesRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
var require_protocol_moniker = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = void 0;
    var messages_1 = require_messages2();
    var UniquenessLevel;
    (function(UniquenessLevel2) {
      UniquenessLevel2.document = "document";
      UniquenessLevel2.project = "project";
      UniquenessLevel2.group = "group";
      UniquenessLevel2.scheme = "scheme";
      UniquenessLevel2.global = "global";
    })(UniquenessLevel = exports.UniquenessLevel || (exports.UniquenessLevel = {}));
    var MonikerKind;
    (function(MonikerKind2) {
      MonikerKind2.$import = "import";
      MonikerKind2.$export = "export";
      MonikerKind2.local = "local";
    })(MonikerKind = exports.MonikerKind || (exports.MonikerKind = {}));
    var MonikerRequest;
    (function(MonikerRequest2) {
      MonikerRequest2.method = "textDocument/moniker";
      MonikerRequest2.messageDirection = messages_1.MessageDirection.clientToServer;
      MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
    })(MonikerRequest = exports.MonikerRequest || (exports.MonikerRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js
var require_protocol_typeHierarchy = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TypeHierarchySubtypesRequest = exports.TypeHierarchySupertypesRequest = exports.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var TypeHierarchyPrepareRequest4;
    (function(TypeHierarchyPrepareRequest5) {
      TypeHierarchyPrepareRequest5.method = "textDocument/prepareTypeHierarchy";
      TypeHierarchyPrepareRequest5.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchyPrepareRequest5.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest5.method);
    })(TypeHierarchyPrepareRequest4 = exports.TypeHierarchyPrepareRequest || (exports.TypeHierarchyPrepareRequest = {}));
    var TypeHierarchySupertypesRequest2;
    (function(TypeHierarchySupertypesRequest3) {
      TypeHierarchySupertypesRequest3.method = "typeHierarchy/supertypes";
      TypeHierarchySupertypesRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySupertypesRequest3.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest3.method);
    })(TypeHierarchySupertypesRequest2 = exports.TypeHierarchySupertypesRequest || (exports.TypeHierarchySupertypesRequest = {}));
    var TypeHierarchySubtypesRequest2;
    (function(TypeHierarchySubtypesRequest3) {
      TypeHierarchySubtypesRequest3.method = "typeHierarchy/subtypes";
      TypeHierarchySubtypesRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      TypeHierarchySubtypesRequest3.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest3.method);
    })(TypeHierarchySubtypesRequest2 = exports.TypeHierarchySubtypesRequest || (exports.TypeHierarchySubtypesRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js
var require_protocol_inlineValue = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InlineValueRefreshRequest = exports.InlineValueRequest = void 0;
    var messages_1 = require_messages2();
    var InlineValueRequest4;
    (function(InlineValueRequest5) {
      InlineValueRequest5.method = "textDocument/inlineValue";
      InlineValueRequest5.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineValueRequest5.type = new messages_1.ProtocolRequestType(InlineValueRequest5.method);
    })(InlineValueRequest4 = exports.InlineValueRequest || (exports.InlineValueRequest = {}));
    var InlineValueRefreshRequest2;
    (function(InlineValueRefreshRequest3) {
      InlineValueRefreshRequest3.method = `workspace/inlineValue/refresh`;
      InlineValueRefreshRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      InlineValueRefreshRequest3.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest3.method);
    })(InlineValueRefreshRequest2 = exports.InlineValueRefreshRequest || (exports.InlineValueRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js
var require_protocol_inlayHint = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = void 0;
    var messages_1 = require_messages2();
    var InlayHintRequest4;
    (function(InlayHintRequest5) {
      InlayHintRequest5.method = "textDocument/inlayHint";
      InlayHintRequest5.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintRequest5.type = new messages_1.ProtocolRequestType(InlayHintRequest5.method);
    })(InlayHintRequest4 = exports.InlayHintRequest || (exports.InlayHintRequest = {}));
    var InlayHintResolveRequest2;
    (function(InlayHintResolveRequest3) {
      InlayHintResolveRequest3.method = "inlayHint/resolve";
      InlayHintResolveRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintResolveRequest3.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest3.method);
    })(InlayHintResolveRequest2 = exports.InlayHintResolveRequest || (exports.InlayHintResolveRequest = {}));
    var InlayHintRefreshRequest2;
    (function(InlayHintRefreshRequest3) {
      InlayHintRefreshRequest3.method = `workspace/inlayHint/refresh`;
      InlayHintRefreshRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      InlayHintRefreshRequest3.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest3.method);
    })(InlayHintRefreshRequest2 = exports.InlayHintRefreshRequest || (exports.InlayHintRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js
var require_protocol_diagnostic = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = void 0;
    var vscode_jsonrpc_1 = require_main();
    var Is2 = require_is2();
    var messages_1 = require_messages2();
    var DiagnosticServerCancellationData2;
    (function(DiagnosticServerCancellationData3) {
      function is(value) {
        const candidate = value;
        return candidate && Is2.boolean(candidate.retriggerRequest);
      }
      DiagnosticServerCancellationData3.is = is;
    })(DiagnosticServerCancellationData2 = exports.DiagnosticServerCancellationData || (exports.DiagnosticServerCancellationData = {}));
    var DocumentDiagnosticReportKind2;
    (function(DocumentDiagnosticReportKind3) {
      DocumentDiagnosticReportKind3.Full = "full";
      DocumentDiagnosticReportKind3.Unchanged = "unchanged";
    })(DocumentDiagnosticReportKind2 = exports.DocumentDiagnosticReportKind || (exports.DocumentDiagnosticReportKind = {}));
    var DocumentDiagnosticRequest4;
    (function(DocumentDiagnosticRequest5) {
      DocumentDiagnosticRequest5.method = "textDocument/diagnostic";
      DocumentDiagnosticRequest5.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentDiagnosticRequest5.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest5.method);
      DocumentDiagnosticRequest5.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(DocumentDiagnosticRequest4 = exports.DocumentDiagnosticRequest || (exports.DocumentDiagnosticRequest = {}));
    var WorkspaceDiagnosticRequest2;
    (function(WorkspaceDiagnosticRequest3) {
      WorkspaceDiagnosticRequest3.method = "workspace/diagnostic";
      WorkspaceDiagnosticRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceDiagnosticRequest3.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest3.method);
      WorkspaceDiagnosticRequest3.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(WorkspaceDiagnosticRequest2 = exports.WorkspaceDiagnosticRequest || (exports.WorkspaceDiagnosticRequest = {}));
    var DiagnosticRefreshRequest2;
    (function(DiagnosticRefreshRequest3) {
      DiagnosticRefreshRequest3.method = `workspace/diagnostic/refresh`;
      DiagnosticRefreshRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      DiagnosticRefreshRequest3.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest3.method);
    })(DiagnosticRefreshRequest2 = exports.DiagnosticRefreshRequest || (exports.DiagnosticRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js
var require_protocol_notebook = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = void 0;
    var vscode_languageserver_types_1 = (init_main(), __toCommonJS(main_exports));
    var Is2 = require_is2();
    var messages_1 = require_messages2();
    var NotebookCellKind;
    (function(NotebookCellKind2) {
      NotebookCellKind2.Markup = 1;
      NotebookCellKind2.Code = 2;
      function is(value) {
        return value === 1 || value === 2;
      }
      NotebookCellKind2.is = is;
    })(NotebookCellKind = exports.NotebookCellKind || (exports.NotebookCellKind = {}));
    var ExecutionSummary;
    (function(ExecutionSummary2) {
      function create(executionOrder, success) {
        const result = { executionOrder };
        if (success === true || success === false) {
          result.success = success;
        }
        return result;
      }
      ExecutionSummary2.create = create;
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === void 0 || Is2.boolean(candidate.success));
      }
      ExecutionSummary2.is = is;
      function equals2(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        return one.executionOrder === other.executionOrder && one.success === other.success;
      }
      ExecutionSummary2.equals = equals2;
    })(ExecutionSummary = exports.ExecutionSummary || (exports.ExecutionSummary = {}));
    var NotebookCell;
    (function(NotebookCell2) {
      function create(kind, document2) {
        return { kind, document: document2 };
      }
      NotebookCell2.create = create;
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === void 0 || Is2.objectLiteral(candidate.metadata));
      }
      NotebookCell2.is = is;
      function diff(one, two) {
        const result = /* @__PURE__ */ new Set();
        if (one.document !== two.document) {
          result.add("document");
        }
        if (one.kind !== two.kind) {
          result.add("kind");
        }
        if (one.executionSummary !== two.executionSummary) {
          result.add("executionSummary");
        }
        if ((one.metadata !== void 0 || two.metadata !== void 0) && !equalsMetadata(one.metadata, two.metadata)) {
          result.add("metadata");
        }
        if ((one.executionSummary !== void 0 || two.executionSummary !== void 0) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
          result.add("executionSummary");
        }
        return result;
      }
      NotebookCell2.diff = diff;
      function equalsMetadata(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        if (typeof one !== typeof other) {
          return false;
        }
        if (typeof one !== "object") {
          return false;
        }
        const oneArray = Array.isArray(one);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
          return false;
        }
        if (oneArray && otherArray) {
          if (one.length !== other.length) {
            return false;
          }
          for (let i = 0; i < one.length; i++) {
            if (!equalsMetadata(one[i], other[i])) {
              return false;
            }
          }
        }
        if (Is2.objectLiteral(one) && Is2.objectLiteral(other)) {
          const oneKeys = Object.keys(one);
          const otherKeys = Object.keys(other);
          if (oneKeys.length !== otherKeys.length) {
            return false;
          }
          oneKeys.sort();
          otherKeys.sort();
          if (!equalsMetadata(oneKeys, otherKeys)) {
            return false;
          }
          for (let i = 0; i < oneKeys.length; i++) {
            const prop = oneKeys[i];
            if (!equalsMetadata(one[prop], other[prop])) {
              return false;
            }
          }
        }
        return true;
      }
    })(NotebookCell = exports.NotebookCell || (exports.NotebookCell = {}));
    var NotebookDocument;
    (function(NotebookDocument2) {
      function create(uri, notebookType, version2, cells) {
        return { uri, notebookType, version: version2, cells };
      }
      NotebookDocument2.create = create;
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && Is2.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is2.typedArray(candidate.cells, NotebookCell.is);
      }
      NotebookDocument2.is = is;
    })(NotebookDocument = exports.NotebookDocument || (exports.NotebookDocument = {}));
    var NotebookDocumentSyncRegistrationType;
    (function(NotebookDocumentSyncRegistrationType2) {
      NotebookDocumentSyncRegistrationType2.method = "notebookDocument/sync";
      NotebookDocumentSyncRegistrationType2.messageDirection = messages_1.MessageDirection.clientToServer;
      NotebookDocumentSyncRegistrationType2.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType2.method);
    })(NotebookDocumentSyncRegistrationType = exports.NotebookDocumentSyncRegistrationType || (exports.NotebookDocumentSyncRegistrationType = {}));
    var DidOpenNotebookDocumentNotification;
    (function(DidOpenNotebookDocumentNotification2) {
      DidOpenNotebookDocumentNotification2.method = "notebookDocument/didOpen";
      DidOpenNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification2.method);
      DidOpenNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidOpenNotebookDocumentNotification = exports.DidOpenNotebookDocumentNotification || (exports.DidOpenNotebookDocumentNotification = {}));
    var NotebookCellArrayChange;
    (function(NotebookCellArrayChange2) {
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === void 0 || Is2.typedArray(candidate.cells, NotebookCell.is));
      }
      NotebookCellArrayChange2.is = is;
      function create(start, deleteCount, cells) {
        const result = { start, deleteCount };
        if (cells !== void 0) {
          result.cells = cells;
        }
        return result;
      }
      NotebookCellArrayChange2.create = create;
    })(NotebookCellArrayChange = exports.NotebookCellArrayChange || (exports.NotebookCellArrayChange = {}));
    var DidChangeNotebookDocumentNotification;
    (function(DidChangeNotebookDocumentNotification2) {
      DidChangeNotebookDocumentNotification2.method = "notebookDocument/didChange";
      DidChangeNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification2.method);
      DidChangeNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidChangeNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification || (exports.DidChangeNotebookDocumentNotification = {}));
    var DidSaveNotebookDocumentNotification;
    (function(DidSaveNotebookDocumentNotification2) {
      DidSaveNotebookDocumentNotification2.method = "notebookDocument/didSave";
      DidSaveNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification2.method);
      DidSaveNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidSaveNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification || (exports.DidSaveNotebookDocumentNotification = {}));
    var DidCloseNotebookDocumentNotification;
    (function(DidCloseNotebookDocumentNotification2) {
      DidCloseNotebookDocumentNotification2.method = "notebookDocument/didClose";
      DidCloseNotebookDocumentNotification2.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification2.method);
      DidCloseNotebookDocumentNotification2.registrationMethod = NotebookDocumentSyncRegistrationType.method;
    })(DidCloseNotebookDocumentNotification = exports.DidCloseNotebookDocumentNotification || (exports.DidCloseNotebookDocumentNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.js
var require_protocol = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WorkspaceSymbolRequest = exports.CodeActionResolveRequest = exports.CodeActionRequest = exports.DocumentSymbolRequest = exports.DocumentHighlightRequest = exports.ReferencesRequest = exports.DefinitionRequest = exports.SignatureHelpRequest = exports.SignatureHelpTriggerKind = exports.HoverRequest = exports.CompletionResolveRequest = exports.CompletionRequest = exports.CompletionTriggerKind = exports.PublishDiagnosticsNotification = exports.WatchKind = exports.RelativePattern = exports.FileChangeType = exports.DidChangeWatchedFilesNotification = exports.WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentNotification = exports.TextDocumentSaveReason = exports.DidSaveTextDocumentNotification = exports.DidCloseTextDocumentNotification = exports.DidChangeTextDocumentNotification = exports.TextDocumentContentChangeEvent = exports.DidOpenTextDocumentNotification = exports.TextDocumentSyncKind = exports.TelemetryEventNotification = exports.LogMessageNotification = exports.ShowMessageRequest = exports.ShowMessageNotification = exports.MessageType = exports.DidChangeConfigurationNotification = exports.ExitNotification = exports.ShutdownRequest = exports.InitializedNotification = exports.InitializeErrorCodes = exports.InitializeRequest = exports.WorkDoneProgressOptions = exports.TextDocumentRegistrationOptions = exports.StaticRegistrationOptions = exports.PositionEncodingKind = exports.FailureHandlingKind = exports.ResourceOperationKind = exports.UnregistrationRequest = exports.RegistrationRequest = exports.DocumentSelector = exports.NotebookCellTextDocumentFilter = exports.NotebookDocumentFilter = exports.TextDocumentFilter = void 0;
    exports.TypeHierarchySubtypesRequest = exports.TypeHierarchyPrepareRequest = exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.WillRenameFilesRequest = exports.DidRenameFilesNotification = exports.WillCreateFilesRequest = exports.DidCreateFilesNotification = exports.FileOperationPatternKind = exports.LinkedEditingRangeRequest = exports.ShowDocumentRequest = exports.SemanticTokensRegistrationType = exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.TokenFormat = exports.CallHierarchyPrepareRequest = exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = exports.SelectionRangeRequest = exports.DeclarationRequest = exports.FoldingRangeRequest = exports.ColorPresentationRequest = exports.DocumentColorRequest = exports.ConfigurationRequest = exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = exports.TypeDefinitionRequest = exports.ImplementationRequest = exports.ApplyWorkspaceEditRequest = exports.ExecuteCommandRequest = exports.PrepareRenameRequest = exports.RenameRequest = exports.PrepareSupportDefaultBehavior = exports.DocumentOnTypeFormattingRequest = exports.DocumentRangeFormattingRequest = exports.DocumentFormattingRequest = exports.DocumentLinkResolveRequest = exports.DocumentLinkRequest = exports.CodeLensRefreshRequest = exports.CodeLensResolveRequest = exports.CodeLensRequest = exports.WorkspaceSymbolResolveRequest = void 0;
    exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = exports.InlineValueRefreshRequest = exports.InlineValueRequest = exports.TypeHierarchySupertypesRequest = void 0;
    var messages_1 = require_messages2();
    var vscode_languageserver_types_1 = (init_main(), __toCommonJS(main_exports));
    var Is2 = require_is2();
    var protocol_implementation_1 = require_protocol_implementation();
    Object.defineProperty(exports, "ImplementationRequest", { enumerable: true, get: function() {
      return protocol_implementation_1.ImplementationRequest;
    } });
    var protocol_typeDefinition_1 = require_protocol_typeDefinition();
    Object.defineProperty(exports, "TypeDefinitionRequest", { enumerable: true, get: function() {
      return protocol_typeDefinition_1.TypeDefinitionRequest;
    } });
    var protocol_workspaceFolder_1 = require_protocol_workspaceFolder();
    Object.defineProperty(exports, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
    } });
    Object.defineProperty(exports, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
    } });
    var protocol_configuration_1 = require_protocol_configuration();
    Object.defineProperty(exports, "ConfigurationRequest", { enumerable: true, get: function() {
      return protocol_configuration_1.ConfigurationRequest;
    } });
    var protocol_colorProvider_1 = require_protocol_colorProvider();
    Object.defineProperty(exports, "DocumentColorRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.DocumentColorRequest;
    } });
    Object.defineProperty(exports, "ColorPresentationRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.ColorPresentationRequest;
    } });
    var protocol_foldingRange_1 = require_protocol_foldingRange();
    Object.defineProperty(exports, "FoldingRangeRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRequest;
    } });
    var protocol_declaration_1 = require_protocol_declaration();
    Object.defineProperty(exports, "DeclarationRequest", { enumerable: true, get: function() {
      return protocol_declaration_1.DeclarationRequest;
    } });
    var protocol_selectionRange_1 = require_protocol_selectionRange();
    Object.defineProperty(exports, "SelectionRangeRequest", { enumerable: true, get: function() {
      return protocol_selectionRange_1.SelectionRangeRequest;
    } });
    var protocol_progress_1 = require_protocol_progress();
    Object.defineProperty(exports, "WorkDoneProgress", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgress;
    } });
    Object.defineProperty(exports, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCreateRequest;
    } });
    Object.defineProperty(exports, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCancelNotification;
    } });
    var protocol_callHierarchy_1 = require_protocol_callHierarchy();
    Object.defineProperty(exports, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
    } });
    Object.defineProperty(exports, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
    } });
    Object.defineProperty(exports, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
    } });
    var protocol_semanticTokens_1 = require_protocol_semanticTokens();
    Object.defineProperty(exports, "TokenFormat", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.TokenFormat;
    } });
    Object.defineProperty(exports, "SemanticTokensRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRangeRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
    } });
    Object.defineProperty(exports, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRegistrationType;
    } });
    var protocol_showDocument_1 = require_protocol_showDocument();
    Object.defineProperty(exports, "ShowDocumentRequest", { enumerable: true, get: function() {
      return protocol_showDocument_1.ShowDocumentRequest;
    } });
    var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange();
    Object.defineProperty(exports, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
      return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
    } });
    var protocol_fileOperations_1 = require_protocol_fileOperations();
    Object.defineProperty(exports, "FileOperationPatternKind", { enumerable: true, get: function() {
      return protocol_fileOperations_1.FileOperationPatternKind;
    } });
    Object.defineProperty(exports, "DidCreateFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidCreateFilesNotification;
    } });
    Object.defineProperty(exports, "WillCreateFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillCreateFilesRequest;
    } });
    Object.defineProperty(exports, "DidRenameFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidRenameFilesNotification;
    } });
    Object.defineProperty(exports, "WillRenameFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillRenameFilesRequest;
    } });
    Object.defineProperty(exports, "DidDeleteFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidDeleteFilesNotification;
    } });
    Object.defineProperty(exports, "WillDeleteFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillDeleteFilesRequest;
    } });
    var protocol_moniker_1 = require_protocol_moniker();
    Object.defineProperty(exports, "UniquenessLevel", { enumerable: true, get: function() {
      return protocol_moniker_1.UniquenessLevel;
    } });
    Object.defineProperty(exports, "MonikerKind", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerKind;
    } });
    Object.defineProperty(exports, "MonikerRequest", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerRequest;
    } });
    var protocol_typeHierarchy_1 = require_protocol_typeHierarchy();
    Object.defineProperty(exports, "TypeHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
    } });
    Object.defineProperty(exports, "TypeHierarchySubtypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
    } });
    Object.defineProperty(exports, "TypeHierarchySupertypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
    } });
    var protocol_inlineValue_1 = require_protocol_inlineValue();
    Object.defineProperty(exports, "InlineValueRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRequest;
    } });
    Object.defineProperty(exports, "InlineValueRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRefreshRequest;
    } });
    var protocol_inlayHint_1 = require_protocol_inlayHint();
    Object.defineProperty(exports, "InlayHintRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRequest;
    } });
    Object.defineProperty(exports, "InlayHintResolveRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintResolveRequest;
    } });
    Object.defineProperty(exports, "InlayHintRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRefreshRequest;
    } });
    var protocol_diagnostic_1 = require_protocol_diagnostic();
    Object.defineProperty(exports, "DiagnosticServerCancellationData", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticServerCancellationData;
    } });
    Object.defineProperty(exports, "DocumentDiagnosticReportKind", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticReportKind;
    } });
    Object.defineProperty(exports, "DocumentDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticRequest;
    } });
    Object.defineProperty(exports, "WorkspaceDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
    } });
    Object.defineProperty(exports, "DiagnosticRefreshRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticRefreshRequest;
    } });
    var protocol_notebook_1 = require_protocol_notebook();
    Object.defineProperty(exports, "NotebookCellKind", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellKind;
    } });
    Object.defineProperty(exports, "ExecutionSummary", { enumerable: true, get: function() {
      return protocol_notebook_1.ExecutionSummary;
    } });
    Object.defineProperty(exports, "NotebookCell", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCell;
    } });
    Object.defineProperty(exports, "NotebookDocument", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocument;
    } });
    Object.defineProperty(exports, "NotebookDocumentSyncRegistrationType", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
    } });
    Object.defineProperty(exports, "DidOpenNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidOpenNotebookDocumentNotification;
    } });
    Object.defineProperty(exports, "NotebookCellArrayChange", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellArrayChange;
    } });
    Object.defineProperty(exports, "DidChangeNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidChangeNotebookDocumentNotification;
    } });
    Object.defineProperty(exports, "DidSaveNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidSaveNotebookDocumentNotification;
    } });
    Object.defineProperty(exports, "DidCloseNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidCloseNotebookDocumentNotification;
    } });
    var TextDocumentFilter2;
    (function(TextDocumentFilter3) {
      function is(value) {
        const candidate = value;
        return Is2.string(candidate.language) || Is2.string(candidate.scheme) || Is2.string(candidate.pattern);
      }
      TextDocumentFilter3.is = is;
    })(TextDocumentFilter2 = exports.TextDocumentFilter || (exports.TextDocumentFilter = {}));
    var NotebookDocumentFilter;
    (function(NotebookDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && (Is2.string(candidate.notebookType) || Is2.string(candidate.scheme) || Is2.string(candidate.pattern));
      }
      NotebookDocumentFilter2.is = is;
    })(NotebookDocumentFilter = exports.NotebookDocumentFilter || (exports.NotebookDocumentFilter = {}));
    var NotebookCellTextDocumentFilter;
    (function(NotebookCellTextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && (Is2.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === void 0 || Is2.string(candidate.language));
      }
      NotebookCellTextDocumentFilter2.is = is;
    })(NotebookCellTextDocumentFilter = exports.NotebookCellTextDocumentFilter || (exports.NotebookCellTextDocumentFilter = {}));
    var DocumentSelector41;
    (function(DocumentSelector42) {
      function is(value) {
        if (!Array.isArray(value)) {
          return false;
        }
        for (let elem of value) {
          if (!Is2.string(elem) && !TextDocumentFilter2.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
            return false;
          }
        }
        return true;
      }
      DocumentSelector42.is = is;
    })(DocumentSelector41 = exports.DocumentSelector || (exports.DocumentSelector = {}));
    var RegistrationRequest2;
    (function(RegistrationRequest3) {
      RegistrationRequest3.method = "client/registerCapability";
      RegistrationRequest3.messageDirection = messages_1.MessageDirection.serverToClient;
      RegistrationRequest3.type = new messages_1.ProtocolRequestType(RegistrationRequest3.method);
    })(RegistrationRequest2 = exports.RegistrationRequest || (exports.RegistrationRequest = {}));
    var UnregistrationRequest2;
    (function(UnregistrationRequest3) {
      UnregistrationRequest3.method = "client/unregisterCapability";
      UnregistrationRequest3.messageDirection = messages_1.MessageDirection.serverToClient;
      UnregistrationRequest3.type = new messages_1.ProtocolRequestType(UnregistrationRequest3.method);
    })(UnregistrationRequest2 = exports.UnregistrationRequest || (exports.UnregistrationRequest = {}));
    var ResourceOperationKind2;
    (function(ResourceOperationKind3) {
      ResourceOperationKind3.Create = "create";
      ResourceOperationKind3.Rename = "rename";
      ResourceOperationKind3.Delete = "delete";
    })(ResourceOperationKind2 = exports.ResourceOperationKind || (exports.ResourceOperationKind = {}));
    var FailureHandlingKind2;
    (function(FailureHandlingKind3) {
      FailureHandlingKind3.Abort = "abort";
      FailureHandlingKind3.Transactional = "transactional";
      FailureHandlingKind3.TextOnlyTransactional = "textOnlyTransactional";
      FailureHandlingKind3.Undo = "undo";
    })(FailureHandlingKind2 = exports.FailureHandlingKind || (exports.FailureHandlingKind = {}));
    var PositionEncodingKind2;
    (function(PositionEncodingKind3) {
      PositionEncodingKind3.UTF8 = "utf-8";
      PositionEncodingKind3.UTF16 = "utf-16";
      PositionEncodingKind3.UTF32 = "utf-32";
    })(PositionEncodingKind2 = exports.PositionEncodingKind || (exports.PositionEncodingKind = {}));
    var StaticRegistrationOptions2;
    (function(StaticRegistrationOptions3) {
      function hasId(value) {
        const candidate = value;
        return candidate && Is2.string(candidate.id) && candidate.id.length > 0;
      }
      StaticRegistrationOptions3.hasId = hasId;
    })(StaticRegistrationOptions2 = exports.StaticRegistrationOptions || (exports.StaticRegistrationOptions = {}));
    var TextDocumentRegistrationOptions7;
    (function(TextDocumentRegistrationOptions8) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector41.is(candidate.documentSelector));
      }
      TextDocumentRegistrationOptions8.is = is;
    })(TextDocumentRegistrationOptions7 = exports.TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = {}));
    var WorkDoneProgressOptions2;
    (function(WorkDoneProgressOptions3) {
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is2.boolean(candidate.workDoneProgress));
      }
      WorkDoneProgressOptions3.is = is;
      function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is2.boolean(candidate.workDoneProgress);
      }
      WorkDoneProgressOptions3.hasWorkDoneProgress = hasWorkDoneProgress;
    })(WorkDoneProgressOptions2 = exports.WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = {}));
    var InitializeRequest2;
    (function(InitializeRequest3) {
      InitializeRequest3.method = "initialize";
      InitializeRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializeRequest3.type = new messages_1.ProtocolRequestType(InitializeRequest3.method);
    })(InitializeRequest2 = exports.InitializeRequest || (exports.InitializeRequest = {}));
    var InitializeErrorCodes;
    (function(InitializeErrorCodes2) {
      InitializeErrorCodes2.unknownProtocolVersion = 1;
    })(InitializeErrorCodes = exports.InitializeErrorCodes || (exports.InitializeErrorCodes = {}));
    var InitializedNotification2;
    (function(InitializedNotification3) {
      InitializedNotification3.method = "initialized";
      InitializedNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      InitializedNotification3.type = new messages_1.ProtocolNotificationType(InitializedNotification3.method);
    })(InitializedNotification2 = exports.InitializedNotification || (exports.InitializedNotification = {}));
    var ShutdownRequest2;
    (function(ShutdownRequest3) {
      ShutdownRequest3.method = "shutdown";
      ShutdownRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      ShutdownRequest3.type = new messages_1.ProtocolRequestType0(ShutdownRequest3.method);
    })(ShutdownRequest2 = exports.ShutdownRequest || (exports.ShutdownRequest = {}));
    var ExitNotification2;
    (function(ExitNotification3) {
      ExitNotification3.method = "exit";
      ExitNotification3.messageDirection = messages_1.MessageDirection.clientToServer;
      ExitNotification3.type = new messages_1.ProtocolNotificationType0(ExitNotification3.method);
    })(ExitNotification2 = exports.ExitNotification || (exports.ExitNotification = {}));
    var DidChangeConfigurationNotification3;
    (function(DidChangeConfigurationNotification4) {
      DidChangeConfigurationNotification4.method = "workspace/didChangeConfiguration";
      DidChangeConfigurationNotification4.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeConfigurationNotification4.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification4.method);
    })(DidChangeConfigurationNotification3 = exports.DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = {}));
    var MessageType2;
    (function(MessageType3) {
      MessageType3.Error = 1;
      MessageType3.Warning = 2;
      MessageType3.Info = 3;
      MessageType3.Log = 4;
    })(MessageType2 = exports.MessageType || (exports.MessageType = {}));
    var ShowMessageNotification2;
    (function(ShowMessageNotification3) {
      ShowMessageNotification3.method = "window/showMessage";
      ShowMessageNotification3.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageNotification3.type = new messages_1.ProtocolNotificationType(ShowMessageNotification3.method);
    })(ShowMessageNotification2 = exports.ShowMessageNotification || (exports.ShowMessageNotification = {}));
    var ShowMessageRequest2;
    (function(ShowMessageRequest3) {
      ShowMessageRequest3.method = "window/showMessageRequest";
      ShowMessageRequest3.messageDirection = messages_1.MessageDirection.serverToClient;
      ShowMessageRequest3.type = new messages_1.ProtocolRequestType(ShowMessageRequest3.method);
    })(ShowMessageRequest2 = exports.ShowMessageRequest || (exports.ShowMessageRequest = {}));
    var LogMessageNotification2;
    (function(LogMessageNotification3) {
      LogMessageNotification3.method = "window/logMessage";
      LogMessageNotification3.messageDirection = messages_1.MessageDirection.serverToClient;
      LogMessageNotification3.type = new messages_1.ProtocolNotificationType(LogMessageNotification3.method);
    })(LogMessageNotification2 = exports.LogMessageNotification || (exports.LogMessageNotification = {}));
    var TelemetryEventNotification2;
    (function(TelemetryEventNotification3) {
      TelemetryEventNotification3.method = "telemetry/event";
      TelemetryEventNotification3.messageDirection = messages_1.MessageDirection.serverToClient;
      TelemetryEventNotification3.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification3.method);
    })(TelemetryEventNotification2 = exports.TelemetryEventNotification || (exports.TelemetryEventNotification = {}));
    var TextDocumentSyncKind3;
    (function(TextDocumentSyncKind4) {
      TextDocumentSyncKind4.None = 0;
      TextDocumentSyncKind4.Full = 1;
      TextDocumentSyncKind4.Incremental = 2;
    })(TextDocumentSyncKind3 = exports.TextDocumentSyncKind || (exports.TextDocumentSyncKind = {}));
    var DidOpenTextDocumentNotification5;
    (function(DidOpenTextDocumentNotification6) {
      DidOpenTextDocumentNotification6.method = "textDocument/didOpen";
      DidOpenTextDocumentNotification6.messageDirection = messages_1.MessageDirection.clientToServer;
      DidOpenTextDocumentNotification6.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification6.method);
    })(DidOpenTextDocumentNotification5 = exports.DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = {}));
    var TextDocumentContentChangeEvent;
    (function(TextDocumentContentChangeEvent2) {
      function isIncremental(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      TextDocumentContentChangeEvent2.isIncremental = isIncremental;
      function isFull(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
      TextDocumentContentChangeEvent2.isFull = isFull;
    })(TextDocumentContentChangeEvent = exports.TextDocumentContentChangeEvent || (exports.TextDocumentContentChangeEvent = {}));
    var DidChangeTextDocumentNotification5;
    (function(DidChangeTextDocumentNotification6) {
      DidChangeTextDocumentNotification6.method = "textDocument/didChange";
      DidChangeTextDocumentNotification6.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeTextDocumentNotification6.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification6.method);
    })(DidChangeTextDocumentNotification5 = exports.DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = {}));
    var DidCloseTextDocumentNotification5;
    (function(DidCloseTextDocumentNotification6) {
      DidCloseTextDocumentNotification6.method = "textDocument/didClose";
      DidCloseTextDocumentNotification6.messageDirection = messages_1.MessageDirection.clientToServer;
      DidCloseTextDocumentNotification6.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification6.method);
    })(DidCloseTextDocumentNotification5 = exports.DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = {}));
    var DidSaveTextDocumentNotification5;
    (function(DidSaveTextDocumentNotification6) {
      DidSaveTextDocumentNotification6.method = "textDocument/didSave";
      DidSaveTextDocumentNotification6.messageDirection = messages_1.MessageDirection.clientToServer;
      DidSaveTextDocumentNotification6.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification6.method);
    })(DidSaveTextDocumentNotification5 = exports.DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = {}));
    var TextDocumentSaveReason2;
    (function(TextDocumentSaveReason3) {
      TextDocumentSaveReason3.Manual = 1;
      TextDocumentSaveReason3.AfterDelay = 2;
      TextDocumentSaveReason3.FocusOut = 3;
    })(TextDocumentSaveReason2 = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));
    var WillSaveTextDocumentNotification4;
    (function(WillSaveTextDocumentNotification5) {
      WillSaveTextDocumentNotification5.method = "textDocument/willSave";
      WillSaveTextDocumentNotification5.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentNotification5.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification5.method);
    })(WillSaveTextDocumentNotification4 = exports.WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = {}));
    var WillSaveTextDocumentWaitUntilRequest4;
    (function(WillSaveTextDocumentWaitUntilRequest5) {
      WillSaveTextDocumentWaitUntilRequest5.method = "textDocument/willSaveWaitUntil";
      WillSaveTextDocumentWaitUntilRequest5.messageDirection = messages_1.MessageDirection.clientToServer;
      WillSaveTextDocumentWaitUntilRequest5.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest5.method);
    })(WillSaveTextDocumentWaitUntilRequest4 = exports.WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = {}));
    var DidChangeWatchedFilesNotification4;
    (function(DidChangeWatchedFilesNotification5) {
      DidChangeWatchedFilesNotification5.method = "workspace/didChangeWatchedFiles";
      DidChangeWatchedFilesNotification5.messageDirection = messages_1.MessageDirection.clientToServer;
      DidChangeWatchedFilesNotification5.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification5.method);
    })(DidChangeWatchedFilesNotification4 = exports.DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = {}));
    var FileChangeType2;
    (function(FileChangeType3) {
      FileChangeType3.Created = 1;
      FileChangeType3.Changed = 2;
      FileChangeType3.Deleted = 3;
    })(FileChangeType2 = exports.FileChangeType || (exports.FileChangeType = {}));
    var RelativePattern3;
    (function(RelativePattern4) {
      function is(value) {
        const candidate = value;
        return Is2.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is2.string(candidate.pattern);
      }
      RelativePattern4.is = is;
    })(RelativePattern3 = exports.RelativePattern || (exports.RelativePattern = {}));
    var WatchKind2;
    (function(WatchKind3) {
      WatchKind3.Create = 1;
      WatchKind3.Change = 2;
      WatchKind3.Delete = 4;
    })(WatchKind2 = exports.WatchKind || (exports.WatchKind = {}));
    var PublishDiagnosticsNotification2;
    (function(PublishDiagnosticsNotification3) {
      PublishDiagnosticsNotification3.method = "textDocument/publishDiagnostics";
      PublishDiagnosticsNotification3.messageDirection = messages_1.MessageDirection.serverToClient;
      PublishDiagnosticsNotification3.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification3.method);
    })(PublishDiagnosticsNotification2 = exports.PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = {}));
    var CompletionTriggerKind2;
    (function(CompletionTriggerKind3) {
      CompletionTriggerKind3.Invoked = 1;
      CompletionTriggerKind3.TriggerCharacter = 2;
      CompletionTriggerKind3.TriggerForIncompleteCompletions = 3;
    })(CompletionTriggerKind2 = exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));
    var CompletionRequest4;
    (function(CompletionRequest5) {
      CompletionRequest5.method = "textDocument/completion";
      CompletionRequest5.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionRequest5.type = new messages_1.ProtocolRequestType(CompletionRequest5.method);
    })(CompletionRequest4 = exports.CompletionRequest || (exports.CompletionRequest = {}));
    var CompletionResolveRequest2;
    (function(CompletionResolveRequest3) {
      CompletionResolveRequest3.method = "completionItem/resolve";
      CompletionResolveRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      CompletionResolveRequest3.type = new messages_1.ProtocolRequestType(CompletionResolveRequest3.method);
    })(CompletionResolveRequest2 = exports.CompletionResolveRequest || (exports.CompletionResolveRequest = {}));
    var HoverRequest4;
    (function(HoverRequest5) {
      HoverRequest5.method = "textDocument/hover";
      HoverRequest5.messageDirection = messages_1.MessageDirection.clientToServer;
      HoverRequest5.type = new messages_1.ProtocolRequestType(HoverRequest5.method);
    })(HoverRequest4 = exports.HoverRequest || (exports.HoverRequest = {}));
    var SignatureHelpTriggerKind2;
    (function(SignatureHelpTriggerKind3) {
      SignatureHelpTriggerKind3.Invoked = 1;
      SignatureHelpTriggerKind3.TriggerCharacter = 2;
      SignatureHelpTriggerKind3.ContentChange = 3;
    })(SignatureHelpTriggerKind2 = exports.SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = {}));
    var SignatureHelpRequest4;
    (function(SignatureHelpRequest5) {
      SignatureHelpRequest5.method = "textDocument/signatureHelp";
      SignatureHelpRequest5.messageDirection = messages_1.MessageDirection.clientToServer;
      SignatureHelpRequest5.type = new messages_1.ProtocolRequestType(SignatureHelpRequest5.method);
    })(SignatureHelpRequest4 = exports.SignatureHelpRequest || (exports.SignatureHelpRequest = {}));
    var DefinitionRequest4;
    (function(DefinitionRequest5) {
      DefinitionRequest5.method = "textDocument/definition";
      DefinitionRequest5.messageDirection = messages_1.MessageDirection.clientToServer;
      DefinitionRequest5.type = new messages_1.ProtocolRequestType(DefinitionRequest5.method);
    })(DefinitionRequest4 = exports.DefinitionRequest || (exports.DefinitionRequest = {}));
    var ReferencesRequest4;
    (function(ReferencesRequest5) {
      ReferencesRequest5.method = "textDocument/references";
      ReferencesRequest5.messageDirection = messages_1.MessageDirection.clientToServer;
      ReferencesRequest5.type = new messages_1.ProtocolRequestType(ReferencesRequest5.method);
    })(ReferencesRequest4 = exports.ReferencesRequest || (exports.ReferencesRequest = {}));
    var DocumentHighlightRequest4;
    (function(DocumentHighlightRequest5) {
      DocumentHighlightRequest5.method = "textDocument/documentHighlight";
      DocumentHighlightRequest5.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentHighlightRequest5.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest5.method);
    })(DocumentHighlightRequest4 = exports.DocumentHighlightRequest || (exports.DocumentHighlightRequest = {}));
    var DocumentSymbolRequest4;
    (function(DocumentSymbolRequest5) {
      DocumentSymbolRequest5.method = "textDocument/documentSymbol";
      DocumentSymbolRequest5.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentSymbolRequest5.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest5.method);
    })(DocumentSymbolRequest4 = exports.DocumentSymbolRequest || (exports.DocumentSymbolRequest = {}));
    var CodeActionRequest4;
    (function(CodeActionRequest5) {
      CodeActionRequest5.method = "textDocument/codeAction";
      CodeActionRequest5.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionRequest5.type = new messages_1.ProtocolRequestType(CodeActionRequest5.method);
    })(CodeActionRequest4 = exports.CodeActionRequest || (exports.CodeActionRequest = {}));
    var CodeActionResolveRequest2;
    (function(CodeActionResolveRequest3) {
      CodeActionResolveRequest3.method = "codeAction/resolve";
      CodeActionResolveRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeActionResolveRequest3.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest3.method);
    })(CodeActionResolveRequest2 = exports.CodeActionResolveRequest || (exports.CodeActionResolveRequest = {}));
    var WorkspaceSymbolRequest4;
    (function(WorkspaceSymbolRequest5) {
      WorkspaceSymbolRequest5.method = "workspace/symbol";
      WorkspaceSymbolRequest5.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolRequest5.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest5.method);
    })(WorkspaceSymbolRequest4 = exports.WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = {}));
    var WorkspaceSymbolResolveRequest2;
    (function(WorkspaceSymbolResolveRequest3) {
      WorkspaceSymbolResolveRequest3.method = "workspaceSymbol/resolve";
      WorkspaceSymbolResolveRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      WorkspaceSymbolResolveRequest3.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest3.method);
    })(WorkspaceSymbolResolveRequest2 = exports.WorkspaceSymbolResolveRequest || (exports.WorkspaceSymbolResolveRequest = {}));
    var CodeLensRequest4;
    (function(CodeLensRequest5) {
      CodeLensRequest5.method = "textDocument/codeLens";
      CodeLensRequest5.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensRequest5.type = new messages_1.ProtocolRequestType(CodeLensRequest5.method);
    })(CodeLensRequest4 = exports.CodeLensRequest || (exports.CodeLensRequest = {}));
    var CodeLensResolveRequest2;
    (function(CodeLensResolveRequest3) {
      CodeLensResolveRequest3.method = "codeLens/resolve";
      CodeLensResolveRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      CodeLensResolveRequest3.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest3.method);
    })(CodeLensResolveRequest2 = exports.CodeLensResolveRequest || (exports.CodeLensResolveRequest = {}));
    var CodeLensRefreshRequest2;
    (function(CodeLensRefreshRequest3) {
      CodeLensRefreshRequest3.method = `workspace/codeLens/refresh`;
      CodeLensRefreshRequest3.messageDirection = messages_1.MessageDirection.serverToClient;
      CodeLensRefreshRequest3.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest3.method);
    })(CodeLensRefreshRequest2 = exports.CodeLensRefreshRequest || (exports.CodeLensRefreshRequest = {}));
    var DocumentLinkRequest4;
    (function(DocumentLinkRequest5) {
      DocumentLinkRequest5.method = "textDocument/documentLink";
      DocumentLinkRequest5.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkRequest5.type = new messages_1.ProtocolRequestType(DocumentLinkRequest5.method);
    })(DocumentLinkRequest4 = exports.DocumentLinkRequest || (exports.DocumentLinkRequest = {}));
    var DocumentLinkResolveRequest2;
    (function(DocumentLinkResolveRequest3) {
      DocumentLinkResolveRequest3.method = "documentLink/resolve";
      DocumentLinkResolveRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentLinkResolveRequest3.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest3.method);
    })(DocumentLinkResolveRequest2 = exports.DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = {}));
    var DocumentFormattingRequest4;
    (function(DocumentFormattingRequest5) {
      DocumentFormattingRequest5.method = "textDocument/formatting";
      DocumentFormattingRequest5.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentFormattingRequest5.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest5.method);
    })(DocumentFormattingRequest4 = exports.DocumentFormattingRequest || (exports.DocumentFormattingRequest = {}));
    var DocumentRangeFormattingRequest4;
    (function(DocumentRangeFormattingRequest5) {
      DocumentRangeFormattingRequest5.method = "textDocument/rangeFormatting";
      DocumentRangeFormattingRequest5.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentRangeFormattingRequest5.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest5.method);
    })(DocumentRangeFormattingRequest4 = exports.DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = {}));
    var DocumentOnTypeFormattingRequest4;
    (function(DocumentOnTypeFormattingRequest5) {
      DocumentOnTypeFormattingRequest5.method = "textDocument/onTypeFormatting";
      DocumentOnTypeFormattingRequest5.messageDirection = messages_1.MessageDirection.clientToServer;
      DocumentOnTypeFormattingRequest5.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest5.method);
    })(DocumentOnTypeFormattingRequest4 = exports.DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = {}));
    var PrepareSupportDefaultBehavior2;
    (function(PrepareSupportDefaultBehavior3) {
      PrepareSupportDefaultBehavior3.Identifier = 1;
    })(PrepareSupportDefaultBehavior2 = exports.PrepareSupportDefaultBehavior || (exports.PrepareSupportDefaultBehavior = {}));
    var RenameRequest4;
    (function(RenameRequest5) {
      RenameRequest5.method = "textDocument/rename";
      RenameRequest5.messageDirection = messages_1.MessageDirection.clientToServer;
      RenameRequest5.type = new messages_1.ProtocolRequestType(RenameRequest5.method);
    })(RenameRequest4 = exports.RenameRequest || (exports.RenameRequest = {}));
    var PrepareRenameRequest2;
    (function(PrepareRenameRequest3) {
      PrepareRenameRequest3.method = "textDocument/prepareRename";
      PrepareRenameRequest3.messageDirection = messages_1.MessageDirection.clientToServer;
      PrepareRenameRequest3.type = new messages_1.ProtocolRequestType(PrepareRenameRequest3.method);
    })(PrepareRenameRequest2 = exports.PrepareRenameRequest || (exports.PrepareRenameRequest = {}));
    var ExecuteCommandRequest5;
    (function(ExecuteCommandRequest6) {
      ExecuteCommandRequest6.method = "workspace/executeCommand";
      ExecuteCommandRequest6.messageDirection = messages_1.MessageDirection.clientToServer;
      ExecuteCommandRequest6.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest6.method);
    })(ExecuteCommandRequest5 = exports.ExecuteCommandRequest || (exports.ExecuteCommandRequest = {}));
    var ApplyWorkspaceEditRequest2;
    (function(ApplyWorkspaceEditRequest3) {
      ApplyWorkspaceEditRequest3.method = "workspace/applyEdit";
      ApplyWorkspaceEditRequest3.messageDirection = messages_1.MessageDirection.serverToClient;
      ApplyWorkspaceEditRequest3.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
    })(ApplyWorkspaceEditRequest2 = exports.ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/connection.js
var require_connection3 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/connection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createProtocolConnection = void 0;
    var vscode_jsonrpc_1 = require_main();
    function createProtocolConnection2(input, output, logger138, options2) {
      if (vscode_jsonrpc_1.ConnectionStrategy.is(options2)) {
        options2 = { connectionStrategy: options2 };
      }
      return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger138, options2);
    }
    exports.createProtocolConnection = createProtocolConnection2;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/api.js
var require_api3 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/api.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LSPErrorCodes = exports.createProtocolConnection = void 0;
    __exportStar(require_main(), exports);
    __exportStar((init_main(), __toCommonJS(main_exports)), exports);
    __exportStar(require_messages2(), exports);
    __exportStar(require_protocol(), exports);
    var connection_1 = require_connection3();
    Object.defineProperty(exports, "createProtocolConnection", { enumerable: true, get: function() {
      return connection_1.createProtocolConnection;
    } });
    var LSPErrorCodes2;
    (function(LSPErrorCodes3) {
      LSPErrorCodes3.lspReservedErrorRangeStart = -32899;
      LSPErrorCodes3.RequestFailed = -32803;
      LSPErrorCodes3.ServerCancelled = -32802;
      LSPErrorCodes3.ContentModified = -32801;
      LSPErrorCodes3.RequestCancelled = -32800;
      LSPErrorCodes3.lspReservedErrorRangeEnd = -32800;
    })(LSPErrorCodes2 = exports.LSPErrorCodes || (exports.LSPErrorCodes = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/node/main.js
var require_main2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/node/main.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createProtocolConnection = void 0;
    var node_1 = require_node2();
    __exportStar(require_node2(), exports);
    __exportStar(require_api3(), exports);
    function createProtocolConnection2(input, output, logger138, options2) {
      return (0, node_1.createMessageConnection)(input, output, logger138, options2);
    }
    exports.createProtocolConnection = createProtocolConnection2;
  }
});

// node_modules/debounce/index.js
var require_debounce = __commonJS({
  "node_modules/debounce/index.js"(exports, module2) {
    function debounce17(func2, wait2, immediate) {
      var timeout, args, context, timestamp, result;
      if (wait2 == null)
        wait2 = 100;
      function later() {
        var last = Date.now() - timestamp;
        if (last < wait2 && last >= 0) {
          timeout = setTimeout(later, wait2 - last);
        } else {
          timeout = null;
          if (!immediate) {
            result = func2.apply(context, args);
            context = args = null;
          }
        }
      }
      ;
      var debounced = function() {
        context = this;
        args = arguments;
        timestamp = Date.now();
        var callNow = immediate && !timeout;
        if (!timeout)
          timeout = setTimeout(later, wait2);
        if (callNow) {
          result = func2.apply(context, args);
          context = args = null;
        }
        return result;
      };
      debounced.clear = function() {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
      };
      debounced.flush = function() {
        if (timeout) {
          result = func2.apply(context, args);
          context = args = null;
          clearTimeout(timeout);
          timeout = null;
        }
      };
      return debounced;
    }
    debounce17.debounce = debounce17;
    module2.exports = debounce17;
  }
});

// node_modules/rfc-3986/index.js
var require_rfc_3986 = __commonJS({
  "node_modules/rfc-3986/index.js"(exports, module2) {
    "use strict";
    var internals = {
      rfc3986: {}
    };
    internals.generate = function() {
      var or = "|";
      var digit = "0-9";
      var digitOnly = "[" + digit + "]";
      var alpha = "a-zA-Z";
      var alphaOnly = "[" + alpha + "]";
      internals.rfc3986.cidr = digitOnly + or + "[1-2]" + digitOnly + or + "3[0-2]";
      var hexDigit = digit + "A-Fa-f";
      var hexDigitOnly = "[" + hexDigit + "]";
      var unreserved = alpha + digit + "-\\._~";
      var subDelims = "!\\$&'\\(\\)\\*\\+,;=";
      var pctEncoded = "%" + hexDigit;
      var pchar = unreserved + pctEncoded + subDelims + ":@";
      var pcharOnly = "[" + pchar + "]";
      var zeroPad = "0?";
      var decOctect = "(?:" + zeroPad + zeroPad + digitOnly + or + zeroPad + "[1-9]" + digitOnly + or + "1" + digitOnly + digitOnly + or + "2[0-4]" + digitOnly + or + "25[0-5])";
      internals.rfc3986.IPv4address = "(?:" + decOctect + "\\.){3}" + decOctect;
      var h16 = hexDigitOnly + "{1,4}";
      var ls32 = "(?:" + h16 + ":" + h16 + "|" + internals.rfc3986.IPv4address + ")";
      var IPv6SixHex = "(?:" + h16 + ":){6}" + ls32;
      var IPv6FiveHex = "::(?:" + h16 + ":){5}" + ls32;
      var IPv6FourHex = "(?:" + h16 + ")?::(?:" + h16 + ":){4}" + ls32;
      var IPv6ThreeHex = "(?:(?:" + h16 + ":){0,1}" + h16 + ")?::(?:" + h16 + ":){3}" + ls32;
      var IPv6TwoHex = "(?:(?:" + h16 + ":){0,2}" + h16 + ")?::(?:" + h16 + ":){2}" + ls32;
      var IPv6OneHex = "(?:(?:" + h16 + ":){0,3}" + h16 + ")?::" + h16 + ":" + ls32;
      var IPv6NoneHex = "(?:(?:" + h16 + ":){0,4}" + h16 + ")?::" + ls32;
      var IPv6NoneHex2 = "(?:(?:" + h16 + ":){0,5}" + h16 + ")?::" + h16;
      var IPv6NoneHex3 = "(?:(?:" + h16 + ":){0,6}" + h16 + ")?::";
      internals.rfc3986.IPv6address = "(?:" + IPv6SixHex + or + IPv6FiveHex + or + IPv6FourHex + or + IPv6ThreeHex + or + IPv6TwoHex + or + IPv6OneHex + or + IPv6NoneHex + or + IPv6NoneHex2 + or + IPv6NoneHex3 + ")";
      internals.rfc3986.IPvFuture = "v" + hexDigitOnly + "+\\.[" + unreserved + subDelims + ":]+";
      internals.rfc3986.scheme = alphaOnly + "[" + alpha + digit + "+-\\.]*";
      var userinfo = "[" + unreserved + pctEncoded + subDelims + ":]*";
      internals.rfc3986.IPLiteral = "\\[(?:" + internals.rfc3986.IPv6address + or + internals.rfc3986.IPvFuture + ")\\]";
      var regName = "[" + unreserved + pctEncoded + subDelims + "]{0,255}";
      var host = "(?:" + internals.rfc3986.IPLiteral + or + internals.rfc3986.IPv4address + or + regName + ")";
      var port = digitOnly + "*";
      var authority = "(?:" + userinfo + "@)?" + host + "(?::" + port + ")?";
      var segment = pcharOnly + "*";
      var segmentNz = pcharOnly + "+";
      var pathAbEmpty = "(?:\\/" + segment + ")*";
      var pathAbsolute = "\\/(?:" + segmentNz + pathAbEmpty + ")?";
      var pathRootless = segmentNz + pathAbEmpty;
      internals.rfc3986.hierPart = "(?:(?:\\/\\/" + authority + pathAbEmpty + ")" + or + pathAbsolute + or + pathRootless + ")";
      internals.rfc3986.query = "[" + pchar + "\\/\\?]*(?=#|$)";
      internals.rfc3986.fragment = "[" + pchar + "\\/\\?]*";
      internals.rfc3986.uri = "^(?:" + internals.rfc3986.scheme + ":" + internals.rfc3986.hierPart + ")(?:\\?" + internals.rfc3986.query + ")?(?:#" + internals.rfc3986.fragment + ")?$";
    };
    internals.generate();
    module2.exports = internals.rfc3986;
  }
});

// node_modules/isuri/index.js
var require_isuri = __commonJS({
  "node_modules/isuri/index.js"(exports, module2) {
    "use strict";
    var rfc3986 = require_rfc_3986();
    function escapeRegex(string2) {
      return string2.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g, "\\$&");
    }
    var internals = {
      Uri: {
        createUriRegex: function(options2) {
          options2 = options2 || {};
          if (typeof options2 !== "object" || Array.isArray(options2)) {
            throw new Error("options must be an object");
          }
          var customScheme = "";
          if (options2.scheme) {
            if (!Array.isArray(options2.scheme)) {
              options2.scheme = [options2.scheme];
            }
            if (options2.scheme.length <= 0) {
              throw new Error("scheme must have at least 1 scheme specified");
            }
            for (var i = 0; i < options2.scheme.length; ++i) {
              var currentScheme = options2.scheme[i];
              if (!(currentScheme instanceof RegExp || typeof currentScheme === "string")) {
                throw new Error("scheme must only contain Regular Expressions or Strings");
              }
              customScheme = customScheme + (customScheme ? "|" : "");
              if (currentScheme instanceof RegExp) {
                customScheme = customScheme + currentScheme.source;
              } else {
                if (!/[a-zA-Z][a-zA-Z0-9+-\.]*/.test(currentScheme)) {
                  throw new Error("scheme at position " + i + " must be a valid scheme");
                }
                customScheme = customScheme + escapeRegex(currentScheme);
              }
            }
          }
          var scheme = "(?:" + (customScheme || rfc3986.scheme) + ")";
          return new RegExp("^(?:" + scheme + ":" + rfc3986.hierPart + ")(?:\\?" + rfc3986.query + ")?(?:#" + rfc3986.fragment + ")?$");
        },
        uriRegex: new RegExp(rfc3986.uri)
      }
    };
    internals.Uri.isValid = function(val) {
      return internals.Uri.uriRegex.test(val);
    };
    module2.exports = {
      createUriRegex: internals.Uri.createUriRegex,
      uriRegex: internals.Uri.uriRegex,
      isValid: internals.Uri.isValid
    };
  }
});

// node_modules/vscode-uri/lib/esm/index.js
var LIB, URI2, Utils;
var init_esm = __esm({
  "node_modules/vscode-uri/lib/esm/index.js"() {
    LIB = (() => {
      "use strict";
      var t = { 470: (t2) => {
        function e2(t3) {
          if (typeof t3 != "string")
            throw new TypeError("Path must be a string. Received " + JSON.stringify(t3));
        }
        function r2(t3, e3) {
          for (var r3, n2 = "", o = 0, i = -1, a = 0, h = 0; h <= t3.length; ++h) {
            if (h < t3.length)
              r3 = t3.charCodeAt(h);
            else {
              if (r3 === 47)
                break;
              r3 = 47;
            }
            if (r3 === 47) {
              if (i === h - 1 || a === 1)
                ;
              else if (i !== h - 1 && a === 2) {
                if (n2.length < 2 || o !== 2 || n2.charCodeAt(n2.length - 1) !== 46 || n2.charCodeAt(n2.length - 2) !== 46) {
                  if (n2.length > 2) {
                    var s = n2.lastIndexOf("/");
                    if (s !== n2.length - 1) {
                      s === -1 ? (n2 = "", o = 0) : o = (n2 = n2.slice(0, s)).length - 1 - n2.lastIndexOf("/"), i = h, a = 0;
                      continue;
                    }
                  } else if (n2.length === 2 || n2.length === 1) {
                    n2 = "", o = 0, i = h, a = 0;
                    continue;
                  }
                }
                e3 && (n2.length > 0 ? n2 += "/.." : n2 = "..", o = 2);
              } else
                n2.length > 0 ? n2 += "/" + t3.slice(i + 1, h) : n2 = t3.slice(i + 1, h), o = h - i - 1;
              i = h, a = 0;
            } else
              r3 === 46 && a !== -1 ? ++a : a = -1;
          }
          return n2;
        }
        var n = { resolve: function() {
          for (var t3, n2 = "", o = false, i = arguments.length - 1; i >= -1 && !o; i--) {
            var a;
            i >= 0 ? a = arguments[i] : (t3 === void 0 && (t3 = process.cwd()), a = t3), e2(a), a.length !== 0 && (n2 = a + "/" + n2, o = a.charCodeAt(0) === 47);
          }
          return n2 = r2(n2, !o), o ? n2.length > 0 ? "/" + n2 : "/" : n2.length > 0 ? n2 : ".";
        }, normalize: function(t3) {
          if (e2(t3), t3.length === 0)
            return ".";
          var n2 = t3.charCodeAt(0) === 47, o = t3.charCodeAt(t3.length - 1) === 47;
          return (t3 = r2(t3, !n2)).length !== 0 || n2 || (t3 = "."), t3.length > 0 && o && (t3 += "/"), n2 ? "/" + t3 : t3;
        }, isAbsolute: function(t3) {
          return e2(t3), t3.length > 0 && t3.charCodeAt(0) === 47;
        }, join: function() {
          if (arguments.length === 0)
            return ".";
          for (var t3, r3 = 0; r3 < arguments.length; ++r3) {
            var o = arguments[r3];
            e2(o), o.length > 0 && (t3 === void 0 ? t3 = o : t3 += "/" + o);
          }
          return t3 === void 0 ? "." : n.normalize(t3);
        }, relative: function(t3, r3) {
          if (e2(t3), e2(r3), t3 === r3)
            return "";
          if ((t3 = n.resolve(t3)) === (r3 = n.resolve(r3)))
            return "";
          for (var o = 1; o < t3.length && t3.charCodeAt(o) === 47; ++o)
            ;
          for (var i = t3.length, a = i - o, h = 1; h < r3.length && r3.charCodeAt(h) === 47; ++h)
            ;
          for (var s = r3.length - h, c = a < s ? a : s, f = -1, u = 0; u <= c; ++u) {
            if (u === c) {
              if (s > c) {
                if (r3.charCodeAt(h + u) === 47)
                  return r3.slice(h + u + 1);
                if (u === 0)
                  return r3.slice(h + u);
              } else
                a > c && (t3.charCodeAt(o + u) === 47 ? f = u : u === 0 && (f = 0));
              break;
            }
            var l = t3.charCodeAt(o + u);
            if (l !== r3.charCodeAt(h + u))
              break;
            l === 47 && (f = u);
          }
          var p = "";
          for (u = o + f + 1; u <= i; ++u)
            u !== i && t3.charCodeAt(u) !== 47 || (p.length === 0 ? p += ".." : p += "/..");
          return p.length > 0 ? p + r3.slice(h + f) : (h += f, r3.charCodeAt(h) === 47 && ++h, r3.slice(h));
        }, _makeLong: function(t3) {
          return t3;
        }, dirname: function(t3) {
          if (e2(t3), t3.length === 0)
            return ".";
          for (var r3 = t3.charCodeAt(0), n2 = r3 === 47, o = -1, i = true, a = t3.length - 1; a >= 1; --a)
            if ((r3 = t3.charCodeAt(a)) === 47) {
              if (!i) {
                o = a;
                break;
              }
            } else
              i = false;
          return o === -1 ? n2 ? "/" : "." : n2 && o === 1 ? "//" : t3.slice(0, o);
        }, basename: function(t3, r3) {
          if (r3 !== void 0 && typeof r3 != "string")
            throw new TypeError('"ext" argument must be a string');
          e2(t3);
          var n2, o = 0, i = -1, a = true;
          if (r3 !== void 0 && r3.length > 0 && r3.length <= t3.length) {
            if (r3.length === t3.length && r3 === t3)
              return "";
            var h = r3.length - 1, s = -1;
            for (n2 = t3.length - 1; n2 >= 0; --n2) {
              var c = t3.charCodeAt(n2);
              if (c === 47) {
                if (!a) {
                  o = n2 + 1;
                  break;
                }
              } else
                s === -1 && (a = false, s = n2 + 1), h >= 0 && (c === r3.charCodeAt(h) ? --h == -1 && (i = n2) : (h = -1, i = s));
            }
            return o === i ? i = s : i === -1 && (i = t3.length), t3.slice(o, i);
          }
          for (n2 = t3.length - 1; n2 >= 0; --n2)
            if (t3.charCodeAt(n2) === 47) {
              if (!a) {
                o = n2 + 1;
                break;
              }
            } else
              i === -1 && (a = false, i = n2 + 1);
          return i === -1 ? "" : t3.slice(o, i);
        }, extname: function(t3) {
          e2(t3);
          for (var r3 = -1, n2 = 0, o = -1, i = true, a = 0, h = t3.length - 1; h >= 0; --h) {
            var s = t3.charCodeAt(h);
            if (s !== 47)
              o === -1 && (i = false, o = h + 1), s === 46 ? r3 === -1 ? r3 = h : a !== 1 && (a = 1) : r3 !== -1 && (a = -1);
            else if (!i) {
              n2 = h + 1;
              break;
            }
          }
          return r3 === -1 || o === -1 || a === 0 || a === 1 && r3 === o - 1 && r3 === n2 + 1 ? "" : t3.slice(r3, o);
        }, format: function(t3) {
          if (t3 === null || typeof t3 != "object")
            throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t3);
          return function(t4, e3) {
            var r3 = e3.dir || e3.root, n2 = e3.base || (e3.name || "") + (e3.ext || "");
            return r3 ? r3 === e3.root ? r3 + n2 : r3 + "/" + n2 : n2;
          }(0, t3);
        }, parse: function(t3) {
          e2(t3);
          var r3 = { root: "", dir: "", base: "", ext: "", name: "" };
          if (t3.length === 0)
            return r3;
          var n2, o = t3.charCodeAt(0), i = o === 47;
          i ? (r3.root = "/", n2 = 1) : n2 = 0;
          for (var a = -1, h = 0, s = -1, c = true, f = t3.length - 1, u = 0; f >= n2; --f)
            if ((o = t3.charCodeAt(f)) !== 47)
              s === -1 && (c = false, s = f + 1), o === 46 ? a === -1 ? a = f : u !== 1 && (u = 1) : a !== -1 && (u = -1);
            else if (!c) {
              h = f + 1;
              break;
            }
          return a === -1 || s === -1 || u === 0 || u === 1 && a === s - 1 && a === h + 1 ? s !== -1 && (r3.base = r3.name = h === 0 && i ? t3.slice(1, s) : t3.slice(h, s)) : (h === 0 && i ? (r3.name = t3.slice(1, a), r3.base = t3.slice(1, s)) : (r3.name = t3.slice(h, a), r3.base = t3.slice(h, s)), r3.ext = t3.slice(a, s)), h > 0 ? r3.dir = t3.slice(0, h - 1) : i && (r3.dir = "/"), r3;
        }, sep: "/", delimiter: ":", win32: null, posix: null };
        n.posix = n, t2.exports = n;
      }, 447: (t2, e2, r2) => {
        var n;
        if (r2.r(e2), r2.d(e2, { URI: () => d, Utils: () => P }), typeof process == "object")
          n = process.platform === "win32";
        else if (typeof navigator == "object") {
          var o = navigator.userAgent;
          n = o.indexOf("Windows") >= 0;
        }
        var i, a, h = (i = function(t3, e3) {
          return (i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e4) {
            t4.__proto__ = e4;
          } || function(t4, e4) {
            for (var r3 in e4)
              Object.prototype.hasOwnProperty.call(e4, r3) && (t4[r3] = e4[r3]);
          })(t3, e3);
        }, function(t3, e3) {
          if (typeof e3 != "function" && e3 !== null)
            throw new TypeError("Class extends value " + String(e3) + " is not a constructor or null");
          function r3() {
            this.constructor = t3;
          }
          i(t3, e3), t3.prototype = e3 === null ? Object.create(e3) : (r3.prototype = e3.prototype, new r3());
        }), s = /^\w[\w\d+.-]*$/, c = /^\//, f = /^\/\//;
        function u(t3, e3) {
          if (!t3.scheme && e3)
            throw new Error('[UriError]: Scheme is missing: {scheme: "", authority: "'.concat(t3.authority, '", path: "').concat(t3.path, '", query: "').concat(t3.query, '", fragment: "').concat(t3.fragment, '"}'));
          if (t3.scheme && !s.test(t3.scheme))
            throw new Error("[UriError]: Scheme contains illegal characters.");
          if (t3.path) {
            if (t3.authority) {
              if (!c.test(t3.path))
                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
            } else if (f.test(t3.path))
              throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
          }
        }
        var l = "", p = "/", g = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/, d = function() {
          function t3(t4, e3, r3, n2, o2, i2) {
            i2 === void 0 && (i2 = false), typeof t4 == "object" ? (this.scheme = t4.scheme || l, this.authority = t4.authority || l, this.path = t4.path || l, this.query = t4.query || l, this.fragment = t4.fragment || l) : (this.scheme = function(t5, e4) {
              return t5 || e4 ? t5 : "file";
            }(t4, i2), this.authority = e3 || l, this.path = function(t5, e4) {
              switch (t5) {
                case "https":
                case "http":
                case "file":
                  e4 ? e4[0] !== p && (e4 = p + e4) : e4 = p;
              }
              return e4;
            }(this.scheme, r3 || l), this.query = n2 || l, this.fragment = o2 || l, u(this, i2));
          }
          return t3.isUri = function(e3) {
            return e3 instanceof t3 || !!e3 && typeof e3.authority == "string" && typeof e3.fragment == "string" && typeof e3.path == "string" && typeof e3.query == "string" && typeof e3.scheme == "string" && typeof e3.fsPath == "string" && typeof e3.with == "function" && typeof e3.toString == "function";
          }, Object.defineProperty(t3.prototype, "fsPath", { get: function() {
            return A(this, false);
          }, enumerable: false, configurable: true }), t3.prototype.with = function(t4) {
            if (!t4)
              return this;
            var e3 = t4.scheme, r3 = t4.authority, n2 = t4.path, o2 = t4.query, i2 = t4.fragment;
            return e3 === void 0 ? e3 = this.scheme : e3 === null && (e3 = l), r3 === void 0 ? r3 = this.authority : r3 === null && (r3 = l), n2 === void 0 ? n2 = this.path : n2 === null && (n2 = l), o2 === void 0 ? o2 = this.query : o2 === null && (o2 = l), i2 === void 0 ? i2 = this.fragment : i2 === null && (i2 = l), e3 === this.scheme && r3 === this.authority && n2 === this.path && o2 === this.query && i2 === this.fragment ? this : new y(e3, r3, n2, o2, i2);
          }, t3.parse = function(t4, e3) {
            e3 === void 0 && (e3 = false);
            var r3 = g.exec(t4);
            return r3 ? new y(r3[2] || l, O(r3[4] || l), O(r3[5] || l), O(r3[7] || l), O(r3[9] || l), e3) : new y(l, l, l, l, l);
          }, t3.file = function(t4) {
            var e3 = l;
            if (n && (t4 = t4.replace(/\\/g, p)), t4[0] === p && t4[1] === p) {
              var r3 = t4.indexOf(p, 2);
              r3 === -1 ? (e3 = t4.substring(2), t4 = p) : (e3 = t4.substring(2, r3), t4 = t4.substring(r3) || p);
            }
            return new y("file", e3, t4, l, l);
          }, t3.from = function(t4) {
            var e3 = new y(t4.scheme, t4.authority, t4.path, t4.query, t4.fragment);
            return u(e3, true), e3;
          }, t3.prototype.toString = function(t4) {
            return t4 === void 0 && (t4 = false), w(this, t4);
          }, t3.prototype.toJSON = function() {
            return this;
          }, t3.revive = function(e3) {
            if (e3) {
              if (e3 instanceof t3)
                return e3;
              var r3 = new y(e3);
              return r3._formatted = e3.external, r3._fsPath = e3._sep === v ? e3.fsPath : null, r3;
            }
            return e3;
          }, t3;
        }(), v = n ? 1 : void 0, y = function(t3) {
          function e3() {
            var e4 = t3 !== null && t3.apply(this, arguments) || this;
            return e4._formatted = null, e4._fsPath = null, e4;
          }
          return h(e3, t3), Object.defineProperty(e3.prototype, "fsPath", { get: function() {
            return this._fsPath || (this._fsPath = A(this, false)), this._fsPath;
          }, enumerable: false, configurable: true }), e3.prototype.toString = function(t4) {
            return t4 === void 0 && (t4 = false), t4 ? w(this, true) : (this._formatted || (this._formatted = w(this, false)), this._formatted);
          }, e3.prototype.toJSON = function() {
            var t4 = { $mid: 1 };
            return this._fsPath && (t4.fsPath = this._fsPath, t4._sep = v), this._formatted && (t4.external = this._formatted), this.path && (t4.path = this.path), this.scheme && (t4.scheme = this.scheme), this.authority && (t4.authority = this.authority), this.query && (t4.query = this.query), this.fragment && (t4.fragment = this.fragment), t4;
          }, e3;
        }(d), m = ((a = {})[58] = "%3A", a[47] = "%2F", a[63] = "%3F", a[35] = "%23", a[91] = "%5B", a[93] = "%5D", a[64] = "%40", a[33] = "%21", a[36] = "%24", a[38] = "%26", a[39] = "%27", a[40] = "%28", a[41] = "%29", a[42] = "%2A", a[43] = "%2B", a[44] = "%2C", a[59] = "%3B", a[61] = "%3D", a[32] = "%20", a);
        function b(t3, e3) {
          for (var r3 = void 0, n2 = -1, o2 = 0; o2 < t3.length; o2++) {
            var i2 = t3.charCodeAt(o2);
            if (i2 >= 97 && i2 <= 122 || i2 >= 65 && i2 <= 90 || i2 >= 48 && i2 <= 57 || i2 === 45 || i2 === 46 || i2 === 95 || i2 === 126 || e3 && i2 === 47)
              n2 !== -1 && (r3 += encodeURIComponent(t3.substring(n2, o2)), n2 = -1), r3 !== void 0 && (r3 += t3.charAt(o2));
            else {
              r3 === void 0 && (r3 = t3.substr(0, o2));
              var a2 = m[i2];
              a2 !== void 0 ? (n2 !== -1 && (r3 += encodeURIComponent(t3.substring(n2, o2)), n2 = -1), r3 += a2) : n2 === -1 && (n2 = o2);
            }
          }
          return n2 !== -1 && (r3 += encodeURIComponent(t3.substring(n2))), r3 !== void 0 ? r3 : t3;
        }
        function C(t3) {
          for (var e3 = void 0, r3 = 0; r3 < t3.length; r3++) {
            var n2 = t3.charCodeAt(r3);
            n2 === 35 || n2 === 63 ? (e3 === void 0 && (e3 = t3.substr(0, r3)), e3 += m[n2]) : e3 !== void 0 && (e3 += t3[r3]);
          }
          return e3 !== void 0 ? e3 : t3;
        }
        function A(t3, e3) {
          var r3;
          return r3 = t3.authority && t3.path.length > 1 && t3.scheme === "file" ? "//".concat(t3.authority).concat(t3.path) : t3.path.charCodeAt(0) === 47 && (t3.path.charCodeAt(1) >= 65 && t3.path.charCodeAt(1) <= 90 || t3.path.charCodeAt(1) >= 97 && t3.path.charCodeAt(1) <= 122) && t3.path.charCodeAt(2) === 58 ? e3 ? t3.path.substr(1) : t3.path[1].toLowerCase() + t3.path.substr(2) : t3.path, n && (r3 = r3.replace(/\//g, "\\")), r3;
        }
        function w(t3, e3) {
          var r3 = e3 ? C : b, n2 = "", o2 = t3.scheme, i2 = t3.authority, a2 = t3.path, h2 = t3.query, s2 = t3.fragment;
          if (o2 && (n2 += o2, n2 += ":"), (i2 || o2 === "file") && (n2 += p, n2 += p), i2) {
            var c2 = i2.indexOf("@");
            if (c2 !== -1) {
              var f2 = i2.substr(0, c2);
              i2 = i2.substr(c2 + 1), (c2 = f2.indexOf(":")) === -1 ? n2 += r3(f2, false) : (n2 += r3(f2.substr(0, c2), false), n2 += ":", n2 += r3(f2.substr(c2 + 1), false)), n2 += "@";
            }
            (c2 = (i2 = i2.toLowerCase()).indexOf(":")) === -1 ? n2 += r3(i2, false) : (n2 += r3(i2.substr(0, c2), false), n2 += i2.substr(c2));
          }
          if (a2) {
            if (a2.length >= 3 && a2.charCodeAt(0) === 47 && a2.charCodeAt(2) === 58)
              (u2 = a2.charCodeAt(1)) >= 65 && u2 <= 90 && (a2 = "/".concat(String.fromCharCode(u2 + 32), ":").concat(a2.substr(3)));
            else if (a2.length >= 2 && a2.charCodeAt(1) === 58) {
              var u2;
              (u2 = a2.charCodeAt(0)) >= 65 && u2 <= 90 && (a2 = "".concat(String.fromCharCode(u2 + 32), ":").concat(a2.substr(2)));
            }
            n2 += r3(a2, true);
          }
          return h2 && (n2 += "?", n2 += r3(h2, false)), s2 && (n2 += "#", n2 += e3 ? s2 : b(s2, false)), n2;
        }
        function x(t3) {
          try {
            return decodeURIComponent(t3);
          } catch (e3) {
            return t3.length > 3 ? t3.substr(0, 3) + x(t3.substr(3)) : t3;
          }
        }
        var _ = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
        function O(t3) {
          return t3.match(_) ? t3.replace(_, function(t4) {
            return x(t4);
          }) : t3;
        }
        var P, j = r2(470), U = function(t3, e3, r3) {
          if (r3 || arguments.length === 2)
            for (var n2, o2 = 0, i2 = e3.length; o2 < i2; o2++)
              !n2 && o2 in e3 || (n2 || (n2 = Array.prototype.slice.call(e3, 0, o2)), n2[o2] = e3[o2]);
          return t3.concat(n2 || Array.prototype.slice.call(e3));
        }, I = j.posix || j;
        !function(t3) {
          t3.joinPath = function(t4) {
            for (var e3 = [], r3 = 1; r3 < arguments.length; r3++)
              e3[r3 - 1] = arguments[r3];
            return t4.with({ path: I.join.apply(I, U([t4.path], e3, false)) });
          }, t3.resolvePath = function(t4) {
            for (var e3 = [], r3 = 1; r3 < arguments.length; r3++)
              e3[r3 - 1] = arguments[r3];
            var n2 = t4.path || "/";
            return t4.with({ path: I.resolve.apply(I, U([n2], e3, false)) });
          }, t3.dirname = function(t4) {
            var e3 = I.dirname(t4.path);
            return e3.length === 1 && e3.charCodeAt(0) === 46 ? t4 : t4.with({ path: e3 });
          }, t3.basename = function(t4) {
            return I.basename(t4.path);
          }, t3.extname = function(t4) {
            return I.extname(t4.path);
          };
        }(P || (P = {}));
      } }, e = {};
      function r(n) {
        if (e[n])
          return e[n].exports;
        var o = e[n] = { exports: {} };
        return t[n](o, o.exports, r), o.exports;
      }
      return r.d = (t2, e2) => {
        for (var n in e2)
          r.o(e2, n) && !r.o(t2, n) && Object.defineProperty(t2, n, { enumerable: true, get: e2[n] });
      }, r.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r.r = (t2) => {
        typeof Symbol != "undefined" && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
      }, r(447);
    })();
    ({ URI: URI2, Utils } = LIB);
  }
});

// node_modules/isexe/windows.js
var require_windows = __commonJS({
  "node_modules/isexe/windows.js"(exports, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs29 = require("fs");
    function checkPathExt(path41, options2) {
      var pathext = options2.pathExt !== void 0 ? options2.pathExt : process.env.PATHEXT;
      if (!pathext) {
        return true;
      }
      pathext = pathext.split(";");
      if (pathext.indexOf("") !== -1) {
        return true;
      }
      for (var i = 0; i < pathext.length; i++) {
        var p = pathext[i].toLowerCase();
        if (p && path41.substr(-p.length).toLowerCase() === p) {
          return true;
        }
      }
      return false;
    }
    function checkStat(stat, path41, options2) {
      if (!stat.isSymbolicLink() && !stat.isFile()) {
        return false;
      }
      return checkPathExt(path41, options2);
    }
    function isexe(path41, options2, cb) {
      fs29.stat(path41, function(er, stat) {
        cb(er, er ? false : checkStat(stat, path41, options2));
      });
    }
    function sync(path41, options2) {
      return checkStat(fs29.statSync(path41), path41, options2);
    }
  }
});

// node_modules/isexe/mode.js
var require_mode = __commonJS({
  "node_modules/isexe/mode.js"(exports, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs29 = require("fs");
    function isexe(path41, options2, cb) {
      fs29.stat(path41, function(er, stat) {
        cb(er, er ? false : checkStat(stat, options2));
      });
    }
    function sync(path41, options2) {
      return checkStat(fs29.statSync(path41), options2);
    }
    function checkStat(stat, options2) {
      return stat.isFile() && checkMode(stat, options2);
    }
    function checkMode(stat, options2) {
      var mod = stat.mode;
      var uid = stat.uid;
      var gid = stat.gid;
      var myUid = options2.uid !== void 0 ? options2.uid : process.getuid && process.getuid();
      var myGid = options2.gid !== void 0 ? options2.gid : process.getgid && process.getgid();
      var u = parseInt("100", 8);
      var g = parseInt("010", 8);
      var o = parseInt("001", 8);
      var ug = u | g;
      var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
      return ret;
    }
  }
});

// node_modules/isexe/index.js
var require_isexe = __commonJS({
  "node_modules/isexe/index.js"(exports, module2) {
    var fs29 = require("fs");
    var core;
    if (process.platform === "win32" || global.TESTING_WINDOWS) {
      core = require_windows();
    } else {
      core = require_mode();
    }
    module2.exports = isexe;
    isexe.sync = sync;
    function isexe(path41, options2, cb) {
      if (typeof options2 === "function") {
        cb = options2;
        options2 = {};
      }
      if (!cb) {
        if (typeof Promise !== "function") {
          throw new TypeError("callback not provided");
        }
        return new Promise(function(resolve3, reject) {
          isexe(path41, options2 || {}, function(er, is) {
            if (er) {
              reject(er);
            } else {
              resolve3(is);
            }
          });
        });
      }
      core(path41, options2 || {}, function(er, is) {
        if (er) {
          if (er.code === "EACCES" || options2 && options2.ignoreErrors) {
            er = null;
            is = false;
          }
        }
        cb(er, is);
      });
    }
    function sync(path41, options2) {
      try {
        return core.sync(path41, options2 || {});
      } catch (er) {
        if (options2 && options2.ignoreErrors || er.code === "EACCES") {
          return false;
        } else {
          throw er;
        }
      }
    }
  }
});

// node_modules/which/which.js
var require_which = __commonJS({
  "node_modules/which/which.js"(exports, module2) {
    var isWindows3 = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    var path41 = require("path");
    var COLON = isWindows3 ? ";" : ":";
    var isexe = require_isexe();
    var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
    var getPathInfo = (cmd, opt) => {
      const colon = opt.colon || COLON;
      const pathEnv = cmd.match(/\//) || isWindows3 && cmd.match(/\\/) ? [""] : [
        ...isWindows3 ? [process.cwd()] : [],
        ...(opt.path || process.env.PATH || "").split(colon)
      ];
      const pathExtExe = isWindows3 ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
      const pathExt = isWindows3 ? pathExtExe.split(colon) : [""];
      if (isWindows3) {
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      return {
        pathEnv,
        pathExt,
        pathExtExe
      };
    };
    var which5 = (cmd, opt, cb) => {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      if (!opt)
        opt = {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      const step = (i) => new Promise((resolve3, reject) => {
        if (i === pathEnv.length)
          return opt.all && found.length ? resolve3(found) : reject(getNotFoundError(cmd));
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path41.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        resolve3(subStep(p, i, 0));
      });
      const subStep = (p, i, ii) => new Promise((resolve3, reject) => {
        if (ii === pathExt.length)
          return resolve3(step(i + 1));
        const ext = pathExt[ii];
        isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {
          if (!er && is) {
            if (opt.all)
              found.push(p + ext);
            else
              return resolve3(p + ext);
          }
          return resolve3(subStep(p, i, ii + 1));
        });
      });
      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
    };
    var whichSync = (cmd, opt) => {
      opt = opt || {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found = [];
      for (let i = 0; i < pathEnv.length; i++) {
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path41.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for (let j = 0; j < pathExt.length; j++) {
          const cur = p + pathExt[j];
          try {
            const is = isexe.sync(cur, { pathExt: pathExtExe });
            if (is) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    module2.exports = which5;
    which5.sync = whichSync;
  }
});

// src/util/platform.ts
var platform_exports = {};
__export(platform_exports, {
  OS: () => OS,
  OperatingSystem: () => OperatingSystem,
  Platform: () => Platform,
  globals: () => globals,
  isLinux: () => isLinux,
  isMacintosh: () => isMacintosh,
  isNative: () => isNative,
  isWeb: () => isWeb,
  isWindows: () => isWindows,
  language: () => language,
  platform: () => platform
});
var _isWindows, _isMacintosh, _isLinux, _isNative, _isWeb, language, Platform, _platform, isWindows, isMacintosh, isLinux, isNative, isWeb, platform, _globals, globals, OperatingSystem, OS;
var init_platform = __esm({
  "src/util/platform.ts"() {
    "use strict";
    _isWindows = false;
    _isMacintosh = false;
    _isLinux = false;
    _isNative = false;
    _isWeb = false;
    language = "en";
    if (typeof process === "object" && typeof process.nextTick === "function" && typeof process.platform === "string") {
      _isWindows = process.platform === "win32";
      _isMacintosh = process.platform === "darwin";
      _isLinux = process.platform === "linux";
      _isNative = true;
    }
    Platform = /* @__PURE__ */ ((Platform2) => {
      Platform2[Platform2["Web"] = 0] = "Web";
      Platform2[Platform2["Mac"] = 1] = "Mac";
      Platform2[Platform2["Linux"] = 2] = "Linux";
      Platform2[Platform2["Windows"] = 3] = "Windows";
      return Platform2;
    })(Platform || {});
    _platform = 0 /* Web */;
    if (_isNative) {
      if (_isMacintosh) {
        _platform = 1 /* Mac */;
      } else if (_isWindows) {
        _platform = 3 /* Windows */;
      } else if (_isLinux) {
        _platform = 2 /* Linux */;
      }
    }
    isWindows = _isWindows;
    isMacintosh = _isMacintosh;
    isLinux = _isLinux;
    isNative = _isNative;
    isWeb = _isWeb;
    platform = _platform;
    _globals = typeof self === "object" ? self : typeof global === "object" ? global : {};
    globals = _globals;
    OperatingSystem = /* @__PURE__ */ ((OperatingSystem2) => {
      OperatingSystem2[OperatingSystem2["Windows"] = 1] = "Windows";
      OperatingSystem2[OperatingSystem2["Macintosh"] = 2] = "Macintosh";
      OperatingSystem2[OperatingSystem2["Linux"] = 3] = "Linux";
      return OperatingSystem2;
    })(OperatingSystem || {});
    OS = _isMacintosh ? 2 /* Macintosh */ : _isWindows ? 1 /* Windows */ : 3 /* Linux */;
  }
});

// src/util/index.ts
function isMarkdown(content) {
  if (import_vscode_languageserver_protocol.MarkupContent.is(content) && content.kind == import_vscode_languageserver_protocol.MarkupKind.Markdown) {
    return true;
  }
  return false;
}
function wait(ms) {
  if (ms <= 0)
    return Promise.resolve(void 0);
  return new Promise((resolve3) => {
    setTimeout(() => {
      resolve3(void 0);
    }, ms);
  });
}
function waitNextTick(fn) {
  return new Promise((resolve3) => {
    process.nextTick(() => {
      if (fn)
        fn();
      resolve3(void 0);
    });
  });
}
function waitImmediate() {
  return new Promise((resolve3) => {
    setImmediate(() => {
      resolve3(void 0);
    });
  });
}
function getUri(fullpath, id, buftype, isCygwin) {
  if (!fullpath)
    return `untitled:${id}`;
  if (isWindows && !isCygwin && !fullpath.startsWith("jdt://"))
    fullpath = import_path.default.win32.normalize(fullpath);
  if (import_path.default.isAbsolute(fullpath))
    return URI2.file(fullpath).toString();
  if (import_isuri.default.isValid(fullpath))
    return URI2.parse(fullpath).toString();
  if (buftype != "")
    return `${buftype}:${id}`;
  return `unknown:${id}`;
}
function disposeAll(disposables) {
  while (disposables.length) {
    const item = disposables.pop();
    if (item) {
      item.dispose();
    }
  }
}
function executable(command) {
  try {
    import_which.default.sync(command);
  } catch (e) {
    return false;
  }
  return true;
}
function runCommand(cmd, opts = {}, timeout) {
  if (!isWindows) {
    opts.shell = opts.shell || process.env.SHELL;
  }
  opts.maxBuffer = 500 * 1024;
  return new Promise((resolve3, reject) => {
    let timer;
    if (timeout) {
      timer = setTimeout(() => {
        reject(new Error(`timeout after ${timeout}s`));
      }, timeout * 1e3);
    }
    (0, import_child_process.exec)(cmd, opts, (err, stdout, stderr) => {
      if (timer)
        clearTimeout(timer);
      if (err) {
        reject(new Error(`exited with ${err.code}
${err}
${stderr}`));
        return;
      }
      resolve3(stdout);
    });
  });
}
function watchFile(filepath, onChange) {
  let callback = (0, import_debounce.default)(onChange, 100);
  try {
    let watcher = import_fs.default.watch(filepath, {
      persistent: true,
      recursive: false,
      encoding: "utf8"
    }, () => {
      callback();
    });
    return import_vscode_languageserver_protocol.Disposable.create(() => {
      callback.clear();
      watcher.close();
    });
  } catch (e) {
    return import_vscode_languageserver_protocol.Disposable.create(() => {
      callback.clear();
    });
  }
}
function isRunning(pid) {
  try {
    let res = process.kill(pid, 0);
    return res == true;
  } catch (e) {
    return e["code"] === "EPERM";
  }
}
function getKeymapModifier(mode) {
  if (mode == "n" || mode == "o" || mode == "x" || mode == "v")
    return "<C-U>";
  if (mode == "i")
    return "<C-o>";
  if (mode == "s")
    return "<Esc>";
  return "";
}
function concurrent(arr, fn, limit = 3) {
  if (arr.length == 0)
    return Promise.resolve();
  let finished = 0;
  let total = arr.length;
  let remain = arr.slice();
  return new Promise((resolve3) => {
    let run = (val) => {
      let cb = () => {
        finished = finished + 1;
        if (finished == total) {
          resolve3();
        } else if (remain.length) {
          let next = remain.shift();
          run(next);
        }
      };
      fn(val).then(cb, cb);
    };
    for (let i = 0; i < Math.min(limit, remain.length); i++) {
      let val = remain.shift();
      run(val);
    }
  });
}
var import_child_process, import_debounce, import_fs, import_isuri, import_path, import_vscode_languageserver_protocol, import_which, logger, CONFIG_FILE_NAME;
var init_util = __esm({
  "src/util/index.ts"() {
    "use strict";
    import_child_process = require("child_process");
    import_debounce = __toESM(require_debounce());
    import_fs = __toESM(require("fs"));
    import_isuri = __toESM(require_isuri());
    import_path = __toESM(require("path"));
    import_vscode_languageserver_protocol = __toESM(require_main2());
    init_esm();
    import_which = __toESM(require_which());
    init_platform();
    logger = require_logger2()("util-index");
    CONFIG_FILE_NAME = "coc-settings.json";
  }
});

// src/util/is.ts
function boolean(value) {
  return typeof value === "boolean";
}
function string(value) {
  return typeof value === "string";
}
function number(value) {
  return typeof value === "number";
}
function func(value) {
  return typeof value == "function";
}
function objectLiteral(obj) {
  return obj != null && typeof obj === "object" && !Array.isArray(obj) && !(obj instanceof RegExp) && !(obj instanceof Date);
}
function emptyObject(obj) {
  if (!objectLiteral(obj)) {
    return false;
  }
  for (let key in obj) {
    if (hasOwnProperty.call(obj, key)) {
      return false;
    }
  }
  return true;
}
var hasOwnProperty;
var init_is = __esm({
  "src/util/is.ts"() {
    "use strict";
    hasOwnProperty = Object.prototype.hasOwnProperty;
  }
});

// src/util/object.ts
function omitUndefined(obj) {
  const result = {};
  Object.entries(obj).forEach(([key, val]) => {
    if (val !== void 0)
      result[key] = val;
  });
  return result;
}
function deepClone(obj) {
  if (!obj || typeof obj !== "object") {
    return obj;
  }
  if (obj instanceof RegExp) {
    return obj;
  }
  const result = Array.isArray(obj) ? [] : {};
  Object.keys(obj).forEach((key) => {
    if (obj[key] && typeof obj[key] === "object") {
      result[key] = deepClone(obj[key]);
    } else {
      result[key] = obj[key];
    }
  });
  return result;
}
function deepFreeze(obj) {
  if (!obj || typeof obj !== "object") {
    return obj;
  }
  const stack = [obj];
  while (stack.length > 0) {
    let obj2 = stack.shift();
    Object.freeze(obj2);
    for (const key in obj2) {
      if (_hasOwnProperty.call(obj2, key)) {
        let prop = obj2[key];
        if (typeof prop === "object" && !Object.isFrozen(prop)) {
          stack.push(prop);
        }
      }
    }
  }
  return obj;
}
function mixin(destination, source, overwrite = true) {
  if (!objectLiteral(destination)) {
    return source;
  }
  if (objectLiteral(source)) {
    Object.keys(source).forEach((key) => {
      if (key in destination) {
        if (overwrite) {
          if (objectLiteral(destination[key]) && objectLiteral(source[key])) {
            mixin(destination[key], source[key], overwrite);
          } else {
            destination[key] = source[key];
          }
        }
      } else {
        destination[key] = source[key];
      }
    });
  }
  return destination;
}
function equals(one, other) {
  if (one === other) {
    return true;
  }
  if (one === null || one === void 0 || other === null || other === void 0) {
    return false;
  }
  if (typeof one !== typeof other) {
    return false;
  }
  if (typeof one !== "object") {
    return false;
  }
  if (Array.isArray(one) !== Array.isArray(other)) {
    return false;
  }
  let i;
  let key;
  if (Array.isArray(one)) {
    if (one.length !== other.length) {
      return false;
    }
    for (i = 0; i < one.length; i++) {
      if (!equals(one[i], other[i])) {
        return false;
      }
    }
  } else {
    const oneKeys = [];
    for (key in one) {
      oneKeys.push(key);
    }
    oneKeys.sort();
    const otherKeys = [];
    for (key in other) {
      otherKeys.push(key);
    }
    otherKeys.sort();
    if (!equals(oneKeys, otherKeys)) {
      return false;
    }
    for (i = 0; i < oneKeys.length; i++) {
      if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {
        return false;
      }
    }
  }
  return true;
}
var _hasOwnProperty;
var init_object = __esm({
  "src/util/object.ts"() {
    "use strict";
    init_is();
    _hasOwnProperty = Object.prototype.hasOwnProperty;
  }
});

// src/util/string.ts
function getCase(code) {
  if (code >= 97 && code <= 122)
    return 1;
  if (code >= 65 && code <= 90)
    return 2;
  return 0;
}
function getNextWord(codes, index) {
  let preCase = index == 0 ? 0 : getCase(codes[index - 1]);
  for (let i = index; i < codes.length; i++) {
    let curr = getCase(codes[i]);
    if (curr > 0 && curr != preCase) {
      return [i, codes[i]];
    }
    preCase = curr;
  }
  return void 0;
}
function getCharIndexes(input, character) {
  let res = [];
  for (let i = 0; i < input.length; i++) {
    if (input[i] == character)
      res.push(i);
  }
  return res;
}
function byteLength(str) {
  return Buffer.byteLength(str);
}
function upperFirst(str) {
  return (str == null ? void 0 : str.length) > 0 ? str[0].toUpperCase() + str.slice(1) : "";
}
function byteIndex(content, index) {
  let s = content.slice(0, index);
  return Buffer.byteLength(s);
}
function characterIndex(content, byteIndex2) {
  let buf = Buffer.from(content, "utf8");
  return buf.slice(0, byteIndex2).toString("utf8").length;
}
function byteSlice(content, start, end) {
  let buf = Buffer.from(content, "utf8");
  return buf.slice(start, end).toString("utf8");
}
function isWord(character) {
  let code = character.charCodeAt(0);
  if (code > 128)
    return false;
  if (code == 95)
    return true;
  if (code >= 48 && code <= 57)
    return true;
  if (isAlphabet(code))
    return true;
  return false;
}
function isAlphabet(code) {
  if (code >= 65 && code <= 90)
    return true;
  if (code >= 97 && code <= 122)
    return true;
  return false;
}
function contentToLines(content, eol) {
  if (eol && content.endsWith("\n")) {
    return content.slice(0, -1).split("\n");
  }
  return content.split("\n");
}
function hasUpperCase(str) {
  for (let i = 0, l = str.length; i < l; i++) {
    let code = str.charCodeAt(i);
    if (code >= 65 && code <= 90) {
      return true;
    }
  }
  return false;
}
function smartMatch(a, b) {
  if (a === b)
    return true;
  let c = b.charCodeAt(0);
  if (c >= 65 && c <= 90) {
    if (c + 32 === a.charCodeAt(0))
      return true;
  }
  return false;
}
function smartcaseIndex(input, other) {
  if (input.length > other.length)
    return -1;
  if (input.length === 0)
    return 0;
  if (!hasUpperCase(input)) {
    return other.toLowerCase().indexOf(input);
  }
  let total = input.length;
  let checked = 0;
  for (let i = 0; i < other.length; i++) {
    let ch = other[i];
    if (smartMatch(input[checked], ch)) {
      checked++;
      if (checked === total) {
        return i - checked + 1;
      }
    } else if (checked > 0) {
      i = i - checked;
      checked = 0;
    }
  }
  return -1;
}
var init_string = __esm({
  "src/util/string.ts"() {
    "use strict";
  }
});

// src/events.ts
var import_vscode_languageserver_protocol2, logger2, Events, events_default;
var init_events = __esm({
  "src/events.ts"() {
    "use strict";
    import_vscode_languageserver_protocol2 = __toESM(require_main2());
    init_util();
    init_object();
    init_string();
    logger2 = require_logger2()("events");
    Events = class {
      constructor() {
        this.handlers = /* @__PURE__ */ new Map();
        this._recentInserts = [];
        this._lastChange = 0;
        this._insertMode = false;
        this._pumAlignTop = false;
        this._pumVisible = false;
        this._completing = false;
      }
      set completing(completing) {
        this._completing = completing;
        this._pumVisible = completing;
      }
      get completing() {
        return this._completing;
      }
      get cursor() {
        return this._cursor;
      }
      get bufnr() {
        return this._bufnr;
      }
      get pumvisible() {
        return this._pumVisible;
      }
      get pumAlignTop() {
        return this._pumAlignTop;
      }
      get insertMode() {
        return this._insertMode;
      }
      get lastChangeTs() {
        return this._lastChange;
      }
      race(events, token) {
        let disposables = [];
        return new Promise((resolve3) => {
          if (typeof token === "number") {
            let timer = setTimeout(() => {
              disposeAll(disposables);
              resolve3(void 0);
            }, token);
            disposables.push(import_vscode_languageserver_protocol2.Disposable.create(() => {
              clearTimeout(timer);
            }));
          } else if (import_vscode_languageserver_protocol2.CancellationToken.is(token)) {
            token.onCancellationRequested(() => {
              disposeAll(disposables);
              resolve3(void 0);
            }, null, disposables);
          }
          events.forEach((ev) => {
            this.on(ev, (...args) => {
              disposeAll(disposables);
              resolve3({ name: ev, args });
            }, null, disposables);
          });
        });
      }
      async fire(event, args) {
        var _a;
        let cbs = this.handlers.get(event);
        if (event == "InsertEnter") {
          this._insertMode = true;
        } else if (event == "InsertLeave") {
          this._insertMode = false;
          this._pumVisible = false;
          this._recentInserts = [];
        } else if (event == "CursorHoldI" || event == "CursorMovedI") {
          this._bufnr = args[0];
          if (!this._insertMode) {
            this._insertMode = true;
            void this.fire("InsertEnter", [args[0]]);
          }
        } else if (event == "CursorHold" || event == "CursorMoved") {
          this._bufnr = args[0];
          if (this._insertMode) {
            this._insertMode = false;
            void this.fire("InsertLeave", [args[0]]);
          }
        } else if (event == "MenuPopupChanged") {
          this._pumVisible = true;
          this._pumAlignTop = args[1] > args[0].row;
        } else if (event == "InsertCharPre") {
          this._recentInserts.push([args[1], args[0]]);
        } else if (event == "TextChanged") {
          this._lastChange = Date.now();
        } else if (event == "BufEnter") {
          this._bufnr = args[0];
        } else if (event == "TextChangedI" || event == "TextChangedP") {
          let arr = this._recentInserts.filter((o) => o[0] == args[0]);
          this._bufnr = args[0];
          this._recentInserts = [];
          this._lastChange = Date.now();
          let info = args[1];
          let pre = byteSlice(info.line ?? "", 0, info.col - 1);
          info.pre = pre;
          this._cursor = Object.freeze({
            bufnr: args[0],
            lnum: info.lnum,
            col: info.col,
            insert: true
          });
          if (arr.length && pre.length) {
            let character = pre.slice(-1);
            if (arr.findIndex((o) => o[1] == character) !== -1) {
              info.insertChar = character;
              process.nextTick(() => {
                void this.fire("TextInsert", [...args, character]);
              });
            }
          }
        }
        if (event == "CursorMoved" || event == "CursorMovedI") {
          args.push(this._recentInserts.length > 0);
          let cursor = {
            bufnr: args[0],
            lnum: args[1][0],
            col: args[1][1],
            insert: event == "CursorMovedI"
          };
          if (this._cursor && equals(this._cursor, cursor))
            return;
          this._cursor = Object.freeze(cursor);
        }
        if (cbs) {
          try {
            await Promise.all(cbs.slice().map((fn) => fn(deepClone(args))));
          } catch (e) {
            if (e instanceof Error && ((_a = e.message) == null ? void 0 : _a.includes("transport disconnected")))
              return;
            logger2.error(`Error on event: ${event}`, e instanceof Error ? e.stack : e);
          }
        }
      }
      on(event, handler, thisArg, disposables) {
        if (Array.isArray(event)) {
          let arr = disposables || [];
          for (let ev of event) {
            this.on(ev, handler, thisArg, arr);
          }
          return import_vscode_languageserver_protocol2.Disposable.create(() => {
            disposeAll(arr);
          });
        } else {
          let arr = this.handlers.get(event) || [];
          let wrappedhandler = (args) => new Promise((resolve3, reject) => {
            try {
              Promise.resolve(handler.apply(thisArg ?? null, args)).then(() => {
                resolve3(void 0);
              }, (e) => {
                reject(e);
              });
            } catch (e) {
              reject(e);
            }
          });
          arr.push(wrappedhandler);
          this.handlers.set(event, arr);
          let disposable = import_vscode_languageserver_protocol2.Disposable.create(() => {
            let idx = arr.indexOf(wrappedhandler);
            if (idx !== -1) {
              arr.splice(idx, 1);
            }
          });
          if (Array.isArray(disposables)) {
            disposables.push(disposable);
          }
          return disposable;
        }
      }
    };
    events_default = new Events();
  }
});

// node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "node_modules/concat-map/index.js"(exports, module2) {
    module2.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x))
          res.push.apply(res, x);
        else
          res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range2(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range2;
    function range2(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports, module2) {
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad2 = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad2) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "node_modules/minimatch/minimatch.js"(exports, module2) {
    module2.exports = minimatch10;
    minimatch10.Minimatch = Minimatch2;
    var path41 = { sep: "/" };
    try {
      path41 = require("path");
    } catch (er) {
    }
    var GLOBSTAR = minimatch10.GLOBSTAR = Minimatch2.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch10.filter = filter2;
    function filter2(pattern, options2) {
      options2 = options2 || {};
      return function(p, i, list2) {
        return minimatch10(p, pattern, options2);
      };
    }
    function ext(a, b) {
      a = a || {};
      b = b || {};
      var t = {};
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      return t;
    }
    minimatch10.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return minimatch10;
      var orig = minimatch10;
      var m = function minimatch11(p, pattern, options2) {
        return orig.minimatch(p, pattern, ext(def, options2));
      };
      m.Minimatch = function Minimatch3(pattern, options2) {
        return new orig.Minimatch(pattern, ext(def, options2));
      };
      return m;
    };
    Minimatch2.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return Minimatch2;
      return minimatch10.defaults(def).Minimatch;
    };
    function minimatch10(p, pattern, options2) {
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options2)
        options2 = {};
      if (!options2.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      if (pattern.trim() === "")
        return p === "";
      return new Minimatch2(pattern, options2).match(p);
    }
    function Minimatch2(pattern, options2) {
      if (!(this instanceof Minimatch2)) {
        return new Minimatch2(pattern, options2);
      }
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options2)
        options2 = {};
      pattern = pattern.trim();
      if (path41.sep !== "/") {
        pattern = pattern.split(path41.sep).join("/");
      }
      this.options = options2;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.make();
    }
    Minimatch2.prototype.debug = function() {
    };
    Minimatch2.prototype.make = make;
    function make() {
      if (this._made)
        return;
      var pattern = this.pattern;
      var options2 = this.options;
      if (!options2.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options2.debug)
        this.debug = console.error;
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch2.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options2 = this.options;
      var negateOffset = 0;
      if (options2.nonegate)
        return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch10.braceExpand = function(pattern, options2) {
      return braceExpand(pattern, options2);
    };
    Minimatch2.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options2) {
      if (!options2) {
        if (this instanceof Minimatch2) {
          options2 = this.options;
        } else {
          options2 = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      if (typeof pattern === "undefined") {
        throw new TypeError("undefined pattern");
      }
      if (options2.nobrace || !pattern.match(/\{.*\}/)) {
        return [pattern];
      }
      return expand(pattern);
    }
    Minimatch2.prototype.parse = parse4;
    var SUBPARSE = {};
    function parse4(pattern, isSub) {
      if (pattern.length > 1024 * 64) {
        throw new TypeError("pattern is too long");
      }
      var options2 = this.options;
      if (!options2.noglobstar && pattern === "**")
        return GLOBSTAR;
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options2.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options2.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/":
            return false;
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options2.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            if (inClass) {
              var cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + cs + "]");
              } catch (er) {
                var sp = this.parse(cs, SUBPARSE);
                re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                hasMagic = hasMagic || sp[1];
                inClass = false;
                continue;
              }
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case ".":
        case "[":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options2.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch10.makeRe = function(pattern, options2) {
      return new Minimatch2(pattern, options2 || {}).makeRe();
    };
    Minimatch2.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options2 = this.options;
      var twoStar = options2.noglobstar ? star : options2.dot ? twoStarDot : twoStarNoDot;
      var flags = options2.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch10.match = function(list2, pattern, options2) {
      options2 = options2 || {};
      var mm = new Minimatch2(pattern, options2);
      list2 = list2.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list2.length) {
        list2.push(pattern);
      }
      return list2;
    };
    Minimatch2.prototype.match = match;
    function match(f, partial) {
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options2 = this.options;
      if (path41.sep !== "/") {
        f = f.split(path41.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options2.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options2.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options2.flipNegate)
        return false;
      return this.negate;
    }
    Minimatch2.prototype.matchOne = function(file, pattern, partial) {
      var options2 = this.options;
      this.debug("matchOne", { "this": this, file, pattern });
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options2.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          if (options2.nocase) {
            hit = f.toLowerCase() === p.toLowerCase();
          } else {
            hit = f === p;
          }
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        var emptyFileEnd = fi === fl - 1 && file[fi] === "";
        return emptyFileEnd;
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// node_modules/fs.realpath/old.js
var require_old = __commonJS({
  "node_modules/fs.realpath/old.js"(exports) {
    var pathModule = require("path");
    var isWindows3 = process.platform === "win32";
    var fs29 = require("fs");
    var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
    function rethrow() {
      var callback;
      if (DEBUG) {
        var backtrace = new Error();
        callback = debugCallback;
      } else
        callback = missingCallback;
      return callback;
      function debugCallback(err) {
        if (err) {
          backtrace.message = err.message;
          err = backtrace;
          missingCallback(err);
        }
      }
      function missingCallback(err) {
        if (err) {
          if (process.throwDeprecation)
            throw err;
          else if (!process.noDeprecation) {
            var msg = "fs: missing callback " + (err.stack || err.message);
            if (process.traceDeprecation)
              console.trace(msg);
            else
              console.error(msg);
          }
        }
      }
    }
    function maybeCallback(cb) {
      return typeof cb === "function" ? cb : rethrow();
    }
    var normalize = pathModule.normalize;
    if (isWindows3) {
      nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
    } else {
      nextPartRe = /(.*?)(?:[\/]+|$)/g;
    }
    var nextPartRe;
    if (isWindows3) {
      splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
    } else {
      splitRootRe = /^[\/]*/;
    }
    var splitRootRe;
    exports.realpathSync = function realpathSync(p, cache) {
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return cache[p];
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows3 && !knownHard[base]) {
          fs29.lstatSync(base);
          knownHard[base] = true;
        }
      }
      while (pos < p.length) {
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          continue;
        }
        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          resolvedLink = cache[base];
        } else {
          var stat = fs29.lstatSync(base);
          if (!stat.isSymbolicLink()) {
            knownHard[base] = true;
            if (cache)
              cache[base] = base;
            continue;
          }
          var linkTarget = null;
          if (!isWindows3) {
            var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              linkTarget = seenLinks[id];
            }
          }
          if (linkTarget === null) {
            fs29.statSync(base);
            linkTarget = fs29.readlinkSync(base);
          }
          resolvedLink = pathModule.resolve(previous, linkTarget);
          if (cache)
            cache[base] = resolvedLink;
          if (!isWindows3)
            seenLinks[id] = linkTarget;
        }
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
      if (cache)
        cache[original] = p;
      return p;
    };
    exports.realpath = function realpath(p, cache, cb) {
      if (typeof cb !== "function") {
        cb = maybeCallback(cache);
        cache = null;
      }
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return process.nextTick(cb.bind(null, null, cache[p]));
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows3 && !knownHard[base]) {
          fs29.lstat(base, function(err) {
            if (err)
              return cb(err);
            knownHard[base] = true;
            LOOP();
          });
        } else {
          process.nextTick(LOOP);
        }
      }
      function LOOP() {
        if (pos >= p.length) {
          if (cache)
            cache[original] = p;
          return cb(null, p);
        }
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          return process.nextTick(LOOP);
        }
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          return gotResolvedLink(cache[base]);
        }
        return fs29.lstat(base, gotStat);
      }
      function gotStat(err, stat) {
        if (err)
          return cb(err);
        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          return process.nextTick(LOOP);
        }
        if (!isWindows3) {
          var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            return gotTarget(null, seenLinks[id], base);
          }
        }
        fs29.stat(base, function(err2) {
          if (err2)
            return cb(err2);
          fs29.readlink(base, function(err3, target) {
            if (!isWindows3)
              seenLinks[id] = target;
            gotTarget(err3, target);
          });
        });
      }
      function gotTarget(err, target, base2) {
        if (err)
          return cb(err);
        var resolvedLink = pathModule.resolve(previous, target);
        if (cache)
          cache[base2] = resolvedLink;
        gotResolvedLink(resolvedLink);
      }
      function gotResolvedLink(resolvedLink) {
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
    };
  }
});

// node_modules/fs.realpath/index.js
var require_fs3 = __commonJS({
  "node_modules/fs.realpath/index.js"(exports, module2) {
    module2.exports = realpath;
    realpath.realpath = realpath;
    realpath.sync = realpathSync;
    realpath.realpathSync = realpathSync;
    realpath.monkeypatch = monkeypatch;
    realpath.unmonkeypatch = unmonkeypatch;
    var fs29 = require("fs");
    var origRealpath = fs29.realpath;
    var origRealpathSync = fs29.realpathSync;
    var version2 = process.version;
    var ok = /^v[0-5]\./.test(version2);
    var old = require_old();
    function newError(er) {
      return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
    }
    function realpath(p, cache, cb) {
      if (ok) {
        return origRealpath(p, cache, cb);
      }
      if (typeof cache === "function") {
        cb = cache;
        cache = null;
      }
      origRealpath(p, cache, function(er, result) {
        if (newError(er)) {
          old.realpath(p, cache, cb);
        } else {
          cb(er, result);
        }
      });
    }
    function realpathSync(p, cache) {
      if (ok) {
        return origRealpathSync(p, cache);
      }
      try {
        return origRealpathSync(p, cache);
      } catch (er) {
        if (newError(er)) {
          return old.realpathSync(p, cache);
        } else {
          throw er;
        }
      }
    }
    function monkeypatch() {
      fs29.realpath = realpath;
      fs29.realpathSync = realpathSync;
    }
    function unmonkeypatch() {
      fs29.realpath = origRealpath;
      fs29.realpathSync = origRealpathSync;
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports, module2) {
    try {
      util4 = require("util");
      if (typeof util4.inherits !== "function")
        throw "";
      module2.exports = util4.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util4;
  }
});

// node_modules/path-is-absolute/index.js
var require_path_is_absolute = __commonJS({
  "node_modules/path-is-absolute/index.js"(exports, module2) {
    "use strict";
    function posix(path41) {
      return path41.charAt(0) === "/";
    }
    function win32(path41) {
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var result = splitDeviceRe.exec(path41);
      var device = result[1] || "";
      var isUnc = Boolean(device && device.charAt(1) !== ":");
      return Boolean(result[2] || isUnc);
    }
    module2.exports = process.platform === "win32" ? win32 : posix;
    module2.exports.posix = posix;
    module2.exports.win32 = win32;
  }
});

// node_modules/glob/common.js
var require_common2 = __commonJS({
  "node_modules/glob/common.js"(exports) {
    exports.setopts = setopts;
    exports.ownProp = ownProp;
    exports.makeAbs = makeAbs;
    exports.finish = finish;
    exports.mark = mark;
    exports.isIgnored = isIgnored;
    exports.childrenIgnored = childrenIgnored;
    function ownProp(obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field);
    }
    var fs29 = require("fs");
    var path41 = require("path");
    var minimatch10 = require_minimatch();
    var isAbsolute = require_path_is_absolute();
    var Minimatch2 = minimatch10.Minimatch;
    function alphasort(a, b) {
      return a.localeCompare(b, "en");
    }
    function setupIgnores(self2, options2) {
      self2.ignore = options2.ignore || [];
      if (!Array.isArray(self2.ignore))
        self2.ignore = [self2.ignore];
      if (self2.ignore.length) {
        self2.ignore = self2.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch2(gpattern, { dot: true });
      }
      return {
        matcher: new Minimatch2(pattern, { dot: true }),
        gmatcher
      };
    }
    function setopts(self2, pattern, options2) {
      if (!options2)
        options2 = {};
      if (options2.matchBase && pattern.indexOf("/") === -1) {
        if (options2.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
      }
      self2.silent = !!options2.silent;
      self2.pattern = pattern;
      self2.strict = options2.strict !== false;
      self2.realpath = !!options2.realpath;
      self2.realpathCache = options2.realpathCache || /* @__PURE__ */ Object.create(null);
      self2.follow = !!options2.follow;
      self2.dot = !!options2.dot;
      self2.mark = !!options2.mark;
      self2.nodir = !!options2.nodir;
      if (self2.nodir)
        self2.mark = true;
      self2.sync = !!options2.sync;
      self2.nounique = !!options2.nounique;
      self2.nonull = !!options2.nonull;
      self2.nosort = !!options2.nosort;
      self2.nocase = !!options2.nocase;
      self2.stat = !!options2.stat;
      self2.noprocess = !!options2.noprocess;
      self2.absolute = !!options2.absolute;
      self2.fs = options2.fs || fs29;
      self2.maxLength = options2.maxLength || Infinity;
      self2.cache = options2.cache || /* @__PURE__ */ Object.create(null);
      self2.statCache = options2.statCache || /* @__PURE__ */ Object.create(null);
      self2.symlinks = options2.symlinks || /* @__PURE__ */ Object.create(null);
      setupIgnores(self2, options2);
      self2.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp(options2, "cwd"))
        self2.cwd = cwd;
      else {
        self2.cwd = path41.resolve(options2.cwd);
        self2.changedCwd = self2.cwd !== cwd;
      }
      self2.root = options2.root || path41.resolve(self2.cwd, "/");
      self2.root = path41.resolve(self2.root);
      if (process.platform === "win32")
        self2.root = self2.root.replace(/\\/g, "/");
      self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
      if (process.platform === "win32")
        self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
      self2.nomount = !!options2.nomount;
      options2.nonegate = true;
      options2.nocomment = true;
      self2.minimatch = new Minimatch2(pattern, options2);
      self2.options = self2.minimatch.options;
    }
    function finish(self2) {
      var nou = self2.nounique;
      var all = nou ? [] : /* @__PURE__ */ Object.create(null);
      for (var i = 0, l = self2.matches.length; i < l; i++) {
        var matches = self2.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
          if (self2.nonull) {
            var literal = self2.minimatch.globSet[i];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          var m = Object.keys(matches);
          if (nou)
            all.push.apply(all, m);
          else
            m.forEach(function(m2) {
              all[m2] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self2.nosort)
        all = all.sort(alphasort);
      if (self2.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self2._mark(all[i]);
        }
        if (self2.nodir) {
          all = all.filter(function(e) {
            var notDir = !/\/$/.test(e);
            var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
            if (notDir && c)
              notDir = c !== "DIR" && !Array.isArray(c);
            return notDir;
          });
        }
      }
      if (self2.ignore.length)
        all = all.filter(function(m2) {
          return !isIgnored(self2, m2);
        });
      self2.found = all;
    }
    function mark(self2, p) {
      var abs = makeAbs(self2, p);
      var c = self2.cache[abs];
      var m = p;
      if (c) {
        var isDir = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir && !slash)
          m += "/";
        else if (!isDir && slash)
          m = m.slice(0, -1);
        if (m !== p) {
          var mabs = makeAbs(self2, m);
          self2.statCache[mabs] = self2.statCache[abs];
          self2.cache[mabs] = self2.cache[abs];
        }
      }
      return m;
    }
    function makeAbs(self2, f) {
      var abs = f;
      if (f.charAt(0) === "/") {
        abs = path41.join(self2.root, f);
      } else if (isAbsolute(f) || f === "") {
        abs = f;
      } else if (self2.changedCwd) {
        abs = path41.resolve(self2.cwd, f);
      } else {
        abs = path41.resolve(f);
      }
      if (process.platform === "win32")
        abs = abs.replace(/\\/g, "/");
      return abs;
    }
    function isIgnored(self2, path42) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return item.matcher.match(path42) || !!(item.gmatcher && item.gmatcher.match(path42));
      });
    }
    function childrenIgnored(self2, path42) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path42));
      });
    }
  }
});

// node_modules/glob/sync.js
var require_sync = __commonJS({
  "node_modules/glob/sync.js"(exports, module2) {
    module2.exports = globSync;
    globSync.GlobSync = GlobSync;
    var rp = require_fs3();
    var minimatch10 = require_minimatch();
    var Minimatch2 = minimatch10.Minimatch;
    var Glob = require_glob().Glob;
    var util4 = require("util");
    var path41 = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var common = require_common2();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    function globSync(pattern, options2) {
      if (typeof options2 === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync(pattern, options2).found;
    }
    function GlobSync(pattern, options2) {
      if (!pattern)
        throw new Error("must provide pattern");
      if (typeof options2 === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options2);
      setopts(this, pattern, options2);
      if (this.noprocess)
        return this;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false);
      }
      this._finish();
    }
    GlobSync.prototype._finish = function() {
      assert(this instanceof GlobSync);
      if (this.realpath) {
        var self2 = this;
        this.matches.forEach(function(matchset, index) {
          var set = self2.matches[index] = /* @__PURE__ */ Object.create(null);
          for (var p in matchset) {
            try {
              p = self2._makeAbs(p);
              var real = rp.realpathSync(p, self2.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === "stat")
                set[self2._makeAbs(p)] = true;
              else
                throw er;
            }
          }
        });
      }
      common.finish(this);
    };
    GlobSync.prototype._process = function(pattern, index, inGlobStar) {
      assert(this instanceof GlobSync);
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return;
      var isGlobStar = remain[0] === minimatch10.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
    };
    GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path41.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return;
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e];
        else
          newPattern = [e];
        this._process(newPattern.concat(remain), index, inGlobStar);
      }
    };
    GlobSync.prototype._emitMatch = function(index, e) {
      if (isIgnored(this, e))
        return;
      var abs = this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute) {
        e = abs;
      }
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      if (this.stat)
        this._stat(e);
    };
    GlobSync.prototype._readdirInGlobStar = function(abs) {
      if (this.follow)
        return this._readdir(abs, false);
      var entries;
      var lstat;
      var stat;
      try {
        lstat = this.fs.lstatSync(abs);
      } catch (er) {
        if (er.code === "ENOENT") {
          return null;
        }
      }
      var isSym = lstat && lstat.isSymbolicLink();
      this.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory())
        this.cache[abs] = "FILE";
      else
        entries = this._readdir(abs, false);
      return entries;
    };
    GlobSync.prototype._readdir = function(abs, inGlobStar) {
      var entries;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return null;
        if (Array.isArray(c))
          return c;
      }
      try {
        return this._readdirEntries(abs, this.fs.readdirSync(abs));
      } catch (er) {
        this._readdirError(abs, er);
        return null;
      }
    };
    GlobSync.prototype._readdirEntries = function(abs, entries) {
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return entries;
    };
    GlobSync.prototype._readdirError = function(f, er) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            throw error;
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict)
            throw er;
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
    };
    GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false);
      var len = entries.length;
      var isSym = this.symlinks[abs];
      if (isSym && inGlobStar)
        return;
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true);
      }
    };
    GlobSync.prototype._processSimple = function(prefix, index) {
      var exists = this._stat(prefix);
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return;
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path41.join(this.root, prefix);
        } else {
          prefix = path41.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
    };
    GlobSync.prototype._stat = function(f) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return false;
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return c;
        if (needDir && c === "FILE")
          return false;
      }
      var exists;
      var stat = this.statCache[abs];
      if (!stat) {
        var lstat;
        try {
          lstat = this.fs.lstatSync(abs);
        } catch (er) {
          if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
            this.statCache[abs] = false;
            return false;
          }
        }
        if (lstat && lstat.isSymbolicLink()) {
          try {
            stat = this.fs.statSync(abs);
          } catch (er) {
            stat = lstat;
          }
        } else {
          stat = lstat;
        }
      }
      this.statCache[abs] = stat;
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return false;
      return c;
    };
    GlobSync.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    GlobSync.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name2 = fn.name || "Function wrapped with `once`";
      f.onceError = name2 + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// node_modules/inflight/inflight.js
var require_inflight = __commonJS({
  "node_modules/inflight/inflight.js"(exports, module2) {
    var wrappy = require_wrappy();
    var reqs = /* @__PURE__ */ Object.create(null);
    var once = require_once();
    module2.exports = wrappy(inflight);
    function inflight(key, cb) {
      if (reqs[key]) {
        reqs[key].push(cb);
        return null;
      } else {
        reqs[key] = [cb];
        return makeres(key);
      }
    }
    function makeres(key) {
      return once(function RES() {
        var cbs = reqs[key];
        var len = cbs.length;
        var args = slice(arguments);
        try {
          for (var i = 0; i < len; i++) {
            cbs[i].apply(null, args);
          }
        } finally {
          if (cbs.length > len) {
            cbs.splice(0, len);
            process.nextTick(function() {
              RES.apply(null, args);
            });
          } else {
            delete reqs[key];
          }
        }
      });
    }
    function slice(args) {
      var length = args.length;
      var array = [];
      for (var i = 0; i < length; i++)
        array[i] = args[i];
      return array;
    }
  }
});

// node_modules/glob/glob.js
var require_glob = __commonJS({
  "node_modules/glob/glob.js"(exports, module2) {
    module2.exports = glob3;
    var rp = require_fs3();
    var minimatch10 = require_minimatch();
    var Minimatch2 = minimatch10.Minimatch;
    var inherits = require_inherits();
    var EE = require("events").EventEmitter;
    var path41 = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var globSync = require_sync();
    var common = require_common2();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = require_inflight();
    var util4 = require("util");
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    var once = require_once();
    function glob3(pattern, options2, cb) {
      if (typeof options2 === "function")
        cb = options2, options2 = {};
      if (!options2)
        options2 = {};
      if (options2.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options2);
      }
      return new Glob(pattern, options2, cb);
    }
    glob3.sync = globSync;
    var GlobSync = glob3.GlobSync = globSync.GlobSync;
    glob3.glob = glob3;
    function extend(origin, add) {
      if (add === null || typeof add !== "object") {
        return origin;
      }
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    }
    glob3.hasMagic = function(pattern, options_) {
      var options2 = extend({}, options_);
      options2.noprocess = true;
      var g = new Glob(pattern, options2);
      var set = g.minimatch.set;
      if (!pattern)
        return false;
      if (set.length > 1)
        return true;
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== "string")
          return true;
      }
      return false;
    };
    glob3.Glob = Glob;
    inherits(Glob, EE);
    function Glob(pattern, options2, cb) {
      if (typeof options2 === "function") {
        cb = options2;
        options2 = null;
      }
      if (options2 && options2.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern, options2);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern, options2, cb);
      setopts(this, pattern, options2);
      this._didRealPath = false;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      if (typeof cb === "function") {
        cb = once(cb);
        this.on("error", cb);
        this.on("end", function(matches) {
          cb(null, matches);
        });
      }
      var self2 = this;
      this._processing = 0;
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n === 0)
        return done();
      var sync = true;
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false, done);
      }
      sync = false;
      function done() {
        --self2._processing;
        if (self2._processing <= 0) {
          if (sync) {
            process.nextTick(function() {
              self2._finish();
            });
          } else {
            self2._finish();
          }
        }
      }
    }
    Glob.prototype._finish = function() {
      assert(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n = this.matches.length;
      if (n === 0)
        return this._finish();
      var self2 = this;
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next);
      function next() {
        if (--n === 0)
          self2._finish();
      }
    };
    Glob.prototype._realpathSet = function(index, cb) {
      var matchset = this.matches[index];
      if (!matchset)
        return cb();
      var found = Object.keys(matchset);
      var self2 = this;
      var n = found.length;
      if (n === 0)
        return cb();
      var set = this.matches[index] = /* @__PURE__ */ Object.create(null);
      found.forEach(function(p, i) {
        p = self2._makeAbs(p);
        rp.realpath(p, self2.realpathCache, function(er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === "stat")
            set[p] = true;
          else
            self2.emit("error", er);
          if (--n === 0) {
            self2.matches[index] = set;
            cb();
          }
        });
      });
    };
    Glob.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    Glob.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i = 0; i < eq.length; i++) {
            var e = eq[i];
            this._emitMatch(e[0], e[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i = 0; i < pq.length; i++) {
            var p = pq[i];
            this._processing--;
            this._process(p[0], p[1], p[2], p[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob);
      assert(typeof cb === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb]);
        return;
      }
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return cb();
      var isGlobStar = remain[0] === minimatch10.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
    };
    Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path41.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return cb();
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        this._process([e].concat(remain), index, inGlobStar, cb);
      }
      cb();
    };
    Glob.prototype._emitMatch = function(index, e) {
      if (this.aborted)
        return;
      if (isIgnored(this, e))
        return;
      if (this.paused) {
        this._emitQueue.push([index, e]);
        return;
      }
      var abs = isAbsolute(e) ? e : this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute)
        e = abs;
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      var st = this.statCache[abs];
      if (st)
        this.emit("stat", e, st);
      this.emit("match", e);
    };
    Glob.prototype._readdirInGlobStar = function(abs, cb) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs, false, cb);
      var lstatkey = "lstat\0" + abs;
      var self2 = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        self2.fs.lstat(abs, lstatcb);
      function lstatcb_(er, lstat) {
        if (er && er.code === "ENOENT")
          return cb();
        var isSym = lstat && lstat.isSymbolicLink();
        self2.symlinks[abs] = isSym;
        if (!isSym && lstat && !lstat.isDirectory()) {
          self2.cache[abs] = "FILE";
          cb();
        } else
          self2._readdir(abs, false, cb);
      }
    };
    Glob.prototype._readdir = function(abs, inGlobStar, cb) {
      if (this.aborted)
        return;
      cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
      if (!cb)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return cb();
        if (Array.isArray(c))
          return cb(null, c);
      }
      var self2 = this;
      self2.fs.readdir(abs, readdirCb(this, abs, cb));
    };
    function readdirCb(self2, abs, cb) {
      return function(er, entries) {
        if (er)
          self2._readdirError(abs, er, cb);
        else
          self2._readdirEntries(abs, entries, cb);
      };
    }
    Glob.prototype._readdirEntries = function(abs, entries, cb) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return cb(null, entries);
    };
    Glob.prototype._readdirError = function(f, er, cb) {
      if (this.aborted)
        return;
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            this.emit("error", error);
            this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict) {
            this.emit("error", er);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
      return cb();
    };
    Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false, cb);
      var isSym = this.symlinks[abs];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb();
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true, cb);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true, cb);
      }
      cb();
    };
    Glob.prototype._processSimple = function(prefix, index, cb) {
      var self2 = this;
      this._stat(prefix, function(er, exists) {
        self2._processSimple2(prefix, index, er, exists, cb);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
      if (!this.matches[index])
        this.matches[index] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return cb();
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path41.join(this.root, prefix);
        } else {
          prefix = path41.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
      cb();
    };
    Glob.prototype._stat = function(f, cb) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return cb();
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return cb(null, c);
        if (needDir && c === "FILE")
          return cb();
      }
      var exists;
      var stat = this.statCache[abs];
      if (stat !== void 0) {
        if (stat === false)
          return cb(null, stat);
        else {
          var type = stat.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb();
          else
            return cb(null, type, stat);
        }
      }
      var self2 = this;
      var statcb = inflight("stat\0" + abs, lstatcb_);
      if (statcb)
        self2.fs.lstat(abs, statcb);
      function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          return self2.fs.stat(abs, function(er2, stat2) {
            if (er2)
              self2._stat2(f, abs, null, lstat, cb);
            else
              self2._stat2(f, abs, er2, stat2, cb);
          });
        } else {
          self2._stat2(f, abs, er, lstat, cb);
        }
      }
    };
    Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
      if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
        this.statCache[abs] = false;
        return cb();
      }
      var needDir = f.slice(-1) === "/";
      this.statCache[abs] = stat;
      if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
        return cb(null, false, stat);
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return cb();
      return cb(null, c, stat);
    };
  }
});

// src/types.ts
var PatternType, SourceType, MessageLevel, ConfigurationTarget, ServiceStat, FileType;
var init_types = __esm({
  "src/types.ts"() {
    "use strict";
    PatternType = /* @__PURE__ */ ((PatternType2) => {
      PatternType2[PatternType2["Buffer"] = 0] = "Buffer";
      PatternType2[PatternType2["LanguageServer"] = 1] = "LanguageServer";
      PatternType2[PatternType2["Global"] = 2] = "Global";
      return PatternType2;
    })(PatternType || {});
    SourceType = /* @__PURE__ */ ((SourceType2) => {
      SourceType2[SourceType2["Native"] = 0] = "Native";
      SourceType2[SourceType2["Remote"] = 1] = "Remote";
      SourceType2[SourceType2["Service"] = 2] = "Service";
      return SourceType2;
    })(SourceType || {});
    MessageLevel = /* @__PURE__ */ ((MessageLevel2) => {
      MessageLevel2[MessageLevel2["More"] = 0] = "More";
      MessageLevel2[MessageLevel2["Warning"] = 1] = "Warning";
      MessageLevel2[MessageLevel2["Error"] = 2] = "Error";
      return MessageLevel2;
    })(MessageLevel || {});
    ConfigurationTarget = /* @__PURE__ */ ((ConfigurationTarget2) => {
      ConfigurationTarget2[ConfigurationTarget2["Global"] = 0] = "Global";
      ConfigurationTarget2[ConfigurationTarget2["User"] = 1] = "User";
      ConfigurationTarget2[ConfigurationTarget2["Workspace"] = 2] = "Workspace";
      return ConfigurationTarget2;
    })(ConfigurationTarget || {});
    ServiceStat = /* @__PURE__ */ ((ServiceStat2) => {
      ServiceStat2[ServiceStat2["Initial"] = 0] = "Initial";
      ServiceStat2[ServiceStat2["Starting"] = 1] = "Starting";
      ServiceStat2[ServiceStat2["StartFailed"] = 2] = "StartFailed";
      ServiceStat2[ServiceStat2["Running"] = 3] = "Running";
      ServiceStat2[ServiceStat2["Stopping"] = 4] = "Stopping";
      ServiceStat2[ServiceStat2["Stopped"] = 5] = "Stopped";
      return ServiceStat2;
    })(ServiceStat || {});
    FileType = /* @__PURE__ */ ((FileType2) => {
      FileType2[FileType2["Unknown"] = 0] = "Unknown";
      FileType2[FileType2["File"] = 1] = "File";
      FileType2[FileType2["Directory"] = 2] = "Directory";
      FileType2[FileType2["SymbolicLink"] = 64] = "SymbolicLink";
      return FileType2;
    })(FileType || {});
  }
});

// src/util/fs.ts
async function statAsync(filepath) {
  let stat = null;
  try {
    stat = await import_fs_extra.default.stat(filepath);
  } catch (e) {
  }
  return stat;
}
async function getFileType(filepath) {
  try {
    const stat = await statAsync(filepath);
    if (stat.isFile()) {
      return 1 /* File */;
    }
    if (stat.isDirectory()) {
      return 2 /* Directory */;
    }
    if (stat.isSymbolicLink()) {
      return 64 /* SymbolicLink */;
    }
    return 0 /* Unknown */;
  } catch (e) {
    return void 0;
  }
}
async function isGitIgnored(fullpath) {
  if (!fullpath)
    return false;
  let stat = await statAsync(fullpath);
  if (!stat || !stat.isFile())
    return false;
  let root = null;
  try {
    let { stdout } = await import_util2.default.promisify(import_child_process2.exec)("git rev-parse --show-toplevel", { cwd: import_path2.default.dirname(fullpath) });
    root = stdout.trim();
  } catch (e) {
  }
  if (!root)
    return false;
  let file = import_path2.default.relative(root, fullpath);
  try {
    let { stdout } = await import_util2.default.promisify(import_child_process2.exec)(`git check-ignore ${file}`, { cwd: root });
    return stdout.trim() == file;
  } catch (e) {
  }
  return false;
}
function isFolderIgnored(folder, ignored = []) {
  if (!ignored || !ignored.length)
    return false;
  return ignored.some((p) => (0, import_minimatch.default)(folder, p, { dot: true }));
}
function resolveRoot(folder, subs, cwd, bottomup = false, checkCwd = true, ignored = []) {
  let dir = fixDriver(folder);
  if (checkCwd && cwd && isParentFolder(cwd, dir, true) && !isFolderIgnored(cwd, ignored) && inDirectory(cwd, subs))
    return cwd;
  let parts = dir.split(import_path2.default.sep);
  if (bottomup) {
    while (parts.length > 0) {
      let dir2 = parts.join(import_path2.default.sep);
      if (!isFolderIgnored(dir2, ignored) && inDirectory(dir2, subs)) {
        return dir2;
      }
      parts.pop();
    }
    return null;
  } else {
    let curr = [parts.shift()];
    for (let part of parts) {
      curr.push(part);
      let dir2 = curr.join(import_path2.default.sep);
      if (!isFolderIgnored(dir2, ignored) && inDirectory(dir2, subs)) {
        return dir2;
      }
    }
    return null;
  }
}
async function checkFolder(dir, pattern, timeout = 500) {
  return new Promise((resolve3, reject) => {
    let timer = setTimeout(() => {
      gl.abort();
      resolve3(false);
    }, timeout);
    let find = false;
    let gl = (0, import_glob.default)(pattern, {
      nosort: true,
      dot: true,
      cwd: dir,
      nodir: true,
      absolute: false
    }, (err) => {
      clearTimeout(timer);
      if (err)
        return reject(err);
      resolve3(find);
    });
    gl.on("match", () => {
      clearTimeout(timer);
      find = true;
      gl.abort();
      resolve3(true);
    });
    gl.on("end", () => {
      clearTimeout(timer);
      resolve3(find);
    });
  });
}
function inDirectory(dir, subs) {
  try {
    let files = import_fs_extra.default.readdirSync(dir);
    for (let pattern of subs) {
      let is_wildcard = pattern.includes("*");
      let res = is_wildcard ? import_minimatch.default.match(files, pattern, { nobrace: true, noext: true, nocomment: true, nonegate: true, dot: true }).length !== 0 : files.includes(pattern);
      if (res)
        return true;
    }
  } catch (e) {
  }
  return false;
}
function findUp(name2, cwd) {
  let root = import_path2.default.parse(cwd).root;
  let subs = Array.isArray(name2) ? name2 : [name2];
  while (cwd && cwd !== root) {
    let find = inDirectory(cwd, subs);
    if (find) {
      for (let sub of subs) {
        let filepath = import_path2.default.join(cwd, sub);
        if (import_fs_extra.default.existsSync(filepath)) {
          return filepath;
        }
      }
    }
    cwd = import_path2.default.dirname(cwd);
  }
  return null;
}
function readFile(fullpath, encoding) {
  return new Promise((resolve3, reject) => {
    import_fs_extra.default.readFile(fullpath, encoding, (err, content) => {
      if (err)
        reject(err);
      resolve3(content);
    });
  });
}
function getFileLineCount(filepath) {
  let i;
  let count = 0;
  return new Promise((resolve3, reject) => {
    import_fs_extra.default.createReadStream(filepath).on("error", (e) => reject(e)).on("data", (chunk) => {
      for (i = 0; i < chunk.length; ++i)
        if (chunk[i] == 10)
          count++;
    }).on("end", () => resolve3(count));
  });
}
function readFileLines(fullpath, start, end) {
  if (!import_fs_extra.default.existsSync(fullpath)) {
    return Promise.reject(new Error(`file does not exist: ${fullpath}`));
  }
  let res = [];
  const input = import_fs_extra.default.createReadStream(fullpath, { encoding: "utf8" });
  const rl = import_readline.default.createInterface({
    input,
    crlfDelay: Infinity,
    terminal: false
  });
  let n = 0;
  return new Promise((resolve3, reject) => {
    rl.on("line", (line) => {
      if (n >= start && n <= end) {
        res.push(line);
      }
      if (n == end) {
        rl.close();
      }
      n = n + 1;
    });
    rl.on("close", () => {
      resolve3(res);
      input.close();
    });
    rl.on("error", reject);
  });
}
function readFileLine(fullpath, count) {
  if (!import_fs_extra.default.existsSync(fullpath)) {
    return Promise.reject(new Error(`file does not exist: ${fullpath}`));
  }
  const input = import_fs_extra.default.createReadStream(fullpath, { encoding: "utf8" });
  const rl = import_readline.default.createInterface({
    input,
    crlfDelay: Infinity,
    terminal: false
  });
  let n = 0;
  return new Promise((resolve3, reject) => {
    rl.on("line", (line) => {
      if (n == count) {
        if (n == 0 && line.startsWith("\uFEFF")) {
          line = line.slice(1);
        }
        rl.close();
        input.close();
        resolve3(line);
        return;
      }
      n = n + 1;
    });
    rl.on("error", reject);
  });
}
function sameFile(fullpath, other, caseInsensitive) {
  caseInsensitive = typeof caseInsensitive == "boolean" ? caseInsensitive : isWindows || isMacintosh;
  if (!fullpath || !other)
    return false;
  if (caseInsensitive)
    return fullpath.toLowerCase() === other.toLowerCase();
  return fullpath === other;
}
function fileStartsWith(dir, pdir) {
  let caseInsensitive = isWindows || isMacintosh;
  if (caseInsensitive)
    return dir.toLowerCase().startsWith(pdir.toLowerCase());
  return dir.startsWith(pdir);
}
async function writeFile(fullpath, content) {
  await import_fs_extra.default.writeFile(fullpath, content, { encoding: "utf8" });
}
function isFile(uri) {
  return uri.startsWith("file:");
}
function isParentFolder(folder, filepath, checkEqual = false) {
  let pdir = fixDriver(import_path2.default.resolve(import_path2.default.normalize(folder)));
  let dir = fixDriver(import_path2.default.resolve(import_path2.default.normalize(filepath)));
  if (pdir == "//")
    pdir = "/";
  if (sameFile(pdir, dir))
    return checkEqual ? true : false;
  if (pdir.endsWith(import_path2.default.sep))
    return fileStartsWith(dir, pdir);
  return fileStartsWith(dir, pdir) && dir[pdir.length] == import_path2.default.sep;
}
function fixDriver(filepath, platform2 = import_os.default.platform()) {
  if (platform2 != "win32" || filepath[1] != ":")
    return filepath;
  return filepath[0].toUpperCase() + filepath.slice(1);
}
var import_child_process2, import_fs_extra, import_minimatch, import_os, import_path2, import_readline, import_util2, import_glob, logger3;
var init_fs = __esm({
  "src/util/fs.ts"() {
    "use strict";
    import_child_process2 = require("child_process");
    import_fs_extra = __toESM(require_lib4());
    import_minimatch = __toESM(require_minimatch());
    import_os = __toESM(require("os"));
    import_path2 = __toESM(require("path"));
    import_readline = __toESM(require("readline"));
    import_util2 = __toESM(require("util"));
    import_glob = __toESM(require_glob());
    init_platform();
    init_types();
    logger3 = require_logger2()("util-fs");
  }
});

// src/util/position.ts
function rangeInRange(r, range2) {
  return positionInRange(r.start, range2) === 0 && positionInRange(r.end, range2) === 0;
}
function samePosition(one, two) {
  return one.line === two.line && one.character === two.character;
}
function toValidRange(range2, max) {
  let { start, end } = range2;
  if (start.line > end.line || start.line === end.line && start.character > end.character) {
    let m = start;
    start = end;
    end = m;
  }
  start = import_vscode_languageserver_protocol3.Position.create(Math.max(0, start.line), Math.max(0, start.character));
  end = import_vscode_languageserver_protocol3.Position.create(Math.max(0, end.line), Math.max(0, end.character));
  return { start, end };
}
function rangeAdjacent(r, range2) {
  if (comparePosition(r.end, range2.start) == 0) {
    return true;
  }
  if (comparePosition(range2.end, r.start) == 0) {
    return true;
  }
  return false;
}
function rangeOverlap(r, range2) {
  let { start, end } = r;
  if (comparePosition(end, range2.start) <= 0) {
    return false;
  }
  if (comparePosition(start, range2.end) >= 0) {
    return false;
  }
  return true;
}
function rangeIntersect(r, range2) {
  if (positionInRange(r.start, range2) == 0) {
    return true;
  }
  if (positionInRange(r.end, range2) == 0) {
    return true;
  }
  if (rangeInRange(range2, r)) {
    return true;
  }
  return false;
}
function adjustRangePosition(range2, position) {
  let { line, character } = position;
  let { start, end } = range2;
  let endCharacter = end.line == start.line ? end.character + character : end.character;
  return import_vscode_languageserver_protocol3.Range.create(start.line + line, character + start.character, end.line + line, endCharacter);
}
function lineInRange(line, range2) {
  let { start, end } = range2;
  return line >= start.line && line <= end.line;
}
function emptyRange(range2) {
  let { start, end } = range2;
  return start.line == end.line && start.character == end.character;
}
function positionInRange(position, range2) {
  let { start, end } = range2;
  if (comparePosition(position, start) < 0)
    return -1;
  if (comparePosition(position, end) > 0)
    return 1;
  return 0;
}
function comparePosition(position, other) {
  if (position.line > other.line)
    return 1;
  if (other.line == position.line && position.character > other.character)
    return 1;
  if (other.line == position.line && position.character == other.character)
    return 0;
  return -1;
}
function isSingleLine(range2) {
  return range2.start.line == range2.end.line;
}
function getEnd(start, content) {
  const lines = content.split(/\r?\n/);
  const len = lines.length;
  const lastLine = lines[len - 1];
  const end = len == 1 ? start.character + content.length : lastLine.length;
  return import_vscode_languageserver_protocol3.Position.create(start.line + len - 1, end);
}
var import_vscode_languageserver_protocol3;
var init_position = __esm({
  "src/util/position.ts"() {
    "use strict";
    import_vscode_languageserver_protocol3 = __toESM(require_main2());
  }
});

// src/model/outputChannel.ts
var logger4, BufferChannel;
var init_outputChannel = __esm({
  "src/model/outputChannel.ts"() {
    "use strict";
    logger4 = require_logger2()("outpubChannel");
    BufferChannel = class {
      constructor(name2, nvim, onDispose) {
        this.name = name2;
        this.nvim = nvim;
        this.onDispose = onDispose;
        this.lines = [""];
        this._disposed = false;
        this.created = false;
        if (!/^[\w\s-.]+$/.test(name2))
          throw new Error(`Invalid channel name "${name2}", only word characters and white space allowed.`);
      }
      get content() {
        return this.lines.join("\n");
      }
      _append(value) {
        let { nvim } = this;
        let idx = this.lines.length - 1;
        let newlines = value.split(/\r?\n/);
        let lastline = this.lines[idx] + newlines[0];
        this.lines[idx] = lastline;
        let append = newlines.slice(1);
        this.lines = this.lines.concat(append);
        if (!this.created)
          return;
        nvim.pauseNotification();
        nvim.call("setbufline", [this.bufname, "$", lastline], true);
        if (append.length) {
          nvim.call("appendbufline", [this.bufname, "$", append], true);
        }
        nvim.resumeNotification(false, true);
      }
      append(value) {
        if (!this.validate())
          return;
        this._append(value);
      }
      appendLine(value) {
        if (!this.validate())
          return;
        this._append(value + "\n");
      }
      clear(keep) {
        if (!this.validate())
          return;
        let { nvim } = this;
        this.lines = keep ? this.lines.slice(-keep) : [];
        if (!this.created)
          return;
        nvim.pauseNotification();
        nvim.call("deletebufline", [this.bufname, 1, "$"], true);
        if (this.lines.length) {
          nvim.call("appendbufline", [this.bufname, "$", this.lines], true);
        }
        nvim.resumeNotification(true, true);
      }
      hide() {
        this.created = false;
        this.nvim.command(`exe 'silent! bd! '.fnameescape('${this.bufname}')`, true);
      }
      get bufname() {
        return `output:///${this.name}`;
      }
      show(preserveFocus, cmd = "vs") {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command(`exe '${cmd} '.fnameescape('${this.bufname}')`, true);
        if (preserveFocus) {
          nvim.command("wincmd p", true);
        }
        nvim.resumeNotification(true, true);
        this.created = true;
      }
      validate() {
        return !this._disposed;
      }
      dispose() {
        if (this.onDispose)
          this.onDispose();
        this._disposed = true;
        this.hide();
        this.lines = [];
      }
    };
  }
});

// src/core/channels.ts
var logger5, Channels, channels_default;
var init_channels = __esm({
  "src/core/channels.ts"() {
    "use strict";
    init_events();
    init_outputChannel();
    logger5 = require_logger2()("core-channels");
    Channels = class {
      constructor() {
        this.outputChannels = /* @__PURE__ */ new Map();
        this.bufnrs = /* @__PURE__ */ new Map();
        this.disposable = events_default.on("BufUnload", (bufnr) => {
          let name2 = this.bufnrs.get(bufnr);
          if (name2) {
            let channel = this.outputChannels.get(name2);
            if (channel)
              channel.created = false;
          }
        });
      }
      getProvider(nvim) {
        let provider = {
          onDidChange: null,
          provideTextDocumentContent: async (uri) => {
            let channel = this.get(uri.path.slice(1));
            if (!channel)
              return "";
            nvim.pauseNotification();
            nvim.call("bufnr", ["%"], true);
            nvim.command("setlocal nospell nofoldenable nowrap noswapfile", true);
            nvim.command("setlocal buftype=nofile bufhidden=hide", true);
            nvim.command("setfiletype log", true);
            let res = await nvim.resumeNotification();
            this.bufnrs.set(res[0][0], channel.name);
            channel.created = true;
            return channel.content;
          }
        };
        return provider;
      }
      get names() {
        return Array.from(this.outputChannels.keys());
      }
      get(channelName) {
        return this.outputChannels.get(channelName);
      }
      create(name2, nvim) {
        if (this.outputChannels.has(name2))
          return this.outputChannels.get(name2);
        let channel = new BufferChannel(name2, nvim, () => {
          this.outputChannels.delete(name2);
        });
        this.outputChannels.set(name2, channel);
        return channel;
      }
      show(name2, cmd, preserveFocus) {
        let channel = this.outputChannels.get(name2);
        if (!channel)
          return;
        channel.show(preserveFocus, cmd);
      }
      dispose() {
        this.disposable.dispose();
        for (let channel of this.outputChannels.values()) {
          channel.dispose();
        }
        this.outputChannels.clear();
      }
    };
    channels_default = new Channels();
  }
});

// src/model/terminal.ts
var logger6, TerminalModel;
var init_terminal = __esm({
  "src/model/terminal.ts"() {
    "use strict";
    logger6 = require_logger2()("model-terminal");
    TerminalModel = class {
      constructor(cmd, args, nvim, _name, strictEnv) {
        this.cmd = cmd;
        this.args = args;
        this.nvim = nvim;
        this._name = _name;
        this.strictEnv = strictEnv;
        this.pid = 0;
      }
      async start(cwd, env) {
        let { nvim } = this;
        let cmd = [this.cmd, ...this.args];
        let [bufnr, pid] = await nvim.call("coc#terminal#start", [cmd, cwd, env || {}, !!this.strictEnv]);
        this.bufnr = bufnr;
        this.pid = pid;
      }
      onExit(code) {
        this.exitStatus = { code: code === -1 ? void 0 : code };
      }
      get name() {
        return this._name || this.cmd;
      }
      get processId() {
        return Promise.resolve(this.pid);
      }
      sendText(text, addNewLine = true) {
        if (!this.bufnr)
          return;
        this.nvim.call("coc#terminal#send", [this.bufnr, text, addNewLine], true);
      }
      async show(preserveFocus) {
        let { bufnr, nvim } = this;
        if (!bufnr)
          return;
        let [loaded, winid, curr] = await nvim.eval(`[bufloaded(${bufnr}),bufwinid(${bufnr}),win_getid()]`);
        if (!loaded)
          return false;
        if (curr == winid)
          return true;
        nvim.pauseNotification();
        if (winid == -1) {
          nvim.command(`below ${bufnr}sb`, true);
          nvim.command("resize 8", true);
          nvim.call("coc#util#do_autocmd", ["CocTerminalOpen"], true);
        } else {
          nvim.call("win_gotoid", [winid], true);
        }
        nvim.command("normal! G", true);
        if (preserveFocus) {
          nvim.command("wincmd p", true);
        }
        await nvim.resumeNotification();
        return true;
      }
      async hide() {
        let { bufnr, nvim } = this;
        if (!bufnr)
          return;
        await nvim.eval(`coc#window#close(bufwinid(${bufnr}))`);
      }
      dispose() {
        if (!this.exitStatus) {
          this.exitStatus = { code: void 0 };
        }
        let { bufnr, nvim } = this;
        if (!bufnr)
          return;
        this.bufnr = void 0;
        nvim.call("coc#terminal#close", [bufnr], true);
      }
    };
  }
});

// src/core/terminals.ts
var import_vscode_languageserver_protocol4, logger7, Terminals;
var init_terminals = __esm({
  "src/core/terminals.ts"() {
    "use strict";
    init_terminal();
    import_vscode_languageserver_protocol4 = __toESM(require_main2());
    init_util();
    init_events();
    logger7 = require_logger2()("core-terminals");
    Terminals = class {
      constructor() {
        this._terminals = /* @__PURE__ */ new Map();
        this.disposables = [];
        this._onDidOpenTerminal = new import_vscode_languageserver_protocol4.Emitter();
        this._onDidCloseTerminal = new import_vscode_languageserver_protocol4.Emitter();
        this.onDidCloseTerminal = this._onDidCloseTerminal.event;
        this.onDidOpenTerminal = this._onDidOpenTerminal.event;
        events_default.on("BufUnload", (bufnr) => {
          if (this._terminals.has(bufnr)) {
            logger7.debug("terminal detach", bufnr);
            let terminal = this._terminals.get(bufnr);
            this._onDidCloseTerminal.fire(terminal);
            this._terminals.delete(bufnr);
          }
        }, null, this.disposables);
        events_default.on("TermExit", (bufnr, status) => {
          let terminal = this._terminals.get(bufnr);
          if (terminal) {
            terminal.onExit(status);
            terminal.dispose();
          }
        }, null, this.disposables);
      }
      get terminals() {
        return Array.from(this._terminals.values());
      }
      async createTerminal(nvim, opts) {
        let cwd = opts.cwd;
        let cmd = opts.shellPath;
        let args = opts.shellArgs;
        if (!cmd)
          cmd = await nvim.getOption("shell");
        if (!cwd)
          cwd = await nvim.call("getcwd");
        let terminal = new TerminalModel(cmd, args || [], nvim, opts.name, opts.strictEnv);
        await terminal.start(cwd, opts.env);
        this._terminals.set(terminal.bufnr, terminal);
        this._onDidOpenTerminal.fire(terminal);
        return terminal;
      }
      reset() {
        for (let terminal of this._terminals.values()) {
          terminal.dispose();
        }
        this._terminals.clear();
      }
      dispose() {
        this._onDidOpenTerminal.dispose();
        this._onDidCloseTerminal.dispose();
        disposeAll(this.disposables);
        this.reset();
      }
    };
  }
});

// node_modules/marked/lib/marked.esm.js
function getDefaults() {
  return {
    baseUrl: null,
    breaks: false,
    extensions: null,
    gfm: true,
    headerIds: true,
    headerPrefix: "",
    highlight: null,
    langPrefix: "language-",
    mangle: true,
    pedantic: false,
    renderer: null,
    sanitize: false,
    sanitizer: null,
    silent: false,
    smartLists: false,
    smartypants: false,
    tokenizer: null,
    walkTokens: null,
    xhtml: false
  };
}
function changeDefaults(newDefaults) {
  defaults = newDefaults;
}
function escape(html, encode) {
  if (encode) {
    if (escapeTest.test(html)) {
      return html.replace(escapeReplace, getEscapeReplacement);
    }
  } else {
    if (escapeTestNoEncode.test(html)) {
      return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
    }
  }
  return html;
}
function unescape2(html) {
  return html.replace(unescapeTest, (_, n) => {
    n = n.toLowerCase();
    if (n === "colon")
      return ":";
    if (n.charAt(0) === "#") {
      return n.charAt(1) === "x" ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));
    }
    return "";
  });
}
function edit(regex3, opt) {
  regex3 = regex3.source || regex3;
  opt = opt || "";
  const obj = {
    replace: (name2, val) => {
      val = val.source || val;
      val = val.replace(caret, "$1");
      regex3 = regex3.replace(name2, val);
      return obj;
    },
    getRegex: () => {
      return new RegExp(regex3, opt);
    }
  };
  return obj;
}
function cleanUrl(sanitize, base, href) {
  if (sanitize) {
    let prot;
    try {
      prot = decodeURIComponent(unescape2(href)).replace(nonWordAndColonTest, "").toLowerCase();
    } catch (e) {
      return null;
    }
    if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
      return null;
    }
  }
  if (base && !originIndependentUrl.test(href)) {
    href = resolveUrl(base, href);
  }
  try {
    href = encodeURI(href).replace(/%25/g, "%");
  } catch (e) {
    return null;
  }
  return href;
}
function resolveUrl(base, href) {
  if (!baseUrls[" " + base]) {
    if (justDomain.test(base)) {
      baseUrls[" " + base] = base + "/";
    } else {
      baseUrls[" " + base] = rtrim(base, "/", true);
    }
  }
  base = baseUrls[" " + base];
  const relativeBase = base.indexOf(":") === -1;
  if (href.substring(0, 2) === "//") {
    if (relativeBase) {
      return href;
    }
    return base.replace(protocol, "$1") + href;
  } else if (href.charAt(0) === "/") {
    if (relativeBase) {
      return href;
    }
    return base.replace(domain, "$1") + href;
  } else {
    return base + href;
  }
}
function merge(obj) {
  let i = 1, target, key;
  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }
  return obj;
}
function splitCells(tableRow, count) {
  const row = tableRow.replace(/\|/g, (match, offset, str) => {
    let escaped = false, curr = offset;
    while (--curr >= 0 && str[curr] === "\\")
      escaped = !escaped;
    if (escaped) {
      return "|";
    } else {
      return " |";
    }
  }), cells = row.split(/ \|/);
  let i = 0;
  if (!cells[0].trim()) {
    cells.shift();
  }
  if (cells.length > 0 && !cells[cells.length - 1].trim()) {
    cells.pop();
  }
  if (cells.length > count) {
    cells.splice(count);
  } else {
    while (cells.length < count)
      cells.push("");
  }
  for (; i < cells.length; i++) {
    cells[i] = cells[i].trim().replace(/\\\|/g, "|");
  }
  return cells;
}
function rtrim(str, c, invert) {
  const l = str.length;
  if (l === 0) {
    return "";
  }
  let suffLen = 0;
  while (suffLen < l) {
    const currChar = str.charAt(l - suffLen - 1);
    if (currChar === c && !invert) {
      suffLen++;
    } else if (currChar !== c && invert) {
      suffLen++;
    } else {
      break;
    }
  }
  return str.substr(0, l - suffLen);
}
function findClosingBracket(str, b) {
  if (str.indexOf(b[1]) === -1) {
    return -1;
  }
  const l = str.length;
  let level = 0, i = 0;
  for (; i < l; i++) {
    if (str[i] === "\\") {
      i++;
    } else if (str[i] === b[0]) {
      level++;
    } else if (str[i] === b[1]) {
      level--;
      if (level < 0) {
        return i;
      }
    }
  }
  return -1;
}
function checkSanitizeDeprecation(opt) {
  if (opt && opt.sanitize && !opt.silent) {
    console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
  }
}
function repeatString(pattern, count) {
  if (count < 1) {
    return "";
  }
  let result = "";
  while (count > 1) {
    if (count & 1) {
      result += pattern;
    }
    count >>= 1;
    pattern += pattern;
  }
  return result + pattern;
}
function outputLink(cap, link, raw, lexer2) {
  const href = link.href;
  const title = link.title ? escape(link.title) : null;
  const text = cap[1].replace(/\\([\[\]])/g, "$1");
  if (cap[0].charAt(0) !== "!") {
    lexer2.state.inLink = true;
    const token = {
      type: "link",
      raw,
      href,
      title,
      text,
      tokens: lexer2.inlineTokens(text, [])
    };
    lexer2.state.inLink = false;
    return token;
  } else {
    return {
      type: "image",
      raw,
      href,
      title,
      text: escape(text)
    };
  }
}
function indentCodeCompensation(raw, text) {
  const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
  if (matchIndentToCode === null) {
    return text;
  }
  const indentToCode = matchIndentToCode[1];
  return text.split("\n").map((node) => {
    const matchIndentInNode = node.match(/^\s+/);
    if (matchIndentInNode === null) {
      return node;
    }
    const [indentInNode] = matchIndentInNode;
    if (indentInNode.length >= indentToCode.length) {
      return node.slice(indentToCode.length);
    }
    return node;
  }).join("\n");
}
function smartypants(text) {
  return text.replace(/---/g, "\u2014").replace(/--/g, "\u2013").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018").replace(/'/g, "\u2019").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C").replace(/"/g, "\u201D").replace(/\.{3}/g, "\u2026");
}
function mangle(text) {
  let out = "", i, ch;
  const l = text.length;
  for (i = 0; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = "x" + ch.toString(16);
    }
    out += "&#" + ch + ";";
  }
  return out;
}
function marked(src, opt, callback) {
  if (typeof src === "undefined" || src === null) {
    throw new Error("marked(): input parameter is undefined or null");
  }
  if (typeof src !== "string") {
    throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
  }
  if (typeof opt === "function") {
    callback = opt;
    opt = null;
  }
  opt = merge({}, marked.defaults, opt || {});
  checkSanitizeDeprecation(opt);
  if (callback) {
    const highlight = opt.highlight;
    let tokens;
    try {
      tokens = Lexer.lex(src, opt);
    } catch (e) {
      return callback(e);
    }
    const done = function(err) {
      let out;
      if (!err) {
        try {
          if (opt.walkTokens) {
            marked.walkTokens(tokens, opt.walkTokens);
          }
          out = Parser.parse(tokens, opt);
        } catch (e) {
          err = e;
        }
      }
      opt.highlight = highlight;
      return err ? callback(err) : callback(null, out);
    };
    if (!highlight || highlight.length < 3) {
      return done();
    }
    delete opt.highlight;
    if (!tokens.length)
      return done();
    let pending = 0;
    marked.walkTokens(tokens, function(token) {
      if (token.type === "code") {
        pending++;
        setTimeout(() => {
          highlight(token.text, token.lang, function(err, code) {
            if (err) {
              return done(err);
            }
            if (code != null && code !== token.text) {
              token.text = code;
              token.escaped = true;
            }
            pending--;
            if (pending === 0) {
              done();
            }
          });
        }, 0);
      }
    });
    if (pending === 0) {
      done();
    }
    return;
  }
  try {
    const tokens = Lexer.lex(src, opt);
    if (opt.walkTokens) {
      marked.walkTokens(tokens, opt.walkTokens);
    }
    return Parser.parse(tokens, opt);
  } catch (e) {
    e.message += "\nPlease report this to https://github.com/markedjs/marked.";
    if (opt.silent) {
      return "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
    }
    throw e;
  }
}
var defaults, escapeTest, escapeReplace, escapeTestNoEncode, escapeReplaceNoEncode, escapeReplacements, getEscapeReplacement, unescapeTest, caret, nonWordAndColonTest, originIndependentUrl, baseUrls, justDomain, protocol, domain, noopTest, Tokenizer, block, inline, Lexer, Renderer, TextRenderer, Slugger, Parser, options, setOptions, use, walkTokens, parseInline, parser, lexer;
var init_marked_esm = __esm({
  "node_modules/marked/lib/marked.esm.js"() {
    defaults = getDefaults();
    escapeTest = /[&<>"']/;
    escapeReplace = /[&<>"']/g;
    escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
    escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;
    escapeReplacements = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    getEscapeReplacement = (ch) => escapeReplacements[ch];
    unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
    caret = /(^|[^\[])\^/g;
    nonWordAndColonTest = /[^\w:]/g;
    originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
    baseUrls = {};
    justDomain = /^[^:]+:\/*[^/]*$/;
    protocol = /^([^:]+:)[\s\S]*$/;
    domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
    noopTest = { exec: function noopTest2() {
    } };
    Tokenizer = class {
      constructor(options2) {
        this.options = options2 || defaults;
      }
      space(src) {
        const cap = this.rules.block.newline.exec(src);
        if (cap && cap[0].length > 0) {
          return {
            type: "space",
            raw: cap[0]
          };
        }
      }
      code(src) {
        const cap = this.rules.block.code.exec(src);
        if (cap) {
          const text = cap[0].replace(/^ {1,4}/gm, "");
          return {
            type: "code",
            raw: cap[0],
            codeBlockStyle: "indented",
            text: !this.options.pedantic ? rtrim(text, "\n") : text
          };
        }
      }
      fences(src) {
        const cap = this.rules.block.fences.exec(src);
        if (cap) {
          const raw = cap[0];
          const text = indentCodeCompensation(raw, cap[3] || "");
          return {
            type: "code",
            raw,
            lang: cap[2] ? cap[2].trim() : cap[2],
            text
          };
        }
      }
      heading(src) {
        const cap = this.rules.block.heading.exec(src);
        if (cap) {
          let text = cap[2].trim();
          if (/#$/.test(text)) {
            const trimmed = rtrim(text, "#");
            if (this.options.pedantic) {
              text = trimmed.trim();
            } else if (!trimmed || / $/.test(trimmed)) {
              text = trimmed.trim();
            }
          }
          const token = {
            type: "heading",
            raw: cap[0],
            depth: cap[1].length,
            text,
            tokens: []
          };
          this.lexer.inline(token.text, token.tokens);
          return token;
        }
      }
      hr(src) {
        const cap = this.rules.block.hr.exec(src);
        if (cap) {
          return {
            type: "hr",
            raw: cap[0]
          };
        }
      }
      blockquote(src) {
        const cap = this.rules.block.blockquote.exec(src);
        if (cap) {
          const text = cap[0].replace(/^ *> ?/gm, "");
          return {
            type: "blockquote",
            raw: cap[0],
            tokens: this.lexer.blockTokens(text, []),
            text
          };
        }
      }
      list(src) {
        let cap = this.rules.block.list.exec(src);
        if (cap) {
          let raw, istask, ischecked, indent, i, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;
          let bull = cap[1].trim();
          const isordered = bull.length > 1;
          const list2 = {
            type: "list",
            raw: "",
            ordered: isordered,
            start: isordered ? +bull.slice(0, -1) : "",
            loose: false,
            items: []
          };
          bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
          if (this.options.pedantic) {
            bull = isordered ? bull : "[*+-]";
          }
          const itemRegex = new RegExp(`^( {0,3}${bull})((?: [^\\n]*)?(?:\\n|$))`);
          while (src) {
            endEarly = false;
            if (!(cap = itemRegex.exec(src))) {
              break;
            }
            if (this.rules.block.hr.test(src)) {
              break;
            }
            raw = cap[0];
            src = src.substring(raw.length);
            line = cap[2].split("\n", 1)[0];
            nextLine = src.split("\n", 1)[0];
            if (this.options.pedantic) {
              indent = 2;
              itemContents = line.trimLeft();
            } else {
              indent = cap[2].search(/[^ ]/);
              indent = indent > 4 ? 1 : indent;
              itemContents = line.slice(indent);
              indent += cap[1].length;
            }
            blankLine = false;
            if (!line && /^ *$/.test(nextLine)) {
              raw += nextLine + "\n";
              src = src.substring(nextLine.length + 1);
              endEarly = true;
            }
            if (!endEarly) {
              const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])`);
              while (src) {
                rawLine = src.split("\n", 1)[0];
                line = rawLine;
                if (this.options.pedantic) {
                  line = line.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
                }
                if (nextBulletRegex.test(line)) {
                  break;
                }
                if (line.search(/[^ ]/) >= indent || !line.trim()) {
                  itemContents += "\n" + line.slice(indent);
                } else if (!blankLine) {
                  itemContents += "\n" + line;
                } else {
                  break;
                }
                if (!blankLine && !line.trim()) {
                  blankLine = true;
                }
                raw += rawLine + "\n";
                src = src.substring(rawLine.length + 1);
              }
            }
            if (!list2.loose) {
              if (endsWithBlankLine) {
                list2.loose = true;
              } else if (/\n *\n *$/.test(raw)) {
                endsWithBlankLine = true;
              }
            }
            if (this.options.gfm) {
              istask = /^\[[ xX]\] /.exec(itemContents);
              if (istask) {
                ischecked = istask[0] !== "[ ] ";
                itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
              }
            }
            list2.items.push({
              type: "list_item",
              raw,
              task: !!istask,
              checked: ischecked,
              loose: false,
              text: itemContents
            });
            list2.raw += raw;
          }
          list2.items[list2.items.length - 1].raw = raw.trimRight();
          list2.items[list2.items.length - 1].text = itemContents.trimRight();
          list2.raw = list2.raw.trimRight();
          const l = list2.items.length;
          for (i = 0; i < l; i++) {
            this.lexer.state.top = false;
            list2.items[i].tokens = this.lexer.blockTokens(list2.items[i].text, []);
            const spacers = list2.items[i].tokens.filter((t) => t.type === "space");
            const hasMultipleLineBreaks = spacers.every((t) => {
              const chars = t.raw.split("");
              let lineBreaks = 0;
              for (const char of chars) {
                if (char === "\n") {
                  lineBreaks += 1;
                }
                if (lineBreaks > 1) {
                  return true;
                }
              }
              return false;
            });
            if (!list2.loose && spacers.length && hasMultipleLineBreaks) {
              list2.loose = true;
              list2.items[i].loose = true;
            }
          }
          return list2;
        }
      }
      html(src) {
        const cap = this.rules.block.html.exec(src);
        if (cap) {
          const token = {
            type: "html",
            raw: cap[0],
            pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
            text: cap[0]
          };
          if (this.options.sanitize) {
            token.type = "paragraph";
            token.text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);
            token.tokens = [];
            this.lexer.inline(token.text, token.tokens);
          }
          return token;
        }
      }
      def(src) {
        const cap = this.rules.block.def.exec(src);
        if (cap) {
          if (cap[3])
            cap[3] = cap[3].substring(1, cap[3].length - 1);
          const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
          return {
            type: "def",
            tag,
            raw: cap[0],
            href: cap[2],
            title: cap[3]
          };
        }
      }
      table(src) {
        const cap = this.rules.block.table.exec(src);
        if (cap) {
          const item = {
            type: "table",
            header: splitCells(cap[1]).map((c) => {
              return { text: c };
            }),
            align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
            rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
          };
          if (item.header.length === item.align.length) {
            item.raw = cap[0];
            let l = item.align.length;
            let i, j, k, row;
            for (i = 0; i < l; i++) {
              if (/^ *-+: *$/.test(item.align[i])) {
                item.align[i] = "right";
              } else if (/^ *:-+: *$/.test(item.align[i])) {
                item.align[i] = "center";
              } else if (/^ *:-+ *$/.test(item.align[i])) {
                item.align[i] = "left";
              } else {
                item.align[i] = null;
              }
            }
            l = item.rows.length;
            for (i = 0; i < l; i++) {
              item.rows[i] = splitCells(item.rows[i], item.header.length).map((c) => {
                return { text: c };
              });
            }
            l = item.header.length;
            for (j = 0; j < l; j++) {
              item.header[j].tokens = [];
              this.lexer.inlineTokens(item.header[j].text, item.header[j].tokens);
            }
            l = item.rows.length;
            for (j = 0; j < l; j++) {
              row = item.rows[j];
              for (k = 0; k < row.length; k++) {
                row[k].tokens = [];
                this.lexer.inlineTokens(row[k].text, row[k].tokens);
              }
            }
            return item;
          }
        }
      }
      lheading(src) {
        const cap = this.rules.block.lheading.exec(src);
        if (cap) {
          const token = {
            type: "heading",
            raw: cap[0],
            depth: cap[2].charAt(0) === "=" ? 1 : 2,
            text: cap[1],
            tokens: []
          };
          this.lexer.inline(token.text, token.tokens);
          return token;
        }
      }
      paragraph(src) {
        const cap = this.rules.block.paragraph.exec(src);
        if (cap) {
          const token = {
            type: "paragraph",
            raw: cap[0],
            text: cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1],
            tokens: []
          };
          this.lexer.inline(token.text, token.tokens);
          return token;
        }
      }
      text(src) {
        const cap = this.rules.block.text.exec(src);
        if (cap) {
          const token = {
            type: "text",
            raw: cap[0],
            text: cap[0],
            tokens: []
          };
          this.lexer.inline(token.text, token.tokens);
          return token;
        }
      }
      escape(src) {
        const cap = this.rules.inline.escape.exec(src);
        if (cap) {
          return {
            type: "escape",
            raw: cap[0],
            text: escape(cap[1])
          };
        }
      }
      tag(src) {
        const cap = this.rules.inline.tag.exec(src);
        if (cap) {
          if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
            this.lexer.state.inLink = true;
          } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
            this.lexer.state.inLink = false;
          }
          if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.lexer.state.inRawBlock = true;
          } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.lexer.state.inRawBlock = false;
          }
          return {
            type: this.options.sanitize ? "text" : "html",
            raw: cap[0],
            inLink: this.lexer.state.inLink,
            inRawBlock: this.lexer.state.inRawBlock,
            text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]
          };
        }
      }
      link(src) {
        const cap = this.rules.inline.link.exec(src);
        if (cap) {
          const trimmedUrl = cap[2].trim();
          if (!this.options.pedantic && /^</.test(trimmedUrl)) {
            if (!/>$/.test(trimmedUrl)) {
              return;
            }
            const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
            if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
              return;
            }
          } else {
            const lastParenIndex = findClosingBracket(cap[2], "()");
            if (lastParenIndex > -1) {
              const start = cap[0].indexOf("!") === 0 ? 5 : 4;
              const linkLen = start + cap[1].length + lastParenIndex;
              cap[2] = cap[2].substring(0, lastParenIndex);
              cap[0] = cap[0].substring(0, linkLen).trim();
              cap[3] = "";
            }
          }
          let href = cap[2];
          let title = "";
          if (this.options.pedantic) {
            const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
            if (link) {
              href = link[1];
              title = link[3];
            }
          } else {
            title = cap[3] ? cap[3].slice(1, -1) : "";
          }
          href = href.trim();
          if (/^</.test(href)) {
            if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
              href = href.slice(1);
            } else {
              href = href.slice(1, -1);
            }
          }
          return outputLink(cap, {
            href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
            title: title ? title.replace(this.rules.inline._escapes, "$1") : title
          }, cap[0], this.lexer);
        }
      }
      reflink(src, links2) {
        let cap;
        if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {
          let link = (cap[2] || cap[1]).replace(/\s+/g, " ");
          link = links2[link.toLowerCase()];
          if (!link || !link.href) {
            const text = cap[0].charAt(0);
            return {
              type: "text",
              raw: text,
              text
            };
          }
          return outputLink(cap, link, cap[0], this.lexer);
        }
      }
      emStrong(src, maskedSrc, prevChar = "") {
        let match = this.rules.inline.emStrong.lDelim.exec(src);
        if (!match)
          return;
        if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
          return;
        const nextChar = match[1] || match[2] || "";
        if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {
          const lLength = match[0].length - 1;
          let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
          const endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
          endReg.lastIndex = 0;
          maskedSrc = maskedSrc.slice(-1 * src.length + lLength);
          while ((match = endReg.exec(maskedSrc)) != null) {
            rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
            if (!rDelim)
              continue;
            rLength = rDelim.length;
            if (match[3] || match[4]) {
              delimTotal += rLength;
              continue;
            } else if (match[5] || match[6]) {
              if (lLength % 3 && !((lLength + rLength) % 3)) {
                midDelimTotal += rLength;
                continue;
              }
            }
            delimTotal -= rLength;
            if (delimTotal > 0)
              continue;
            rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
            if (Math.min(lLength, rLength) % 2) {
              const text2 = src.slice(1, lLength + match.index + rLength);
              return {
                type: "em",
                raw: src.slice(0, lLength + match.index + rLength + 1),
                text: text2,
                tokens: this.lexer.inlineTokens(text2, [])
              };
            }
            const text = src.slice(2, lLength + match.index + rLength - 1);
            return {
              type: "strong",
              raw: src.slice(0, lLength + match.index + rLength + 1),
              text,
              tokens: this.lexer.inlineTokens(text, [])
            };
          }
        }
      }
      codespan(src) {
        const cap = this.rules.inline.code.exec(src);
        if (cap) {
          let text = cap[2].replace(/\n/g, " ");
          const hasNonSpaceChars = /[^ ]/.test(text);
          const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
          if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
            text = text.substring(1, text.length - 1);
          }
          text = escape(text, true);
          return {
            type: "codespan",
            raw: cap[0],
            text
          };
        }
      }
      br(src) {
        const cap = this.rules.inline.br.exec(src);
        if (cap) {
          return {
            type: "br",
            raw: cap[0]
          };
        }
      }
      del(src) {
        const cap = this.rules.inline.del.exec(src);
        if (cap) {
          return {
            type: "del",
            raw: cap[0],
            text: cap[2],
            tokens: this.lexer.inlineTokens(cap[2], [])
          };
        }
      }
      autolink(src, mangle2) {
        const cap = this.rules.inline.autolink.exec(src);
        if (cap) {
          let text, href;
          if (cap[2] === "@") {
            text = escape(this.options.mangle ? mangle2(cap[1]) : cap[1]);
            href = "mailto:" + text;
          } else {
            text = escape(cap[1]);
            href = text;
          }
          return {
            type: "link",
            raw: cap[0],
            text,
            href,
            tokens: [
              {
                type: "text",
                raw: text,
                text
              }
            ]
          };
        }
      }
      url(src, mangle2) {
        let cap;
        if (cap = this.rules.inline.url.exec(src)) {
          let text, href;
          if (cap[2] === "@") {
            text = escape(this.options.mangle ? mangle2(cap[0]) : cap[0]);
            href = "mailto:" + text;
          } else {
            let prevCapZero;
            do {
              prevCapZero = cap[0];
              cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
            } while (prevCapZero !== cap[0]);
            text = escape(cap[0]);
            if (cap[1] === "www.") {
              href = "http://" + text;
            } else {
              href = text;
            }
          }
          return {
            type: "link",
            raw: cap[0],
            text,
            href,
            tokens: [
              {
                type: "text",
                raw: text,
                text
              }
            ]
          };
        }
      }
      inlineText(src, smartypants2) {
        const cap = this.rules.inline.text.exec(src);
        if (cap) {
          let text;
          if (this.lexer.state.inRawBlock) {
            text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
          } else {
            text = escape(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
          }
          return {
            type: "text",
            raw: cap[0],
            text
          };
        }
      }
    };
    block = {
      newline: /^(?: *(?:\n|$))+/,
      code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
      fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
      hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
      heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
      blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
      list: /^( {0,3}bull)( [^\n]+?)?(?:\n|$)/,
      html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
      def: /^ {0,3}\[(label)\]: *(?:\n *)?<?([^\s>]+)>?(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
      table: noopTest,
      lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
      _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
      text: /^[^\n]+/
    };
    block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
    block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
    block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
    block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
    block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
    block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
    block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
    block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
    block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
    block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
    block.normal = merge({}, block);
    block.gfm = merge({}, block.normal, {
      table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
    });
    block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
    block.pedantic = merge({}, block.normal, {
      html: edit(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
      heading: /^(#{1,6})(.*)(?:\n+|$)/,
      fences: noopTest,
      paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
    });
    inline = {
      escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
      autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
      url: noopTest,
      tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
      link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
      reflink: /^!?\[(label)\]\[(ref)\]/,
      nolink: /^!?\[(ref)\](?:\[\])?/,
      reflinkSearch: "reflink|nolink(?!\\()",
      emStrong: {
        lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
        rDelimAst: /^[^_*]*?\_\_[^_*]*?\*[^_*]*?(?=\_\_)|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
        rDelimUnd: /^[^_*]*?\*\*[^_*]*?\_[^_*]*?(?=\*\*)|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
      },
      code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
      br: /^( {2,}|\\)\n(?!\s*$)/,
      del: noopTest,
      text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
      punctuation: /^([\spunctuation])/
    };
    inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
    inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();
    inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
    inline.escapedEmSt = /\\\*|\\_/g;
    inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
    inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
    inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "g").replace(/punct/g, inline._punctuation).getRegex();
    inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "g").replace(/punct/g, inline._punctuation).getRegex();
    inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
    inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
    inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
    inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
    inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
    inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
    inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
    inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
    inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
    inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
    inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
    inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
    inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
    inline.normal = merge({}, inline);
    inline.pedantic = merge({}, inline.normal, {
      strong: {
        start: /^__|\*\*/,
        middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
        endAst: /\*\*(?!\*)/g,
        endUnd: /__(?!_)/g
      },
      em: {
        start: /^_|\*/,
        middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
        endAst: /\*(?!\*)/g,
        endUnd: /_(?!_)/g
      },
      link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
      reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
    });
    inline.gfm = merge({}, inline.normal, {
      escape: edit(inline.escape).replace("])", "~|])").getRegex(),
      _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
      url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
      _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
      del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
      text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
    });
    inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
    inline.breaks = merge({}, inline.gfm, {
      br: edit(inline.br).replace("{2,}", "*").getRegex(),
      text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
    });
    Lexer = class {
      constructor(options2) {
        this.tokens = [];
        this.tokens.links = /* @__PURE__ */ Object.create(null);
        this.options = options2 || defaults;
        this.options.tokenizer = this.options.tokenizer || new Tokenizer();
        this.tokenizer = this.options.tokenizer;
        this.tokenizer.options = this.options;
        this.tokenizer.lexer = this;
        this.inlineQueue = [];
        this.state = {
          inLink: false,
          inRawBlock: false,
          top: true
        };
        const rules = {
          block: block.normal,
          inline: inline.normal
        };
        if (this.options.pedantic) {
          rules.block = block.pedantic;
          rules.inline = inline.pedantic;
        } else if (this.options.gfm) {
          rules.block = block.gfm;
          if (this.options.breaks) {
            rules.inline = inline.breaks;
          } else {
            rules.inline = inline.gfm;
          }
        }
        this.tokenizer.rules = rules;
      }
      static get rules() {
        return {
          block,
          inline
        };
      }
      static lex(src, options2) {
        const lexer2 = new Lexer(options2);
        return lexer2.lex(src);
      }
      static lexInline(src, options2) {
        const lexer2 = new Lexer(options2);
        return lexer2.inlineTokens(src);
      }
      lex(src) {
        src = src.replace(/\r\n|\r/g, "\n").replace(/\t/g, "    ");
        this.blockTokens(src, this.tokens);
        let next;
        while (next = this.inlineQueue.shift()) {
          this.inlineTokens(next.src, next.tokens);
        }
        return this.tokens;
      }
      blockTokens(src, tokens = []) {
        if (this.options.pedantic) {
          src = src.replace(/^ +$/gm, "");
        }
        let token, lastToken, cutSrc, lastParagraphClipped;
        while (src) {
          if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
            if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              return true;
            }
            return false;
          })) {
            continue;
          }
          if (token = this.tokenizer.space(src)) {
            src = src.substring(token.raw.length);
            if (token.raw.length === 1 && tokens.length > 0) {
              tokens[tokens.length - 1].raw += "\n";
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.code(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.fences(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.heading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.hr(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.blockquote(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.list(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.html(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.def(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.raw;
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else if (!this.tokens.links[token.tag]) {
              this.tokens.links[token.tag] = {
                href: token.href,
                title: token.title
              };
            }
            continue;
          }
          if (token = this.tokenizer.table(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.lheading(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startBlock) {
            let startIndex = Infinity;
            const tempSrc = src.slice(1);
            let tempStart;
            this.options.extensions.startBlock.forEach(function(getStartIndex) {
              tempStart = getStartIndex.call({ lexer: this }, tempSrc);
              if (typeof tempStart === "number" && tempStart >= 0) {
                startIndex = Math.min(startIndex, tempStart);
              }
            });
            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          }
          if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
            lastToken = tokens[tokens.length - 1];
            if (lastParagraphClipped && lastToken.type === "paragraph") {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue.pop();
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            lastParagraphClipped = cutSrc.length !== src.length;
            src = src.substring(token.raw.length);
            continue;
          }
          if (token = this.tokenizer.text(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "text") {
              lastToken.raw += "\n" + token.raw;
              lastToken.text += "\n" + token.text;
              this.inlineQueue.pop();
              this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (src) {
            const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        this.state.top = true;
        return tokens;
      }
      inline(src, tokens) {
        this.inlineQueue.push({ src, tokens });
      }
      inlineTokens(src, tokens = []) {
        let token, lastToken, cutSrc;
        let maskedSrc = src;
        let match;
        let keepPrevChar, prevChar;
        if (this.tokens.links) {
          const links2 = Object.keys(this.tokens.links);
          if (links2.length > 0) {
            while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
              if (links2.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
                maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
              }
            }
          }
        }
        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        }
        while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
          maskedSrc = maskedSrc.slice(0, match.index) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
        }
        while (src) {
          if (!keepPrevChar) {
            prevChar = "";
          }
          keepPrevChar = false;
          if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
            if (token = extTokenizer.call({ lexer: this }, src, tokens)) {
              src = src.substring(token.raw.length);
              tokens.push(token);
              return true;
            }
            return false;
          })) {
            continue;
          }
          if (token = this.tokenizer.escape(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.tag(src)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token.type === "text" && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.link(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.reflink(src, this.tokens.links)) {
            src = src.substring(token.raw.length);
            lastToken = tokens[tokens.length - 1];
            if (lastToken && token.type === "text" && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.codespan(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.br(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.del(src)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (token = this.tokenizer.autolink(src, mangle)) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          if (!this.state.inLink && (token = this.tokenizer.url(src, mangle))) {
            src = src.substring(token.raw.length);
            tokens.push(token);
            continue;
          }
          cutSrc = src;
          if (this.options.extensions && this.options.extensions.startInline) {
            let startIndex = Infinity;
            const tempSrc = src.slice(1);
            let tempStart;
            this.options.extensions.startInline.forEach(function(getStartIndex) {
              tempStart = getStartIndex.call({ lexer: this }, tempSrc);
              if (typeof tempStart === "number" && tempStart >= 0) {
                startIndex = Math.min(startIndex, tempStart);
              }
            });
            if (startIndex < Infinity && startIndex >= 0) {
              cutSrc = src.substring(0, startIndex + 1);
            }
          }
          if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
            src = src.substring(token.raw.length);
            if (token.raw.slice(-1) !== "_") {
              prevChar = token.raw.slice(-1);
            }
            keepPrevChar = true;
            lastToken = tokens[tokens.length - 1];
            if (lastToken && lastToken.type === "text") {
              lastToken.raw += token.raw;
              lastToken.text += token.text;
            } else {
              tokens.push(token);
            }
            continue;
          }
          if (src) {
            const errMsg = "Infinite loop on byte: " + src.charCodeAt(0);
            if (this.options.silent) {
              console.error(errMsg);
              break;
            } else {
              throw new Error(errMsg);
            }
          }
        }
        return tokens;
      }
    };
    Renderer = class {
      constructor(options2) {
        this.options = options2 || defaults;
      }
      code(code, infostring, escaped) {
        const lang = (infostring || "").match(/\S*/)[0];
        if (this.options.highlight) {
          const out = this.options.highlight(code, lang);
          if (out != null && out !== code) {
            escaped = true;
            code = out;
          }
        }
        code = code.replace(/\n$/, "") + "\n";
        if (!lang) {
          return "<pre><code>" + (escaped ? code : escape(code, true)) + "</code></pre>\n";
        }
        return '<pre><code class="' + this.options.langPrefix + escape(lang, true) + '">' + (escaped ? code : escape(code, true)) + "</code></pre>\n";
      }
      blockquote(quote) {
        return "<blockquote>\n" + quote + "</blockquote>\n";
      }
      html(html) {
        return html;
      }
      heading(text, level, raw, slugger) {
        if (this.options.headerIds) {
          return "<h" + level + ' id="' + this.options.headerPrefix + slugger.slug(raw) + '">' + text + "</h" + level + ">\n";
        }
        return "<h" + level + ">" + text + "</h" + level + ">\n";
      }
      hr() {
        return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
      }
      list(body, ordered, start) {
        const type = ordered ? "ol" : "ul", startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
        return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
      }
      listitem(text) {
        return "<li>" + text + "</li>\n";
      }
      checkbox(checked) {
        return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
      }
      paragraph(text) {
        return "<p>" + text + "</p>\n";
      }
      table(header, body) {
        if (body)
          body = "<tbody>" + body + "</tbody>";
        return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
      }
      tablerow(content) {
        return "<tr>\n" + content + "</tr>\n";
      }
      tablecell(content, flags) {
        const type = flags.header ? "th" : "td";
        const tag = flags.align ? "<" + type + ' align="' + flags.align + '">' : "<" + type + ">";
        return tag + content + "</" + type + ">\n";
      }
      strong(text) {
        return "<strong>" + text + "</strong>";
      }
      em(text) {
        return "<em>" + text + "</em>";
      }
      codespan(text) {
        return "<code>" + text + "</code>";
      }
      br() {
        return this.options.xhtml ? "<br/>" : "<br>";
      }
      del(text) {
        return "<del>" + text + "</del>";
      }
      link(href, title, text) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text;
        }
        let out = '<a href="' + escape(href) + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += ">" + text + "</a>";
        return out;
      }
      image(href, title, text) {
        href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
        if (href === null) {
          return text;
        }
        let out = '<img src="' + href + '" alt="' + text + '"';
        if (title) {
          out += ' title="' + title + '"';
        }
        out += this.options.xhtml ? "/>" : ">";
        return out;
      }
      text(text) {
        return text;
      }
    };
    TextRenderer = class {
      strong(text) {
        return text;
      }
      em(text) {
        return text;
      }
      codespan(text) {
        return text;
      }
      del(text) {
        return text;
      }
      html(text) {
        return text;
      }
      text(text) {
        return text;
      }
      link(href, title, text) {
        return "" + text;
      }
      image(href, title, text) {
        return "" + text;
      }
      br() {
        return "";
      }
    };
    Slugger = class {
      constructor() {
        this.seen = {};
      }
      serialize(value) {
        return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
      }
      getNextSafeSlug(originalSlug, isDryRun) {
        let slug = originalSlug;
        let occurenceAccumulator = 0;
        if (this.seen.hasOwnProperty(slug)) {
          occurenceAccumulator = this.seen[originalSlug];
          do {
            occurenceAccumulator++;
            slug = originalSlug + "-" + occurenceAccumulator;
          } while (this.seen.hasOwnProperty(slug));
        }
        if (!isDryRun) {
          this.seen[originalSlug] = occurenceAccumulator;
          this.seen[slug] = 0;
        }
        return slug;
      }
      slug(value, options2 = {}) {
        const slug = this.serialize(value);
        return this.getNextSafeSlug(slug, options2.dryrun);
      }
    };
    Parser = class {
      constructor(options2) {
        this.options = options2 || defaults;
        this.options.renderer = this.options.renderer || new Renderer();
        this.renderer = this.options.renderer;
        this.renderer.options = this.options;
        this.textRenderer = new TextRenderer();
        this.slugger = new Slugger();
      }
      static parse(tokens, options2) {
        const parser2 = new Parser(options2);
        return parser2.parse(tokens);
      }
      static parseInline(tokens, options2) {
        const parser2 = new Parser(options2);
        return parser2.parseInline(tokens);
      }
      parse(tokens, top = true) {
        let out = "", i, j, k, l2, l3, row, cell, header, body, token, ordered, start, loose, itemBody, item, checked, task, checkbox, ret;
        const l = tokens.length;
        for (i = 0; i < l; i++) {
          token = tokens[i];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
            if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token.type)) {
              out += ret || "";
              continue;
            }
          }
          switch (token.type) {
            case "space": {
              continue;
            }
            case "hr": {
              out += this.renderer.hr();
              continue;
            }
            case "heading": {
              out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape2(this.parseInline(token.tokens, this.textRenderer)), this.slugger);
              continue;
            }
            case "code": {
              out += this.renderer.code(token.text, token.lang, token.escaped);
              continue;
            }
            case "table": {
              header = "";
              cell = "";
              l2 = token.header.length;
              for (j = 0; j < l2; j++) {
                cell += this.renderer.tablecell(this.parseInline(token.header[j].tokens), { header: true, align: token.align[j] });
              }
              header += this.renderer.tablerow(cell);
              body = "";
              l2 = token.rows.length;
              for (j = 0; j < l2; j++) {
                row = token.rows[j];
                cell = "";
                l3 = row.length;
                for (k = 0; k < l3; k++) {
                  cell += this.renderer.tablecell(this.parseInline(row[k].tokens), { header: false, align: token.align[k] });
                }
                body += this.renderer.tablerow(cell);
              }
              out += this.renderer.table(header, body);
              continue;
            }
            case "blockquote": {
              body = this.parse(token.tokens);
              out += this.renderer.blockquote(body);
              continue;
            }
            case "list": {
              ordered = token.ordered;
              start = token.start;
              loose = token.loose;
              l2 = token.items.length;
              body = "";
              for (j = 0; j < l2; j++) {
                item = token.items[j];
                checked = item.checked;
                task = item.task;
                itemBody = "";
                if (item.task) {
                  checkbox = this.renderer.checkbox(checked);
                  if (loose) {
                    if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                      item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                        item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                      }
                    } else {
                      item.tokens.unshift({
                        type: "text",
                        text: checkbox
                      });
                    }
                  } else {
                    itemBody += checkbox;
                  }
                }
                itemBody += this.parse(item.tokens, loose);
                body += this.renderer.listitem(itemBody, task, checked);
              }
              out += this.renderer.list(body, ordered, start);
              continue;
            }
            case "html": {
              out += this.renderer.html(token.text);
              continue;
            }
            case "paragraph": {
              out += this.renderer.paragraph(this.parseInline(token.tokens));
              continue;
            }
            case "text": {
              body = token.tokens ? this.parseInline(token.tokens) : token.text;
              while (i + 1 < l && tokens[i + 1].type === "text") {
                token = tokens[++i];
                body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
              }
              out += top ? this.renderer.paragraph(body) : body;
              continue;
            }
            default: {
              const errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      }
      parseInline(tokens, renderer) {
        renderer = renderer || this.renderer;
        let out = "", i, token, ret;
        const l = tokens.length;
        for (i = 0; i < l; i++) {
          token = tokens[i];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
            ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
            if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
              out += ret || "";
              continue;
            }
          }
          switch (token.type) {
            case "escape": {
              out += renderer.text(token.text);
              break;
            }
            case "html": {
              out += renderer.html(token.text);
              break;
            }
            case "link": {
              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
              break;
            }
            case "image": {
              out += renderer.image(token.href, token.title, token.text);
              break;
            }
            case "strong": {
              out += renderer.strong(this.parseInline(token.tokens, renderer));
              break;
            }
            case "em": {
              out += renderer.em(this.parseInline(token.tokens, renderer));
              break;
            }
            case "codespan": {
              out += renderer.codespan(token.text);
              break;
            }
            case "br": {
              out += renderer.br();
              break;
            }
            case "del": {
              out += renderer.del(this.parseInline(token.tokens, renderer));
              break;
            }
            case "text": {
              out += renderer.text(token.text);
              break;
            }
            default: {
              const errMsg = 'Token with "' + token.type + '" type was not found.';
              if (this.options.silent) {
                console.error(errMsg);
                return;
              } else {
                throw new Error(errMsg);
              }
            }
          }
        }
        return out;
      }
    };
    marked.options = marked.setOptions = function(opt) {
      merge(marked.defaults, opt);
      changeDefaults(marked.defaults);
      return marked;
    };
    marked.getDefaults = getDefaults;
    marked.defaults = defaults;
    marked.use = function(...args) {
      const opts = merge({}, ...args);
      const extensions = marked.defaults.extensions || { renderers: {}, childTokens: {} };
      let hasExtensions;
      args.forEach((pack) => {
        if (pack.extensions) {
          hasExtensions = true;
          pack.extensions.forEach((ext) => {
            if (!ext.name) {
              throw new Error("extension name required");
            }
            if (ext.renderer) {
              const prevRenderer = extensions.renderers ? extensions.renderers[ext.name] : null;
              if (prevRenderer) {
                extensions.renderers[ext.name] = function(...args2) {
                  let ret = ext.renderer.apply(this, args2);
                  if (ret === false) {
                    ret = prevRenderer.apply(this, args2);
                  }
                  return ret;
                };
              } else {
                extensions.renderers[ext.name] = ext.renderer;
              }
            }
            if (ext.tokenizer) {
              if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
                throw new Error("extension level must be 'block' or 'inline'");
              }
              if (extensions[ext.level]) {
                extensions[ext.level].unshift(ext.tokenizer);
              } else {
                extensions[ext.level] = [ext.tokenizer];
              }
              if (ext.start) {
                if (ext.level === "block") {
                  if (extensions.startBlock) {
                    extensions.startBlock.push(ext.start);
                  } else {
                    extensions.startBlock = [ext.start];
                  }
                } else if (ext.level === "inline") {
                  if (extensions.startInline) {
                    extensions.startInline.push(ext.start);
                  } else {
                    extensions.startInline = [ext.start];
                  }
                }
              }
            }
            if (ext.childTokens) {
              extensions.childTokens[ext.name] = ext.childTokens;
            }
          });
        }
        if (pack.renderer) {
          const renderer = marked.defaults.renderer || new Renderer();
          for (const prop in pack.renderer) {
            const prevRenderer = renderer[prop];
            renderer[prop] = (...args2) => {
              let ret = pack.renderer[prop].apply(renderer, args2);
              if (ret === false) {
                ret = prevRenderer.apply(renderer, args2);
              }
              return ret;
            };
          }
          opts.renderer = renderer;
        }
        if (pack.tokenizer) {
          const tokenizer = marked.defaults.tokenizer || new Tokenizer();
          for (const prop in pack.tokenizer) {
            const prevTokenizer = tokenizer[prop];
            tokenizer[prop] = (...args2) => {
              let ret = pack.tokenizer[prop].apply(tokenizer, args2);
              if (ret === false) {
                ret = prevTokenizer.apply(tokenizer, args2);
              }
              return ret;
            };
          }
          opts.tokenizer = tokenizer;
        }
        if (pack.walkTokens) {
          const walkTokens2 = marked.defaults.walkTokens;
          opts.walkTokens = function(token) {
            pack.walkTokens.call(this, token);
            if (walkTokens2) {
              walkTokens2.call(this, token);
            }
          };
        }
        if (hasExtensions) {
          opts.extensions = extensions;
        }
        marked.setOptions(opts);
      });
    };
    marked.walkTokens = function(tokens, callback) {
      for (const token of tokens) {
        callback.call(marked, token);
        switch (token.type) {
          case "table": {
            for (const cell of token.header) {
              marked.walkTokens(cell.tokens, callback);
            }
            for (const row of token.rows) {
              for (const cell of row) {
                marked.walkTokens(cell.tokens, callback);
              }
            }
            break;
          }
          case "list": {
            marked.walkTokens(token.items, callback);
            break;
          }
          default: {
            if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {
              marked.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {
                marked.walkTokens(token[childTokens], callback);
              });
            } else if (token.tokens) {
              marked.walkTokens(token.tokens, callback);
            }
          }
        }
      }
    };
    marked.parseInline = function(src, opt) {
      if (typeof src === "undefined" || src === null) {
        throw new Error("marked.parseInline(): input parameter is undefined or null");
      }
      if (typeof src !== "string") {
        throw new Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(src) + ", string expected");
      }
      opt = merge({}, marked.defaults, opt || {});
      checkSanitizeDeprecation(opt);
      try {
        const tokens = Lexer.lexInline(src, opt);
        if (opt.walkTokens) {
          marked.walkTokens(tokens, opt.walkTokens);
        }
        return Parser.parseInline(tokens, opt);
      } catch (e) {
        e.message += "\nPlease report this to https://github.com/markedjs/marked.";
        if (opt.silent) {
          return "<p>An error occurred:</p><pre>" + escape(e.message + "", true) + "</pre>";
        }
        throw e;
      }
    };
    marked.Parser = Parser;
    marked.parser = Parser.parse;
    marked.Renderer = Renderer;
    marked.TextRenderer = TextRenderer;
    marked.Lexer = Lexer;
    marked.lexer = Lexer.lex;
    marked.Tokenizer = Tokenizer;
    marked.Slugger = Slugger;
    marked.parse = marked;
    options = marked.options;
    setOptions = marked.setOptions;
    use = marked.use;
    walkTokens = marked.walkTokens;
    parseInline = marked.parseInline;
    parser = Parser.parse;
    lexer = Lexer.lex;
  }
});

// node_modules/colors/lib/styles.js
var require_styles = __commonJS({
  "node_modules/colors/lib/styles.js"(exports, module2) {
    var styles2 = {};
    module2["exports"] = styles2;
    var codes = {
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      grey: [90, 39],
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      blackBG: [40, 49],
      redBG: [41, 49],
      greenBG: [42, 49],
      yellowBG: [43, 49],
      blueBG: [44, 49],
      magentaBG: [45, 49],
      cyanBG: [46, 49],
      whiteBG: [47, 49]
    };
    Object.keys(codes).forEach(function(key) {
      var val = codes[key];
      var style2 = styles2[key] = [];
      style2.open = "\x1B[" + val[0] + "m";
      style2.close = "\x1B[" + val[1] + "m";
    });
  }
});

// node_modules/colors/lib/system/supports-colors.js
var require_supports_colors = __commonJS({
  "node_modules/colors/lib/system/supports-colors.js"(exports, module2) {
    var argv = process.argv;
    module2.exports = function() {
      if (argv.indexOf("--no-color") !== -1 || argv.indexOf("--color=false") !== -1) {
        return false;
      }
      if (argv.indexOf("--color") !== -1 || argv.indexOf("--color=true") !== -1 || argv.indexOf("--color=always") !== -1) {
        return true;
      }
      if (process.stdout && !process.stdout.isTTY) {
        return false;
      }
      if (process.platform === "win32") {
        return true;
      }
      if ("COLORTERM" in process.env) {
        return true;
      }
      if (process.env.TERM === "dumb") {
        return false;
      }
      if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
        return true;
      }
      return false;
    }();
  }
});

// node_modules/colors/lib/custom/trap.js
var require_trap = __commonJS({
  "node_modules/colors/lib/custom/trap.js"(exports, module2) {
    module2["exports"] = function runTheTrap(text, options2) {
      var result = "";
      text = text || "Run the trap, drop the bass";
      text = text.split("");
      var trap = {
        a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
        b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
        c: ["\xA9", "\u023B", "\u03FE"],
        d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
        e: ["\xCB", "\u0115", "\u018E", "\u0258", "\u03A3", "\u03BE", "\u04BC", "\u0A6C"],
        f: ["\u04FA"],
        g: ["\u0262"],
        h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
        i: ["\u0F0F"],
        j: ["\u0134"],
        k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
        l: ["\u0139"],
        m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
        n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
        o: ["\xD8", "\xF5", "\xF8", "\u01FE", "\u0298", "\u047A", "\u05DD", "\u06DD", "\u0E4F"],
        p: ["\u01F7", "\u048E"],
        q: ["\u09CD"],
        r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
        s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
        t: ["\u0141", "\u0166", "\u0373"],
        u: ["\u01B1", "\u054D"],
        v: ["\u05D8"],
        w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
        x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
        y: ["\xA5", "\u04B0", "\u04CB"],
        z: ["\u01B5", "\u0240"]
      };
      text.forEach(function(c) {
        c = c.toLowerCase();
        var chars = trap[c] || [" "];
        var rand = Math.floor(Math.random() * chars.length);
        if (typeof trap[c] !== "undefined") {
          result += trap[c][rand];
        } else {
          result += c;
        }
      });
      return result;
    };
  }
});

// node_modules/colors/lib/custom/zalgo.js
var require_zalgo = __commonJS({
  "node_modules/colors/lib/custom/zalgo.js"(exports, module2) {
    module2["exports"] = function zalgo(text, options2) {
      text = text || "   he is here   ";
      var soul = {
        "up": [
          "\u030D",
          "\u030E",
          "\u0304",
          "\u0305",
          "\u033F",
          "\u0311",
          "\u0306",
          "\u0310",
          "\u0352",
          "\u0357",
          "\u0351",
          "\u0307",
          "\u0308",
          "\u030A",
          "\u0342",
          "\u0313",
          "\u0308",
          "\u034A",
          "\u034B",
          "\u034C",
          "\u0303",
          "\u0302",
          "\u030C",
          "\u0350",
          "\u0300",
          "\u0301",
          "\u030B",
          "\u030F",
          "\u0312",
          "\u0313",
          "\u0314",
          "\u033D",
          "\u0309",
          "\u0363",
          "\u0364",
          "\u0365",
          "\u0366",
          "\u0367",
          "\u0368",
          "\u0369",
          "\u036A",
          "\u036B",
          "\u036C",
          "\u036D",
          "\u036E",
          "\u036F",
          "\u033E",
          "\u035B",
          "\u0346",
          "\u031A"
        ],
        "down": [
          "\u0316",
          "\u0317",
          "\u0318",
          "\u0319",
          "\u031C",
          "\u031D",
          "\u031E",
          "\u031F",
          "\u0320",
          "\u0324",
          "\u0325",
          "\u0326",
          "\u0329",
          "\u032A",
          "\u032B",
          "\u032C",
          "\u032D",
          "\u032E",
          "\u032F",
          "\u0330",
          "\u0331",
          "\u0332",
          "\u0333",
          "\u0339",
          "\u033A",
          "\u033B",
          "\u033C",
          "\u0345",
          "\u0347",
          "\u0348",
          "\u0349",
          "\u034D",
          "\u034E",
          "\u0353",
          "\u0354",
          "\u0355",
          "\u0356",
          "\u0359",
          "\u035A",
          "\u0323"
        ],
        "mid": [
          "\u0315",
          "\u031B",
          "\u0300",
          "\u0301",
          "\u0358",
          "\u0321",
          "\u0322",
          "\u0327",
          "\u0328",
          "\u0334",
          "\u0335",
          "\u0336",
          "\u035C",
          "\u035D",
          "\u035E",
          "\u035F",
          "\u0360",
          "\u0362",
          "\u0338",
          "\u0337",
          "\u0361",
          " \u0489"
        ]
      }, all = [].concat(soul.up, soul.down, soul.mid), zalgo2 = {};
      function randomNumber(range2) {
        var r = Math.floor(Math.random() * range2);
        return r;
      }
      function is_char(character) {
        var bool = false;
        all.filter(function(i) {
          bool = i === character;
        });
        return bool;
      }
      function heComes(text2, options3) {
        var result = "", counts, l;
        options3 = options3 || {};
        options3["up"] = options3["up"] || true;
        options3["mid"] = options3["mid"] || true;
        options3["down"] = options3["down"] || true;
        options3["size"] = options3["size"] || "maxi";
        text2 = text2.split("");
        for (l in text2) {
          if (is_char(l)) {
            continue;
          }
          result = result + text2[l];
          counts = { "up": 0, "down": 0, "mid": 0 };
          switch (options3.size) {
            case "mini":
              counts.up = randomNumber(8);
              counts.min = randomNumber(2);
              counts.down = randomNumber(8);
              break;
            case "maxi":
              counts.up = randomNumber(16) + 3;
              counts.min = randomNumber(4) + 1;
              counts.down = randomNumber(64) + 3;
              break;
            default:
              counts.up = randomNumber(8) + 1;
              counts.mid = randomNumber(6) / 2;
              counts.down = randomNumber(8) + 1;
              break;
          }
          var arr = ["up", "mid", "down"];
          for (var d in arr) {
            var index = arr[d];
            for (var i = 0; i <= counts[index]; i++) {
              if (options3[index]) {
                result = result + soul[index][randomNumber(soul[index].length)];
              }
            }
          }
        }
        return result;
      }
      return heComes(text);
    };
  }
});

// node_modules/colors/lib/maps/america.js
var require_america = __commonJS({
  "node_modules/colors/lib/maps/america.js"(exports, module2) {
    var colors = require_colors();
    module2["exports"] = function() {
      return function(letter, i, exploded) {
        if (letter === " ")
          return letter;
        switch (i % 3) {
          case 0:
            return colors.red(letter);
          case 1:
            return colors.white(letter);
          case 2:
            return colors.blue(letter);
        }
      };
    }();
  }
});

// node_modules/colors/lib/maps/zebra.js
var require_zebra = __commonJS({
  "node_modules/colors/lib/maps/zebra.js"(exports, module2) {
    var colors = require_colors();
    module2["exports"] = function(letter, i, exploded) {
      return i % 2 === 0 ? letter : colors.inverse(letter);
    };
  }
});

// node_modules/colors/lib/maps/rainbow.js
var require_rainbow = __commonJS({
  "node_modules/colors/lib/maps/rainbow.js"(exports, module2) {
    var colors = require_colors();
    module2["exports"] = function() {
      var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
      return function(letter, i, exploded) {
        if (letter === " ") {
          return letter;
        } else {
          return colors[rainbowColors[i++ % rainbowColors.length]](letter);
        }
      };
    }();
  }
});

// node_modules/colors/lib/maps/random.js
var require_random = __commonJS({
  "node_modules/colors/lib/maps/random.js"(exports, module2) {
    var colors = require_colors();
    module2["exports"] = function() {
      var available = ["underline", "inverse", "grey", "yellow", "red", "green", "blue", "white", "cyan", "magenta"];
      return function(letter, i, exploded) {
        return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 1))]](letter);
      };
    }();
  }
});

// node_modules/colors/lib/colors.js
var require_colors = __commonJS({
  "node_modules/colors/lib/colors.js"(exports, module2) {
    var colors = {};
    module2["exports"] = colors;
    colors.themes = {};
    var ansiStyles = colors.styles = require_styles();
    var defineProps = Object.defineProperties;
    colors.supportsColor = require_supports_colors();
    if (typeof colors.enabled === "undefined") {
      colors.enabled = colors.supportsColor;
    }
    colors.stripColors = colors.strip = function(str) {
      return ("" + str).replace(/\x1B\[\d+m/g, "");
    };
    var stylize = colors.stylize = function stylize2(str, style2) {
      return ansiStyles[style2].open + str + ansiStyles[style2].close;
    };
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    var escapeStringRegexp = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
    function build(_styles) {
      var builder = function builder2() {
        return applyStyle.apply(builder2, arguments);
      };
      builder._styles = _styles;
      builder.__proto__ = proto;
      return builder;
    }
    var styles2 = function() {
      var ret = {};
      ansiStyles.grey = ansiStyles.gray;
      Object.keys(ansiStyles).forEach(function(key) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
        ret[key] = {
          get: function() {
            return build(this._styles.concat(key));
          }
        };
      });
      return ret;
    }();
    var proto = defineProps(function colors2() {
    }, styles2);
    function applyStyle() {
      var args = arguments;
      var argsLen = args.length;
      var str = argsLen !== 0 && String(arguments[0]);
      if (argsLen > 1) {
        for (var a = 1; a < argsLen; a++) {
          str += " " + args[a];
        }
      }
      if (!colors.enabled || !str) {
        return str;
      }
      var nestedStyles = this._styles;
      var i = nestedStyles.length;
      while (i--) {
        var code = ansiStyles[nestedStyles[i]];
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
      }
      return str;
    }
    function applyTheme(theme) {
      for (var style2 in theme) {
        (function(style3) {
          colors[style3] = function(str) {
            return colors[theme[style3]](str);
          };
        })(style2);
      }
    }
    colors.setTheme = function(theme) {
      if (typeof theme === "string") {
        try {
          colors.themes[theme] = require(theme);
          applyTheme(colors.themes[theme]);
          return colors.themes[theme];
        } catch (err) {
          console.log(err);
          return err;
        }
      } else {
        applyTheme(theme);
      }
    };
    function init() {
      var ret = {};
      Object.keys(styles2).forEach(function(name2) {
        ret[name2] = {
          get: function() {
            return build([name2]);
          }
        };
      });
      return ret;
    }
    var sequencer = function sequencer2(map2, str) {
      var exploded = str.split(""), i = 0;
      exploded = exploded.map(map2);
      return exploded.join("");
    };
    colors.trap = require_trap();
    colors.zalgo = require_zalgo();
    colors.maps = {};
    colors.maps.america = require_america();
    colors.maps.zebra = require_zebra();
    colors.maps.rainbow = require_rainbow();
    colors.maps.random = require_random();
    for (map in colors.maps) {
      (function(map2) {
        colors[map2] = function(str) {
          return sequencer(colors.maps[map2], str);
        };
      })(map);
    }
    var map;
    defineProps(colors, init());
  }
});

// node_modules/colors/safe.js
var require_safe = __commonJS({
  "node_modules/colors/safe.js"(exports, module2) {
    var colors = require_colors();
    module2["exports"] = colors;
  }
});

// node_modules/cli-table/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/cli-table/lib/utils.js"(exports) {
    exports.repeat = function(str, times) {
      return Array(times + 1).join(str);
    };
    exports.pad = function(str, len, pad2, dir) {
      if (len + 1 >= str.length)
        switch (dir) {
          case "left":
            str = Array(len + 1 - str.length).join(pad2) + str;
            break;
          case "both":
            var right = Math.ceil((padlen = len - str.length) / 2);
            var left = padlen - right;
            str = Array(left + 1).join(pad2) + str + Array(right + 1).join(pad2);
            break;
          default:
            str = str + Array(len + 1 - str.length).join(pad2);
        }
      ;
      return str;
    };
    exports.truncate = function(str, length, chr) {
      chr = chr || "\u2026";
      return str.length >= length ? str.substr(0, length - chr.length) + chr : str;
    };
    function options2(defaults3, opts) {
      for (var p in opts) {
        if (p === "__proto__" || p === "constructor" || p === "prototype") {
          continue;
        }
        if (opts[p] && opts[p].constructor && opts[p].constructor === Object) {
          defaults3[p] = defaults3[p] || {};
          options2(defaults3[p], opts[p]);
        } else {
          defaults3[p] = opts[p];
        }
      }
      return defaults3;
    }
    exports.options = options2;
    exports.strlen = function(str) {
      var code = /\u001b\[(?:\d*;){0,5}\d*m/g;
      var stripped = ("" + str).replace(code, "");
      var split = stripped.split("\n");
      return split.reduce(function(memo, s) {
        return s.length > memo ? s.length : memo;
      }, 0);
    };
  }
});

// node_modules/cli-table/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/cli-table/lib/index.js"(exports, module2) {
    var colors = require_safe();
    var utils = require_utils3();
    var repeat2 = utils.repeat;
    var truncate = utils.truncate;
    var pad2 = utils.pad;
    function Table2(options2) {
      this.options = utils.options({
        chars: {
          "top": "\u2500",
          "top-mid": "\u252C",
          "top-left": "\u250C",
          "top-right": "\u2510",
          "bottom": "\u2500",
          "bottom-mid": "\u2534",
          "bottom-left": "\u2514",
          "bottom-right": "\u2518",
          "left": "\u2502",
          "left-mid": "\u251C",
          "mid": "\u2500",
          "mid-mid": "\u253C",
          "right": "\u2502",
          "right-mid": "\u2524",
          "middle": "\u2502"
        },
        truncate: "\u2026",
        colWidths: [],
        colAligns: [],
        style: {
          "padding-left": 1,
          "padding-right": 1,
          head: ["red"],
          border: ["grey"],
          compact: false
        },
        head: []
      }, options2);
    }
    Table2.prototype.__proto__ = Array.prototype;
    Table2.prototype.__defineGetter__("width", function() {
      var str = this.toString().split("\n");
      if (str.length)
        return str[0].length;
      return 0;
    });
    Table2.prototype.render;
    Table2.prototype.toString = function() {
      var ret = "", options2 = this.options, style2 = options2.style, head = options2.head, chars = options2.chars, truncater = options2.truncate, colWidths = options2.colWidths || new Array(this.head.length), totalWidth = 0;
      if (!head.length && !this.length)
        return "";
      if (!colWidths.length) {
        var all_rows = this.slice(0);
        if (head.length) {
          all_rows = all_rows.concat([head]);
        }
        ;
        all_rows.forEach(function(cells) {
          if (typeof cells === "object" && cells.length) {
            extractColumnWidths(cells);
          } else {
            var header_cell = Object.keys(cells)[0], value_cell = cells[header_cell];
            colWidths[0] = Math.max(colWidths[0] || 0, get_width(header_cell) || 0);
            if (typeof value_cell === "object" && value_cell.length) {
              extractColumnWidths(value_cell, 1);
            } else {
              colWidths[1] = Math.max(colWidths[1] || 0, get_width(value_cell) || 0);
            }
          }
        });
      }
      ;
      totalWidth = (colWidths.length == 1 ? colWidths[0] : colWidths.reduce(function(a, b) {
        return a + b;
      })) + colWidths.length + 1;
      function extractColumnWidths(arr, offset) {
        var offset = offset || 0;
        arr.forEach(function(cell, i) {
          colWidths[i + offset] = Math.max(colWidths[i + offset] || 0, get_width(cell) || 0);
        });
      }
      ;
      function get_width(obj) {
        return typeof obj == "object" && obj.width != void 0 ? obj.width : (typeof obj == "object" ? utils.strlen(obj.text) : utils.strlen(obj)) + (style2["padding-left"] || 0) + (style2["padding-right"] || 0);
      }
      function line(line2, left, right, intersection) {
        var width = 0, line2 = left + repeat2(line2, totalWidth - 2) + right;
        colWidths.forEach(function(w, i) {
          if (i == colWidths.length - 1)
            return;
          width += w + 1;
          line2 = line2.substr(0, width) + intersection + line2.substr(width + 1);
        });
        return applyStyles(options2.style.border, line2);
      }
      ;
      function lineTop() {
        var l2 = line(chars.top, chars["top-left"] || chars.top, chars["top-right"] || chars.top, chars["top-mid"]);
        if (l2)
          ret += l2 + "\n";
      }
      ;
      function generateRow(items, style3) {
        var cells = [], max_height = 0;
        if (!Array.isArray(items) && typeof items === "object") {
          var key = Object.keys(items)[0], value = items[key], first_cell_head = true;
          if (Array.isArray(value)) {
            items = value;
            items.unshift(key);
          } else {
            items = [key, value];
          }
        }
        items.forEach(function(item, i) {
          var contents = item.toString().split("\n").reduce(function(memo, l2) {
            memo.push(string2(l2, i));
            return memo;
          }, []);
          var height = contents.length;
          if (height > max_height) {
            max_height = height;
          }
          ;
          cells.push({ contents, height });
        });
        var lines = new Array(max_height);
        cells.forEach(function(cell, i) {
          cell.contents.forEach(function(line2, j2) {
            if (!lines[j2]) {
              lines[j2] = [];
            }
            ;
            if (style3 || first_cell_head && i === 0 && options2.style.head) {
              line2 = applyStyles(options2.style.head, line2);
            }
            lines[j2].push(line2);
          });
          for (var j = cell.height, l2 = max_height; j < l2; j++) {
            if (!lines[j]) {
              lines[j] = [];
            }
            ;
            lines[j].push(string2("", i));
          }
        });
        var ret2 = "";
        lines.forEach(function(line2, index) {
          if (ret2.length > 0) {
            ret2 += "\n" + applyStyles(options2.style.border, chars.left);
          }
          ret2 += line2.join(applyStyles(options2.style.border, chars.middle)) + applyStyles(options2.style.border, chars.right);
        });
        return applyStyles(options2.style.border, chars.left) + ret2;
      }
      ;
      function applyStyles(styles2, subject) {
        if (!subject)
          return "";
        styles2.forEach(function(style3) {
          subject = colors[style3](subject);
        });
        return subject;
      }
      ;
      function string2(str, index) {
        var str = String(typeof str == "object" && str.text ? str.text : str), length = utils.strlen(str), width = colWidths[index] - (style2["padding-left"] || 0) - (style2["padding-right"] || 0), align = options2.colAligns[index] || "left";
        return repeat2(" ", style2["padding-left"] || 0) + (length == width ? str : length < width ? pad2(str, width + (str.length - length), " ", align == "left" ? "right" : align == "middle" ? "both" : "left") : truncater ? truncate(str, width, truncater) : str) + repeat2(" ", style2["padding-right"] || 0);
      }
      ;
      if (head.length) {
        lineTop();
        ret += generateRow(head, style2.head) + "\n";
      }
      if (this.length)
        this.forEach(function(cells, i) {
          if (!head.length && i == 0)
            lineTop();
          else {
            if (!style2.compact || i < !!head.length ? 1 : cells.length == 0) {
              var l2 = line(chars.mid, chars["left-mid"], chars["right-mid"], chars["mid-mid"]);
              if (l2)
                ret += l2 + "\n";
            }
          }
          if (cells.hasOwnProperty("length") && !cells.length) {
            return;
          } else {
            ret += generateRow(cells) + "\n";
          }
          ;
        });
      var l = line(chars.bottom, chars["bottom-left"] || chars.bottom, chars["bottom-right"] || chars.bottom, chars["bottom-mid"]);
      if (l)
        ret += l;
      else
        ret = ret.slice(0, -1);
      return ret;
    };
    module2.exports = Table2;
    module2.exports.version = "0.0.1";
  }
});

// node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "node_modules/ansi-styles/index.js"(exports, module2) {
    "use strict";
    var ANSI_BACKGROUND_OFFSET = 10;
    var wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
    var wrapAnsi16m = (offset = 0) => (red, green, blue2) => `\x1B[${38 + offset};2;${red};${green};${blue2}m`;
    function assembleStyles() {
      const codes = /* @__PURE__ */ new Map();
      const styles2 = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          overline: [53, 55],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles2.color.gray = styles2.color.blackBright;
      styles2.bgColor.bgGray = styles2.bgColor.bgBlackBright;
      styles2.color.grey = styles2.color.blackBright;
      styles2.bgColor.bgGrey = styles2.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles2)) {
        for (const [styleName, style2] of Object.entries(group)) {
          styles2[styleName] = {
            open: `\x1B[${style2[0]}m`,
            close: `\x1B[${style2[1]}m`
          };
          group[styleName] = styles2[styleName];
          codes.set(style2[0], style2[1]);
        }
        Object.defineProperty(styles2, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles2, "codes", {
        value: codes,
        enumerable: false
      });
      styles2.color.close = "\x1B[39m";
      styles2.bgColor.close = "\x1B[49m";
      styles2.color.ansi256 = wrapAnsi256();
      styles2.color.ansi16m = wrapAnsi16m();
      styles2.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
      styles2.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
      Object.defineProperties(styles2, {
        rgbToAnsi256: {
          value: (red, green, blue2) => {
            if (red === green && green === blue2) {
              if (red < 8) {
                return 16;
              }
              if (red > 248) {
                return 231;
              }
              return Math.round((red - 8) / 247 * 24) + 232;
            }
            return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue2 / 255 * 5);
          },
          enumerable: false
        },
        hexToRgb: {
          value: (hex) => {
            const matches = /(?<colorString>[a-f\d]{6}|[a-f\d]{3})/i.exec(hex.toString(16));
            if (!matches) {
              return [0, 0, 0];
            }
            let { colorString } = matches.groups;
            if (colorString.length === 3) {
              colorString = colorString.split("").map((character) => character + character).join("");
            }
            const integer2 = Number.parseInt(colorString, 16);
            return [
              integer2 >> 16 & 255,
              integer2 >> 8 & 255,
              integer2 & 255
            ];
          },
          enumerable: false
        },
        hexToAnsi256: {
          value: (hex) => styles2.rgbToAnsi256(...styles2.hexToRgb(hex)),
          enumerable: false
        }
      });
      return styles2;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// src/markdown/styles.ts
function gray(str) {
  return `${import_ansi_styles.default.gray.open}${str}${import_ansi_styles.default.gray.close}`;
}
function magenta(str) {
  return `${import_ansi_styles.default.magenta.open}${str}${import_ansi_styles.default.magenta.close}`;
}
function bold(str) {
  return `${import_ansi_styles.default.bold.open}${str}${import_ansi_styles.default.bold.close}`;
}
function underline(str) {
  return `${import_ansi_styles.default.underline.open}${str}${import_ansi_styles.default.underline.close}`;
}
function strikethrough(str) {
  return `${import_ansi_styles.default.strikethrough.open}${str}${import_ansi_styles.default.strikethrough.close}`;
}
function italic(str) {
  return `${import_ansi_styles.default.italic.open}${str}${import_ansi_styles.default.italic.close}`;
}
function yellow(str) {
  return `${import_ansi_styles.default.yellow.open}${str}${import_ansi_styles.default.yellow.close}`;
}
function blue(str) {
  return `${import_ansi_styles.default.blue.open}${str}${import_ansi_styles.default.blue.close}`;
}
var import_ansi_styles;
var init_styles = __esm({
  "src/markdown/styles.ts"() {
    "use strict";
    import_ansi_styles = __toESM(require_ansi_styles());
  }
});

// src/markdown/renderer.ts
function identity(str) {
  return str;
}
function cleanUpHtml(input) {
  return gray(input.replace(/(<([^>]+)>)/ig, ""));
}
function fixHardReturn(text, reflow) {
  return reflow ? text.replace(HARD_RETURN, /\n/g) : text;
}
function indentLines(indent, text) {
  return text.replace(/(^|\n)(.+)/g, "$1" + indent + "$2");
}
function identify(indent, text) {
  if (!text)
    return text;
  return indent + text.split("\n").join("\n" + indent);
}
function fixNestedLists(body, indent) {
  let regex3 = new RegExp("(\\S(?: |  )?)((?:" + indent + ")+)(" + POINT_REGEX + "(?:.*)+)$", "gm");
  return body.replace(regex3, "$1\n" + indent + "$2$3");
}
function toSpaces(str) {
  return " ".repeat(str.length);
}
function bulletPointLine(indent, line) {
  return isPointedLine(line, indent) ? line : toSpaces(BULLET_POINT) + line;
}
function bulletPointLines(lines, indent) {
  let transform = bulletPointLine.bind(null, indent);
  return lines.split("\n").filter(identity).map(transform).join("\n");
}
function numberedLine(indent, line, num) {
  return isPointedLine(line, indent) ? {
    num: num + 1,
    line: line.replace(BULLET_POINT, numberedPoint(num + 1))
  } : {
    num,
    line: toSpaces(numberedPoint(num)) + line
  };
}
function numberedLines(lines, indent) {
  let transform = numberedLine.bind(null, indent);
  let num = 0;
  return lines.split("\n").filter(identity).map((line) => {
    const numbered = transform(line, num);
    num = numbered.num;
    return numbered.line;
  }).join("\n");
}
function list(body, ordered, indent) {
  body = body.trim();
  body = ordered ? numberedLines(body, indent) : bulletPointLines(body, indent);
  return body;
}
function section(text) {
  return text + "\n\n";
}
function undoColon(str) {
  return str.replace(COLON_REPLACER_REGEXP, ":");
}
function generateTableRow(text, escape2 = null) {
  if (!text)
    return [];
  escape2 = escape2 || identity;
  let lines = escape2(text).split("\n");
  let data = [];
  lines.forEach(function(line) {
    if (!line)
      return;
    let parsed = line.replace(TABLE_ROW_WRAP_REGEXP, "").split(TABLE_CELL_SPLIT);
    data.push(parsed.splice(0, parsed.length - 1));
  });
  return data;
}
function escapeRegExp(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
function unescapeEntities(html) {
  return html.replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#39;/g, "'");
}
var import_cli_table, logger8, TABLE_CELL_SPLIT, TABLE_ROW_WRAP, TABLE_ROW_WRAP_REGEXP, COLON_REPLACER, COLON_REPLACER_REGEXP, HARD_RETURN, defaultOptions, BULLET_POINT_REGEX, NUMBERED_POINT_REGEX, POINT_REGEX, isPointedLine, BULLET_POINT, numberedPoint, links, Renderer2, renderer_default;
var init_renderer = __esm({
  "src/markdown/renderer.ts"() {
    "use strict";
    import_cli_table = __toESM(require_lib6());
    init_styles();
    logger8 = require_logger2()("markdown-renderer");
    TABLE_CELL_SPLIT = "^*||*^";
    TABLE_ROW_WRAP = "*|*|*|*";
    TABLE_ROW_WRAP_REGEXP = new RegExp(escapeRegExp(TABLE_ROW_WRAP), "g");
    COLON_REPLACER = "*#COLON|*";
    COLON_REPLACER_REGEXP = new RegExp(escapeRegExp(COLON_REPLACER), "g");
    HARD_RETURN = "\r";
    defaultOptions = {
      code: identity,
      blockquote: identity,
      html: cleanUpHtml,
      heading: magenta,
      firstHeading: magenta,
      hr: identity,
      listitem: identity,
      list,
      table: identity,
      paragraph: identity,
      strong: bold,
      em: italic,
      codespan: yellow,
      del: strikethrough,
      link: underline,
      href: underline,
      text: identity,
      unescape: true,
      emoji: false,
      width: 80,
      showSectionPrefix: false,
      tab: 2,
      tableOptions: {}
    };
    BULLET_POINT_REGEX = "\\*";
    NUMBERED_POINT_REGEX = "\\d+\\.";
    POINT_REGEX = "(?:" + [BULLET_POINT_REGEX, NUMBERED_POINT_REGEX].join("|") + ")";
    isPointedLine = function(line, indent) {
      return line.match("^(?:" + indent + ")*" + POINT_REGEX);
    };
    BULLET_POINT = "* ";
    numberedPoint = function(n) {
      return n + ". ";
    };
    links = /* @__PURE__ */ new Map();
    Renderer2 = class {
      constructor(options2 = {}, highlightOptions = {}) {
        this.options = options2;
        this.highlightOptions = highlightOptions;
        this.o = Object.assign({}, defaultOptions, options2);
        this.tab = "  ";
        this.tableSettings = this.o.tableOptions;
        this.unescape = this.o.unescape ? unescapeEntities : identity;
        this.highlightOptions = highlightOptions || {};
        this.transform = this.compose(undoColon, this.unescape);
      }
      text(t) {
        return this.o.text(t);
      }
      code(code, lang, _escaped) {
        return "``` " + lang + "\n" + code + "\n```\n";
      }
      blockquote(quote) {
        return section(this.o.blockquote(identify(this.tab, quote.trim())));
      }
      html(html) {
        return this.o.html(html);
      }
      heading(text, level, _raw) {
        text = this.transform(text);
        let prefix = this.o.showSectionPrefix ? new Array(level + 1).join("#") + " " : "";
        text = prefix + text;
        return section(level === 1 ? this.o.firstHeading(text) : this.o.heading(text));
      }
      hr() {
        return `\u2500\u2500\u2500
`;
      }
      list(body, ordered) {
        body = this.o.list(body, ordered, this.tab);
        return section(fixNestedLists(indentLines(this.tab, body), this.tab));
      }
      listitem(text) {
        let transform = this.compose(this.o.listitem, this.transform);
        let isNested = text.indexOf("\n") !== -1;
        if (isNested)
          text = text.trim();
        return "\n" + BULLET_POINT + transform(text);
      }
      checkbox(checked) {
        return "[" + (checked ? "X" : " ") + "] ";
      }
      paragraph(text) {
        let transform = this.compose(this.o.paragraph, this.transform);
        text = transform(text);
        return section(text);
      }
      table(header, body) {
        let table = new import_cli_table.default(Object.assign({}, {
          head: generateTableRow(header)[0]
        }, this.tableSettings));
        generateTableRow(body, this.transform).forEach(function(row) {
          table.push(row);
        });
        return section(this.o.table(table.toString()));
      }
      tablerow(content) {
        return TABLE_ROW_WRAP + content + TABLE_ROW_WRAP + "\n";
      }
      tablecell(content, _flags) {
        return content + TABLE_CELL_SPLIT;
      }
      strong(text) {
        return this.o.strong(text);
      }
      em(text) {
        text = fixHardReturn(text, this.o.reflowText);
        return this.o.em(text);
      }
      codespan(text) {
        text = fixHardReturn(text, this.o.reflowText);
        return this.o.codespan(text.replace(/:/g, COLON_REPLACER));
      }
      br() {
        return "\n";
      }
      del(text) {
        return this.o.del(text);
      }
      link(href, title, text) {
        let prot;
        try {
          prot = decodeURIComponent(unescape(href)).replace(/[^\w:]/g, "").toLowerCase();
        } catch (e) {
          return "";
        }
        if (prot.startsWith("javascript:")) {
          return "";
        }
        if (text && href && text != href) {
          links.set(text, href);
        }
        if (text && text != href)
          return blue(text);
        let out = this.o.href(href);
        return this.o.link(out);
      }
      image(href, title, text) {
        let out = "![" + text;
        if (title)
          out += " \u2013 " + title;
        return out + "](" + href + ")";
      }
      compose(...funcs) {
        return (...args) => {
          for (let i = funcs.length; i-- > 0; ) {
            args = [funcs[i].apply(this, args)];
          }
          return args[0];
        };
      }
      static getLinks() {
        let res = [];
        for (let [text, href] of links.entries()) {
          res.push(`${blue(text)}: ${href}`);
        }
        links.clear();
        return res;
      }
    };
    renderer_default = Renderer2;
  }
});

// src/util/ansiparse.ts
function parseAnsiHighlights(line, markdown = false) {
  let items = ansiparse(line);
  let highlights = [];
  let newLabel = "";
  for (let item of items) {
    if (!item.text)
      continue;
    let { foreground, background } = item;
    let len = byteLength(newLabel);
    let span = [len, len + byteLength(item.text)];
    if (foreground && background) {
      let hlGroup = `CocList${upperFirst(foreground)}${upperFirst(background)}`;
      highlights.push({ span, hlGroup });
    } else if (foreground) {
      let hlGroup;
      if (markdown) {
        if (foreground == "yellow") {
          hlGroup = "CocMarkdownCode";
        } else if (foreground == "blue") {
          hlGroup = "CocMarkdownLink";
        } else if (foreground == "magenta") {
          hlGroup = "CocMarkdownHeader";
        } else {
          hlGroup = `CocListFg${upperFirst(foreground)}`;
        }
      } else {
        hlGroup = `CocListFg${upperFirst(foreground)}`;
      }
      highlights.push({ span, hlGroup });
    } else if (background) {
      let hlGroup = `CocListBg${upperFirst(background)}`;
      highlights.push({ span, hlGroup });
    }
    if (item.bold) {
      highlights.push({ span, hlGroup: "CocBold" });
    } else if (item.italic) {
      highlights.push({ span, hlGroup: "CocItalic" });
    } else if (item.underline) {
      highlights.push({ span, hlGroup: "CocUnderline" });
    } else if (item.strikethrough) {
      highlights.push({ span, hlGroup: "CocStrikeThrough" });
    }
    newLabel = newLabel + item.text;
  }
  return { line: newLabel, highlights };
}
function ansiparse(str) {
  let matchingControl = null;
  let matchingData = null;
  let matchingText = "";
  let ansiState = [];
  let result = [];
  let state = {};
  let eraseChar;
  eraseChar = () => {
    let index;
    let text;
    if (matchingText.length) {
      matchingText = matchingText.substr(0, matchingText.length - 1);
    } else if (result.length) {
      index = result.length - 1;
      text = result[index].text;
      if (text.length === 1) {
        result.pop();
      } else {
        result[index].text = text.substr(0, text.length - 1);
      }
    }
  };
  for (let i = 0; i < str.length; i++) {
    if (matchingControl != null) {
      if (matchingControl == "\x1B" && str[i] == "[") {
        if (matchingText) {
          state.text = matchingText;
          result.push(state);
          state = {};
          matchingText = "";
        }
        if (matchingText == "" && (str[i + 1] == "m" || str[i + 1] == "K")) {
          if (state.foreground || state.background) {
            state.text = "";
            result.push(state);
          }
          state = {};
        }
        matchingControl = null;
        matchingData = "";
      } else {
        matchingText += matchingControl + str[i];
        matchingControl = null;
      }
      continue;
    } else if (matchingData != null) {
      if (str[i] == ";") {
        ansiState.push(matchingData);
        matchingData = "";
      } else if (str[i] == "m" || str[i] == "K") {
        ansiState.push(matchingData);
        matchingData = null;
        matchingText = "";
        ansiState.forEach((ansiCode) => {
          if (foregroundColors[ansiCode]) {
            state.foreground = foregroundColors[ansiCode];
          } else if (backgroundColors[ansiCode]) {
            state.background = backgroundColors[ansiCode];
          } else if (ansiCode == 39) {
            delete state.foreground;
          } else if (ansiCode == 49) {
            delete state.background;
          } else if (styles[ansiCode]) {
            state[styles[ansiCode]] = true;
          } else if (ansiCode == 22) {
            state.bold = false;
          } else if (ansiCode == 23) {
            state.italic = false;
          } else if (ansiCode == 24) {
            state.underline = false;
          } else if (ansiCode == 29) {
            state.strikethrough = false;
          }
        });
        ansiState = [];
      } else {
        matchingData += str[i];
      }
      continue;
    }
    if (str[i] == "\x1B") {
      matchingControl = str[i];
    } else if (str[i] == "\b") {
      eraseChar();
    } else {
      matchingText += str[i];
    }
  }
  if (matchingText) {
    state.text = matchingText + (matchingControl ? matchingControl : "");
    result.push(state);
  }
  return result;
}
var foregroundColors, backgroundColors, styles;
var init_ansiparse = __esm({
  "src/util/ansiparse.ts"() {
    "use strict";
    init_string();
    foregroundColors = {
      30: "black",
      31: "red",
      32: "green",
      33: "yellow",
      34: "blue",
      35: "magenta",
      36: "cyan",
      37: "white",
      90: "grey"
    };
    backgroundColors = {
      40: "black",
      41: "red",
      42: "green",
      43: "yellow",
      44: "blue",
      45: "magenta",
      46: "cyan",
      47: "white"
    };
    styles = {
      1: "bold",
      3: "italic",
      4: "underline",
      9: "strikethrough"
    };
  }
});

// node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS({
  "node_modules/ansi-regex/index.js"(exports, module2) {
    "use strict";
    module2.exports = ({ onlyFirst = false } = {}) => {
      const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(pattern, onlyFirst ? void 0 : "g");
    };
  }
});

// node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS({
  "node_modules/strip-ansi/index.js"(exports, module2) {
    "use strict";
    var ansiRegex = require_ansi_regex();
    module2.exports = (string2) => typeof string2 === "string" ? string2.replace(ansiRegex(), "") : string2;
  }
});

// src/markdown/index.ts
function parseDocuments(docs, opts = {}) {
  let lines = [];
  let highlights = [];
  let codes = [];
  let idx = 0;
  for (let doc of docs) {
    let currline = lines.length;
    let { content, filetype } = doc;
    let hls = doc.highlights;
    if (filetype == "markdown") {
      let info = parseMarkdown(content, opts);
      codes.push(...info.codes.map((o) => {
        o.startLine = o.startLine + currline;
        o.endLine = o.endLine + currline;
        return o;
      }));
      highlights.push(...info.highlights.map((o) => {
        o.lnum = o.lnum + currline;
        return o;
      }));
      lines.push(...info.lines);
    } else {
      let parts = content.trim().split(/\r?\n/);
      if (diagnosticFiletypes.includes(doc.filetype)) {
        codes.push({ hlGroup: `Coc${filetype}Float`, startLine: currline, endLine: currline + parts.length });
      } else {
        codes.push({ filetype: doc.filetype, startLine: currline, endLine: currline + parts.length });
      }
      lines.push(...parts);
    }
    if (Array.isArray(hls)) {
      highlights.push(...hls.map((o) => {
        return Object.assign({}, o, { lnum: o.lnum + currline });
      }));
    }
    if (Array.isArray(doc.active)) {
      let arr = getHighlightItems(content, currline, doc.active);
      if (arr.length)
        highlights.push(...arr);
    }
    if (idx != docs.length - 1) {
      highlights.push({
        lnum: lines.length,
        hlGroup: "CocFloatDividingLine",
        colStart: 0,
        colEnd: -1
      });
      lines.push("\u2500");
    }
    idx = idx + 1;
  }
  return { lines, highlights, codes };
}
function getHighlightItems(content, currline, active) {
  let res = [];
  let [start, end] = active;
  let lines = content.split(/\r?\n/);
  let used = 0;
  let inRange = false;
  for (let i = 0; i < lines.length; i++) {
    let line = lines[i];
    if (!inRange) {
      if (used + line.length > start) {
        inRange = true;
        let colStart = byteLength(line.slice(0, start - used));
        if (used + line.length > end) {
          let colEnd = byteLength(line.slice(0, end - used));
          inRange = false;
          res.push({ colStart, colEnd, lnum: i + currline, hlGroup: "CocUnderline" });
          break;
        } else {
          let colEnd = byteLength(line);
          res.push({ colStart, colEnd, lnum: i + currline, hlGroup: "CocUnderline" });
        }
      }
    } else {
      if (used + line.length > end) {
        let colEnd = byteLength(line.slice(0, end - used));
        res.push({ colStart: 0, colEnd, lnum: i + currline, hlGroup: "CocUnderline" });
        inRange = false;
        break;
      } else {
        let colEnd = byteLength(line);
        res.push({ colStart: 0, colEnd, lnum: i + currline, hlGroup: "CocUnderline" });
      }
    }
    used = used + line.length + 1;
  }
  return res;
}
function parseMarkdown(content, opts) {
  marked.setOptions({
    renderer: new renderer_default(),
    gfm: true,
    breaks: true
  });
  let lines = [];
  let highlights = [];
  let codes = [];
  let currline = 0;
  let inCodeBlock = false;
  let filetype;
  let startLnum = 0;
  let parsed = marked(content);
  let links2 = renderer_default.getLinks();
  parsed = parsed.replace(/\n\n/g, "\n").replace(/\s*$/, "");
  if (links2.length) {
    parsed = parsed + "\n\n" + links2.join("\n");
  }
  let parsedLines = parsed.split(/\n/);
  for (let i = 0; i < parsedLines.length; i++) {
    let line = parsedLines[i];
    if (!line.length) {
      let pre = lines[lines.length - 1];
      if (pre) {
        lines.push(line);
        currline++;
      }
      continue;
    }
    if (opts.excludeImages && line.indexOf("![") !== -1) {
      line = line.replace(/\s*!\[.*?\]\(.*?\)/g, "");
      if (!(0, import_strip_ansi.default)(line).trim().length)
        continue;
    }
    if (/\s*```\s*([A-Za-z0-9_,]+)?$/.test(line)) {
      if (!inCodeBlock) {
        let pre = parsedLines[i - 1];
        if (pre && /^\s*```\s*/.test(pre)) {
          lines.push("");
          currline++;
        }
        inCodeBlock = true;
        filetype = line.replace(/^\s*```\s*/, "");
        if (filetype == "js")
          filetype = "javascript";
        if (filetype == "ts")
          filetype = "typescript";
        if (filetype == "bash")
          filetype = "sh";
        startLnum = currline;
      } else {
        inCodeBlock = false;
        codes.push({
          filetype,
          startLine: startLnum,
          endLine: currline
        });
      }
      continue;
    }
    if (inCodeBlock) {
      lines.push(line);
      currline++;
      continue;
    }
    let res = parseAnsiHighlights(line, true);
    if (line === "\u2500\u2500\u2500") {
      highlights.push({
        hlGroup: "CocFloatDividingLine",
        lnum: currline,
        colStart: 0,
        colEnd: -1
      });
    } else if (res.highlights) {
      for (let hi of res.highlights) {
        let { hlGroup, span } = hi;
        highlights.push({
          hlGroup,
          lnum: currline,
          colStart: span[0],
          colEnd: span[1]
        });
      }
    }
    lines.push(res.line);
    currline++;
  }
  return { lines, highlights, codes };
}
var import_strip_ansi, diagnosticFiletypes, logger9;
var init_markdown = __esm({
  "src/markdown/index.ts"() {
    "use strict";
    init_marked_esm();
    init_renderer();
    init_ansiparse();
    init_string();
    import_strip_ansi = __toESM(require_strip_ansi());
    diagnosticFiletypes = ["Error", "Warning", "Info", "Hint"];
    logger9 = require_logger2()("markdown-index");
  }
});

// src/util/mutex.ts
var Mutex;
var init_mutex = __esm({
  "src/util/mutex.ts"() {
    "use strict";
    Mutex = class {
      constructor() {
        this.tasks = [];
        this.count = 1;
      }
      sched() {
        if (this.count > 0 && this.tasks.length > 0) {
          this.count--;
          let next = this.tasks.shift();
          next();
        }
      }
      get busy() {
        return this.count == 0;
      }
      acquire() {
        return new Promise((res) => {
          let task = () => {
            let released = false;
            res(() => {
              if (!released) {
                released = true;
                this.count++;
                this.sched();
              }
            });
          };
          this.tasks.push(task);
          process.nextTick(this.sched.bind(this));
        });
      }
      use(f) {
        return this.acquire().then((release) => f().then((res) => {
          release();
          return res;
        }).catch((err) => {
          release();
          throw err;
        }));
      }
    };
  }
});

// src/model/floatFactory.ts
var import_debounce2, import_vscode_languageserver_protocol5, isVim, logger10, FloatFactoryImpl;
var init_floatFactory = __esm({
  "src/model/floatFactory.ts"() {
    "use strict";
    import_debounce2 = __toESM(require_debounce());
    import_vscode_languageserver_protocol5 = __toESM(require_main2());
    init_events();
    init_markdown();
    init_util();
    init_mutex();
    init_object();
    isVim = process.env.VIM_NODE_RPC == "1";
    logger10 = require_logger2()("model-float");
    FloatFactoryImpl = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.winid = 0;
        this._bufnr = 0;
        this.mutex = new Mutex();
        this.disposables = [];
        this.onCursorMoved = (0, import_debounce2.default)(this._onCursorMoved.bind(this), 100);
      }
      bindEvents(autoHide, alignTop) {
        let eventNames = ["InsertLeave", "InsertEnter", "BufEnter"];
        for (let ev of eventNames) {
          events_default.on(ev, (bufnr) => {
            if (bufnr == this._bufnr)
              return;
            this.close();
          }, null, this.disposables);
        }
        events_default.on("MenuPopupChanged", () => {
          if (events_default.pumAlignTop == alignTop) {
            this.close();
          }
        }, null, this.disposables);
        this.disposables.push(import_vscode_languageserver_protocol5.Disposable.create(() => {
          this.onCursorMoved.clear();
        }));
        events_default.on("CursorMoved", this.onCursorMoved.bind(this, autoHide), this, this.disposables);
        events_default.on("CursorMovedI", this.onCursorMoved.bind(this, autoHide), this, this.disposables);
      }
      unbind() {
        if (this.disposables.length) {
          disposeAll(this.disposables);
          this.disposables = [];
        }
      }
      _onCursorMoved(autoHide, bufnr, cursor) {
        if (bufnr == this._bufnr)
          return;
        if (bufnr == this.targetBufnr && equals(cursor, this.cursor)) {
          return;
        }
        if (autoHide || bufnr != this.targetBufnr || !events_default.insertMode) {
          this.close();
          return;
        }
      }
      async create(docs, _allowSelection = false, offsetX = 0) {
        await this.show(docs, {
          offsetX
        });
      }
      async show(docs, config = {}) {
        if (docs.length == 0 || docs.every((doc) => doc.content.length == 0)) {
          this.close();
          return;
        }
        let curr = Date.now();
        let release = await this.mutex.acquire();
        try {
          await this.createPopup(docs, config, curr);
          release();
        } catch (e) {
          this.nvim.echoError(e);
          release();
        }
      }
      async createPopup(docs, opts, timestamp) {
        docs = docs.filter((o) => o.content.trim().length > 0);
        let { lines, codes, highlights } = parseDocuments(docs);
        let config = {
          codes,
          highlights,
          pumAlignTop: events_default.pumAlignTop,
          preferTop: typeof opts.preferTop === "boolean" ? opts.preferTop : false,
          offsetX: opts.offsetX || 0,
          title: opts.title || "",
          close: opts.close ? 1 : 0,
          rounded: opts.rounded ? 1 : 0,
          modes: opts.modes || ["n", "i", "ic", "s"]
        };
        if (!isVim) {
          if (typeof opts.winblend === "number")
            config.winblend = opts.winblend;
          if (opts.focusable != null)
            config.focusable = opts.focusable ? 1 : 0;
          if (opts.shadow)
            config.shadow = 1;
        }
        if (opts.maxHeight)
          config.maxHeight = opts.maxHeight;
        if (opts.maxWidth)
          config.maxWidth = opts.maxWidth;
        if (opts.border === true) {
          config.border = [1, 1, 1, 1];
        } else if (Array.isArray(opts.border) && !opts.border.every((o) => o == 0)) {
          config.border = opts.border.slice(0, 4);
          config.rounded = opts.rounded ? 1 : 0;
        }
        if (opts.highlight)
          config.highlight = opts.highlight;
        if (opts.borderhighlight)
          config.borderhighlight = opts.borderhighlight;
        if (opts.cursorline)
          config.cursorline = 1;
        let autoHide = opts.autoHide === false ? false : true;
        if (autoHide)
          config.autohide = 1;
        this.unbind();
        let arr = await this.nvim.call("coc#dialog#create_cursor_float", [this.winid, this._bufnr, lines, config]);
        this.nvim.redrawVim();
        if (!arr || arr.length == 0 || this.closeTs > timestamp) {
          let winid2 = arr && arr.length > 0 ? arr[2] : this.winid;
          if (winid2) {
            this.winid = 0;
            this.nvim.call("coc#float#close", [winid2], true);
            this.nvim.redrawVim();
          }
          return;
        }
        let [targetBufnr, cursor, winid, bufnr, alignTop] = arr;
        this.winid = winid;
        this._bufnr = bufnr;
        this.targetBufnr = targetBufnr;
        this.cursor = cursor;
        this.bindEvents(autoHide, alignTop == 1);
      }
      close() {
        let { winid, nvim } = this;
        this.closeTs = Date.now();
        this.unbind();
        if (winid) {
          this.winid = 0;
          nvim.call("coc#float#close", [winid], true);
          nvim.redrawVim();
        }
      }
      checkRetrigger(bufnr) {
        if (this.winid && this.targetBufnr == bufnr)
          return true;
        return false;
      }
      get bufnr() {
        return this._bufnr;
      }
      get buffer() {
        return this.bufnr ? this.nvim.createBuffer(this.bufnr) : null;
      }
      get window() {
        return this.winid ? this.nvim.createWindow(this.winid) : null;
      }
      async activated() {
        if (!this.winid)
          return false;
        return await this.nvim.call("coc#float#valid", [this.winid]) != 0;
      }
      dispose() {
        this.cursor = void 0;
        this.close();
      }
    };
  }
});

// src/core/ui.ts
async function getCursorPosition(nvim) {
  let [line, content] = await nvim.eval(`[line('.')-1, strpart(getline('.'), 0, col('.') - 1)]`);
  return import_vscode_languageserver_protocol6.Position.create(line, content.length);
}
function createFloatFactory(nvim, conf, defaults3) {
  let opts = Object.assign({}, defaults3, conf);
  let factory = new FloatFactoryImpl(nvim);
  return {
    show: (docs, option) => {
      return factory.show(docs, option ? Object.assign({}, opts, option) : opts);
    },
    activated: () => {
      return factory.activated();
    },
    dispose: () => {
      factory.dispose();
    },
    checkRetrigger: (bufnr) => {
      return factory.checkRetrigger(bufnr);
    },
    close: () => {
      factory.close();
    }
  };
}
async function showPrompt(nvim, title) {
  let res = await nvim.callAsync("coc#dialog#prompt_confirm", [title]);
  return res == 1;
}
async function moveTo(nvim, position, redraw) {
  await nvim.call("coc#cursor#move_to", [position.line, position.character]);
  if (redraw)
    nvim.command("redraw", true);
}
async function getOffset(nvim) {
  return await nvim.call("coc#cursor#char_offset");
}
async function getCursorScreenPosition(nvim) {
  let [row, col] = await nvim.call("coc#cursor#screen_pos");
  return { row, col };
}
function showMessage(nvim, msg, hl = "MoreMsg", forceTimer = false) {
  let method = forceTimer || isVim2 ? "callTimer" : "call";
  nvim[method]("coc#ui#echo_messages", [hl, ("[coc.nvim] " + msg).split("\n")], true);
}
async function getSelection(nvim, mode) {
  if (mode === "currline") {
    let line = await nvim.call("line", ["."]);
    return import_vscode_languageserver_protocol6.Range.create(line - 1, 0, line, 0);
  }
  if (mode === "cursor") {
    let [line, character] = await nvim.eval("coc#cursor#position()");
    return import_vscode_languageserver_protocol6.Range.create(line, character, line, character);
  }
  let res = await nvim.call("coc#cursor#get_selection", [operateModes.includes(mode) ? 1 : 0]);
  if (!res || res[0] == -1)
    return null;
  return import_vscode_languageserver_protocol6.Range.create(res[0], res[1], res[2], res[3]);
}
async function selectRange(nvim, range2, redraw) {
  let { start, end } = range2;
  let [line, endLine] = await nvim.eval(`[getline(${start.line + 1}),getline(${end.line + 1})]`);
  let col = line.length > 0 ? byteLength(line.slice(0, start.character)) : 0;
  let endCol;
  let endLnum;
  let toEnd = end.character == 0;
  if (toEnd) {
    endLnum = end.line == 0 ? 0 : end.line - 1;
    let pre = await nvim.call("getline", [endLnum + 1]);
    endCol = byteLength(pre);
  } else {
    endLnum = end.line;
    endCol = endLine.length > 0 ? byteLength(endLine.slice(0, end.character)) : 0;
  }
  nvim.pauseNotification();
  nvim.command(`noa call cursor(${start.line + 1},${col + 1})`, true);
  nvim.command("normal! v", true);
  nvim.command(`noa call cursor(${endLnum + 1},${endCol})`, true);
  if (toEnd)
    nvim.command("normal! $", true);
  await nvim.resumeNotification(redraw);
}
var import_vscode_languageserver_protocol6, isVim2, operateModes;
var init_ui = __esm({
  "src/core/ui.ts"() {
    "use strict";
    import_vscode_languageserver_protocol6 = __toESM(require_main2());
    init_string();
    init_floatFactory();
    isVim2 = process.env.VIM_NODE_RPC == "1";
    operateModes = ["char", "line", "block"];
  }
});

// src/model/dialog.ts
var import_vscode_languageserver_protocol7, logger11, Dialog;
var init_dialog = __esm({
  "src/model/dialog.ts"() {
    "use strict";
    import_vscode_languageserver_protocol7 = __toESM(require_main2());
    init_events();
    init_util();
    logger11 = require_logger2()("model-dialog");
    Dialog = class {
      constructor(nvim, config) {
        this.nvim = nvim;
        this.config = config;
        this.disposables = [];
        this._onDidClose = new import_vscode_languageserver_protocol7.Emitter();
        this.onDidClose = this._onDidClose.event;
        events_default.on("BufWinLeave", (bufnr) => {
          if (bufnr == this.bufnr) {
            this.dispose();
            if (config.callback)
              config.callback(-1);
          }
        }, null, this.disposables);
        events_default.on("FloatBtnClick", (bufnr, idx) => {
          if (bufnr == this.bufnr) {
            this.dispose();
            let btns = config == null ? void 0 : config.buttons.filter((o) => o.disabled != true);
            if (config.callback)
              config.callback(btns[idx].index);
          }
        }, null, this.disposables);
      }
      get lines() {
        return [...this.config.content.split(/\r?\n/)];
      }
      async show(preferences) {
        let { nvim } = this;
        let { title, close, highlights, buttons } = this.config;
        let borderhighlight = this.config.borderhighlight || preferences.floatBorderHighlight;
        let highlight = this.config.highlight || preferences.floatHighlight;
        let opts = { maxwidth: preferences.maxWidth || 80 };
        if (title)
          opts.title = title;
        if (close || typeof close === "undefined")
          opts.close = 1;
        if (preferences.maxHeight)
          opts.maxHeight = preferences.maxHeight;
        if (preferences.maxWidth)
          opts.maxWidth = preferences.maxWidth;
        if (highlight)
          opts.highlight = highlight;
        if (highlights)
          opts.highlights = highlights;
        if (borderhighlight)
          opts.borderhighlight = [borderhighlight];
        if (buttons)
          opts.buttons = buttons.filter((o) => !o.disabled).map((o) => o.text);
        if (preferences.rounded)
          opts.rounded = 1;
        if (Array.isArray(opts.buttons))
          opts.getchar = 1;
        let res = await nvim.call("coc#dialog#create_dialog", [this.lines, opts]);
        if (!res)
          throw new Error("Unable to open dialog window.");
        this.bufnr = res[1];
        nvim.command("redraw", true);
      }
      get winid() {
        if (!this.bufnr)
          return Promise.resolve(null);
        return this.nvim.call("bufwinid", [this.bufnr]);
      }
      dispose() {
        this._onDidClose.fire();
        this.bufnr = void 0;
        disposeAll(this.disposables);
        this.disposables = [];
      }
    };
  }
});

// src/model/highligher.ts
var Highlighter;
var init_highligher = __esm({
  "src/model/highligher.ts"() {
    "use strict";
    init_ansiparse();
    init_string();
    Highlighter = class {
      constructor() {
        this.lines = [];
        this._highlights = [];
      }
      addLine(line, hlGroup) {
        if (line.includes("\n")) {
          for (let content of line.split(/\r?\n/)) {
            this.addLine(content, hlGroup);
          }
          return;
        }
        if (hlGroup) {
          this._highlights.push({
            lnum: this.lines.length,
            colStart: line.match(/^\s*/)[0].length,
            colEnd: byteLength(line),
            hlGroup
          });
        }
        if (line.includes("\x1B")) {
          let res = parseAnsiHighlights(line);
          for (let hl of res.highlights) {
            let { span, hlGroup: hlGroup2 } = hl;
            if (span[0] != span[1]) {
              this._highlights.push({
                lnum: this.lines.length,
                colStart: span[0],
                colEnd: span[1],
                hlGroup: hlGroup2
              });
            }
          }
          this.lines.push(res.line);
        } else {
          this.lines.push(line);
        }
      }
      addLines(lines) {
        this.lines.push(...lines);
      }
      addTexts(items) {
        let len = this.lines.length;
        let text = "";
        for (let item of items) {
          let colStart = byteLength(text);
          if (item.hlGroup) {
            this._highlights.push({
              lnum: len,
              colStart,
              colEnd: colStart + byteLength(item.text),
              hlGroup: item.hlGroup
            });
          }
          text += item.text;
        }
        this.lines.push(text);
      }
      addText(text, hlGroup) {
        let { lines } = this;
        let pre = lines[lines.length - 1] || "";
        if (text.includes("\n")) {
          let parts = text.split("\n");
          this.addText(parts[0], hlGroup);
          for (let line of parts.slice(1)) {
            this.addLine(line, hlGroup);
          }
          return;
        }
        if (hlGroup) {
          let colStart = byteLength(pre);
          this._highlights.push({
            lnum: lines.length ? lines.length - 1 : 0,
            colStart,
            colEnd: colStart + byteLength(text),
            hlGroup
          });
        }
        if (lines.length) {
          lines[lines.length - 1] = `${pre}${text}`;
        } else {
          lines.push(text);
        }
      }
      get length() {
        return this.lines.length;
      }
      getline(line) {
        return this.lines[line] || "";
      }
      get highlights() {
        return this._highlights;
      }
      get content() {
        return this.lines.join("\n");
      }
      render(buffer, start = 0, end = -1) {
        buffer.setLines(this.lines, { start, end, strictIndexing: false }, true);
        for (let item of this._highlights) {
          buffer.addHighlight({
            hlGroup: item.hlGroup,
            colStart: item.colStart,
            colEnd: item.colEnd == null ? -1 : item.colEnd,
            line: start + item.lnum,
            srcId: -1
          });
        }
      }
    };
  }
});

// src/model/input.ts
var import_vscode_languageserver_protocol8, logger12, InputBox;
var init_input = __esm({
  "src/model/input.ts"() {
    "use strict";
    import_vscode_languageserver_protocol8 = __toESM(require_main2());
    init_events();
    init_util();
    init_object();
    logger12 = require_logger2()("model-input");
    InputBox = class {
      constructor(nvim, defaultValue) {
        this.nvim = nvim;
        this.disposables = [];
        this.accepted = false;
        this._dimension = [0, 0, 0, 0];
        this._onDidFinish = new import_vscode_languageserver_protocol8.Emitter();
        this._onDidChange = new import_vscode_languageserver_protocol8.Emitter();
        this.onDidFinish = this._onDidFinish.event;
        this.onDidChange = this._onDidChange.event;
        this._input = defaultValue;
        this.disposables.push(this._onDidFinish);
        this.disposables.push(this._onDidChange);
        let _title;
        Object.defineProperty(this, "title", {
          set: (newTitle) => {
            _title = newTitle;
            if (this._winid)
              nvim.call("coc#dialog#change_title", [this._winid, newTitle], true);
          },
          get: () => {
            return _title;
          }
        });
        let _loading = false;
        Object.defineProperty(this, "loading", {
          set: (loading) => {
            _loading = loading;
            if (this._winid)
              nvim.call("coc#dialog#change_loading", [this._winid, loading], true);
          },
          get: () => {
            return _loading;
          }
        });
        let _borderhighlight;
        Object.defineProperty(this, "borderhighlight", {
          set: (borderhighlight) => {
            _borderhighlight = borderhighlight;
            if (this._winid)
              nvim.call("coc#dialog#change_border_hl", [this._winid, borderhighlight], true);
          },
          get: () => {
            return _borderhighlight;
          }
        });
        events_default.on("BufWinLeave", (bufnr) => {
          if (bufnr == this._bufnr) {
            this._winid = void 0;
            this.dispose();
          }
        }, null, this.disposables);
        events_default.on("PromptInsert", (value, bufnr) => {
          if (bufnr == this._bufnr) {
            this._input = value;
            this.accepted = true;
            this.dispose();
          }
        }, null, this.disposables);
        events_default.on("TextChangedI", (bufnr, info) => {
          if (bufnr == this._bufnr) {
            this._input = info.line;
            this._onDidChange.fire(info.line);
          }
        }, null, this.disposables);
      }
      get dimension() {
        let { _dimension } = this;
        return { width: _dimension[0], height: _dimension[1], row: _dimension[2], col: _dimension[3] };
      }
      get bufnr() {
        return this._bufnr;
      }
      get winid() {
        return this._winid;
      }
      get value() {
        return this._input;
      }
      async show(title, preferences) {
        this.title = title;
        this.borderhighlight = preferences.borderhighlight ?? "CocFloating";
        this.loading = false;
        let config = omitUndefined(preferences);
        let res = await this.nvim.call("coc#dialog#create_prompt_win", [title, this._input, config]);
        if (!res)
          throw new Error("Unable to open input window");
        this._bufnr = res[0];
        this._winid = res[1];
        this._dimension = res[2];
        return true;
      }
      dispose() {
        this._onDidFinish.fire(this.accepted ? this._input : null);
        if (this._winid) {
          this.nvim.call("coc#float#close", [this._winid], true);
        }
        this._winid = void 0;
        this._bufnr = void 0;
        disposeAll(this.disposables);
      }
    };
  }
});

// src/model/popup.ts
var isVim3, Popup;
var init_popup = __esm({
  "src/model/popup.ts"() {
    "use strict";
    isVim3 = process.env.VIM_NODE_RPC == "1";
    Popup = class {
      constructor(nvim, winid, bufnr, linecount, _currIndex = 0) {
        this.nvim = nvim;
        this.winid = winid;
        this.bufnr = bufnr;
        this.linecount = linecount;
        this._currIndex = _currIndex;
      }
      get currIndex() {
        return this._currIndex;
      }
      get valid() {
        return this.nvim.call("coc#float#valid", [this.winid]).then((res) => {
          return !!res;
        });
      }
      close() {
        this.nvim.call("coc#float#close", [this.winid], true);
      }
      refreshScrollbar() {
        if (!isVim3)
          this.nvim.call("coc#float#nvim_scrollbar", [this.winid], true);
      }
      execute(cmd) {
        this.nvim.call("coc#compat#execute", [this.winid, cmd], true);
      }
      async scrollForward() {
        let { nvim, bufnr, winid } = this;
        let buf = nvim.createBuffer(bufnr);
        let total = await buf.length;
        let botline;
        if (!isVim3) {
          let infos = await nvim.call("getwininfo", [winid]);
          if (!infos || !infos.length)
            return;
          botline = infos[0].botline;
        } else {
          botline = await nvim.eval(`get(popup_getpos(${winid}), 'lastline', 0)`);
        }
        if (botline >= total || botline == 0)
          return;
        nvim.pauseNotification();
        this.setCursor(botline - 1);
        this.execute(`silent! noa setl scrolloff=0`);
        this.execute(`normal! ${botline}Gzt`);
        this.refreshScrollbar();
        nvim.command("redraw", true);
        nvim.resumeNotification(false, true);
      }
      async scrollBackward() {
        let { nvim, winid } = this;
        let topline;
        if (!isVim3) {
          let infos = await nvim.call("getwininfo", [winid]);
          if (!infos || !infos.length)
            return;
          topline = infos[0].topline;
        } else {
          topline = await nvim.eval(`get(popup_getpos(${winid}), 'firstline', 0)`);
        }
        if (topline == 1)
          return;
        nvim.pauseNotification();
        this.setCursor(topline - 1);
        this.execute(`normal! ${topline}Gzb`);
        this.refreshScrollbar();
        nvim.command("redraw", true);
        nvim.resumeNotification(false, true);
      }
      setCursor(index, redraw = false) {
        let { nvim, bufnr, winid, linecount } = this;
        if (index < 0) {
          index = 0;
        } else if (index > linecount - 1) {
          index = linecount - 1;
        }
        this._currIndex = index;
        nvim.call("coc#dialog#set_cursor", [winid, bufnr, index + 1], true);
        if (redraw) {
          this.refreshScrollbar();
          nvim.command("redraw", true);
        }
      }
    };
  }
});

// src/model/menu.ts
function isMenuItem(item) {
  if (!item)
    return false;
  return typeof item.text === "string";
}
var import_vscode_languageserver_protocol9, logger13, Menu;
var init_menu = __esm({
  "src/model/menu.ts"() {
    "use strict";
    import_vscode_languageserver_protocol9 = __toESM(require_main2());
    init_events();
    init_util();
    init_string();
    init_popup();
    logger13 = require_logger2()("model-menu");
    Menu = class {
      constructor(nvim, config, token) {
        this.nvim = nvim;
        this.config = config;
        this.currIndex = 0;
        this.contentHeight = 0;
        this.disposables = [];
        this.keyMappings = /* @__PURE__ */ new Map();
        this.shortcutIndexes = /* @__PURE__ */ new Set();
        this._disposed = false;
        this._onDidClose = new import_vscode_languageserver_protocol9.Emitter();
        this.onDidClose = this._onDidClose.event;
        this.total = config.items.length;
        if (token) {
          token.onCancellationRequested(() => {
            var _a;
            if (this.win) {
              (_a = this.win) == null ? void 0 : _a.close();
            } else {
              this._onDidClose.fire(-1);
              this.dispose();
            }
          });
        }
        this.disposables.push(this._onDidClose);
        this.addKeymappings();
      }
      attachEvents() {
        events_default.on("InputChar", this.onInputChar.bind(this), null, this.disposables);
        events_default.on("BufWinLeave", (bufnr) => {
          if (bufnr == this.bufnr) {
            this._onDidClose.fire(-1);
            this.dispose();
          }
        }, null, this.disposables);
      }
      addKeymappings() {
        let { nvim } = this;
        this.addKeys(["<esc>", "<C-c>"], () => {
          this._onDidClose.fire(-1);
          this.dispose();
        });
        this.addKeys(["\r", "<cr>"], () => {
          this.selectCurrent();
        });
        let setCursorIndex = (idx) => {
          var _a;
          if (!this.win)
            return;
          nvim.pauseNotification();
          this.setCursor(idx + this.contentHeight);
          (_a = this.win) == null ? void 0 : _a.refreshScrollbar();
          nvim.command("redraw", true);
          nvim.resumeNotification(false, true);
        };
        this.addKeys("<C-f>", async () => {
          var _a;
          await ((_a = this.win) == null ? void 0 : _a.scrollForward());
        });
        this.addKeys("<C-b>", async () => {
          var _a;
          await ((_a = this.win) == null ? void 0 : _a.scrollBackward());
        });
        this.addKeys(["j", "<down>", "<tab>", "<C-n>"], () => {
          let idx = this.currIndex == this.total - 1 ? 0 : this.currIndex + 1;
          setCursorIndex(idx);
        });
        this.addKeys(["k", "<up>", "<s-tab>", "<C-p>"], () => {
          let idx = this.currIndex == 0 ? this.total - 1 : this.currIndex - 1;
          setCursorIndex(idx);
        });
        this.addKeys(["g"], () => {
          setCursorIndex(0);
        });
        this.addKeys(["G"], () => {
          setCursorIndex(this.total - 1);
        });
        let timer;
        let firstNumber;
        const choose = (n) => {
          let disabled = this.isDisabled(n);
          if (disabled)
            return;
          this._onDidClose.fire(n);
          this.dispose();
        };
        this.addKeys(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"], (character) => {
          if (timer)
            clearTimeout(timer);
          let n = parseInt(character, 10);
          if (isNaN(n) || n > this.total)
            return;
          if (firstNumber == null && n == 0)
            return;
          if (firstNumber) {
            let count = firstNumber * 10 + n;
            firstNumber = void 0;
            choose(count - 1);
            return;
          }
          if (this.total < 10 || n * 10 > this.total) {
            choose(n - 1);
            return;
          }
          timer = setTimeout(async () => {
            choose(n - 1);
          }, 200);
          firstNumber = n;
        });
        if (this.config.shortcuts) {
          this.addShortcuts(choose);
        }
      }
      addShortcuts(choose) {
        let { items } = this.config;
        let texts = items.map((o) => {
          return isMenuItem(o) ? o.text : o;
        });
        texts.forEach((text, idx) => {
          if (text.length) {
            let s = text[0];
            if (isAlphabet(s.charCodeAt(0)) && !this.keyMappings.has(s)) {
              this.shortcutIndexes.add(idx);
              this.addKeys(s, () => {
                choose(idx);
              });
            }
          }
        });
      }
      isDisabled(idx) {
        let { items } = this.config;
        let item = items[idx];
        if (isMenuItem(item) && item.disabled) {
          return true;
        }
        return false;
      }
      async show(preferences = {}) {
        let { nvim, shortcutIndexes } = this;
        let { title, items, borderhighlight, position, content } = this.config;
        let opts = {};
        if (title)
          opts.title = title;
        if (position === "center")
          opts.relative = "editor";
        if (preferences.maxHeight)
          opts.maxHeight = preferences.maxHeight;
        if (preferences.maxWidth)
          opts.maxWidth = preferences.maxWidth;
        if (preferences.floatHighlight)
          opts.highlight = preferences.floatHighlight;
        if (borderhighlight) {
          opts.borderhighlight = borderhighlight;
        } else if (preferences.floatBorderHighlight) {
          opts.borderhighlight = preferences.floatBorderHighlight;
        }
        if (preferences.rounded)
          opts.rounded = 1;
        if (typeof content === "string")
          opts.content = content;
        let highlights = [];
        let lines = items.map((v, i) => {
          let text = isMenuItem(v) ? v.text : v;
          let pre = i < 99 ? `${i + 1}. ` : "";
          if (shortcutIndexes.has(i)) {
            highlights.push({
              lnum: i,
              hlGroup: preferences.shortcutHighlight || "MoreMsg",
              colStart: byteLength(pre),
              colEnd: byteLength(pre) + 1
            });
          }
          return pre + text.trim();
        });
        lines.forEach((line, i) => {
          let item = items[i];
          if (isMenuItem(item) && item.disabled) {
            highlights.push({
              hlGroup: "CocDisabled",
              lnum: i,
              colStart: 0,
              colEnd: byteLength(line)
            });
          }
        });
        if (highlights.length)
          opts.highlights = highlights;
        if (preferences.confirmKey && preferences.confirmKey != "<cr>") {
          this.addKeys(preferences.confirmKey, () => {
            this.selectCurrent();
          });
        }
        let res = await nvim.call("coc#dialog#create_menu", [lines, opts]);
        if (!res)
          throw new Error("Unable to create menu window");
        nvim.command("redraw", true);
        if (this._disposed)
          return;
        this.win = new Popup(nvim, res[0], res[1], lines.length + res[2], res[2]);
        this.bufnr = res[1];
        this.contentHeight = res[2];
        this.attachEvents();
        nvim.call("coc#prompt#start_prompt", ["menu"], true);
      }
      selectCurrent() {
        if (this.isDisabled(this.currIndex)) {
          let item = this.config.items[this.currIndex];
          if (item.disabled["reason"]) {
            this.nvim.outWriteLine(`Item disabled: ${item.disabled["reason"]}`);
          }
          return;
        }
        this._onDidClose.fire(this.currIndex);
        this.dispose();
      }
      get buffer() {
        return this.bufnr ? this.nvim.createBuffer(this.bufnr) : void 0;
      }
      dispose() {
        var _a;
        this._disposed = true;
        disposeAll(this.disposables);
        this.shortcutIndexes.clear();
        this.keyMappings.clear();
        this.nvim.call("coc#prompt#stop_prompt", ["menu"], true);
        (_a = this.win) == null ? void 0 : _a.close();
        this.bufnr = void 0;
        this.win = void 0;
      }
      async onInputChar(session, character) {
        if (session != "menu" || !this.win)
          return;
        let fn = this.keyMappings.get(character);
        if (fn) {
          await Promise.resolve(fn(character));
        } else {
          logger13.warn(`Ignored key press: ${character}`);
        }
      }
      setCursor(index) {
        if (!this.win)
          return;
        this.currIndex = index - this.contentHeight;
        this.win.setCursor(index);
      }
      addKeys(keys, fn) {
        if (Array.isArray(keys)) {
          for (let key of keys) {
            this.keyMappings.set(key, fn);
          }
        } else {
          this.keyMappings.set(keys, fn);
        }
      }
    };
  }
});

// src/model/notification.ts
var logger14, Notification;
var init_notification = __esm({
  "src/model/notification.ts"() {
    "use strict";
    init_events();
    init_util();
    logger14 = require_logger2()("model-notification");
    Notification = class {
      constructor(nvim, config, attachEvents = true) {
        this.nvim = nvim;
        this.config = config;
        this.disposables = [];
        this._disposed = false;
        if (attachEvents) {
          events_default.on("BufWinLeave", (bufnr) => {
            if (bufnr == this.bufnr) {
              this.dispose();
              if (config.callback)
                config.callback(-1);
            }
          }, null, this.disposables);
          events_default.on("FloatBtnClick", (bufnr, idx) => {
            if (bufnr == this.bufnr) {
              this.dispose();
              let btns = config == null ? void 0 : config.buttons.filter((o) => o.disabled != true);
              if (config.callback)
                config.callback(btns[idx].index);
            }
          }, null, this.disposables);
        }
      }
      get lines() {
        return this.config.content ? this.config.content.split(/\r?\n/) : [];
      }
      async show(preferences) {
        let { nvim } = this;
        let { buttons, kind, title } = this.config;
        let opts = Object.assign({}, preferences);
        opts.kind = kind ?? "";
        if (title)
          opts.title = title;
        if (preferences.broder) {
          opts.borderhighlight = kind ? `CocNotification${kind[0].toUpperCase()}${kind.slice(1)}` : preferences.highlight;
        }
        if (Array.isArray(buttons)) {
          let actions = buttons.filter((o) => !o.disabled).map((o) => o.text);
          if (actions.length)
            opts.actions = actions;
        }
        let res = await nvim.call("coc#notify#create", [this.lines, opts]);
        if (!res)
          throw new Error(`Unable to create notification window`);
        this._winid = res[0];
        this.bufnr = res[1];
      }
      get winid() {
        return this._winid;
      }
      dispose() {
        if (this._disposed)
          return;
        this._disposed = true;
        let { winid } = this;
        if (winid) {
          this.nvim.call("coc#notify#close", [winid], true);
          this.nvim.redrawVim();
        }
        this.bufnr = void 0;
        this._winid = void 0;
        disposeAll(this.disposables);
      }
    };
  }
});

// src/model/picker.ts
var import_vscode_languageserver_protocol10, logger15, isVim4, Picker;
var init_picker = __esm({
  "src/model/picker.ts"() {
    "use strict";
    import_vscode_languageserver_protocol10 = __toESM(require_main2());
    init_events();
    init_util();
    init_string();
    init_popup();
    logger15 = require_logger2()("model-dialog");
    isVim4 = process.env.VIM_NODE_RPC == "1";
    Picker = class {
      constructor(nvim, config, token) {
        this.nvim = nvim;
        this.config = config;
        this.picked = /* @__PURE__ */ new Set();
        this.disposables = [];
        this.keyMappings = /* @__PURE__ */ new Map();
        this._onDidClose = new import_vscode_languageserver_protocol10.Emitter();
        this.onDidClose = this._onDidClose.event;
        for (let i = 0; i < config.items.length; i++) {
          let item = config.items[i];
          if (item.picked)
            this.picked.add(i);
        }
        this.total = config.items.length;
        if (token) {
          token.onCancellationRequested(() => {
            var _a;
            (_a = this.win) == null ? void 0 : _a.close();
          });
        }
        this.disposables.push(this._onDidClose);
        this.addKeymappings();
      }
      get currIndex() {
        return this.win ? this.win.currIndex : 0;
      }
      attachEvents() {
        events_default.on("InputChar", this.onInputChar.bind(this), null, this.disposables);
        events_default.on("BufWinLeave", (bufnr) => {
          if (bufnr == this.bufnr) {
            this._onDidClose.fire(void 0);
            this.bufnr = void 0;
            this.win = void 0;
            this.dispose();
          }
        }, null, this.disposables);
        events_default.on("FloatBtnClick", (bufnr, idx) => {
          if (bufnr == this.bufnr) {
            if (idx == 0) {
              let selected = Array.from(this.picked);
              this._onDidClose.fire(selected.length ? selected : void 0);
            } else {
              this._onDidClose.fire(void 0);
            }
            this.dispose();
          }
        }, null, this.disposables);
      }
      addKeymappings() {
        let { nvim } = this;
        const toggleSelect = (idx) => {
          if (this.picked.has(idx)) {
            this.picked.delete(idx);
          } else {
            this.picked.add(idx);
          }
        };
        this.addKeys("<LeftRelease>", async () => {
          if (isVim4 || !this.win)
            return;
          let [winid, lnum, col] = await nvim.eval("[v:mouse_winid,v:mouse_lnum,v:mouse_col]");
          if (global.hasOwnProperty("__TEST__")) {
            let res = await nvim.getVar("mouse_position");
            winid = res[0];
            lnum = res[1];
            col = res[2];
          }
          nvim.pauseNotification();
          if (winid == this.win.winid) {
            if (col <= 3) {
              toggleSelect(lnum - 1);
              this.changeLine(lnum - 1);
            } else {
              this.setCursor(lnum - 1);
            }
          }
          nvim.call("win_gotoid", [winid], true);
          nvim.call("cursor", [lnum, col], true);
          nvim.call("coc#float#nvim_float_click", [], true);
          nvim.command("redraw", true);
          await nvim.resumeNotification();
        });
        this.addKeys(["<esc>", "<C-c>"], () => {
          this._onDidClose.fire(void 0);
          this.dispose();
        });
        this.addKeys("<cr>", () => {
          if (this.picked.size == 0) {
            this._onDidClose.fire(void 0);
          } else {
            let selected = Array.from(this.picked);
            this._onDidClose.fire(selected);
          }
          this.dispose();
        });
        this.addKeys(["j", "<down>", "<tab>", "<C-n>"], () => {
          this.win.setCursor(this.currIndex + 1, true);
        });
        this.addKeys(["k", "<up>", "<s-tab>", "<C-p>"], () => {
          this.win.setCursor(this.currIndex - 1, true);
        });
        this.addKeys(["g"], () => {
          this.win.setCursor(0, true);
        });
        this.addKeys(["G"], () => {
          this.win.setCursor(this.total - 1, true);
        });
        this.addKeys(" ", async () => {
          let idx = this.currIndex;
          toggleSelect(idx);
          nvim.pauseNotification();
          this.changeLine(idx);
          this.setCursor(this.currIndex + 1);
          nvim.command("redraw", true);
          await nvim.resumeNotification();
        });
        this.addKeys("<C-f>", async () => {
          var _a;
          await ((_a = this.win) == null ? void 0 : _a.scrollForward());
        });
        this.addKeys("<C-b>", async () => {
          var _a;
          await ((_a = this.win) == null ? void 0 : _a.scrollBackward());
        });
      }
      async show(preferences = {}) {
        let { nvim } = this;
        let { title, items } = this.config;
        let opts = { close: 1, cursorline: 1 };
        if (preferences.maxHeight)
          opts.maxHeight = preferences.maxHeight;
        if (preferences.maxWidth)
          opts.maxWidth = preferences.maxWidth;
        if (title)
          opts.title = title;
        if (preferences.floatHighlight)
          opts.highlight = preferences.floatHighlight;
        if (preferences.floatBorderHighlight)
          opts.borderhighlight = [preferences.floatBorderHighlight];
        if (preferences.pickerButtons) {
          let shortcut = preferences.pickerButtonShortcut;
          opts.buttons = ["Submit" + (shortcut ? " <cr>" : ""), "Cancel" + (shortcut ? " <esc>" : "")];
        }
        if (preferences.rounded)
          opts.rounded = 1;
        if (preferences.confirmKey && preferences.confirmKey != "<cr>") {
          this.addKeys(preferences.confirmKey, () => {
            this._onDidClose.fire(void 0);
            this.dispose();
          });
        }
        let lines = [];
        let highlights = [];
        for (let i = 0; i < items.length; i++) {
          let item = items[i];
          let line = `[${item.picked ? "x" : " "}] ${item.label}`;
          if (item.description) {
            let start = byteLength(line);
            line = line + ` ${item.description}`;
            highlights.push({ hlGroup: "Comment", lnum: i, colStart: start, colEnd: byteLength(line) });
          }
          lines.push(line);
        }
        if (highlights.length)
          opts.highlights = highlights;
        let res = await nvim.call("coc#dialog#create_dialog", [lines, opts]);
        this.win = new Popup(nvim, res[0], res[1], lines.length);
        this.bufnr = res[1];
        nvim.call("coc#prompt#start_prompt", ["picker"], true);
        this.attachEvents();
        this.win.setCursor(0, true);
        return res[0];
      }
      get buffer() {
        return this.bufnr ? this.nvim.createBuffer(this.bufnr) : void 0;
      }
      dispose() {
        var _a;
        this.picked.clear();
        this.keyMappings.clear();
        disposeAll(this.disposables);
        this.nvim.call("coc#prompt#stop_prompt", ["picker"], true);
        (_a = this.win) == null ? void 0 : _a.close();
        this.win = void 0;
      }
      async onInputChar(session, character) {
        if (session != "picker" || !this.win)
          return;
        let fn = this.keyMappings.get(character);
        if (fn) {
          await Promise.resolve(fn(character));
        } else {
          logger15.warn(`Ignored key press: ${character}`);
        }
      }
      changeLine(index) {
        let { nvim } = this;
        let item = this.config.items[index];
        if (!item)
          return;
        let line = `[${this.picked.has(index) ? "x" : " "}] ${item.label}`;
        let col = byteLength(line);
        if (item.description)
          line = line + ` ${item.description}`;
        nvim.call("setbufline", [this.bufnr, index + 1, line], true);
        let buf = nvim.createBuffer(this.bufnr);
        buf.addHighlight({ hlGroup: "Comment", line: index, srcId: 1, colStart: col, colEnd: -1 });
      }
      setCursor(index) {
        if (!this.win)
          return;
        this.win.setCursor(index);
      }
      addKeys(keys, fn) {
        if (Array.isArray(keys)) {
          for (let key of keys) {
            this.keyMappings.set(key, fn);
          }
        } else {
          this.keyMappings.set(keys, fn);
        }
      }
    };
  }
});

// src/model/progress.ts
var import_vscode_languageserver_protocol11, logger16, ProgressNotification;
var init_progress = __esm({
  "src/model/progress.ts"() {
    "use strict";
    init_notification();
    import_vscode_languageserver_protocol11 = __toESM(require_main2());
    init_events();
    logger16 = require_logger2()("model-progress");
    ProgressNotification = class extends Notification {
      constructor(nvim, option) {
        super(nvim, {
          kind: "progress",
          title: option.title,
          buttons: option.cancellable ? [{ index: 1, text: "Cancel" }] : void 0
        }, false);
        this.option = option;
        this._onDidFinish = new import_vscode_languageserver_protocol11.Emitter();
        this.onDidFinish = this._onDidFinish.event;
        this.disposables.push(this._onDidFinish);
        events_default.on("BufWinLeave", (bufnr) => {
          if (bufnr == this.bufnr) {
            if (this.tokenSource)
              this.tokenSource.cancel();
            this._onDidFinish.fire(void 0);
            this._winid = void 0;
            this.dispose();
          }
        }, null, this.disposables);
      }
      async show(preferences) {
        let { task } = this.option;
        let tokenSource = this.tokenSource = new import_vscode_languageserver_protocol11.CancellationTokenSource();
        this.disposables.push(tokenSource);
        let total = 0;
        if (this.config.buttons || !preferences.disabled) {
          await super.show(preferences);
        } else {
          logger16.warn(`progress window disabled by "notification.disabledProgressSources"`);
        }
        task({
          report: (p) => {
            if (!this.winid)
              return;
            let { nvim } = this;
            if (p.increment) {
              total += p.increment;
              nvim.call("coc#window#set_var", [this.winid, "percent", `${total}%`], true);
            }
            if (p.message)
              nvim.call("coc#window#set_var", [this.winid, "message", p.message.replace(/\r?\n/g, " ")], true);
          }
        }, tokenSource.token).then((res) => {
          if (this._disposed)
            return;
          this._onDidFinish.fire(res);
          this.dispose();
        }, (err) => {
          if (this._disposed)
            return;
          if (err)
            this.nvim.echoError(err);
          this._onDidFinish.fire(void 0);
          this.dispose();
        });
      }
    };
  }
});

// node_modules/eastasianwidth/eastasianwidth.js
var require_eastasianwidth = __commonJS({
  "node_modules/eastasianwidth/eastasianwidth.js"(exports, module2) {
    var eaw = {};
    if (typeof module2 == "undefined") {
      window.eastasianwidth = eaw;
    } else {
      module2.exports = eaw;
    }
    eaw.eastAsianWidth = function(character) {
      var x = character.charCodeAt(0);
      var y = character.length == 2 ? character.charCodeAt(1) : 0;
      var codePoint = x;
      if (55296 <= x && x <= 56319 && (56320 <= y && y <= 57343)) {
        x &= 1023;
        y &= 1023;
        codePoint = x << 10 | y;
        codePoint += 65536;
      }
      if (codePoint == 12288 || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510) {
        return "F";
      }
      if (codePoint == 8361 || 65377 <= codePoint && codePoint <= 65470 || 65474 <= codePoint && codePoint <= 65479 || 65482 <= codePoint && codePoint <= 65487 || 65490 <= codePoint && codePoint <= 65495 || 65498 <= codePoint && codePoint <= 65500 || 65512 <= codePoint && codePoint <= 65518) {
        return "H";
      }
      if (4352 <= codePoint && codePoint <= 4447 || 4515 <= codePoint && codePoint <= 4519 || 4602 <= codePoint && codePoint <= 4607 || 9001 <= codePoint && codePoint <= 9002 || 11904 <= codePoint && codePoint <= 11929 || 11931 <= codePoint && codePoint <= 12019 || 12032 <= codePoint && codePoint <= 12245 || 12272 <= codePoint && codePoint <= 12283 || 12289 <= codePoint && codePoint <= 12350 || 12353 <= codePoint && codePoint <= 12438 || 12441 <= codePoint && codePoint <= 12543 || 12549 <= codePoint && codePoint <= 12589 || 12593 <= codePoint && codePoint <= 12686 || 12688 <= codePoint && codePoint <= 12730 || 12736 <= codePoint && codePoint <= 12771 || 12784 <= codePoint && codePoint <= 12830 || 12832 <= codePoint && codePoint <= 12871 || 12880 <= codePoint && codePoint <= 13054 || 13056 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42124 || 42128 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 55216 <= codePoint && codePoint <= 55238 || 55243 <= codePoint && codePoint <= 55291 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65106 || 65108 <= codePoint && codePoint <= 65126 || 65128 <= codePoint && codePoint <= 65131 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127490 || 127504 <= codePoint && codePoint <= 127546 || 127552 <= codePoint && codePoint <= 127560 || 127568 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 194367 || 177984 <= codePoint && codePoint <= 196605 || 196608 <= codePoint && codePoint <= 262141) {
        return "W";
      }
      if (32 <= codePoint && codePoint <= 126 || 162 <= codePoint && codePoint <= 163 || 165 <= codePoint && codePoint <= 166 || codePoint == 172 || codePoint == 175 || 10214 <= codePoint && codePoint <= 10221 || 10629 <= codePoint && codePoint <= 10630) {
        return "Na";
      }
      if (codePoint == 161 || codePoint == 164 || 167 <= codePoint && codePoint <= 168 || codePoint == 170 || 173 <= codePoint && codePoint <= 174 || 176 <= codePoint && codePoint <= 180 || 182 <= codePoint && codePoint <= 186 || 188 <= codePoint && codePoint <= 191 || codePoint == 198 || codePoint == 208 || 215 <= codePoint && codePoint <= 216 || 222 <= codePoint && codePoint <= 225 || codePoint == 230 || 232 <= codePoint && codePoint <= 234 || 236 <= codePoint && codePoint <= 237 || codePoint == 240 || 242 <= codePoint && codePoint <= 243 || 247 <= codePoint && codePoint <= 250 || codePoint == 252 || codePoint == 254 || codePoint == 257 || codePoint == 273 || codePoint == 275 || codePoint == 283 || 294 <= codePoint && codePoint <= 295 || codePoint == 299 || 305 <= codePoint && codePoint <= 307 || codePoint == 312 || 319 <= codePoint && codePoint <= 322 || codePoint == 324 || 328 <= codePoint && codePoint <= 331 || codePoint == 333 || 338 <= codePoint && codePoint <= 339 || 358 <= codePoint && codePoint <= 359 || codePoint == 363 || codePoint == 462 || codePoint == 464 || codePoint == 466 || codePoint == 468 || codePoint == 470 || codePoint == 472 || codePoint == 474 || codePoint == 476 || codePoint == 593 || codePoint == 609 || codePoint == 708 || codePoint == 711 || 713 <= codePoint && codePoint <= 715 || codePoint == 717 || codePoint == 720 || 728 <= codePoint && codePoint <= 731 || codePoint == 733 || codePoint == 735 || 768 <= codePoint && codePoint <= 879 || 913 <= codePoint && codePoint <= 929 || 931 <= codePoint && codePoint <= 937 || 945 <= codePoint && codePoint <= 961 || 963 <= codePoint && codePoint <= 969 || codePoint == 1025 || 1040 <= codePoint && codePoint <= 1103 || codePoint == 1105 || codePoint == 8208 || 8211 <= codePoint && codePoint <= 8214 || 8216 <= codePoint && codePoint <= 8217 || 8220 <= codePoint && codePoint <= 8221 || 8224 <= codePoint && codePoint <= 8226 || 8228 <= codePoint && codePoint <= 8231 || codePoint == 8240 || 8242 <= codePoint && codePoint <= 8243 || codePoint == 8245 || codePoint == 8251 || codePoint == 8254 || codePoint == 8308 || codePoint == 8319 || 8321 <= codePoint && codePoint <= 8324 || codePoint == 8364 || codePoint == 8451 || codePoint == 8453 || codePoint == 8457 || codePoint == 8467 || codePoint == 8470 || 8481 <= codePoint && codePoint <= 8482 || codePoint == 8486 || codePoint == 8491 || 8531 <= codePoint && codePoint <= 8532 || 8539 <= codePoint && codePoint <= 8542 || 8544 <= codePoint && codePoint <= 8555 || 8560 <= codePoint && codePoint <= 8569 || codePoint == 8585 || 8592 <= codePoint && codePoint <= 8601 || 8632 <= codePoint && codePoint <= 8633 || codePoint == 8658 || codePoint == 8660 || codePoint == 8679 || codePoint == 8704 || 8706 <= codePoint && codePoint <= 8707 || 8711 <= codePoint && codePoint <= 8712 || codePoint == 8715 || codePoint == 8719 || codePoint == 8721 || codePoint == 8725 || codePoint == 8730 || 8733 <= codePoint && codePoint <= 8736 || codePoint == 8739 || codePoint == 8741 || 8743 <= codePoint && codePoint <= 8748 || codePoint == 8750 || 8756 <= codePoint && codePoint <= 8759 || 8764 <= codePoint && codePoint <= 8765 || codePoint == 8776 || codePoint == 8780 || codePoint == 8786 || 8800 <= codePoint && codePoint <= 8801 || 8804 <= codePoint && codePoint <= 8807 || 8810 <= codePoint && codePoint <= 8811 || 8814 <= codePoint && codePoint <= 8815 || 8834 <= codePoint && codePoint <= 8835 || 8838 <= codePoint && codePoint <= 8839 || codePoint == 8853 || codePoint == 8857 || codePoint == 8869 || codePoint == 8895 || codePoint == 8978 || 9312 <= codePoint && codePoint <= 9449 || 9451 <= codePoint && codePoint <= 9547 || 9552 <= codePoint && codePoint <= 9587 || 9600 <= codePoint && codePoint <= 9615 || 9618 <= codePoint && codePoint <= 9621 || 9632 <= codePoint && codePoint <= 9633 || 9635 <= codePoint && codePoint <= 9641 || 9650 <= codePoint && codePoint <= 9651 || 9654 <= codePoint && codePoint <= 9655 || 9660 <= codePoint && codePoint <= 9661 || 9664 <= codePoint && codePoint <= 9665 || 9670 <= codePoint && codePoint <= 9672 || codePoint == 9675 || 9678 <= codePoint && codePoint <= 9681 || 9698 <= codePoint && codePoint <= 9701 || codePoint == 9711 || 9733 <= codePoint && codePoint <= 9734 || codePoint == 9737 || 9742 <= codePoint && codePoint <= 9743 || 9748 <= codePoint && codePoint <= 9749 || codePoint == 9756 || codePoint == 9758 || codePoint == 9792 || codePoint == 9794 || 9824 <= codePoint && codePoint <= 9825 || 9827 <= codePoint && codePoint <= 9829 || 9831 <= codePoint && codePoint <= 9834 || 9836 <= codePoint && codePoint <= 9837 || codePoint == 9839 || 9886 <= codePoint && codePoint <= 9887 || 9918 <= codePoint && codePoint <= 9919 || 9924 <= codePoint && codePoint <= 9933 || 9935 <= codePoint && codePoint <= 9953 || codePoint == 9955 || 9960 <= codePoint && codePoint <= 9983 || codePoint == 10045 || codePoint == 10071 || 10102 <= codePoint && codePoint <= 10111 || 11093 <= codePoint && codePoint <= 11097 || 12872 <= codePoint && codePoint <= 12879 || 57344 <= codePoint && codePoint <= 63743 || 65024 <= codePoint && codePoint <= 65039 || codePoint == 65533 || 127232 <= codePoint && codePoint <= 127242 || 127248 <= codePoint && codePoint <= 127277 || 127280 <= codePoint && codePoint <= 127337 || 127344 <= codePoint && codePoint <= 127386 || 917760 <= codePoint && codePoint <= 917999 || 983040 <= codePoint && codePoint <= 1048573 || 1048576 <= codePoint && codePoint <= 1114109) {
        return "A";
      }
      return "N";
    };
    eaw.characterLength = function(character) {
      var code = this.eastAsianWidth(character);
      if (code == "F" || code == "W" || code == "A") {
        return 2;
      } else {
        return 1;
      }
    };
    function stringToArray(string2) {
      return string2.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]|[^\uD800-\uDFFF]/g) || [];
    }
    eaw.length = function(string2) {
      var characters = stringToArray(string2);
      var len = 0;
      for (var i = 0; i < characters.length; i++) {
        len = len + this.characterLength(characters[i]);
      }
      return len;
    };
    eaw.slice = function(text, start, end) {
      textLen = eaw.length(text);
      start = start ? start : 0;
      end = end ? end : 1;
      if (start < 0) {
        start = textLen + start;
      }
      if (end < 0) {
        end = textLen + end;
      }
      var result = "";
      var eawLen = 0;
      var chars = stringToArray(text);
      for (var i = 0; i < chars.length; i++) {
        var char = chars[i];
        var charLen = eaw.length(char);
        if (eawLen >= start - (charLen == 2 ? 1 : 0)) {
          if (eawLen + charLen <= end) {
            result += char;
          } else {
            break;
          }
        }
        eawLen += charLen;
      }
      return result;
    };
  }
});

// node_modules/emoji-regex/index.js
var require_emoji_regex = __commonJS({
  "node_modules/emoji-regex/index.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
      return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
    };
  }
});

// node_modules/@chemzqm/string-width/index.js
var require_string_width = __commonJS({
  "node_modules/@chemzqm/string-width/index.js"(exports, module2) {
    var stripAnsi4 = require_strip_ansi();
    var eastAsianWidth = require_eastasianwidth();
    var emojiRegex = require_emoji_regex();
    module2.exports = function stringWidth3(string2, options2 = {}) {
      if (typeof string2 !== "string" || string2.length === 0) {
        return 0;
      }
      options2 = __spreadValues({
        ambiguousIsNarrow: true
      }, options2);
      string2 = stripAnsi4(string2);
      if (string2.length === 0) {
        return 0;
      }
      string2 = string2.replace(emojiRegex(), "  ");
      const ambiguousCharacterWidth = options2.ambiguousIsNarrow ? 1 : 2;
      let width = 0;
      for (const character of string2) {
        const codePoint = character.codePointAt(0);
        if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) {
          continue;
        }
        if (codePoint >= 768 && codePoint <= 879) {
          continue;
        }
        const code = eastAsianWidth.eastAsianWidth(character);
        switch (code) {
          case "F":
          case "W":
            width += 2;
            break;
          case "A":
            width += ambiguousCharacterWidth;
            break;
          default:
            width += 1;
        }
      }
      return width;
    };
  }
});

// src/util/fzy.ts
function islower(s) {
  return s.toLowerCase() === s;
}
function isupper(s) {
  return s.toUpperCase() === s;
}
function precompute_bonus(haystack) {
  let m = haystack.length;
  let match_bonus = new Array(m);
  let last_ch = "/";
  for (let i = 0; i < m; i++) {
    let ch = haystack[i];
    if (last_ch === "/") {
      match_bonus[i] = SCORE_MATCH_SLASH;
    } else if (last_ch === "-" || last_ch === "_" || last_ch === " ") {
      match_bonus[i] = SCORE_MATCH_WORD;
    } else if (last_ch === ".") {
      match_bonus[i] = SCORE_MATCH_DOT;
    } else if (islower(last_ch) && isupper(ch)) {
      match_bonus[i] = SCORE_MATCH_CAPITAL;
    } else {
      match_bonus[i] = 0;
    }
    last_ch = ch;
  }
  return match_bonus;
}
function compute(needle, haystack, D, M) {
  let n = needle.length;
  let m = haystack.length;
  let lower_needle = needle.toLowerCase();
  let lower_haystack = haystack.toLowerCase();
  let match_bonus = precompute_bonus(haystack);
  for (let i = 0; i < n; i++) {
    D[i] = new Array(m);
    M[i] = new Array(m);
    let prev_score = SCORE_MIN;
    let gap_score = i === n - 1 ? SCORE_GAP_TRAILING : SCORE_GAP_INNER;
    for (let j = 0; j < m; j++) {
      if (lower_needle[i] === lower_haystack[j]) {
        let score5 = SCORE_MIN;
        if (!i) {
          score5 = j * SCORE_GAP_LEADING + match_bonus[j];
        } else if (j) {
          score5 = Math.max(M[i - 1][j - 1] + match_bonus[j], D[i - 1][j - 1] + SCORE_MATCH_CONSECUTIVE);
        }
        D[i][j] = score5;
        M[i][j] = prev_score = Math.max(score5, prev_score + gap_score);
      } else {
        D[i][j] = SCORE_MIN;
        M[i][j] = prev_score = prev_score + gap_score;
      }
    }
  }
}
function score(needle, haystack) {
  let n = needle.length;
  let m = haystack.length;
  if (!n || !m)
    return SCORE_MIN;
  if (n === m) {
    return SCORE_MAX;
  }
  if (m > 1024) {
    return SCORE_MIN;
  }
  let D = new Array(n);
  let M = new Array(n);
  compute(needle, haystack, D, M);
  return M[n - 1][m - 1];
}
function groupPositions(arr) {
  let res = [];
  for (let i = 0; i < arr.length; i++) {
    let last = res.length ? res[res.length - 1] : void 0;
    let curr = arr[i];
    if (last && curr == last[1]) {
      last[1] = curr + 1;
    } else {
      res.push([curr, curr + 1]);
    }
  }
  return res;
}
function positions(needle, haystack) {
  let n = needle.length;
  let m = haystack.length;
  let positions2 = new Array(n);
  if (!n || !m)
    return positions2;
  if (n === m) {
    for (let i = 0; i < n; i++)
      positions2[i] = i;
    return positions2;
  }
  if (m > 1024) {
    return positions2;
  }
  let D = new Array(n);
  let M = new Array(n);
  compute(needle, haystack, D, M);
  let match_required = false;
  for (let i = n - 1, j = m - 1; i >= 0; i--) {
    for (; j >= 0; j--) {
      if (D[i][j] !== SCORE_MIN && (match_required || D[i][j] === M[i][j])) {
        match_required = i && j && M[i][j] === D[i - 1][j - 1] + SCORE_MATCH_CONSECUTIVE;
        positions2[i] = j--;
        break;
      }
    }
  }
  return positions2;
}
function hasMatch(needle, haystack) {
  needle = needle.toLowerCase();
  haystack = haystack.toLowerCase();
  let l = needle.length;
  for (let i = 0, j = 0; i < l; i += 1) {
    j = haystack.indexOf(needle[i], j) + 1;
    if (j === 0)
      return false;
  }
  return true;
}
var SCORE_MIN, SCORE_MAX, SCORE_GAP_LEADING, SCORE_GAP_TRAILING, SCORE_GAP_INNER, SCORE_MATCH_CONSECUTIVE, SCORE_MATCH_SLASH, SCORE_MATCH_WORD, SCORE_MATCH_CAPITAL, SCORE_MATCH_DOT;
var init_fzy = __esm({
  "src/util/fzy.ts"() {
    "use strict";
    SCORE_MIN = -Infinity;
    SCORE_MAX = Infinity;
    SCORE_GAP_LEADING = -5e-3;
    SCORE_GAP_TRAILING = -5e-3;
    SCORE_GAP_INNER = -0.01;
    SCORE_MATCH_CONSECUTIVE = 1;
    SCORE_MATCH_SLASH = 0.9;
    SCORE_MATCH_WORD = 0.8;
    SCORE_MATCH_CAPITAL = 0.7;
    SCORE_MATCH_DOT = 0.6;
  }
});

// src/model/quickpick.ts
var import_string_width, import_vscode_languageserver_protocol12, logger17, QuickPick;
var init_quickpick = __esm({
  "src/model/quickpick.ts"() {
    "use strict";
    import_string_width = __toESM(require_string_width());
    import_vscode_languageserver_protocol12 = __toESM(require_main2());
    init_events();
    init_util();
    init_fzy();
    init_string();
    init_input();
    init_popup();
    logger17 = require_logger2()("model-quickpick");
    QuickPick = class {
      constructor(nvim, config) {
        this.nvim = nvim;
        this.config = config;
        this.disposables = [];
        this._changed = false;
        this._onDidFinish = new import_vscode_languageserver_protocol12.Emitter();
        this._onDidChangeSelection = new import_vscode_languageserver_protocol12.Emitter();
        this._onDidChangeValue = new import_vscode_languageserver_protocol12.Emitter();
        this.onDidFinish = this._onDidFinish.event;
        this.onDidChangeSelection = this._onDidChangeSelection.event;
        this.onDidChangeValue = this._onDidChangeValue.event;
        let items = config.items ?? [];
        Object.defineProperty(this, "items", {
          set: (list2) => {
            this._changed = true;
            items = list2;
            this.filterItems("");
          },
          get: () => {
            return items;
          }
        });
        Object.defineProperty(this, "activeItems", {
          set: (list2) => {
            this._changed = true;
            this.filteredItems = list2;
            this.showFilteredItems();
          },
          get: () => {
            return this.filteredItems;
          }
        });
        Object.defineProperty(this, "title", {
          set: (newTitle) => {
            if (this.input)
              this.input.title = newTitle;
          },
          get: () => {
            return this.input ? this.input.title : config.title;
          }
        });
        Object.defineProperty(this, "loading", {
          set: (loading) => {
            if (this.input)
              this.input.loading = loading;
          },
          get: () => {
            return this.input ? this.input.loading : false;
          }
        });
      }
      get value() {
        return this.input ? this.input.value : this.config.value ?? "";
      }
      get currIndex() {
        return this.win ? this.win.currIndex : 0;
      }
      get buffer() {
        return this.bufnr ? this.nvim.createBuffer(this.bufnr) : void 0;
      }
      setCursor(index) {
        var _a;
        (_a = this.win) == null ? void 0 : _a.setCursor(index, true);
      }
      attachEvents(inputBufnr) {
        events_default.on("BufWinLeave", (bufnr) => {
          if (bufnr == this.bufnr) {
            this.dispose();
          }
        }, null, this.disposables);
        events_default.on("PromptKeyPress", async (bufnr, key) => {
          var _a, _b;
          if (bufnr == inputBufnr) {
            if (key == "C-f") {
              await ((_a = this.win) == null ? void 0 : _a.scrollForward());
            } else if (key == "C-b") {
              await ((_b = this.win) == null ? void 0 : _b.scrollBackward());
            } else if (["C-j", "C-n", "down"].includes(key)) {
              this.setCursor(this.currIndex + 1);
            } else if (["C-k", "C-p", "up"].includes(key)) {
              this.setCursor(this.currIndex - 1);
            } else if (this.config.canSelectMany && key == "C-@") {
              this.toggePicked(this.currIndex);
            }
          }
        }, null, this.disposables);
      }
      async show(preferences = {}) {
        let { nvim, items } = this;
        let { title, canSelectMany, value } = this.config;
        let lines = [];
        let highlights = [];
        let selectedItems = [];
        for (let i = 0; i < items.length; i++) {
          let item = items[i];
          let line = canSelectMany ? `[${item.picked ? "x" : " "}] ${item.label}` : item.label;
          if (item.picked)
            selectedItems.push(item);
          if (item.description) {
            let start = byteLength(line);
            line = line + ` ${item.description}`;
            highlights.push({ hlGroup: "Comment", lnum: i, colStart: start, colEnd: byteLength(line) });
          }
          lines.push(line);
        }
        let input = this.input = new InputBox(this.nvim, value ?? "");
        input.onDidChange((value2) => {
          this._onDidChangeValue.fire(value2);
          if (this._changed) {
            this._changed = false;
            return;
          }
          this.filterItems(value2);
        }, this);
        input.onDidFinish(this.onFinish, this);
        let minWidth = Math.max(40, Math.min(80, lines.reduce((p, c) => Math.max(p, (0, import_string_width.default)(c)), 0)));
        await input.show(title ?? "", {
          position: "center",
          marginTop: 10,
          border: [1, 1, 0, 1],
          list: true,
          minWidth,
          maxWidth: preferences.maxWidth || 80,
          rounded: !!preferences.rounded,
          highlight: preferences.floatHighlight,
          borderhighlight: preferences.floatBorderHighlight
        });
        this.selectedItems = selectedItems;
        let opts = { lines, rounded: !!preferences.rounded };
        opts.highlights = highlights;
        if (preferences.floatHighlight)
          opts.highlight = preferences.floatHighlight;
        if (preferences.floatBorderHighlight)
          opts.borderhighlight = preferences.floatBorderHighlight;
        let maxHeight = this.config.maxHeight || preferences.maxHeight;
        if (maxHeight)
          opts.maxHeight = maxHeight;
        let res = await nvim.call("coc#dialog#create_list", [input.winid, input.dimension, opts]);
        if (!res)
          throw new Error("Unable to open list window.");
        this.filteredItems = items;
        this.win = new Popup(nvim, res[0], res[1], lines.length);
        this.win.refreshScrollbar();
        this.bufnr = res[1];
        let idx = canSelectMany || selectedItems.length == 0 ? 0 : items.indexOf(selectedItems[0]);
        this.setCursor(idx);
        this.attachEvents(input.bufnr);
      }
      filterItems(input) {
        let { items, win, selectedItems } = this;
        if (!win)
          return;
        let { canSelectMany } = this.config;
        let lines = [];
        let highlights = [];
        let idx = 0;
        let filteredItems = [];
        for (let item of items) {
          let filterText = this.toFilterText(item);
          if (input.length > 0 && !hasMatch(input, filterText))
            continue;
          let picked = selectedItems.includes(item);
          let line = canSelectMany ? `[${picked ? "x" : " "}] ${item.label}` : item.label;
          if (item.description) {
            let start = byteLength(line);
            line = line + ` ${item.description}`;
            highlights.push({ hlGroup: "Comment", lnum: idx, colStart: start, colEnd: byteLength(line) });
          }
          let arr = positions(input, filterText);
          arr.forEach((n) => {
            let colStart = byteIndex(filterText, n);
            highlights.push({
              hlGroup: "CocSearch",
              colStart,
              colEnd: colStart + 1,
              lnum: idx
            });
          });
          filteredItems.push(item);
          lines.push(line);
          idx += 1;
        }
        this.filteredItems = filteredItems;
        this.win.linecount = lines.length;
        this.nvim.call("coc#dialog#update_list", [this.win.winid, this.win.bufnr, lines, highlights], true);
        this.setCursor(0);
      }
      showFilteredItems() {
        let { win, input, filteredItems } = this;
        if (!win)
          return;
        let { canSelectMany } = this.config;
        let lines = [];
        let highlights = [];
        let idx = 0;
        let selectedItems = [];
        for (let item of filteredItems) {
          let filterText = this.toFilterText(item);
          let line = canSelectMany ? `[${item.picked ? "x" : " "}] ${item.label}` : item.label;
          if (item.picked)
            selectedItems.push(item);
          if (item.description) {
            let start = byteLength(line);
            line = line + ` ${item.description}`;
            highlights.push({ hlGroup: "Comment", lnum: idx, colStart: start, colEnd: byteLength(line) });
          }
          let arr = positions(input.value, filterText);
          arr.forEach((n) => {
            let colStart = byteIndex(filterText, n);
            highlights.push({
              hlGroup: "CocSearch",
              colStart,
              colEnd: colStart + 1,
              lnum: idx
            });
          });
          lines.push(line);
          idx += 1;
        }
        this.selectedItems = selectedItems;
        this.win.linecount = lines.length;
        this.nvim.call("coc#dialog#update_list", [this.win.winid, this.win.bufnr, lines, highlights], true);
        this.setCursor(canSelectMany || selectedItems.length == 0 ? 0 : filteredItems.indexOf(selectedItems[0]));
      }
      onFinish(input) {
        if (input == null) {
          this._onDidChangeSelection.fire([]);
          this._onDidFinish.fire(null);
          return;
        }
        let selected = this.getSelectedItems();
        if (!this.config.canSelectMany) {
          this._onDidChangeSelection.fire(selected);
        }
        this._onDidFinish.fire(selected);
      }
      getSelectedItems() {
        let { win } = this;
        let { canSelectMany } = this.config;
        if (canSelectMany)
          return this.selectedItems;
        let item = this.filteredItems[win.currIndex];
        return item == null ? [] : [item];
      }
      toggePicked(index) {
        let { nvim, filteredItems, selectedItems } = this;
        let item = filteredItems[index];
        if (!item)
          return;
        let idx = selectedItems.indexOf(item);
        if (idx != -1) {
          selectedItems.splice(idx, 1);
        } else {
          selectedItems.push(item);
        }
        let text = idx == -1 ? "x" : " ";
        nvim.pauseNotification();
        this.win.execute(`normal! ^1lr${text}`);
        this.win.setCursor(this.win.currIndex + 1);
        nvim.resumeNotification(true, true);
        this._onDidChangeSelection.fire(selectedItems);
      }
      toFilterText(item) {
        let { label, description } = item;
        let { canSelectMany } = this.config;
        let line = `${canSelectMany ? "    " : ""}${label.replace(/\r?\n/, "")}`;
        return this.matchOnDescription ? line + " " + (description ?? "") : line;
      }
      dispose() {
        var _a, _b;
        this.bufnr = void 0;
        (_a = this.input) == null ? void 0 : _a.dispose();
        (_b = this.win) == null ? void 0 : _b.close();
        this._onDidFinish.dispose();
        this._onDidChangeSelection.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// node_modules/uuid/dist/esm-node/rng.js
function rng() {
  return import_crypto.default.randomBytes(16);
}
var import_crypto;
var init_rng = __esm({
  "node_modules/uuid/dist/esm-node/rng.js"() {
    import_crypto = __toESM(require("crypto"));
  }
});

// node_modules/uuid/dist/esm-node/bytesToUuid.js
function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], "-", bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join("");
}
var byteToHex, i, bytesToUuid_default;
var init_bytesToUuid = __esm({
  "node_modules/uuid/dist/esm-node/bytesToUuid.js"() {
    byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex[i] = (i + 256).toString(16).substr(1);
    }
    bytesToUuid_default = bytesToUuid;
  }
});

// node_modules/uuid/dist/esm-node/v1.js
function v1(options2, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];
  options2 = options2 || {};
  var node = options2.node || _nodeId;
  var clockseq = options2.clockseq !== void 0 ? options2.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    var seedBytes = options2.random || (options2.rng || rng)();
    if (node == null) {
      node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  var msecs = options2.msecs !== void 0 ? options2.msecs : new Date().getTime();
  var nsecs = options2.nsecs !== void 0 ? options2.nsecs : _lastNSecs + 1;
  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options2.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options2.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  var tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf ? buf : bytesToUuid_default(b);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  "node_modules/uuid/dist/esm-node/v1.js"() {
    init_rng();
    init_bytesToUuid();
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1_default = v1;
  }
});

// node_modules/uuid/dist/esm-node/v4.js
function v4(options2, buf, offset) {
  var i = buf && offset || 0;
  if (typeof options2 == "string") {
    buf = options2 === "binary" ? new Array(16) : null;
    options2 = null;
  }
  options2 = options2 || {};
  var rnds = options2.random || (options2.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }
  return buf || bytesToUuid_default(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/uuid/dist/esm-node/v4.js"() {
    init_rng();
    init_bytesToUuid();
    v4_default = v4;
  }
});

// node_modules/uuid/dist/esm-node/index.js
var init_esm_node = __esm({
  "node_modules/uuid/dist/esm-node/index.js"() {
    init_v1();
    init_v4();
  }
});

// src/model/status.ts
var logger18, frames, StatusLine;
var init_status = __esm({
  "src/model/status.ts"() {
    "use strict";
    init_esm_node();
    logger18 = require_logger2()("model-status");
    frames = ["\u280B", "\u2819", "\u2839", "\u2838", "\u283C", "\u2834", "\u2826", "\u2827", "\u2807", "\u280F"];
    StatusLine = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.items = /* @__PURE__ */ new Map();
        this.shownIds = /* @__PURE__ */ new Set();
        this._text = "";
        this.interval = setInterval(() => {
          this.setStatusText();
        }, 100);
      }
      dispose() {
        this.items.clear();
        this.shownIds.clear();
        clearInterval(this.interval);
      }
      createStatusBarItem(priority = 0, isProgress = false) {
        let uid = v1_default();
        let item = {
          text: "",
          priority,
          isProgress,
          show: () => {
            this.shownIds.add(uid);
            this.setStatusText();
          },
          hide: () => {
            this.shownIds.delete(uid);
            this.setStatusText();
          },
          dispose: () => {
            this.shownIds.delete(uid);
            this.items.delete(uid);
            this.setStatusText();
          }
        };
        this.items.set(uid, item);
        return item;
      }
      getText() {
        if (this.shownIds.size == 0)
          return "";
        let d = new Date();
        let idx = Math.floor(d.getMilliseconds() / 100);
        let text = "";
        let items = [];
        for (let [id, item] of this.items) {
          if (this.shownIds.has(id)) {
            items.push(item);
          }
        }
        items.sort((a, b) => a.priority - b.priority);
        for (let item of items) {
          if (!item.isProgress) {
            text = `${text} ${item.text}`;
          } else {
            text = `${text} ${frames[idx]} ${item.text}`;
          }
        }
        return text;
      }
      setStatusText() {
        let text = this.getText();
        let { nvim } = this;
        if (!nvim)
          return;
        if (text != this._text) {
          this._text = text;
          nvim.pauseNotification();
          this.nvim.setVar("coc_status", text, true);
          this.nvim.call("coc#util#do_autocmd", ["CocStatusChange"], true);
          nvim.resumeNotification(false, true);
        }
      }
    };
  }
});

// package.json
var version;
var init_package = __esm({
  "package.json"() {
    version = "0.0.82";
  }
});

// node_modules/jsonc-parser/lib/esm/impl/scanner.js
function createScanner(text, ignoreTrivia) {
  if (ignoreTrivia === void 0) {
    ignoreTrivia = false;
  }
  var len = text.length;
  var pos = 0, value = "", tokenOffset = 0, token = 16, lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0;
  function scanHexDigits(count, exact) {
    var digits = 0;
    var value2 = 0;
    while (digits < count || !exact) {
      var ch = text.charCodeAt(pos);
      if (ch >= 48 && ch <= 57) {
        value2 = value2 * 16 + ch - 48;
      } else if (ch >= 65 && ch <= 70) {
        value2 = value2 * 16 + ch - 65 + 10;
      } else if (ch >= 97 && ch <= 102) {
        value2 = value2 * 16 + ch - 97 + 10;
      } else {
        break;
      }
      pos++;
      digits++;
    }
    if (digits < count) {
      value2 = -1;
    }
    return value2;
  }
  function setPosition(newPosition) {
    pos = newPosition;
    value = "";
    tokenOffset = 0;
    token = 16;
    scanError = 0;
  }
  function scanNumber() {
    var start = pos;
    if (text.charCodeAt(pos) === 48) {
      pos++;
    } else {
      pos++;
      while (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
      }
    }
    if (pos < text.length && text.charCodeAt(pos) === 46) {
      pos++;
      if (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
        while (pos < text.length && isDigit(text.charCodeAt(pos))) {
          pos++;
        }
      } else {
        scanError = 3;
        return text.substring(start, pos);
      }
    }
    var end = pos;
    if (pos < text.length && (text.charCodeAt(pos) === 69 || text.charCodeAt(pos) === 101)) {
      pos++;
      if (pos < text.length && text.charCodeAt(pos) === 43 || text.charCodeAt(pos) === 45) {
        pos++;
      }
      if (pos < text.length && isDigit(text.charCodeAt(pos))) {
        pos++;
        while (pos < text.length && isDigit(text.charCodeAt(pos))) {
          pos++;
        }
        end = pos;
      } else {
        scanError = 3;
      }
    }
    return text.substring(start, end);
  }
  function scanString() {
    var result = "", start = pos;
    while (true) {
      if (pos >= len) {
        result += text.substring(start, pos);
        scanError = 2;
        break;
      }
      var ch = text.charCodeAt(pos);
      if (ch === 34) {
        result += text.substring(start, pos);
        pos++;
        break;
      }
      if (ch === 92) {
        result += text.substring(start, pos);
        pos++;
        if (pos >= len) {
          scanError = 2;
          break;
        }
        var ch2 = text.charCodeAt(pos++);
        switch (ch2) {
          case 34:
            result += '"';
            break;
          case 92:
            result += "\\";
            break;
          case 47:
            result += "/";
            break;
          case 98:
            result += "\b";
            break;
          case 102:
            result += "\f";
            break;
          case 110:
            result += "\n";
            break;
          case 114:
            result += "\r";
            break;
          case 116:
            result += "	";
            break;
          case 117:
            var ch3 = scanHexDigits(4, true);
            if (ch3 >= 0) {
              result += String.fromCharCode(ch3);
            } else {
              scanError = 4;
            }
            break;
          default:
            scanError = 5;
        }
        start = pos;
        continue;
      }
      if (ch >= 0 && ch <= 31) {
        if (isLineBreak(ch)) {
          result += text.substring(start, pos);
          scanError = 2;
          break;
        } else {
          scanError = 6;
        }
      }
      pos++;
    }
    return result;
  }
  function scanNext() {
    value = "";
    scanError = 0;
    tokenOffset = pos;
    lineStartOffset = lineNumber;
    prevTokenLineStartOffset = tokenLineStartOffset;
    if (pos >= len) {
      tokenOffset = len;
      return token = 17;
    }
    var code = text.charCodeAt(pos);
    if (isWhiteSpace(code)) {
      do {
        pos++;
        value += String.fromCharCode(code);
        code = text.charCodeAt(pos);
      } while (isWhiteSpace(code));
      return token = 15;
    }
    if (isLineBreak(code)) {
      pos++;
      value += String.fromCharCode(code);
      if (code === 13 && text.charCodeAt(pos) === 10) {
        pos++;
        value += "\n";
      }
      lineNumber++;
      tokenLineStartOffset = pos;
      return token = 14;
    }
    switch (code) {
      case 123:
        pos++;
        return token = 1;
      case 125:
        pos++;
        return token = 2;
      case 91:
        pos++;
        return token = 3;
      case 93:
        pos++;
        return token = 4;
      case 58:
        pos++;
        return token = 6;
      case 44:
        pos++;
        return token = 5;
      case 34:
        pos++;
        value = scanString();
        return token = 10;
      case 47:
        var start = pos - 1;
        if (text.charCodeAt(pos + 1) === 47) {
          pos += 2;
          while (pos < len) {
            if (isLineBreak(text.charCodeAt(pos))) {
              break;
            }
            pos++;
          }
          value = text.substring(start, pos);
          return token = 12;
        }
        if (text.charCodeAt(pos + 1) === 42) {
          pos += 2;
          var safeLength = len - 1;
          var commentClosed = false;
          while (pos < safeLength) {
            var ch = text.charCodeAt(pos);
            if (ch === 42 && text.charCodeAt(pos + 1) === 47) {
              pos += 2;
              commentClosed = true;
              break;
            }
            pos++;
            if (isLineBreak(ch)) {
              if (ch === 13 && text.charCodeAt(pos) === 10) {
                pos++;
              }
              lineNumber++;
              tokenLineStartOffset = pos;
            }
          }
          if (!commentClosed) {
            pos++;
            scanError = 1;
          }
          value = text.substring(start, pos);
          return token = 13;
        }
        value += String.fromCharCode(code);
        pos++;
        return token = 16;
      case 45:
        value += String.fromCharCode(code);
        pos++;
        if (pos === len || !isDigit(text.charCodeAt(pos))) {
          return token = 16;
        }
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        value += scanNumber();
        return token = 11;
      default:
        while (pos < len && isUnknownContentCharacter(code)) {
          pos++;
          code = text.charCodeAt(pos);
        }
        if (tokenOffset !== pos) {
          value = text.substring(tokenOffset, pos);
          switch (value) {
            case "true":
              return token = 8;
            case "false":
              return token = 9;
            case "null":
              return token = 7;
          }
          return token = 16;
        }
        value += String.fromCharCode(code);
        pos++;
        return token = 16;
    }
  }
  function isUnknownContentCharacter(code) {
    if (isWhiteSpace(code) || isLineBreak(code)) {
      return false;
    }
    switch (code) {
      case 125:
      case 93:
      case 123:
      case 91:
      case 34:
      case 58:
      case 44:
      case 47:
        return false;
    }
    return true;
  }
  function scanNextNonTrivia() {
    var result;
    do {
      result = scanNext();
    } while (result >= 12 && result <= 15);
    return result;
  }
  return {
    setPosition,
    getPosition: function() {
      return pos;
    },
    scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
    getToken: function() {
      return token;
    },
    getTokenValue: function() {
      return value;
    },
    getTokenOffset: function() {
      return tokenOffset;
    },
    getTokenLength: function() {
      return pos - tokenOffset;
    },
    getTokenStartLine: function() {
      return lineStartOffset;
    },
    getTokenStartCharacter: function() {
      return tokenOffset - prevTokenLineStartOffset;
    },
    getTokenError: function() {
      return scanError;
    }
  };
}
function isWhiteSpace(ch) {
  return ch === 32 || ch === 9 || ch === 11 || ch === 12 || ch === 160 || ch === 5760 || ch >= 8192 && ch <= 8203 || ch === 8239 || ch === 8287 || ch === 12288 || ch === 65279;
}
function isLineBreak(ch) {
  return ch === 10 || ch === 13 || ch === 8232 || ch === 8233;
}
function isDigit(ch) {
  return ch >= 48 && ch <= 57;
}
var init_scanner = __esm({
  "node_modules/jsonc-parser/lib/esm/impl/scanner.js"() {
    "use strict";
  }
});

// node_modules/jsonc-parser/lib/esm/impl/format.js
function format(documentText, range2, options2) {
  var initialIndentLevel;
  var formatText;
  var formatTextStart;
  var rangeStart;
  var rangeEnd;
  if (range2) {
    rangeStart = range2.offset;
    rangeEnd = rangeStart + range2.length;
    formatTextStart = rangeStart;
    while (formatTextStart > 0 && !isEOL(documentText, formatTextStart - 1)) {
      formatTextStart--;
    }
    var endOffset = rangeEnd;
    while (endOffset < documentText.length && !isEOL(documentText, endOffset)) {
      endOffset++;
    }
    formatText = documentText.substring(formatTextStart, endOffset);
    initialIndentLevel = computeIndentLevel(formatText, options2);
  } else {
    formatText = documentText;
    initialIndentLevel = 0;
    formatTextStart = 0;
    rangeStart = 0;
    rangeEnd = documentText.length;
  }
  var eol = getEOL(options2, documentText);
  var lineBreak = false;
  var indentLevel = 0;
  var indentValue;
  if (options2.insertSpaces) {
    indentValue = repeat(" ", options2.tabSize || 4);
  } else {
    indentValue = "	";
  }
  var scanner = createScanner(formatText, false);
  var hasError = false;
  function newLineAndIndent() {
    return eol + repeat(indentValue, initialIndentLevel + indentLevel);
  }
  function scanNext() {
    var token = scanner.scan();
    lineBreak = false;
    while (token === 15 || token === 14) {
      lineBreak = lineBreak || token === 14;
      token = scanner.scan();
    }
    hasError = token === 16 || scanner.getTokenError() !== 0;
    return token;
  }
  var editOperations = [];
  function addEdit(text, startOffset, endOffset2) {
    if (!hasError && (!range2 || startOffset < rangeEnd && endOffset2 > rangeStart) && documentText.substring(startOffset, endOffset2) !== text) {
      editOperations.push({ offset: startOffset, length: endOffset2 - startOffset, content: text });
    }
  }
  var firstToken = scanNext();
  if (firstToken !== 17) {
    var firstTokenStart = scanner.getTokenOffset() + formatTextStart;
    var initialIndent = repeat(indentValue, initialIndentLevel);
    addEdit(initialIndent, formatTextStart, firstTokenStart);
  }
  while (firstToken !== 17) {
    var firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;
    var secondToken = scanNext();
    var replaceContent = "";
    var needsLineBreak = false;
    while (!lineBreak && (secondToken === 12 || secondToken === 13)) {
      var commentTokenStart = scanner.getTokenOffset() + formatTextStart;
      addEdit(" ", firstTokenEnd, commentTokenStart);
      firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;
      needsLineBreak = secondToken === 12;
      replaceContent = needsLineBreak ? newLineAndIndent() : "";
      secondToken = scanNext();
    }
    if (secondToken === 2) {
      if (firstToken !== 1) {
        indentLevel--;
        replaceContent = newLineAndIndent();
      }
    } else if (secondToken === 4) {
      if (firstToken !== 3) {
        indentLevel--;
        replaceContent = newLineAndIndent();
      }
    } else {
      switch (firstToken) {
        case 3:
        case 1:
          indentLevel++;
          replaceContent = newLineAndIndent();
          break;
        case 5:
        case 12:
          replaceContent = newLineAndIndent();
          break;
        case 13:
          if (lineBreak) {
            replaceContent = newLineAndIndent();
          } else if (!needsLineBreak) {
            replaceContent = " ";
          }
          break;
        case 6:
          if (!needsLineBreak) {
            replaceContent = " ";
          }
          break;
        case 10:
          if (secondToken === 6) {
            if (!needsLineBreak) {
              replaceContent = "";
            }
            break;
          }
        case 7:
        case 8:
        case 9:
        case 11:
        case 2:
        case 4:
          if (secondToken === 12 || secondToken === 13) {
            if (!needsLineBreak) {
              replaceContent = " ";
            }
          } else if (secondToken !== 5 && secondToken !== 17) {
            hasError = true;
          }
          break;
        case 16:
          hasError = true;
          break;
      }
      if (lineBreak && (secondToken === 12 || secondToken === 13)) {
        replaceContent = newLineAndIndent();
      }
    }
    if (secondToken === 17) {
      replaceContent = options2.insertFinalNewline ? eol : "";
    }
    var secondTokenStart = scanner.getTokenOffset() + formatTextStart;
    addEdit(replaceContent, firstTokenEnd, secondTokenStart);
    firstToken = secondToken;
  }
  return editOperations;
}
function repeat(s, count) {
  var result = "";
  for (var i = 0; i < count; i++) {
    result += s;
  }
  return result;
}
function computeIndentLevel(content, options2) {
  var i = 0;
  var nChars = 0;
  var tabSize = options2.tabSize || 4;
  while (i < content.length) {
    var ch = content.charAt(i);
    if (ch === " ") {
      nChars++;
    } else if (ch === "	") {
      nChars += tabSize;
    } else {
      break;
    }
    i++;
  }
  return Math.floor(nChars / tabSize);
}
function getEOL(options2, text) {
  for (var i = 0; i < text.length; i++) {
    var ch = text.charAt(i);
    if (ch === "\r") {
      if (i + 1 < text.length && text.charAt(i + 1) === "\n") {
        return "\r\n";
      }
      return "\r";
    } else if (ch === "\n") {
      return "\n";
    }
  }
  return options2 && options2.eol || "\n";
}
function isEOL(text, offset) {
  return "\r\n".indexOf(text.charAt(offset)) !== -1;
}
var init_format = __esm({
  "node_modules/jsonc-parser/lib/esm/impl/format.js"() {
    "use strict";
    init_scanner();
  }
});

// node_modules/jsonc-parser/lib/esm/impl/parser.js
function parse(text, errors, options2) {
  if (errors === void 0) {
    errors = [];
  }
  if (options2 === void 0) {
    options2 = ParseOptions.DEFAULT;
  }
  var currentProperty = null;
  var currentParent = [];
  var previousParents = [];
  function onValue(value) {
    if (Array.isArray(currentParent)) {
      currentParent.push(value);
    } else if (currentProperty !== null) {
      currentParent[currentProperty] = value;
    }
  }
  var visitor = {
    onObjectBegin: function() {
      var object = {};
      onValue(object);
      previousParents.push(currentParent);
      currentParent = object;
      currentProperty = null;
    },
    onObjectProperty: function(name2) {
      currentProperty = name2;
    },
    onObjectEnd: function() {
      currentParent = previousParents.pop();
    },
    onArrayBegin: function() {
      var array = [];
      onValue(array);
      previousParents.push(currentParent);
      currentParent = array;
      currentProperty = null;
    },
    onArrayEnd: function() {
      currentParent = previousParents.pop();
    },
    onLiteralValue: onValue,
    onError: function(error, offset, length) {
      errors.push({ error, offset, length });
    }
  };
  visit(text, visitor, options2);
  return currentParent[0];
}
function parseTree(text, errors, options2) {
  if (errors === void 0) {
    errors = [];
  }
  if (options2 === void 0) {
    options2 = ParseOptions.DEFAULT;
  }
  var currentParent = { type: "array", offset: -1, length: -1, children: [], parent: void 0 };
  function ensurePropertyComplete(endOffset) {
    if (currentParent.type === "property") {
      currentParent.length = endOffset - currentParent.offset;
      currentParent = currentParent.parent;
    }
  }
  function onValue(valueNode) {
    currentParent.children.push(valueNode);
    return valueNode;
  }
  var visitor = {
    onObjectBegin: function(offset) {
      currentParent = onValue({ type: "object", offset, length: -1, parent: currentParent, children: [] });
    },
    onObjectProperty: function(name2, offset, length) {
      currentParent = onValue({ type: "property", offset, length: -1, parent: currentParent, children: [] });
      currentParent.children.push({ type: "string", value: name2, offset, length, parent: currentParent });
    },
    onObjectEnd: function(offset, length) {
      ensurePropertyComplete(offset + length);
      currentParent.length = offset + length - currentParent.offset;
      currentParent = currentParent.parent;
      ensurePropertyComplete(offset + length);
    },
    onArrayBegin: function(offset, length) {
      currentParent = onValue({ type: "array", offset, length: -1, parent: currentParent, children: [] });
    },
    onArrayEnd: function(offset, length) {
      currentParent.length = offset + length - currentParent.offset;
      currentParent = currentParent.parent;
      ensurePropertyComplete(offset + length);
    },
    onLiteralValue: function(value, offset, length) {
      onValue({ type: getNodeType(value), offset, length, parent: currentParent, value });
      ensurePropertyComplete(offset + length);
    },
    onSeparator: function(sep, offset, length) {
      if (currentParent.type === "property") {
        if (sep === ":") {
          currentParent.colonOffset = offset;
        } else if (sep === ",") {
          ensurePropertyComplete(offset);
        }
      }
    },
    onError: function(error, offset, length) {
      errors.push({ error, offset, length });
    }
  };
  visit(text, visitor, options2);
  var result = currentParent.children[0];
  if (result) {
    delete result.parent;
  }
  return result;
}
function findNodeAtLocation(root, path41) {
  if (!root) {
    return void 0;
  }
  var node = root;
  for (var _i = 0, path_1 = path41; _i < path_1.length; _i++) {
    var segment = path_1[_i];
    if (typeof segment === "string") {
      if (node.type !== "object" || !Array.isArray(node.children)) {
        return void 0;
      }
      var found = false;
      for (var _a = 0, _b = node.children; _a < _b.length; _a++) {
        var propertyNode = _b[_a];
        if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {
          node = propertyNode.children[1];
          found = true;
          break;
        }
      }
      if (!found) {
        return void 0;
      }
    } else {
      var index = segment;
      if (node.type !== "array" || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {
        return void 0;
      }
      node = node.children[index];
    }
  }
  return node;
}
function visit(text, visitor, options2) {
  if (options2 === void 0) {
    options2 = ParseOptions.DEFAULT;
  }
  var _scanner = createScanner(text, false);
  function toNoArgVisit(visitFunction) {
    return visitFunction ? function() {
      return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());
    } : function() {
      return true;
    };
  }
  function toOneArgVisit(visitFunction) {
    return visitFunction ? function(arg) {
      return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter());
    } : function() {
      return true;
    };
  }
  var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);
  var disallowComments = options2 && options2.disallowComments;
  var allowTrailingComma = options2 && options2.allowTrailingComma;
  function scanNext() {
    while (true) {
      var token = _scanner.scan();
      switch (_scanner.getTokenError()) {
        case 4:
          handleError(14);
          break;
        case 5:
          handleError(15);
          break;
        case 3:
          handleError(13);
          break;
        case 1:
          if (!disallowComments) {
            handleError(11);
          }
          break;
        case 2:
          handleError(12);
          break;
        case 6:
          handleError(16);
          break;
      }
      switch (token) {
        case 12:
        case 13:
          if (disallowComments) {
            handleError(10);
          } else {
            onComment();
          }
          break;
        case 16:
          handleError(1);
          break;
        case 15:
        case 14:
          break;
        default:
          return token;
      }
    }
  }
  function handleError(error, skipUntilAfter, skipUntil) {
    if (skipUntilAfter === void 0) {
      skipUntilAfter = [];
    }
    if (skipUntil === void 0) {
      skipUntil = [];
    }
    onError(error);
    if (skipUntilAfter.length + skipUntil.length > 0) {
      var token = _scanner.getToken();
      while (token !== 17) {
        if (skipUntilAfter.indexOf(token) !== -1) {
          scanNext();
          break;
        } else if (skipUntil.indexOf(token) !== -1) {
          break;
        }
        token = scanNext();
      }
    }
  }
  function parseString(isValue) {
    var value = _scanner.getTokenValue();
    if (isValue) {
      onLiteralValue(value);
    } else {
      onObjectProperty(value);
    }
    scanNext();
    return true;
  }
  function parseLiteral() {
    switch (_scanner.getToken()) {
      case 11:
        var tokenValue = _scanner.getTokenValue();
        var value = Number(tokenValue);
        if (isNaN(value)) {
          handleError(2);
          value = 0;
        }
        onLiteralValue(value);
        break;
      case 7:
        onLiteralValue(null);
        break;
      case 8:
        onLiteralValue(true);
        break;
      case 9:
        onLiteralValue(false);
        break;
      default:
        return false;
    }
    scanNext();
    return true;
  }
  function parseProperty() {
    if (_scanner.getToken() !== 10) {
      handleError(3, [], [2, 5]);
      return false;
    }
    parseString(false);
    if (_scanner.getToken() === 6) {
      onSeparator(":");
      scanNext();
      if (!parseValue()) {
        handleError(4, [], [2, 5]);
      }
    } else {
      handleError(5, [], [2, 5]);
    }
    return true;
  }
  function parseObject() {
    onObjectBegin();
    scanNext();
    var needsComma = false;
    while (_scanner.getToken() !== 2 && _scanner.getToken() !== 17) {
      if (_scanner.getToken() === 5) {
        if (!needsComma) {
          handleError(4, [], []);
        }
        onSeparator(",");
        scanNext();
        if (_scanner.getToken() === 2 && allowTrailingComma) {
          break;
        }
      } else if (needsComma) {
        handleError(6, [], []);
      }
      if (!parseProperty()) {
        handleError(4, [], [2, 5]);
      }
      needsComma = true;
    }
    onObjectEnd();
    if (_scanner.getToken() !== 2) {
      handleError(7, [2], []);
    } else {
      scanNext();
    }
    return true;
  }
  function parseArray() {
    onArrayBegin();
    scanNext();
    var needsComma = false;
    while (_scanner.getToken() !== 4 && _scanner.getToken() !== 17) {
      if (_scanner.getToken() === 5) {
        if (!needsComma) {
          handleError(4, [], []);
        }
        onSeparator(",");
        scanNext();
        if (_scanner.getToken() === 4 && allowTrailingComma) {
          break;
        }
      } else if (needsComma) {
        handleError(6, [], []);
      }
      if (!parseValue()) {
        handleError(4, [], [4, 5]);
      }
      needsComma = true;
    }
    onArrayEnd();
    if (_scanner.getToken() !== 4) {
      handleError(8, [4], []);
    } else {
      scanNext();
    }
    return true;
  }
  function parseValue() {
    switch (_scanner.getToken()) {
      case 3:
        return parseArray();
      case 1:
        return parseObject();
      case 10:
        return parseString(true);
      default:
        return parseLiteral();
    }
  }
  scanNext();
  if (_scanner.getToken() === 17) {
    if (options2.allowEmptyContent) {
      return true;
    }
    handleError(4, [], []);
    return false;
  }
  if (!parseValue()) {
    handleError(4, [], []);
    return false;
  }
  if (_scanner.getToken() !== 17) {
    handleError(9, [], []);
  }
  return true;
}
function getNodeType(value) {
  switch (typeof value) {
    case "boolean":
      return "boolean";
    case "number":
      return "number";
    case "string":
      return "string";
    case "object": {
      if (!value) {
        return "null";
      } else if (Array.isArray(value)) {
        return "array";
      }
      return "object";
    }
    default:
      return "null";
  }
}
var ParseOptions;
var init_parser = __esm({
  "node_modules/jsonc-parser/lib/esm/impl/parser.js"() {
    "use strict";
    init_scanner();
    (function(ParseOptions2) {
      ParseOptions2.DEFAULT = {
        allowTrailingComma: false
      };
    })(ParseOptions || (ParseOptions = {}));
  }
});

// node_modules/jsonc-parser/lib/esm/impl/edit.js
function setProperty(text, originalPath, value, options2) {
  var _a;
  var path41 = originalPath.slice();
  var errors = [];
  var root = parseTree(text, errors);
  var parent = void 0;
  var lastSegment = void 0;
  while (path41.length > 0) {
    lastSegment = path41.pop();
    parent = findNodeAtLocation(root, path41);
    if (parent === void 0 && value !== void 0) {
      if (typeof lastSegment === "string") {
        value = (_a = {}, _a[lastSegment] = value, _a);
      } else {
        value = [value];
      }
    } else {
      break;
    }
  }
  if (!parent) {
    if (value === void 0) {
      throw new Error("Can not delete in empty document");
    }
    return withFormatting(text, { offset: root ? root.offset : 0, length: root ? root.length : 0, content: JSON.stringify(value) }, options2);
  } else if (parent.type === "object" && typeof lastSegment === "string" && Array.isArray(parent.children)) {
    var existing = findNodeAtLocation(parent, [lastSegment]);
    if (existing !== void 0) {
      if (value === void 0) {
        if (!existing.parent) {
          throw new Error("Malformed AST");
        }
        var propertyIndex = parent.children.indexOf(existing.parent);
        var removeBegin = void 0;
        var removeEnd = existing.parent.offset + existing.parent.length;
        if (propertyIndex > 0) {
          var previous = parent.children[propertyIndex - 1];
          removeBegin = previous.offset + previous.length;
        } else {
          removeBegin = parent.offset + 1;
          if (parent.children.length > 1) {
            var next = parent.children[1];
            removeEnd = next.offset;
          }
        }
        return withFormatting(text, { offset: removeBegin, length: removeEnd - removeBegin, content: "" }, options2);
      } else {
        return withFormatting(text, { offset: existing.offset, length: existing.length, content: JSON.stringify(value) }, options2);
      }
    } else {
      if (value === void 0) {
        return [];
      }
      var newProperty = JSON.stringify(lastSegment) + ": " + JSON.stringify(value);
      var index = options2.getInsertionIndex ? options2.getInsertionIndex(parent.children.map(function(p) {
        return p.children[0].value;
      })) : parent.children.length;
      var edit2 = void 0;
      if (index > 0) {
        var previous = parent.children[index - 1];
        edit2 = { offset: previous.offset + previous.length, length: 0, content: "," + newProperty };
      } else if (parent.children.length === 0) {
        edit2 = { offset: parent.offset + 1, length: 0, content: newProperty };
      } else {
        edit2 = { offset: parent.offset + 1, length: 0, content: newProperty + "," };
      }
      return withFormatting(text, edit2, options2);
    }
  } else if (parent.type === "array" && typeof lastSegment === "number" && Array.isArray(parent.children)) {
    var insertIndex = lastSegment;
    if (insertIndex === -1) {
      var newProperty = "" + JSON.stringify(value);
      var edit2 = void 0;
      if (parent.children.length === 0) {
        edit2 = { offset: parent.offset + 1, length: 0, content: newProperty };
      } else {
        var previous = parent.children[parent.children.length - 1];
        edit2 = { offset: previous.offset + previous.length, length: 0, content: "," + newProperty };
      }
      return withFormatting(text, edit2, options2);
    } else if (value === void 0 && parent.children.length >= 0) {
      var removalIndex = lastSegment;
      var toRemove = parent.children[removalIndex];
      var edit2 = void 0;
      if (parent.children.length === 1) {
        edit2 = { offset: parent.offset + 1, length: parent.length - 2, content: "" };
      } else if (parent.children.length - 1 === removalIndex) {
        var previous = parent.children[removalIndex - 1];
        var offset = previous.offset + previous.length;
        var parentEndOffset = parent.offset + parent.length;
        edit2 = { offset, length: parentEndOffset - 2 - offset, content: "" };
      } else {
        edit2 = { offset: toRemove.offset, length: parent.children[removalIndex + 1].offset - toRemove.offset, content: "" };
      }
      return withFormatting(text, edit2, options2);
    } else if (value !== void 0) {
      var edit2 = void 0;
      var newProperty = "" + JSON.stringify(value);
      if (!options2.isArrayInsertion && parent.children.length > lastSegment) {
        var toModify = parent.children[lastSegment];
        edit2 = { offset: toModify.offset, length: toModify.length, content: newProperty };
      } else if (parent.children.length === 0 || lastSegment === 0) {
        edit2 = { offset: parent.offset + 1, length: 0, content: parent.children.length === 0 ? newProperty : newProperty + "," };
      } else {
        var index = lastSegment > parent.children.length ? parent.children.length : lastSegment;
        var previous = parent.children[index - 1];
        edit2 = { offset: previous.offset + previous.length, length: 0, content: "," + newProperty };
      }
      return withFormatting(text, edit2, options2);
    } else {
      throw new Error("Can not " + (value === void 0 ? "remove" : options2.isArrayInsertion ? "insert" : "modify") + " Array index " + insertIndex + " as length is not sufficient");
    }
  } else {
    throw new Error("Can not add " + (typeof lastSegment !== "number" ? "index" : "property") + " to parent of type " + parent.type);
  }
}
function withFormatting(text, edit2, options2) {
  if (!options2.formattingOptions) {
    return [edit2];
  }
  var newText = applyEdit(text, edit2);
  var begin = edit2.offset;
  var end = edit2.offset + edit2.content.length;
  if (edit2.length === 0 || edit2.content.length === 0) {
    while (begin > 0 && !isEOL(newText, begin - 1)) {
      begin--;
    }
    while (end < newText.length && !isEOL(newText, end)) {
      end++;
    }
  }
  var edits = format(newText, { offset: begin, length: end - begin }, options2.formattingOptions);
  for (var i = edits.length - 1; i >= 0; i--) {
    var edit_1 = edits[i];
    newText = applyEdit(newText, edit_1);
    begin = Math.min(begin, edit_1.offset);
    end = Math.max(end, edit_1.offset + edit_1.length);
    end += edit_1.content.length - edit_1.length;
  }
  var editLength = text.length - (newText.length - end) - begin;
  return [{ offset: begin, length: editLength, content: newText.substring(begin, end) }];
}
function applyEdit(text, edit2) {
  return text.substring(0, edit2.offset) + edit2.content + text.substring(edit2.offset + edit2.length);
}
var init_edit = __esm({
  "node_modules/jsonc-parser/lib/esm/impl/edit.js"() {
    "use strict";
    init_format();
    init_parser();
  }
});

// node_modules/jsonc-parser/lib/esm/main.js
function modify(text, path41, value, options2) {
  return setProperty(text, path41, value, options2);
}
function applyEdits(text, edits) {
  for (var i = edits.length - 1; i >= 0; i--) {
    text = applyEdit(text, edits[i]);
  }
  return text;
}
var parse2;
var init_main2 = __esm({
  "node_modules/jsonc-parser/lib/esm/main.js"() {
    "use strict";
    init_format();
    init_edit();
    init_scanner();
    init_parser();
    parse2 = parse;
  }
});

// node_modules/vscode-languageserver-textdocument/lib/esm/main.js
function mergeSort(data, compare) {
  if (data.length <= 1) {
    return data;
  }
  const p = data.length / 2 | 0;
  const left = data.slice(0, p);
  const right = data.slice(p);
  mergeSort(left, compare);
  mergeSort(right, compare);
  let leftIdx = 0;
  let rightIdx = 0;
  let i = 0;
  while (leftIdx < left.length && rightIdx < right.length) {
    let ret = compare(left[leftIdx], right[rightIdx]);
    if (ret <= 0) {
      data[i++] = left[leftIdx++];
    } else {
      data[i++] = right[rightIdx++];
    }
  }
  while (leftIdx < left.length) {
    data[i++] = left[leftIdx++];
  }
  while (rightIdx < right.length) {
    data[i++] = right[rightIdx++];
  }
  return data;
}
function computeLineOffsets(text, isAtLineStart, textOffset = 0) {
  const result = isAtLineStart ? [textOffset] : [];
  for (let i = 0; i < text.length; i++) {
    let ch = text.charCodeAt(i);
    if (ch === 13 || ch === 10) {
      if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {
        i++;
      }
      result.push(textOffset + i + 1);
    }
  }
  return result;
}
function getWellformedRange(range2) {
  const start = range2.start;
  const end = range2.end;
  if (start.line > end.line || start.line === end.line && start.character > end.character) {
    return { start: end, end: start };
  }
  return range2;
}
function getWellformedEdit(textEdit) {
  const range2 = getWellformedRange(textEdit.range);
  if (range2 !== textEdit.range) {
    return { newText: textEdit.newText, range: range2 };
  }
  return textEdit;
}
var FullTextDocument2, TextDocument2;
var init_main3 = __esm({
  "node_modules/vscode-languageserver-textdocument/lib/esm/main.js"() {
    "use strict";
    FullTextDocument2 = class {
      constructor(uri, languageId, version2, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version2;
        this._content = content;
        this._lineOffsets = void 0;
      }
      get uri() {
        return this._uri;
      }
      get languageId() {
        return this._languageId;
      }
      get version() {
        return this._version;
      }
      getText(range2) {
        if (range2) {
          const start = this.offsetAt(range2.start);
          const end = this.offsetAt(range2.end);
          return this._content.substring(start, end);
        }
        return this._content;
      }
      update(changes, version2) {
        for (let change of changes) {
          if (FullTextDocument2.isIncremental(change)) {
            const range2 = getWellformedRange(change.range);
            const startOffset = this.offsetAt(range2.start);
            const endOffset = this.offsetAt(range2.end);
            this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
            const startLine = Math.max(range2.start.line, 0);
            const endLine = Math.max(range2.end.line, 0);
            let lineOffsets = this._lineOffsets;
            const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
            if (endLine - startLine === addedLineOffsets.length) {
              for (let i = 0, len = addedLineOffsets.length; i < len; i++) {
                lineOffsets[i + startLine + 1] = addedLineOffsets[i];
              }
            } else {
              if (addedLineOffsets.length < 1e4) {
                lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
              } else {
                this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
              }
            }
            const diff = change.text.length - (endOffset - startOffset);
            if (diff !== 0) {
              for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
                lineOffsets[i] = lineOffsets[i] + diff;
              }
            }
          } else if (FullTextDocument2.isFull(change)) {
            this._content = change.text;
            this._lineOffsets = void 0;
          } else {
            throw new Error("Unknown change event received");
          }
        }
        this._version = version2;
      }
      getLineOffsets() {
        if (this._lineOffsets === void 0) {
          this._lineOffsets = computeLineOffsets(this._content, true);
        }
        return this._lineOffsets;
      }
      positionAt(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        let lineOffsets = this.getLineOffsets();
        let low = 0, high = lineOffsets.length;
        if (high === 0) {
          return { line: 0, character: offset };
        }
        while (low < high) {
          let mid = Math.floor((low + high) / 2);
          if (lineOffsets[mid] > offset) {
            high = mid;
          } else {
            low = mid + 1;
          }
        }
        let line = low - 1;
        return { line, character: offset - lineOffsets[line] };
      }
      offsetAt(position) {
        let lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
          return this._content.length;
        } else if (position.line < 0) {
          return 0;
        }
        let lineOffset = lineOffsets[position.line];
        let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
      }
      get lineCount() {
        return this.getLineOffsets().length;
      }
      static isIncremental(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      static isFull(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
    };
    (function(TextDocument4) {
      function create(uri, languageId, version2, content) {
        return new FullTextDocument2(uri, languageId, version2, content);
      }
      TextDocument4.create = create;
      function update(document2, changes, version2) {
        if (document2 instanceof FullTextDocument2) {
          document2.update(changes, version2);
          return document2;
        } else {
          throw new Error("TextDocument.update: document must be created by TextDocument.create");
        }
      }
      TextDocument4.update = update;
      function applyEdits3(document2, edits) {
        let text = document2.getText();
        let sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {
          let diff = a.range.start.line - b.range.start.line;
          if (diff === 0) {
            return a.range.start.character - b.range.start.character;
          }
          return diff;
        });
        let lastModifiedOffset = 0;
        const spans = [];
        for (const e of sortedEdits) {
          let startOffset = document2.offsetAt(e.range.start);
          if (startOffset < lastModifiedOffset) {
            throw new Error("Overlapping edit");
          } else if (startOffset > lastModifiedOffset) {
            spans.push(text.substring(lastModifiedOffset, startOffset));
          }
          if (e.newText.length) {
            spans.push(e.newText);
          }
          lastModifiedOffset = document2.offsetAt(e.range.end);
        }
        spans.push(text.substr(lastModifiedOffset));
        return spans.join("");
      }
      TextDocument4.applyEdits = applyEdits3;
    })(TextDocument2 || (TextDocument2 = {}));
  }
});

// src/configuration/util.ts
function mergeConfigProperties(obj) {
  let res = {};
  for (let key of Object.keys(obj)) {
    if (key.indexOf(".") == -1) {
      res[key] = obj[key];
    } else {
      let parts = key.split(".");
      let pre = res;
      let len = parts.length;
      for (let i = 0; i < len; i++) {
        let k = parts[i];
        if (i == len - 1) {
          pre[k] = obj[key];
        } else {
          pre[k] = pre[k] || {};
          pre = pre[k];
        }
      }
    }
  }
  return res;
}
function parseContentFromFile(filepath, onError) {
  if (!filepath || !import_fs2.default.existsSync(filepath))
    return { contents: {} };
  let content;
  let uri = URI2.file(filepath).toString();
  try {
    content = import_fs2.default.readFileSync(filepath, "utf8");
  } catch (_e) {
    content = "";
  }
  let [errors, contents] = parseConfiguration(content);
  if (errors && errors.length) {
    onError(convertErrors(uri, content, errors));
  }
  return { contents };
}
function parseConfiguration(content) {
  if (content.length == 0)
    return [[], {}];
  let errors = [];
  let data = parse2(content, errors, { allowTrailingComma: true });
  function addProperty(current, key, remains, value) {
    if (remains.length == 0) {
      current[key] = convert(value);
    } else {
      if (!current[key])
        current[key] = {};
      let o = current[key];
      let first = remains.shift();
      addProperty(o, first, remains, value);
    }
  }
  function convert(obj, split = false) {
    if (!objectLiteral(obj))
      return obj;
    if (emptyObject(obj))
      return {};
    let dest = {};
    for (let key of Object.keys(obj)) {
      if (split && key.includes(".") && !/^.+:\//.test(key)) {
        let parts = key.split(".");
        let first = parts.shift();
        addProperty(dest, first, parts, obj[key]);
      } else {
        dest[key] = convert(obj[key]);
      }
    }
    return dest;
  }
  return [errors, convert(data, true)];
}
function convertErrors(uri, content, errors) {
  let items = [];
  let document2 = TextDocument2.create(uri, "json", 0, content);
  for (let err of errors) {
    let msg = "parse error";
    switch (err.error) {
      case 2:
        msg = "invalid number";
        break;
      case 8:
        msg = "close brace expected";
        break;
      case 5:
        msg = "colon expected";
        break;
      case 6:
        msg = "comma expected";
        break;
      case 9:
        msg = "end of file expected";
        break;
      case 16:
        msg = "invaliad character";
        break;
      case 10:
        msg = "invalid comment token";
        break;
      case 15:
        msg = "invalid escape character";
        break;
      case 1:
        msg = "invalid symbol";
        break;
      case 14:
        msg = "invalid unicode";
        break;
      case 3:
        msg = "property name expected";
        break;
      case 13:
        msg = "unexpected end of number";
        break;
      case 12:
        msg = "unexpected end of string";
        break;
      case 11:
        msg = "unexpected end of comment";
        break;
      case 4:
        msg = "value expected";
        break;
      default:
        msg = "Unknown error";
        break;
    }
    let range2 = {
      start: document2.positionAt(err.offset),
      end: document2.positionAt(err.offset + err.length)
    };
    let loc = import_vscode_languageserver_protocol13.Location.create(uri, range2);
    items.push({ location: loc, message: msg });
  }
  return items;
}
function addToValueTree(settingsTreeRoot, key, value, conflictReporter) {
  const segments = key.split(".");
  const last = segments.pop();
  let curr = settingsTreeRoot;
  for (let i = 0; i < segments.length; i++) {
    let s = segments[i];
    let obj = curr[s];
    switch (typeof obj) {
      case "function": {
        obj = curr[s] = {};
        break;
      }
      case "undefined": {
        obj = curr[s] = {};
        break;
      }
      case "object":
        break;
      default:
        conflictReporter(`Ignoring ${key} as ${segments.slice(0, i + 1).join(".")} is ${JSON.stringify(obj)}`);
        return;
    }
    curr = obj;
  }
  if (typeof curr === "object") {
    curr[last] = value;
  } else {
    conflictReporter(`Ignoring ${key} as ${segments.join(".")} is ${JSON.stringify(curr)}`);
  }
}
function removeFromValueTree(valueTree, key) {
  const segments = key.split(".");
  doRemoveFromValueTree(valueTree, segments);
}
function doRemoveFromValueTree(valueTree, segments) {
  const first = segments.shift();
  if (segments.length === 0) {
    delete valueTree[first];
    return;
  }
  if (Object.keys(valueTree).includes(first)) {
    const value = valueTree[first];
    if (typeof value === "object" && !Array.isArray(value)) {
      doRemoveFromValueTree(value, segments);
      if (Object.keys(value).length === 0) {
        delete valueTree[first];
      }
    }
  }
}
function getConfigurationValue(config, settingPath, defaultValue) {
  function accessSetting(config2, path42) {
    let current = config2;
    for (let i = 0; i < path42.length; i++) {
      if (typeof current !== "object" || current === null) {
        return void 0;
      }
      current = current[path42[i]];
    }
    return current;
  }
  const path41 = settingPath.split(".");
  const result = accessSetting(config, path41);
  return typeof result === "undefined" ? defaultValue : result;
}
function getKeys(obj, curr) {
  let keys = [];
  for (let key of Object.keys(obj)) {
    let val = obj[key];
    let newKey = curr ? `${curr}.${key}` : key;
    keys.push(newKey);
    if (objectLiteral(val)) {
      keys.push(...getKeys(val, newKey));
    }
  }
  return keys;
}
function getChangedKeys(from, to) {
  let keys = [];
  let fromKeys = getKeys(from);
  let toKeys = getKeys(to);
  const added = toKeys.filter((key) => !fromKeys.includes(key));
  const removed = fromKeys.filter((key) => !toKeys.includes(key));
  keys.push(...added);
  keys.push(...removed);
  for (const key of fromKeys) {
    if (!toKeys.includes(key))
      continue;
    const value1 = getConfigurationValue(from, key);
    const value2 = getConfigurationValue(to, key);
    if (!equals(value1, value2)) {
      keys.push(key);
    }
  }
  return keys;
}
function toJSONObject(obj) {
  if (obj) {
    if (Array.isArray(obj)) {
      return obj.map(toJSONObject);
    } else if (typeof obj === "object") {
      const res = /* @__PURE__ */ Object.create(null);
      for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          res[key] = toJSONObject(obj[key]);
        }
      }
      return res;
    }
  }
  return obj;
}
var import_fs2, import_vscode_languageserver_protocol13, logger19;
var init_util2 = __esm({
  "src/configuration/util.ts"() {
    "use strict";
    import_fs2 = __toESM(require("fs"));
    init_main2();
    import_vscode_languageserver_protocol13 = __toESM(require_main2());
    init_main3();
    init_esm();
    init_is();
    init_object();
    logger19 = require_logger2()("configuration-util");
  }
});

// src/configuration/model.ts
var ConfigurationModel;
var init_model = __esm({
  "src/configuration/model.ts"() {
    "use strict";
    init_is();
    init_object();
    init_util2();
    ConfigurationModel = class {
      constructor(_contents = {}) {
        this._contents = _contents;
      }
      get contents() {
        return this._contents;
      }
      clone() {
        return new ConfigurationModel(deepClone(this._contents));
      }
      getValue(section2) {
        let res = section2 ? getConfigurationValue(this.contents, section2) : this.contents;
        return res;
      }
      merge(...others) {
        const contents = deepClone(this.contents);
        for (const other of others) {
          this.mergeContents(contents, other.contents);
        }
        return new ConfigurationModel(contents);
      }
      freeze() {
        if (!Object.isFrozen(this._contents)) {
          Object.freeze(this._contents);
        }
        return this;
      }
      mergeContents(source, target) {
        for (const key of Object.keys(target)) {
          if (key in source) {
            if (objectLiteral(source[key]) && objectLiteral(target[key])) {
              this.mergeContents(source[key], target[key]);
              continue;
            }
          }
          source[key] = deepClone(target[key]);
        }
      }
      setValue(key, value) {
        addToValueTree(this.contents, key, value, (message) => {
          console.error(message);
        });
      }
      removeValue(key) {
        removeFromValueTree(this.contents, key);
      }
    };
  }
});

// src/configuration/configuration.ts
var Configuration;
var init_configuration = __esm({
  "src/configuration/configuration.ts"() {
    "use strict";
    init_model();
    Configuration = class {
      constructor(_defaultConfiguration, _userConfiguration, _workspaceConfiguration, _memoryConfiguration = new ConfigurationModel()) {
        this._defaultConfiguration = _defaultConfiguration;
        this._userConfiguration = _userConfiguration;
        this._workspaceConfiguration = _workspaceConfiguration;
        this._memoryConfiguration = _memoryConfiguration;
      }
      getConsolidateConfiguration() {
        if (!this._consolidateConfiguration) {
          this._consolidateConfiguration = this._defaultConfiguration.merge(this._userConfiguration, this._workspaceConfiguration, this._memoryConfiguration);
          this._consolidateConfiguration = this._consolidateConfiguration.freeze();
        }
        return this._consolidateConfiguration;
      }
      getValue(section2) {
        let configuration = this.getConsolidateConfiguration();
        return configuration.getValue(section2);
      }
      inspect(key) {
        const consolidateConfigurationModel = this.getConsolidateConfiguration();
        const { _workspaceConfiguration, _memoryConfiguration } = this;
        return {
          default: this._defaultConfiguration.freeze().getValue(key),
          user: this._userConfiguration.freeze().getValue(key),
          workspace: _workspaceConfiguration.freeze().getValue(key),
          memory: _memoryConfiguration.freeze().getValue(key),
          value: consolidateConfigurationModel.getValue(key)
        };
      }
      get defaults() {
        return this._defaultConfiguration;
      }
      get user() {
        return this._userConfiguration;
      }
      get workspace() {
        return this._workspaceConfiguration;
      }
      toData() {
        return {
          defaults: {
            contents: this._defaultConfiguration.contents
          },
          user: {
            contents: this._userConfiguration.contents
          },
          workspace: {
            contents: this._workspaceConfiguration.contents
          }
        };
      }
    };
  }
});

// src/configuration/index.ts
function lookUp(tree, key) {
  if (key) {
    if (tree && tree.hasOwnProperty(key))
      return tree[key];
    const parts = key.split(".");
    let node = tree;
    for (let i = 0; node && i < parts.length; i++) {
      node = node[parts[i]];
    }
    return node;
  }
  return tree;
}
var import_fs3, import_os2, import_path3, import_vscode_languageserver_protocol14, logger20, pluginRoot, Configurations;
var init_configuration2 = __esm({
  "src/configuration/index.ts"() {
    "use strict";
    import_fs3 = __toESM(require("fs"));
    import_os2 = __toESM(require("os"));
    import_path3 = __toESM(require("path"));
    import_vscode_languageserver_protocol14 = __toESM(require_main2());
    init_esm();
    init_types();
    init_util();
    init_fs();
    init_is();
    init_object();
    init_configuration();
    init_model();
    init_util2();
    logger20 = require_logger2()("configurations");
    pluginRoot = false ? resolve(__dirname, "../..") : (0, import_path3.dirname)(__dirname);
    Configurations = class {
      constructor(userConfigFile, _proxy) {
        this.userConfigFile = userConfigFile;
        this._proxy = _proxy;
        this.cwd = process.cwd();
        this.builtinKeys = [];
        this._errorItems = [];
        this._folderConfigurations = /* @__PURE__ */ new Map();
        this._onError = new import_vscode_languageserver_protocol14.Emitter();
        this._onChange = new import_vscode_languageserver_protocol14.Emitter();
        this.disposables = [];
        this.onError = this._onError.event;
        this.onDidChange = this._onChange.event;
        let user = this.parseContentFromFile(userConfigFile);
        let data = {
          defaults: this.loadDefaultConfigurations(),
          user,
          workspace: { contents: {} }
        };
        this._configuration = Configurations.parse(data);
        this.watchFile(userConfigFile, 1 /* User */);
        this.addFolderFromCwd();
      }
      parseContentFromFile(filepath) {
        if (!filepath)
          return { contents: {} };
        let uri = URI2.file(filepath).toString();
        this._errorItems = this._errorItems.filter((o) => o.location.uri != uri);
        let res = parseContentFromFile(filepath, (errors) => {
          this._errorItems.push(...errors);
        });
        this._onError.fire(this._errorItems);
        return res;
      }
      get errorItems() {
        return this._errorItems;
      }
      get foldConfigurations() {
        return this._folderConfigurations;
      }
      extendsDefaults(props, id) {
        let { defaults: defaults3 } = this._configuration;
        let { contents } = defaults3;
        contents = deepClone(contents);
        Object.keys(props).forEach((key) => {
          if (id && this.builtinKeys.includes(key)) {
            logger20.error(`Invalid configuration "${key}" from ${id}, overwrite defaults is fobidden.`);
            return;
          }
          addToValueTree(contents, key, props[key], (msg) => {
            logger20.error(msg);
          });
        });
        let data = {
          defaults: { contents },
          user: this._configuration.user,
          workspace: this._configuration.workspace
        };
        this._configuration = Configurations.parse(data);
      }
      updateUserConfig(props) {
        if (!props || Object.keys(props).length == 0)
          return;
        let { user } = this._configuration;
        let model = user.clone();
        Object.keys(props).forEach((key) => {
          let val = props[key];
          if (val === void 0) {
            model.removeValue(key);
          } else if (objectLiteral(val)) {
            for (let k of Object.keys(val)) {
              model.setValue(`${key}.${k}`, val[k]);
            }
          } else {
            model.setValue(key, val);
          }
        });
        this.changeConfiguration(1 /* User */, model, void 0);
      }
      get defaults() {
        return this._configuration.defaults;
      }
      get user() {
        return this._configuration.user;
      }
      get workspace() {
        return this._configuration.workspace;
      }
      addFolderFile(filepath, change = true, fromCwd = false) {
        if (!import_fs3.default.existsSync(filepath))
          return false;
        if (sameFile(this.userConfigFile, filepath))
          return false;
        if (sameFile(filepath, import_path3.default.join(import_os2.default.homedir(), `.vim/${CONFIG_FILE_NAME}`)))
          return false;
        if (!this._folderConfigurations.has(filepath)) {
          this.watchFile(filepath, 2 /* Workspace */);
        }
        let model = this.updateFolderConfiguration(filepath);
        logger20.info(`Add folder configuration from ${fromCwd ? "cwd" : "file"}:`, filepath);
        if (!change)
          return true;
        if (this.workspaceConfigFile !== filepath) {
          this.workspaceConfigFile = filepath;
          logger20.info(`Change folder configuration from ${fromCwd ? "cwd" : "file"} to:`, filepath);
          this.changeConfiguration(2 /* Workspace */, model, filepath);
        }
        return true;
      }
      addFolderFromCwd() {
        let filepath = import_path3.default.join(this.cwd, `.vim/${CONFIG_FILE_NAME}`);
        this.addFolderFile(filepath, true, true);
      }
      watchFile(filepath, target) {
        if (!import_fs3.default.existsSync(filepath) || global.__TEST__)
          return;
        let isWorkspace = target === 2 /* Workspace */;
        let disposable = watchFile(filepath, () => {
          let model = this.parseContentFromFile(filepath);
          if (isWorkspace) {
            this._folderConfigurations.set(filepath, new ConfigurationModel(model.contents));
            if (sameFile(this.workspaceConfigFile, filepath)) {
              this.changeConfiguration(target, model, filepath);
            }
          } else {
            this.changeConfiguration(target, model, filepath);
          }
        });
        this.disposables.push(disposable);
      }
      updateFolderConfiguration(configFile) {
        let model = this.parseContentFromFile(configFile);
        this._folderConfigurations.set(configFile, new ConfigurationModel(model.contents));
        return model;
      }
      changeConfiguration(target, model, folderConfigFile) {
        let { defaults: defaults3, user, workspace } = this._configuration;
        let data = {
          defaults: target == 0 /* Global */ ? model : defaults3,
          user: target == 1 /* User */ ? model : user,
          workspace: target == 2 /* Workspace */ ? model : workspace
        };
        let configuration = Configurations.parse(data);
        let changed = getChangedKeys(this._configuration.getValue(), configuration.getValue());
        if (changed.length == 0)
          return;
        this._configuration = configuration;
        this._onChange.fire({
          affectsConfiguration: (section2, resource) => {
            if (!resource || !resource.startsWith("file:") || target != 2 /* Workspace */) {
              return changed.includes(section2);
            }
            let u = URI2.parse(resource);
            let filepath = u.fsPath;
            if (folderConfigFile && !isParentFolder(import_path3.default.resolve(folderConfigFile, "../.."), filepath)) {
              return false;
            }
            return changed.includes(section2);
          }
        });
      }
      loadDefaultConfigurations() {
        let file = import_path3.default.join(pluginRoot, "data/schema.json");
        let content = import_fs3.default.readFileSync(file, "utf8");
        let { properties } = JSON.parse(content);
        let config = {};
        let builtinKeys = [];
        Object.keys(properties).forEach((key) => {
          let value = properties[key].default;
          builtinKeys.push(key);
          if (value !== void 0) {
            addToValueTree(config, key, value, (message) => {
              logger20.error(message);
            });
          }
        });
        this.builtinKeys = builtinKeys;
        return { contents: config };
      }
      getFolderConfigFile(filepath) {
        let { folders } = this;
        let folder = folders.find((f) => isParentFolder(f, filepath, true));
        return folder ? import_path3.default.join(folder, `.vim/${CONFIG_FILE_NAME}`) : void 0;
      }
      getConfigFile(target) {
        if (target == 0 /* Global */)
          return null;
        if (target == 1 /* User */)
          return this.userConfigFile;
        return this.workspaceConfigFile;
      }
      get folders() {
        let res = [];
        let { _folderConfigurations } = this;
        for (let folder of _folderConfigurations.keys()) {
          res.push(import_path3.default.resolve(folder, "../.."));
        }
        return res;
      }
      get configuration() {
        return this._configuration;
      }
      getWorkspaceConfigUri(resource) {
        let uri;
        if (!resource) {
          uri = this.workspaceConfigFile ? URI2.file(this.workspaceConfigFile) : void 0;
        }
        if (!uri && this._proxy && typeof this._proxy.getWorkspaceConfig === "function") {
          uri = this._proxy.getWorkspaceConfig(resource);
          if (uri && sameFile(this.userConfigFile, uri.fsPath)) {
            uri = void 0;
          }
        }
        return uri;
      }
      getConfiguration(section2, resource) {
        let configuration;
        let localConfig;
        if (resource) {
          let { defaults: defaults3, user } = this._configuration;
          let [configUri, model] = this.getFolderConfiguration(resource);
          localConfig = configUri;
          configuration = new Configuration(defaults3, user, model);
        } else {
          localConfig = this.workspaceConfigFile ? URI2.file(this.workspaceConfigFile) : void 0;
          configuration = this._configuration;
        }
        const config = Object.freeze(lookUp(configuration.getValue(null), section2));
        const result = {
          has(key) {
            return typeof lookUp(config, key) !== "undefined";
          },
          get: (key, defaultValue) => {
            let result2 = lookUp(config, key);
            if (result2 == null)
              return defaultValue;
            return result2;
          },
          update: (key, value, isUser = false) => {
            let s = section2 ? `${section2}.${key}` : key;
            let target = isUser ? 1 /* User */ : 2 /* Workspace */;
            let model = target == 1 /* User */ ? this.user.clone() : this.workspace.clone();
            if (value === void 0) {
              model.removeValue(s);
            } else {
              model.setValue(s, value);
            }
            if (!localConfig)
              localConfig = this.getWorkspaceConfigUri(resource);
            if (localConfig && !sameFile(this.workspaceConfigFile, localConfig.fsPath)) {
              logger20.info(`Change folder configuration ${resource ? "by " + resource : ""} to:`, localConfig.fsPath);
              this.workspaceConfigFile = localConfig.fsPath;
            }
            this.changeConfiguration(target, model, target == 2 /* Workspace */ ? this.workspaceConfigFile : this.userConfigFile);
            if (!isUser && !localConfig) {
              if (!global.__TEST__)
                console.error(`Unable to locate workspace configuration ${resource ? "for " + resource : ""}, workspace folder not resolved.`);
              logger20.error(`Unable to locate workspace configuration`, resource);
              return;
            }
            let uri = isUser ? URI2.parse(this.userConfigFile) : localConfig;
            if (this._proxy && !global.__TEST__) {
              if (value === void 0) {
                this._proxy.$removeConfigurationOption(target, s, { resource: uri });
              } else {
                this._proxy.$updateConfigurationOption(target, s, value, { resource: uri });
              }
            }
            if (!isUser && localConfig)
              this.addFolderFile(localConfig.fsPath, false);
          },
          inspect: (key) => {
            key = section2 ? `${section2}.${key}` : key;
            const config2 = this._configuration.inspect(key);
            return {
              key,
              defaultValue: config2.default,
              globalValue: config2.user,
              workspaceValue: config2.workspace
            };
          }
        };
        Object.defineProperty(result, "has", {
          enumerable: false
        });
        Object.defineProperty(result, "get", {
          enumerable: false
        });
        Object.defineProperty(result, "update", {
          enumerable: false
        });
        Object.defineProperty(result, "inspect", {
          enumerable: false
        });
        if (typeof config === "object") {
          mixin(result, config, false);
        }
        return deepFreeze(result);
      }
      getFolderConfiguration(uri) {
        let u = URI2.parse(uri);
        let dir;
        if (u.scheme != "file") {
          dir = this.cwd;
        } else {
          dir = u.fsPath;
        }
        for (let [configFile, model] of this.foldConfigurations) {
          let root = import_path3.default.resolve(configFile, "../..");
          if (isParentFolder(root, dir, true))
            return [URI2.file(configFile), model];
        }
        return [void 0, new ConfigurationModel()];
      }
      resolveFolderConfigution(uri) {
        let u = URI2.parse(uri);
        if (u.scheme != "file")
          return;
        let rootPath = import_path3.default.dirname(u.fsPath);
        let configFile = this.getFolderConfigFile(rootPath);
        if (configFile)
          return configFile;
        let folder = findUp(".vim", rootPath);
        if (!folder)
          return;
        let filepath = import_path3.default.join(folder, CONFIG_FILE_NAME);
        let added = this.addFolderFile(filepath, false);
        if (!added)
          return;
        return filepath;
      }
      setFolderConfiguration(uri) {
        let u = URI2.parse(uri);
        if (u.scheme != "file")
          return;
        let filepath = u.fsPath;
        for (let [configFile, model] of this.foldConfigurations) {
          let root = import_path3.default.resolve(configFile, "../..");
          if (isParentFolder(root, filepath, true)) {
            if (this.workspaceConfigFile != configFile) {
              this.workspaceConfigFile = configFile;
              logger20.info(`Change folder configuration to:`, configFile);
              this.changeConfiguration(2 /* Workspace */, model, configFile);
            }
            break;
          }
        }
      }
      static parse(data) {
        const defaultConfiguration = new ConfigurationModel(data.defaults.contents);
        const userConfiguration = new ConfigurationModel(data.user.contents);
        const workspaceConfiguration = new ConfigurationModel(data.workspace.contents);
        return new Configuration(defaultConfiguration, userConfiguration, workspaceConfiguration, new ConfigurationModel());
      }
      reset() {
        this._errorItems = [];
        this._folderConfigurations.clear();
        let user = this.parseContentFromFile(this.userConfigFile);
        let data = {
          defaults: this.loadDefaultConfigurations(),
          user,
          workspace: { contents: {} }
        };
        this._configuration = Configurations.parse(data);
        this._onChange.fire({
          affectsConfiguration: () => {
            return true;
          }
        });
      }
      dispose() {
        this._folderConfigurations.clear();
        this._onError.dispose();
        this._onChange.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/configuration/shape.ts
var import_fs5, import_os3, import_path4, logger21, ConfigurationProxy;
var init_shape = __esm({
  "src/configuration/shape.ts"() {
    "use strict";
    import_fs5 = __toESM(require("fs"));
    init_main2();
    import_os3 = __toESM(require("os"));
    import_path4 = __toESM(require("path"));
    init_esm();
    init_util();
    init_fs();
    logger21 = require_logger2()("configuration-shape");
    ConfigurationProxy = class {
      constructor(resolver2) {
        this.resolver = resolver2;
      }
      modifyConfiguration(uri, key, value) {
        if (!uri || uri.scheme !== "file")
          return;
        logger21.info("modify configuration file:", uri.fsPath);
        let file = uri.fsPath;
        let dir = import_path4.default.dirname(file);
        let formattingOptions = { tabSize: 2, insertSpaces: true };
        if (!import_fs5.default.existsSync(dir))
          import_fs5.default.mkdirSync(dir, { recursive: true });
        let content = import_fs5.default.readFileSync(file, { encoding: "utf8", flag: "a+" });
        content = content || "{}";
        let edits = modify(content, [key], value, { formattingOptions });
        content = applyEdits(content, edits);
        import_fs5.default.writeFileSync(file, content, "utf8");
      }
      getWorkspaceConfig(resource) {
        let folder;
        if (resource) {
          if (typeof this.resolver.getWorkspaceFolder === "function") {
            let workspaceFolder = this.resolver.getWorkspaceFolder(resource);
            if (workspaceFolder)
              folder = URI2.parse(workspaceFolder.uri).fsPath;
          }
        } else {
          folder = this.resolver.root;
        }
        if (folder && !sameFile(folder, import_os3.default.homedir())) {
          return URI2.file(import_path4.default.join(folder, ".vim", CONFIG_FILE_NAME));
        }
        return void 0;
      }
      $updateConfigurationOption(_target, key, value, overrides) {
        this.modifyConfiguration(overrides == null ? void 0 : overrides.resource, key, value);
      }
      $removeConfigurationOption(_target, key, overrides) {
        this.modifyConfiguration(overrides == null ? void 0 : overrides.resource, key);
      }
    };
  }
});

// src/core/autocmds.ts
var import_fs_extra2, import_os4, import_path5, import_vscode_languageserver_protocol15, logger22, Autocmds;
var init_autocmds = __esm({
  "src/core/autocmds.ts"() {
    "use strict";
    import_fs_extra2 = __toESM(require_lib4());
    import_os4 = __toESM(require("os"));
    import_path5 = __toESM(require("path"));
    import_vscode_languageserver_protocol15 = __toESM(require_main2());
    init_util();
    logger22 = require_logger2()("core-autocmds");
    Autocmds = class {
      constructor(contentProvider, watchers) {
        this.contentProvider = contentProvider;
        this.watchers = watchers;
        this._dynAutocmd = false;
        this.autocmdMaxId = 0;
        this.autocmds = /* @__PURE__ */ new Map();
        this.disposables = [];
        this.contentProvider.onDidProviderChange(() => {
          this.setupDynamicAutocmd();
        }, null, this.disposables);
        this.watchers.onDidOptionChange(() => {
          this.setupDynamicAutocmd();
        }, null, this.disposables);
      }
      attach(nvim, env) {
        this.nvim = nvim;
        this.env = env;
      }
      async doAutocmd(id, args) {
        let autocmd = this.autocmds.get(id);
        if (autocmd) {
          let ev = Array.isArray(autocmd.event) ? autocmd.event.join(",") : autocmd.event;
          logger22.debug(`invoke ${autocmd.request ? "request" : "notify"} autocmd:`, ev);
          await Promise.resolve(autocmd.callback.apply(autocmd.thisArg, args));
        }
      }
      registerAutocmd(autocmd) {
        this.autocmdMaxId += 1;
        let id = this.autocmdMaxId;
        this.autocmds.set(id, autocmd);
        this.setupDynamicAutocmd();
        return import_vscode_languageserver_protocol15.Disposable.create(() => {
          this.autocmds.delete(id);
          this.setupDynamicAutocmd();
        });
      }
      setupDynamicAutocmd(force = false) {
        if (!force && !this._dynAutocmd)
          return;
        this._dynAutocmd = true;
        let schemes = this.contentProvider.schemes;
        let cmds = [];
        for (let scheme of schemes) {
          cmds.push(`autocmd BufReadCmd,FileReadCmd,SourceCmd ${scheme}:/* call coc#rpc#request('CocAutocmd', ['BufReadCmd','${scheme}', expand('<afile>')])`);
        }
        for (let [id, autocmd] of this.autocmds.entries()) {
          let args = autocmd.arglist && autocmd.arglist.length ? ", " + autocmd.arglist.join(", ") : "";
          let event = Array.isArray(autocmd.event) ? autocmd.event.join(",") : autocmd.event;
          let pattern = autocmd.pattern != null ? autocmd.pattern : "*";
          if (/\buser\b/i.test(event)) {
            pattern = "";
          }
          cmds.push(`autocmd ${event} ${pattern} call coc#rpc#${autocmd.request ? "request" : "notify"}('doAutocmd', [${id}${args}])`);
        }
        for (let key of this.watchers.options) {
          cmds.push(`autocmd OptionSet ${key} call coc#rpc#notify('OptionSet',[expand('<amatch>'), v:option_old, v:option_new])`);
        }
        let content = `
augroup coc_dynamic_autocmd
  autocmd!
  ${cmds.join("\n  ")}
augroup end`;
        if (this.nvim.hasFunction("nvim_exec")) {
          void this.nvim.exec(content, false);
        } else {
          let dir = import_path5.default.join(process.env.TMPDIR || import_os4.default.tmpdir(), `coc.nvim-${process.pid}.vim`);
          import_fs_extra2.default.mkdirSync(dir, { recursive: true });
          let filepath = import_path5.default.join(dir, `coc-${process.pid}.vim`);
          import_fs_extra2.default.writeFileSync(filepath, content, "utf8");
          let cmd = `source ${filepath}`;
          if (this.env.isCygwin && platform_exports.isWindows) {
            cmd = `execute "source" . substitute(system('cygpath ${filepath.replace(/\\/g, "/")}'), '\\n', '', 'g')`;
          }
          void this.nvim.command(cmd);
        }
      }
      dispose() {
        this.nvim.command(`augroup coc_dynamic_autocmd|  autocmd!|augroup end`, true);
        disposeAll(this.disposables);
      }
    };
  }
});

// src/core/contentProvider.ts
var import_vscode_languageserver_protocol16, ContentProvider;
var init_contentProvider = __esm({
  "src/core/contentProvider.ts"() {
    "use strict";
    import_vscode_languageserver_protocol16 = __toESM(require_main2());
    init_esm();
    init_events();
    init_util();
    ContentProvider = class {
      constructor(documents) {
        this.documents = documents;
        this.disposables = [];
        this.providers = /* @__PURE__ */ new Map();
        this._onDidProviderChange = new import_vscode_languageserver_protocol16.Emitter();
        this.onDidProviderChange = this._onDidProviderChange.event;
      }
      attach(nvim) {
        this.nvim = nvim;
        events_default.on("BufReadCmd", this.onBufReadCmd, this, this.disposables);
      }
      get schemes() {
        return Array.from(this.providers.keys());
      }
      async onBufReadCmd(scheme, uri) {
        let provider = this.providers.get(scheme);
        if (!provider)
          return;
        let tokenSource = new import_vscode_languageserver_protocol16.CancellationTokenSource();
        let content = await Promise.resolve(provider.provideTextDocumentContent(URI2.parse(uri), tokenSource.token));
        let buf = await this.nvim.buffer;
        await buf.setLines(content.split(/\r?\n/), {
          start: 0,
          end: -1,
          strictIndexing: false
        });
        process.nextTick(() => {
          void events_default.fire("BufCreate", [buf.id]);
        });
      }
      registerTextDocumentContentProvider(scheme, provider) {
        this.providers.set(scheme, provider);
        this._onDidProviderChange.fire();
        let disposables = [];
        if (provider.onDidChange) {
          provider.onDidChange(async (uri) => {
            let { buffer } = this.documents.getDocument(uri.toString());
            let tokenSource = new import_vscode_languageserver_protocol16.CancellationTokenSource();
            let content = await Promise.resolve(provider.provideTextDocumentContent(uri, tokenSource.token));
            await buffer.setLines(content.split(/\r?\n/), {
              start: 0,
              end: -1,
              strictIndexing: false
            });
          }, null, disposables);
        }
        return import_vscode_languageserver_protocol16.Disposable.create(() => {
          this.providers.delete(scheme);
          disposeAll(disposables);
          this._onDidProviderChange.fire();
        });
      }
      dispose() {
        disposeAll(this.disposables);
        this._onDidProviderChange.dispose();
        this.providers.clear();
      }
    };
  }
});

// node_modules/bytes/index.js
var require_bytes = __commonJS({
  "node_modules/bytes/index.js"(exports, module2) {
    "use strict";
    module2.exports = bytes2;
    module2.exports.format = format2;
    module2.exports.parse = parse4;
    var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
    var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
    var map = {
      b: 1,
      kb: 1 << 10,
      mb: 1 << 20,
      gb: 1 << 30,
      tb: Math.pow(1024, 4),
      pb: Math.pow(1024, 5)
    };
    var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
    function bytes2(value, options2) {
      if (typeof value === "string") {
        return parse4(value);
      }
      if (typeof value === "number") {
        return format2(value, options2);
      }
      return null;
    }
    function format2(value, options2) {
      if (!Number.isFinite(value)) {
        return null;
      }
      var mag = Math.abs(value);
      var thousandsSeparator = options2 && options2.thousandsSeparator || "";
      var unitSeparator = options2 && options2.unitSeparator || "";
      var decimalPlaces = options2 && options2.decimalPlaces !== void 0 ? options2.decimalPlaces : 2;
      var fixedDecimals = Boolean(options2 && options2.fixedDecimals);
      var unit = options2 && options2.unit || "";
      if (!unit || !map[unit.toLowerCase()]) {
        if (mag >= map.pb) {
          unit = "PB";
        } else if (mag >= map.tb) {
          unit = "TB";
        } else if (mag >= map.gb) {
          unit = "GB";
        } else if (mag >= map.mb) {
          unit = "MB";
        } else if (mag >= map.kb) {
          unit = "KB";
        } else {
          unit = "B";
        }
      }
      var val = value / map[unit.toLowerCase()];
      var str = val.toFixed(decimalPlaces);
      if (!fixedDecimals) {
        str = str.replace(formatDecimalsRegExp, "$1");
      }
      if (thousandsSeparator) {
        str = str.replace(formatThousandsRegExp, thousandsSeparator);
      }
      return str + unitSeparator + unit;
    }
    function parse4(val) {
      if (typeof val === "number" && !isNaN(val)) {
        return val;
      }
      if (typeof val !== "string") {
        return null;
      }
      var results = parseRegExp.exec(val);
      var floatValue;
      var unit = "b";
      if (!results) {
        floatValue = parseInt(val, 10);
        unit = "b";
      } else {
        floatValue = parseFloat(results[1]);
        unit = results[4].toLowerCase();
      }
      return Math.floor(map[unit] * floatValue);
    }
  }
});

// node_modules/fast-diff/diff.js
var require_diff = __commonJS({
  "node_modules/fast-diff/diff.js"(exports, module2) {
    var DIFF_DELETE = -1;
    var DIFF_INSERT = 1;
    var DIFF_EQUAL = 0;
    function diff_main(text1, text2, cursor_pos, _fix_unicode) {
      if (text1 === text2) {
        if (text1) {
          return [[DIFF_EQUAL, text1]];
        }
        return [];
      }
      if (cursor_pos != null) {
        var editdiff = find_cursor_edit_diff(text1, text2, cursor_pos);
        if (editdiff) {
          return editdiff;
        }
      }
      var commonlength = diff_commonPrefix(text1, text2);
      var commonprefix = text1.substring(0, commonlength);
      text1 = text1.substring(commonlength);
      text2 = text2.substring(commonlength);
      commonlength = diff_commonSuffix(text1, text2);
      var commonsuffix = text1.substring(text1.length - commonlength);
      text1 = text1.substring(0, text1.length - commonlength);
      text2 = text2.substring(0, text2.length - commonlength);
      var diffs = diff_compute_(text1, text2);
      if (commonprefix) {
        diffs.unshift([DIFF_EQUAL, commonprefix]);
      }
      if (commonsuffix) {
        diffs.push([DIFF_EQUAL, commonsuffix]);
      }
      diff_cleanupMerge(diffs, _fix_unicode);
      return diffs;
    }
    function diff_compute_(text1, text2) {
      var diffs;
      if (!text1) {
        return [[DIFF_INSERT, text2]];
      }
      if (!text2) {
        return [[DIFF_DELETE, text1]];
      }
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      var i = longtext.indexOf(shorttext);
      if (i !== -1) {
        diffs = [
          [DIFF_INSERT, longtext.substring(0, i)],
          [DIFF_EQUAL, shorttext],
          [DIFF_INSERT, longtext.substring(i + shorttext.length)]
        ];
        if (text1.length > text2.length) {
          diffs[0][0] = diffs[2][0] = DIFF_DELETE;
        }
        return diffs;
      }
      if (shorttext.length === 1) {
        return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
      }
      var hm = diff_halfMatch_(text1, text2);
      if (hm) {
        var text1_a = hm[0];
        var text1_b = hm[1];
        var text2_a = hm[2];
        var text2_b = hm[3];
        var mid_common = hm[4];
        var diffs_a = diff_main(text1_a, text2_a);
        var diffs_b = diff_main(text1_b, text2_b);
        return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
      }
      return diff_bisect_(text1, text2);
    }
    function diff_bisect_(text1, text2) {
      var text1_length = text1.length;
      var text2_length = text2.length;
      var max_d = Math.ceil((text1_length + text2_length) / 2);
      var v_offset = max_d;
      var v_length = 2 * max_d;
      var v12 = new Array(v_length);
      var v2 = new Array(v_length);
      for (var x = 0; x < v_length; x++) {
        v12[x] = -1;
        v2[x] = -1;
      }
      v12[v_offset + 1] = 0;
      v2[v_offset + 1] = 0;
      var delta = text1_length - text2_length;
      var front = delta % 2 !== 0;
      var k1start = 0;
      var k1end = 0;
      var k2start = 0;
      var k2end = 0;
      for (var d = 0; d < max_d; d++) {
        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
          var k1_offset = v_offset + k1;
          var x1;
          if (k1 === -d || k1 !== d && v12[k1_offset - 1] < v12[k1_offset + 1]) {
            x1 = v12[k1_offset + 1];
          } else {
            x1 = v12[k1_offset - 1] + 1;
          }
          var y1 = x1 - k1;
          while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) === text2.charAt(y1)) {
            x1++;
            y1++;
          }
          v12[k1_offset] = x1;
          if (x1 > text1_length) {
            k1end += 2;
          } else if (y1 > text2_length) {
            k1start += 2;
          } else if (front) {
            var k2_offset = v_offset + delta - k1;
            if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] !== -1) {
              var x2 = text1_length - v2[k2_offset];
              if (x1 >= x2) {
                return diff_bisectSplit_(text1, text2, x1, y1);
              }
            }
          }
        }
        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
          var k2_offset = v_offset + k2;
          var x2;
          if (k2 === -d || k2 !== d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
            x2 = v2[k2_offset + 1];
          } else {
            x2 = v2[k2_offset - 1] + 1;
          }
          var y2 = x2 - k2;
          while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) === text2.charAt(text2_length - y2 - 1)) {
            x2++;
            y2++;
          }
          v2[k2_offset] = x2;
          if (x2 > text1_length) {
            k2end += 2;
          } else if (y2 > text2_length) {
            k2start += 2;
          } else if (!front) {
            var k1_offset = v_offset + delta - k2;
            if (k1_offset >= 0 && k1_offset < v_length && v12[k1_offset] !== -1) {
              var x1 = v12[k1_offset];
              var y1 = v_offset + x1 - k1_offset;
              x2 = text1_length - x2;
              if (x1 >= x2) {
                return diff_bisectSplit_(text1, text2, x1, y1);
              }
            }
          }
        }
      }
      return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
    }
    function diff_bisectSplit_(text1, text2, x, y) {
      var text1a = text1.substring(0, x);
      var text2a = text2.substring(0, y);
      var text1b = text1.substring(x);
      var text2b = text2.substring(y);
      var diffs = diff_main(text1a, text2a);
      var diffsb = diff_main(text1b, text2b);
      return diffs.concat(diffsb);
    }
    function diff_commonPrefix(text1, text2) {
      if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerstart = 0;
      while (pointermin < pointermid) {
        if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
          pointermin = pointermid;
          pointerstart = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      if (is_surrogate_pair_start(text1.charCodeAt(pointermid - 1))) {
        pointermid--;
      }
      return pointermid;
    }
    function diff_commonSuffix(text1, text2) {
      if (!text1 || !text2 || text1.slice(-1) !== text2.slice(-1)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerend = 0;
      while (pointermin < pointermid) {
        if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
          pointermin = pointermid;
          pointerend = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      if (is_surrogate_pair_end(text1.charCodeAt(text1.length - pointermid))) {
        pointermid--;
      }
      return pointermid;
    }
    function diff_halfMatch_(text1, text2) {
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
        return null;
      }
      function diff_halfMatchI_(longtext2, shorttext2, i) {
        var seed = longtext2.substring(i, i + Math.floor(longtext2.length / 4));
        var j = -1;
        var best_common = "";
        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
        while ((j = shorttext2.indexOf(seed, j + 1)) !== -1) {
          var prefixLength = diff_commonPrefix(longtext2.substring(i), shorttext2.substring(j));
          var suffixLength = diff_commonSuffix(longtext2.substring(0, i), shorttext2.substring(0, j));
          if (best_common.length < suffixLength + prefixLength) {
            best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
            best_longtext_a = longtext2.substring(0, i - suffixLength);
            best_longtext_b = longtext2.substring(i + prefixLength);
            best_shorttext_a = shorttext2.substring(0, j - suffixLength);
            best_shorttext_b = shorttext2.substring(j + prefixLength);
          }
        }
        if (best_common.length * 2 >= longtext2.length) {
          return [
            best_longtext_a,
            best_longtext_b,
            best_shorttext_a,
            best_shorttext_b,
            best_common
          ];
        } else {
          return null;
        }
      }
      var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
      var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
      var hm;
      if (!hm1 && !hm2) {
        return null;
      } else if (!hm2) {
        hm = hm1;
      } else if (!hm1) {
        hm = hm2;
      } else {
        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
      }
      var text1_a, text1_b, text2_a, text2_b;
      if (text1.length > text2.length) {
        text1_a = hm[0];
        text1_b = hm[1];
        text2_a = hm[2];
        text2_b = hm[3];
      } else {
        text2_a = hm[0];
        text2_b = hm[1];
        text1_a = hm[2];
        text1_b = hm[3];
      }
      var mid_common = hm[4];
      return [text1_a, text1_b, text2_a, text2_b, mid_common];
    }
    function diff_cleanupMerge(diffs, fix_unicode) {
      diffs.push([DIFF_EQUAL, ""]);
      var pointer = 0;
      var count_delete = 0;
      var count_insert = 0;
      var text_delete = "";
      var text_insert = "";
      var commonlength;
      while (pointer < diffs.length) {
        if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
          diffs.splice(pointer, 1);
          continue;
        }
        switch (diffs[pointer][0]) {
          case DIFF_INSERT:
            count_insert++;
            text_insert += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_DELETE:
            count_delete++;
            text_delete += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_EQUAL:
            var previous_equality = pointer - count_insert - count_delete - 1;
            if (fix_unicode) {
              if (previous_equality >= 0 && ends_with_pair_start(diffs[previous_equality][1])) {
                var stray = diffs[previous_equality][1].slice(-1);
                diffs[previous_equality][1] = diffs[previous_equality][1].slice(0, -1);
                text_delete = stray + text_delete;
                text_insert = stray + text_insert;
                if (!diffs[previous_equality][1]) {
                  diffs.splice(previous_equality, 1);
                  pointer--;
                  var k = previous_equality - 1;
                  if (diffs[k] && diffs[k][0] === DIFF_INSERT) {
                    count_insert++;
                    text_insert = diffs[k][1] + text_insert;
                    k--;
                  }
                  if (diffs[k] && diffs[k][0] === DIFF_DELETE) {
                    count_delete++;
                    text_delete = diffs[k][1] + text_delete;
                    k--;
                  }
                  previous_equality = k;
                }
              }
              if (starts_with_pair_end(diffs[pointer][1])) {
                var stray = diffs[pointer][1].charAt(0);
                diffs[pointer][1] = diffs[pointer][1].slice(1);
                text_delete += stray;
                text_insert += stray;
              }
            }
            if (pointer < diffs.length - 1 && !diffs[pointer][1]) {
              diffs.splice(pointer, 1);
              break;
            }
            if (text_delete.length > 0 || text_insert.length > 0) {
              if (text_delete.length > 0 && text_insert.length > 0) {
                commonlength = diff_commonPrefix(text_insert, text_delete);
                if (commonlength !== 0) {
                  if (previous_equality >= 0) {
                    diffs[previous_equality][1] += text_insert.substring(0, commonlength);
                  } else {
                    diffs.splice(0, 0, [DIFF_EQUAL, text_insert.substring(0, commonlength)]);
                    pointer++;
                  }
                  text_insert = text_insert.substring(commonlength);
                  text_delete = text_delete.substring(commonlength);
                }
                commonlength = diff_commonSuffix(text_insert, text_delete);
                if (commonlength !== 0) {
                  diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                  text_insert = text_insert.substring(0, text_insert.length - commonlength);
                  text_delete = text_delete.substring(0, text_delete.length - commonlength);
                }
              }
              var n = count_insert + count_delete;
              if (text_delete.length === 0 && text_insert.length === 0) {
                diffs.splice(pointer - n, n);
                pointer = pointer - n;
              } else if (text_delete.length === 0) {
                diffs.splice(pointer - n, n, [DIFF_INSERT, text_insert]);
                pointer = pointer - n + 1;
              } else if (text_insert.length === 0) {
                diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete]);
                pointer = pointer - n + 1;
              } else {
                diffs.splice(pointer - n, n, [DIFF_DELETE, text_delete], [DIFF_INSERT, text_insert]);
                pointer = pointer - n + 2;
              }
            }
            if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
              diffs[pointer - 1][1] += diffs[pointer][1];
              diffs.splice(pointer, 1);
            } else {
              pointer++;
            }
            count_insert = 0;
            count_delete = 0;
            text_delete = "";
            text_insert = "";
            break;
        }
      }
      if (diffs[diffs.length - 1][1] === "") {
        diffs.pop();
      }
      var changes = false;
      pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
          if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {
            diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
            diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
            diffs.splice(pointer - 1, 1);
            changes = true;
          } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
            diffs[pointer - 1][1] += diffs[pointer + 1][1];
            diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
            diffs.splice(pointer + 1, 1);
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        diff_cleanupMerge(diffs, fix_unicode);
      }
    }
    function is_surrogate_pair_start(charCode) {
      return charCode >= 55296 && charCode <= 56319;
    }
    function is_surrogate_pair_end(charCode) {
      return charCode >= 56320 && charCode <= 57343;
    }
    function starts_with_pair_end(str) {
      return is_surrogate_pair_end(str.charCodeAt(0));
    }
    function ends_with_pair_start(str) {
      return is_surrogate_pair_start(str.charCodeAt(str.length - 1));
    }
    function remove_empty_tuples(tuples) {
      var ret = [];
      for (var i = 0; i < tuples.length; i++) {
        if (tuples[i][1].length > 0) {
          ret.push(tuples[i]);
        }
      }
      return ret;
    }
    function make_edit_splice(before, oldMiddle, newMiddle, after) {
      if (ends_with_pair_start(before) || starts_with_pair_end(after)) {
        return null;
      }
      return remove_empty_tuples([
        [DIFF_EQUAL, before],
        [DIFF_DELETE, oldMiddle],
        [DIFF_INSERT, newMiddle],
        [DIFF_EQUAL, after]
      ]);
    }
    function find_cursor_edit_diff(oldText, newText, cursor_pos) {
      var oldRange = typeof cursor_pos === "number" ? { index: cursor_pos, length: 0 } : cursor_pos.oldRange;
      var newRange = typeof cursor_pos === "number" ? null : cursor_pos.newRange;
      var oldLength = oldText.length;
      var newLength = newText.length;
      if (oldRange.length === 0 && (newRange === null || newRange.length === 0)) {
        var oldCursor = oldRange.index;
        var oldBefore = oldText.slice(0, oldCursor);
        var oldAfter = oldText.slice(oldCursor);
        var maybeNewCursor = newRange ? newRange.index : null;
        editBefore: {
          var newCursor = oldCursor + newLength - oldLength;
          if (maybeNewCursor !== null && maybeNewCursor !== newCursor) {
            break editBefore;
          }
          if (newCursor < 0 || newCursor > newLength) {
            break editBefore;
          }
          var newBefore = newText.slice(0, newCursor);
          var newAfter = newText.slice(newCursor);
          if (newAfter !== oldAfter) {
            break editBefore;
          }
          var prefixLength = Math.min(oldCursor, newCursor);
          var oldPrefix = oldBefore.slice(0, prefixLength);
          var newPrefix = newBefore.slice(0, prefixLength);
          if (oldPrefix !== newPrefix) {
            break editBefore;
          }
          var oldMiddle = oldBefore.slice(prefixLength);
          var newMiddle = newBefore.slice(prefixLength);
          return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldAfter);
        }
        editAfter: {
          if (maybeNewCursor !== null && maybeNewCursor !== oldCursor) {
            break editAfter;
          }
          var cursor = oldCursor;
          var newBefore = newText.slice(0, cursor);
          var newAfter = newText.slice(cursor);
          if (newBefore !== oldBefore) {
            break editAfter;
          }
          var suffixLength = Math.min(oldLength - cursor, newLength - cursor);
          var oldSuffix = oldAfter.slice(oldAfter.length - suffixLength);
          var newSuffix = newAfter.slice(newAfter.length - suffixLength);
          if (oldSuffix !== newSuffix) {
            break editAfter;
          }
          var oldMiddle = oldAfter.slice(0, oldAfter.length - suffixLength);
          var newMiddle = newAfter.slice(0, newAfter.length - suffixLength);
          return make_edit_splice(oldBefore, oldMiddle, newMiddle, oldSuffix);
        }
      }
      if (oldRange.length > 0 && newRange && newRange.length === 0) {
        replaceRange: {
          var oldPrefix = oldText.slice(0, oldRange.index);
          var oldSuffix = oldText.slice(oldRange.index + oldRange.length);
          var prefixLength = oldPrefix.length;
          var suffixLength = oldSuffix.length;
          if (newLength < prefixLength + suffixLength) {
            break replaceRange;
          }
          var newPrefix = newText.slice(0, prefixLength);
          var newSuffix = newText.slice(newLength - suffixLength);
          if (oldPrefix !== newPrefix || oldSuffix !== newSuffix) {
            break replaceRange;
          }
          var oldMiddle = oldText.slice(prefixLength, oldLength - suffixLength);
          var newMiddle = newText.slice(prefixLength, newLength - suffixLength);
          return make_edit_splice(oldPrefix, oldMiddle, newMiddle, oldSuffix);
        }
      }
      return null;
    }
    function diff(text1, text2, cursor_pos) {
      return diff_main(text1, text2, cursor_pos, true);
    }
    diff.INSERT = DIFF_INSERT;
    diff.DELETE = DIFF_DELETE;
    diff.EQUAL = DIFF_EQUAL;
    module2.exports = diff;
  }
});

// src/util/diff.ts
function diffLines(oldLines, newLines, startLine) {
  let endOffset = 0;
  let startOffset = 0;
  let parts = oldLines.slice(startLine + 1);
  for (let i = 0; i < Math.min(parts.length, newLines.length); i++) {
    if (parts[parts.length - 1 - i] == newLines[newLines.length - 1 - i]) {
      endOffset = endOffset + 1;
    } else {
      break;
    }
  }
  for (let i = 0; i <= Math.min(startLine, newLines.length - 1 - endOffset); i++) {
    if (oldLines[i] == newLines[i]) {
      startOffset = startOffset + 1;
    } else {
      break;
    }
  }
  let replacement = newLines.slice(startOffset, newLines.length - endOffset);
  let end = oldLines.length - endOffset;
  if (end > startOffset && replacement.length) {
    let offset = 0;
    for (let i = 0; i < Math.min(replacement.length, end - startOffset); i++) {
      if (replacement[i] == oldLines[startOffset + i]) {
        offset = offset + 1;
      } else {
        break;
      }
    }
    if (offset) {
      return {
        start: startOffset + offset,
        end,
        replacement: replacement.slice(offset)
      };
    }
  }
  return {
    start: startOffset,
    end,
    replacement
  };
}
function patchLine(from, to, fill = " ") {
  if (from == to)
    return to;
  let idx = to.indexOf(from);
  if (idx !== -1)
    return fill.repeat(idx) + from;
  let result = (0, import_fast_diff.default)(from, to);
  let str = "";
  for (let item of result) {
    if (item[0] == import_fast_diff.default.DELETE) {
      return to;
    } else if (item[0] == import_fast_diff.default.INSERT) {
      str = str + fill.repeat(byteLength(item[1]));
    } else {
      str = str + item[1];
    }
  }
  return str;
}
function getTextEdit(oldLines, newLines, cursor, insertMode) {
  let ol = oldLines.length;
  let nl = newLines.length;
  let n = cursor ? cursor.line : Math.min(ol, nl);
  let used = 0;
  for (let i = 0; i < n; i++) {
    if (newLines[i] === oldLines[i]) {
      used += 1;
    } else {
      break;
    }
  }
  if (ol == nl && used == ol)
    return void 0;
  let delta = nl - ol;
  let r = Math.min(ol - used, nl - used);
  let e = 0;
  for (let i = 0; i < r; i++) {
    if (newLines[nl - i - 1] === oldLines[ol - i - 1]) {
      e += 1;
    } else {
      break;
    }
  }
  let inserted = e == 0 ? newLines.slice(used) : newLines.slice(used, -e);
  if (delta == 0 && cursor && inserted.length == 1) {
    let newLine = newLines[used];
    let oldLine = oldLines[used];
    let nl2 = newLine.length;
    let ol2 = oldLine.length;
    if (nl2 === 0)
      return TextEdit.del(Range.create(used, 0, used, ol2));
    if (ol2 === 0)
      return TextEdit.insert(Position.create(used, 0), newLine);
    let character = Math.min(cursor.character, nl2);
    if (!insertMode && nl2 >= ol2 && character !== nl2) {
      character += 1;
    }
    let r2 = 0;
    for (let i = 0; i < nl2 - character; i++) {
      let idx = ol2 - 1 - i;
      if (idx === -1)
        break;
      if (newLine[nl2 - 1 - i] === oldLine[idx]) {
        r2 += 1;
      } else {
        break;
      }
    }
    let l = 0;
    for (let i = 0; i < Math.min(ol2 - r2, nl2 - r2); i++) {
      if (newLine[i] === oldLine[i]) {
        l += 1;
      } else {
        break;
      }
    }
    let newText = r2 === 0 ? newLine.slice(l) : newLine.slice(l, -r2);
    return TextEdit.replace(Range.create(used, l, used, ol2 - r2), newText);
  }
  let text = inserted.length > 0 ? inserted.join("\n") + "\n" : "";
  if (text.length === 0 && used === ol - e)
    return void 0;
  return TextEdit.replace(Range.create(used, 0, ol - e, 0), text);
}
var import_fast_diff, logger23;
var init_diff = __esm({
  "src/util/diff.ts"() {
    "use strict";
    import_fast_diff = __toESM(require_diff());
    init_main();
    init_string();
    logger23 = require_logger2()("util-diff");
  }
});

// src/util/textedit.ts
function getStartLine(edit2) {
  let { start, end } = edit2.range;
  if (edit2.newText.endsWith("\n") && start.line == end.line && start.character == 0 && end.character == 0) {
    return start.line - 1;
  }
  return start.line;
}
function lineCountChange(edit2) {
  let { newText } = edit2;
  let range2 = getWellformedRange2(edit2.range);
  let n = range2.end.line - range2.start.line;
  return newText.split(/\r?\n/).length - n - 1;
}
function getWellformedRange2(range2) {
  const start = range2.start;
  const end = range2.end;
  if (start.line > end.line || start.line === end.line && start.character > end.character) {
    return { start: end, end: start };
  }
  return range2;
}
function mergeSort2(data, compare) {
  if (data.length <= 1) {
    return data;
  }
  const p = data.length / 2 | 0;
  const left = data.slice(0, p);
  const right = data.slice(p);
  mergeSort2(left, compare);
  mergeSort2(right, compare);
  let leftIdx = 0;
  let rightIdx = 0;
  let i = 0;
  while (leftIdx < left.length && rightIdx < right.length) {
    let ret = compare(left[leftIdx], right[rightIdx]);
    if (ret <= 0) {
      data[i++] = left[leftIdx++];
    } else {
      data[i++] = right[rightIdx++];
    }
  }
  while (leftIdx < left.length) {
    data[i++] = left[leftIdx++];
  }
  while (rightIdx < right.length) {
    data[i++] = right[rightIdx++];
  }
  return data;
}
function emptyWorkspaceEdit(edit2) {
  let { changes, documentChanges } = edit2;
  if (documentChanges && documentChanges.length)
    return false;
  if (changes && Object.keys(changes).length)
    return false;
  return true;
}
function getConfirmAnnotations(changes, changeAnnotations) {
  var _a;
  let keys = [];
  for (let change of changes) {
    let key = getAnnotationKey(change);
    if (key && !keys.includes(key) && ((_a = changeAnnotations[key]) == null ? void 0 : _a.needsConfirmation))
      keys.push(key);
  }
  return keys;
}
function getAnnotationKey(change) {
  let key;
  if (import_vscode_languageserver_protocol17.TextDocumentEdit.is(change)) {
    if (import_vscode_languageserver_protocol17.AnnotatedTextEdit.is(change.edits[0])) {
      key = change.edits[0].annotationId;
    }
  } else {
    key = change.annotationId;
  }
  return key;
}
function toDocumentChanges(edit2) {
  if (edit2.documentChanges)
    return edit2.documentChanges;
  let changes = [];
  if (edit2.changes) {
    for (let [uri, edits] of Object.entries(edit2.changes)) {
      changes.push({ textDocument: { uri, version: null }, edits });
    }
  }
  return changes;
}
function filterSortEdits(textDocument, edits) {
  let res = [];
  let end = textDocument.end;
  let checkEnd = end.line > 0 && end.character == 0;
  let prevDelete;
  for (let i = 0; i < edits.length; i++) {
    let edit2 = edits[i];
    let { newText } = edit2;
    let range2 = toValidRange(edit2.range);
    if (prevDelete) {
      if (samePosition(prevDelete, range2.start) && emptyRange(range2) && newText.length > 0) {
        let last = res[res.length - 1];
        last.newText = newText;
        prevDelete = void 0;
        continue;
      }
      prevDelete = void 0;
    }
    if (newText.includes("\r"))
      newText = newText.replace(/\r\n/g, "\n");
    let d = comparePosition(range2.end, end);
    if (d > 0)
      range2.end = { line: end.line, character: end.character };
    if (textDocument.getText(range2) !== newText) {
      if (d === 0 && checkEnd && !emptyRange(range2) && newText.endsWith("\n")) {
        newText = newText.slice(0, -1);
        let text = textDocument.lines[end.line - 1];
        range2.end = import_vscode_languageserver_protocol17.Position.create(end.line - 1, text.length);
      } else if (newText.length == 0) {
        prevDelete = range2.start;
      }
      res.push({ range: range2, newText });
    }
  }
  return mergeSort2(res, (a, b) => {
    let diff = a.range.start.line - b.range.start.line;
    if (diff === 0) {
      return a.range.start.character - b.range.start.character;
    }
    return diff;
  });
}
function applyEdits2(document2, edits) {
  if (edits.length == 1) {
    let { start, end } = edits[0].range;
    let { lines } = document2;
    let sl = lines[start.line] ?? "";
    let el = lines[end.line] ?? "";
    let content = sl.substring(0, start.character) + edits[0].newText + el.substring(end.character);
    if (end.line >= lines.length && document2.eol) {
      if (content == "")
        return [...lines.slice(0, start.line)];
      if (content.endsWith("\n"))
        content = content.slice(0, -1);
      return [...lines.slice(0, start.line), ...content.split("\n")];
    }
    return [...lines.slice(0, start.line), ...content.split("\n"), ...lines.slice(end.line + 1)];
  }
  let text = document2.getText();
  let lastModifiedOffset = 0;
  const spans = [];
  for (const e of edits) {
    let startOffset = document2.offsetAt(e.range.start);
    if (startOffset < lastModifiedOffset) {
      throw new Error("Overlapping edit");
    } else if (startOffset > lastModifiedOffset) {
      spans.push(text.substring(lastModifiedOffset, startOffset));
    }
    if (e.newText.length) {
      spans.push(e.newText);
    }
    lastModifiedOffset = document2.offsetAt(e.range.end);
  }
  spans.push(text.substring(lastModifiedOffset));
  let result = spans.join("");
  if (result === text)
    return void 0;
  return contentToLines(result, document2.eol);
}
function toTextChanges(lines, edits) {
  return edits.map((o) => {
    let { start, end } = o.range;
    let sl = lines[start.line] ?? "";
    let sc = byteLength(sl.slice(0, start.character));
    let el = end.line == start.line ? sl : lines[end.line] ?? "";
    let ec = byteLength(el.slice(0, end.character));
    let { newText } = o;
    return [newText.length > 0 ? newText.split("\n") : [], start.line, sc, end.line, ec];
  });
}
function getChangedPosition(start, edit2) {
  let { range: range2, newText } = edit2;
  if (comparePosition(range2.end, start) <= 0) {
    let lines = newText.split("\n");
    let lineCount = lines.length - (range2.end.line - range2.start.line) - 1;
    let character = start.character;
    if (range2.end.line == start.line) {
      let last = lines[lines.length - 1].length;
      if (lines.length > 1) {
        character = last + character - range2.end.character;
      } else {
        character = range2.start.character + last + character - range2.end.character;
      }
    }
    return { line: lineCount, character: character - start.character };
  }
  return { line: 0, character: 0 };
}
function getPosition(start, edit2) {
  let { line, character } = start;
  let { range: range2, newText } = edit2;
  let { end } = range2;
  let lines = newText.split("\n");
  let lineCount = lines.length - (end.line - range2.start.line) - 1;
  let c = range2.end.line - start.line;
  if (c > 0)
    return { line, character };
  if (c < 0)
    return { line: line + lineCount, character };
  if (lines.length > 1) {
    let last = lines[lines.length - 1].length;
    return { line: line + lineCount, character: last + character - end.character };
  }
  let d = range2.start.character - range2.end.character;
  return { line: line + lineCount, character: d + newText.length + character };
}
function getPositionFromEdits(start, edits) {
  let position = import_vscode_languageserver_protocol17.Position.create(start.line, start.character);
  let before = false;
  for (let i = edits.length - 1; i >= 0; i--) {
    let edit2 = edits[i];
    if (before) {
      position.line += lineCountChange(edit2);
      continue;
    }
    let d = comparePosition(edit2.range.end, position);
    if (d > 0)
      continue;
    if (edit2.range.end.line == position.line) {
      position = getPosition(position, edit2);
    } else {
      before = true;
      position.line += lineCountChange(edit2);
    }
  }
  return position;
}
function getChangedLineCount(start, edits) {
  let total = 0;
  for (let edit2 of edits) {
    let r = getWellformedRange2(edit2.range);
    if (comparePosition(r.end, start) <= 0) {
      total += lineCountChange(edit2);
    }
  }
  return total;
}
function mergeTextEdits(edits, oldLines, newLines) {
  let start = edits[0].range.start;
  let end = edits[edits.length - 1].range.end;
  let lr = oldLines.length - end.line;
  let cr = (oldLines[end.line] ?? "").length - end.character;
  let line = newLines.length - lr;
  let character = (newLines[line] ?? "").length - cr;
  let newText = getText(start, import_vscode_languageserver_protocol17.Position.create(line, character), newLines);
  return import_vscode_languageserver_protocol17.TextEdit.replace(import_vscode_languageserver_protocol17.Range.create(start, end), newText);
}
function getText(start, end, lines) {
  if (start.line === end.line) {
    return (lines[start.line] ?? "").slice(start.character, end.character);
  }
  let spans = [];
  for (let i = start.line; i <= end.line; i++) {
    let s = lines[i] ?? "";
    if (i === start.line) {
      spans.push(s.slice(start.character));
    } else if (i === end.line) {
      spans.push(s.slice(0, end.character));
    } else {
      spans.push(s);
    }
  }
  return spans.join("\n");
}
var import_vscode_languageserver_protocol17;
var init_textedit = __esm({
  "src/util/textedit.ts"() {
    "use strict";
    import_vscode_languageserver_protocol17 = __toESM(require_main2());
    init_position();
    init_string();
  }
});

// src/model/chars.ts
var import_vscode_languageserver_protocol18, logger24, Range6, Chars;
var init_chars = __esm({
  "src/model/chars.ts"() {
    "use strict";
    import_vscode_languageserver_protocol18 = __toESM(require_main2());
    init_util();
    init_main3();
    logger24 = require_logger2()("model-chars");
    Range6 = class {
      constructor(start, end) {
        this.start = start;
        this.end = end ? end : start;
      }
      static fromKeywordOption(keywordOption) {
        let parts = keywordOption.split(",");
        let ranges = [];
        ranges.push(new Range6(65, 90));
        ranges.push(new Range6(97, 122));
        for (let part of parts) {
          if (part == "@") {
            ranges.push(new Range6(256, 65535));
          } else if (part == "@-@") {
            ranges.push(new Range6(64));
          } else if (/^\d+-\d+$/.test(part)) {
            let ms = part.match(/^(\d+)-(\d+)$/);
            ranges.push(new Range6(Number(ms[1]), Number(ms[2])));
          } else if (/^\d+$/.test(part)) {
            ranges.push(new Range6(Number(part)));
          } else {
            let c = part.charCodeAt(0);
            if (!ranges.some((o) => o.contains(c))) {
              ranges.push(new Range6(c));
            }
          }
        }
        return ranges;
      }
      contains(c) {
        return c >= this.start && c <= this.end;
      }
    };
    Chars = class {
      constructor(keywordOption) {
        this.ranges = [];
        if (keywordOption)
          this.ranges = Range6.fromKeywordOption(keywordOption);
      }
      addKeyword(ch) {
        let c = ch.charCodeAt(0);
        let { ranges } = this;
        if (!ranges.some((o) => o.contains(c))) {
          ranges.push(new Range6(c));
        }
      }
      clone() {
        let chars = new Chars();
        chars.ranges = this.ranges.slice();
        return chars;
      }
      setKeywordOption(keywordOption) {
        this.ranges = Range6.fromKeywordOption(keywordOption);
      }
      async matchLines(lines, min = 2, token) {
        let res = /* @__PURE__ */ new Set();
        let ts = Date.now();
        for (let line of lines) {
          if (line.length === 0)
            continue;
          let str = "";
          if (Date.now() - ts > 15) {
            await waitImmediate();
            ts = Date.now();
          }
          for (let codePoint of line) {
            if (token && token.isCancellationRequested)
              return void 0;
            let code = codePoint.codePointAt(0);
            let isKeyword = this.isKeywordCode(code);
            if (isKeyword) {
              str = str + codePoint;
            } else {
              if (str.length > 0) {
                if (str.length >= min && str.length < 48)
                  res.add(str);
                str = "";
              }
            }
          }
          if (str.length >= min && str.length < 48)
            res.add(str);
        }
        return res;
      }
      isKeywordCode(code) {
        if (code > 255)
          return true;
        if (code < 33)
          return false;
        return this.ranges.some((r) => r.contains(code));
      }
      isKeywordChar(ch) {
        let { ranges } = this;
        if (/\s/.test(ch))
          return false;
        let c = ch.charCodeAt(0);
        if (c < 33)
          return false;
        return ranges.some((r) => r.contains(c));
      }
      isKeyword(word) {
        for (let i = 0, l = word.length; i < l; i++) {
          if (!this.isKeywordChar(word[i]))
            return false;
        }
        return true;
      }
      getLocalifyBonus(sp, ep, lines, max = 10 * 1024) {
        let res = /* @__PURE__ */ new Map();
        let startLine = Math.max(0, sp.line - 50);
        let endLine = Math.min(lines.length, sp.line + 50);
        let content = lines.slice(startLine, endLine).join("\n");
        if (content.length > max) {
          let len2 = content.length;
          let finished = false;
          while (endLine > sp.line + 1) {
            let length = lines[endLine - 1].length;
            if (len2 - length < max) {
              finished = true;
              break;
            }
            endLine = endLine - 1;
            len2 -= length;
          }
          if (!finished) {
            while (startLine <= sp.line) {
              let length = lines[startLine].length;
              if (len2 - length < max) {
                break;
              }
              len2 -= length;
              startLine += 1;
            }
          }
          content = lines.slice(startLine, endLine).join("\n");
        }
        sp = import_vscode_languageserver_protocol18.Position.create(sp.line - startLine, sp.character);
        ep = import_vscode_languageserver_protocol18.Position.create(ep.line - startLine, ep.character);
        let doc = TextDocument2.create("", "", 1, content);
        let headCount = doc.offsetAt(sp);
        let len = content.length;
        let tailCount = len - doc.offsetAt(ep);
        let start = 0;
        let preKeyword = false;
        for (let i = 0; i < headCount; i++) {
          let iskeyword = this.isKeyword(content[i]);
          if (!preKeyword && iskeyword) {
            start = i;
          } else if (preKeyword && !iskeyword) {
            if (i - start > 1) {
              let str = content.substring(start, i);
              res.set(str, i / headCount);
            }
          }
          preKeyword = iskeyword;
        }
        start = len - tailCount;
        preKeyword = false;
        for (let i = start; i < content.length; i++) {
          let iskeyword = this.isKeyword(content[i]);
          if (!preKeyword && iskeyword) {
            start = i;
          } else if (preKeyword && (!iskeyword || i == len - 1)) {
            if (i - start > 1) {
              let end = i == len - 1 ? i + 1 : i;
              let str = content.substring(start, end);
              let score5 = res.get(str) || 0;
              let n = len - i + (end - start);
              if (n !== tailCount) {
                res.set(str, Math.max(score5, n / tailCount));
              }
            }
          }
          preKeyword = iskeyword;
        }
        return res;
      }
    };
  }
});

// src/model/textline.ts
var import_vscode_languageserver_protocol19, TextLine;
var init_textline = __esm({
  "src/model/textline.ts"() {
    "use strict";
    import_vscode_languageserver_protocol19 = __toESM(require_main2());
    TextLine = class {
      constructor(line, text, isLastLine) {
        this._line = line;
        this._text = text;
        this._isLastLine = isLastLine;
      }
      get lineNumber() {
        return this._line;
      }
      get text() {
        return this._text;
      }
      get range() {
        return import_vscode_languageserver_protocol19.Range.create(this._line, 0, this._line, this._text.length);
      }
      get rangeIncludingLineBreak() {
        return this._isLastLine ? this.range : import_vscode_languageserver_protocol19.Range.create(this._line, 0, this._line + 1, 0);
      }
      get firstNonWhitespaceCharacterIndex() {
        return /^(\s*)/.exec(this._text)[1].length;
      }
      get isEmptyOrWhitespace() {
        return this.firstNonWhitespaceCharacterIndex === this._text.length;
      }
    };
  }
});

// src/model/textdocument.ts
function computeLinesOffsets(lines, eol) {
  const result = [];
  let textOffset = 0;
  for (let line of lines) {
    result.push(textOffset);
    textOffset += line.length + 1;
  }
  if (eol)
    result.push(textOffset);
  return result;
}
var import_vscode_languageserver_protocol20, LinesTextDocument;
var init_textdocument = __esm({
  "src/model/textdocument.ts"() {
    "use strict";
    import_vscode_languageserver_protocol20 = __toESM(require_main2());
    init_textline();
    LinesTextDocument = class {
      constructor(uri, languageId, version2, lines, bufnr, eol) {
        this.uri = uri;
        this.languageId = languageId;
        this.version = version2;
        this.lines = lines;
        this.bufnr = bufnr;
        this.eol = eol;
      }
      get content() {
        if (!this._content) {
          this._content = this.lines.join("\n") + (this.eol ? "\n" : "");
        }
        return this._content;
      }
      get length() {
        if (!this._content) {
          let n = this.lines.reduce((p, c) => {
            return p + c.length + 1;
          }, 0);
          return this.eol ? n : n - 1;
        }
        return this._content.length;
      }
      get end() {
        let line = this.lineCount - 1;
        if (this.eol)
          return import_vscode_languageserver_protocol20.Position.create(line, 0);
        return import_vscode_languageserver_protocol20.Position.create(line, this.lines[line].length);
      }
      get lineCount() {
        return this.lines.length + (this.eol ? 1 : 0);
      }
      getText(range2) {
        if (range2) {
          let { start, end } = range2;
          if (start.line === end.line) {
            if (start.character === end.character)
              return "";
            let line = this.lines[start.line] ?? "";
            return line.substring(start.character, end.character);
          }
          return this.content.substring(this.offsetAt(range2.start), this.offsetAt(range2.end));
        }
        return this.content;
      }
      lineAt(lineOrPos) {
        const line = import_vscode_languageserver_protocol20.Position.is(lineOrPos) ? lineOrPos.line : lineOrPos;
        if (typeof line !== "number" || line < 0 || line >= this.lineCount || Math.floor(line) !== line) {
          throw new Error("Illegal value for `line`");
        }
        return new TextLine(line, this.lines[line] ?? "", line === this.lineCount - 1);
      }
      positionAt(offset) {
        offset = Math.max(Math.min(offset, this.content.length), 0);
        let lineOffsets = this.getLineOffsets();
        let low = 0;
        let high = lineOffsets.length;
        if (high === 0) {
          return { line: 0, character: offset };
        }
        while (low < high) {
          let mid = Math.floor((low + high) / 2);
          if (lineOffsets[mid] > offset) {
            high = mid;
          } else {
            low = mid + 1;
          }
        }
        let line = low - 1;
        return { line, character: offset - lineOffsets[line] };
      }
      offsetAt(position) {
        let lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
          return this.content.length;
        } else if (position.line < 0) {
          return 0;
        }
        let lineOffset = lineOffsets[position.line];
        let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this.content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
      }
      getLineOffsets() {
        if (this._lineOffsets === void 0) {
          this._lineOffsets = computeLinesOffsets(this.lines, this.eol);
        }
        return this._lineOffsets;
      }
    };
  }
});

// src/model/document.ts
function fireDetach(bufnr) {
  void events_default.fire("BufDetach", [bufnr]);
}
function fireLinesChanged(bufnr) {
  void events_default.fire("LinesChanged", [bufnr]);
}
var import_debounce3, import_vscode_languageserver_protocol21, logger25, Document;
var init_document = __esm({
  "src/model/document.ts"() {
    "use strict";
    import_debounce3 = __toESM(require_debounce());
    import_vscode_languageserver_protocol21 = __toESM(require_main2());
    init_esm();
    init_events();
    init_diff();
    init_util();
    init_object();
    init_position();
    init_string();
    init_textedit();
    init_chars();
    init_textdocument();
    logger25 = require_logger2()("model-document");
    Document = class {
      constructor(buffer, env, nvim, opts) {
        this.buffer = buffer;
        this.env = env;
        this.nvim = nvim;
        this.isIgnored = false;
        this.eol = true;
        this._disposed = false;
        this._attached = false;
        this._notAttachReason = "";
        this._previewwindow = false;
        this._winid = -1;
        this.disposables = [];
        this.lines = [];
        this._onDocumentChange = new import_vscode_languageserver_protocol21.Emitter();
        this.onDocumentChange = this._onDocumentChange.event;
        this.fireContentChanges = (0, import_debounce3.default)(() => {
          this._fireContentChanges();
        }, global.__TEST__ ? 20 : 150);
        this.fetchContent = (0, import_debounce3.default)(() => {
          void this._fetchContent();
        }, 100);
        this.init(opts);
      }
      get content() {
        return this.syncLines.join("\n") + (this.eol ? "\n" : "");
      }
      get attached() {
        return this._attached;
      }
      get textDocument() {
        return this._textDocument;
      }
      get syncLines() {
        return this._textDocument.lines;
      }
      get version() {
        return this._textDocument.version;
      }
      get bufnr() {
        return this.buffer.id;
      }
      get bufname() {
        return this._bufname;
      }
      get filetype() {
        return this._filetype;
      }
      get uri() {
        return this._uri;
      }
      get isCommandLine() {
        return this.uri && this.uri.endsWith("%5BCommand%20Line%5D");
      }
      get enabled() {
        return this.getVar("enabled", true);
      }
      get languageId() {
        let { _filetype } = this;
        return _filetype.includes(".") ? _filetype.match(/(.*?)\./)[1] : _filetype;
      }
      get changedtick() {
        return this._changedtick;
      }
      convertFiletype(filetype) {
        switch (filetype) {
          case "javascript.jsx":
            return "javascriptreact";
          case "typescript.jsx":
          case "typescript.tsx":
            return "typescriptreact";
          case "tex":
            return "latex";
          default: {
            let map = this.env.filetypeMap;
            return String(map[filetype] || filetype);
          }
        }
      }
      get schema() {
        return URI2.parse(this.uri).scheme;
      }
      get lineCount() {
        return this.lines.length;
      }
      get winid() {
        return this._winid;
      }
      get indentkeys() {
        return this._indentkeys;
      }
      get previewwindow() {
        return this._previewwindow;
      }
      init(opts) {
        let buftype = this.buftype = opts.buftype;
        this._indentkeys = opts.indentkeys;
        this._bufname = opts.bufname;
        this._previewwindow = !!opts.previewwindow;
        this._winid = opts.winid;
        this.variables = opts.variables || {};
        this._changedtick = opts.changedtick;
        this.eol = opts.eol == 1;
        this._uri = getUri(opts.fullpath, this.bufnr, buftype, this.env.isCygwin);
        if (Array.isArray(opts.lines)) {
          this.lines = opts.lines;
          this._noFetch = true;
          this._attached = true;
          this.attach();
        } else {
          if (!["", "acwrite"].includes(buftype)) {
            this._notAttachReason = `not a normal buffer, buftype "${buftype}"`;
          } else if (this.variables[`coc_enabled`] === 0) {
            this._notAttachReason = `b:coc_enabled = 0`;
          } else {
            this._notAttachReason = `buffer size ${opts.size} exceed coc.preferences.maxFileSize`;
          }
        }
        this._filetype = this.convertFiletype(opts.filetype);
        this.setIskeyword(opts.iskeyword);
        this.createTextDocument(1, this.lines);
      }
      get notAttachReason() {
        return this._notAttachReason;
      }
      attach() {
        if (this.env.isVim)
          return;
        let lines = this.lines;
        this.buffer.attach(true).then((res) => {
          if (!res)
            fireDetach(this.bufnr);
        }, (_e) => {
          fireDetach(this.bufnr);
        });
        this.buffer.listen("lines", (buf, tick, firstline, lastline, linedata) => {
          if (buf.id !== this.bufnr || !this._attached || tick == null)
            return;
          if (tick > this._changedtick) {
            this._changedtick = tick;
            lines = [...lines.slice(0, firstline), ...linedata, ...lastline == -1 ? [] : lines.slice(lastline)];
            if (lines.length == 0)
              lines = [""];
            this.lines = lines;
            fireLinesChanged(buf.id);
            if (events_default.pumvisible)
              return;
            this.fireContentChanges();
          }
        }, this.disposables);
        this.buffer.listen("detach", () => {
          fireDetach(this.bufnr);
        }, this.disposables);
      }
      get dirty() {
        return this.lines !== this.syncLines;
      }
      get hasChanged() {
        if (!this.dirty)
          return false;
        return !equals(this.lines, this.syncLines);
      }
      _fireContentChanges(edit2) {
        if (this.lines === this.syncLines)
          return;
        let textDocument = this._textDocument;
        let changes = [];
        if (!edit2) {
          let { cursor } = events_default;
          let pos;
          if (cursor && cursor.bufnr == this.bufnr) {
            let content = this.lines[cursor.lnum - 1] ?? "";
            pos = import_vscode_languageserver_protocol21.Position.create(cursor.lnum - 1, characterIndex(content, cursor.col - 1));
          }
          edit2 = getTextEdit(textDocument.lines, this.lines, pos, cursor ? cursor.insert : false);
        }
        let original;
        if (edit2) {
          original = textDocument.getText(edit2.range);
          changes.push({ range: edit2.range, text: edit2.newText, rangeLength: original.length });
        } else {
          original = "";
        }
        let created = this.createTextDocument(this.version + (edit2 ? 1 : 0), this.lines);
        this._onDocumentChange.fire(Object.freeze({
          bufnr: this.bufnr,
          original,
          originalLines: textDocument.lines,
          textDocument: { version: created.version, uri: this.uri },
          contentChanges: changes
        }));
      }
      async applyEdits(edits, joinUndo = false, move = false) {
        var _a;
        if (Array.isArray(arguments[1]))
          edits = arguments[1];
        if (!this._attached || edits.length === 0)
          return;
        this._forceSync();
        let textDocument = this.textDocument;
        edits = filterSortEdits(textDocument, edits);
        if (edits.length === 0)
          return;
        let newLines = applyEdits2(textDocument, edits);
        if (!newLines)
          return;
        let lines = textDocument.lines;
        let changed = diffLines(lines, newLines, getStartLine(edits[0]));
        if (changed.start === changed.end && changed.replacement.length == 0)
          return;
        let isAppend = changed.start === changed.end && changed.start === lines.length + (this.eol ? 0 : 1);
        let original = lines.slice(changed.start, changed.end);
        let changes = [];
        if (this.nvim.hasFunction("nvim_buf_set_text") && edits.length < 200 && changed.start !== changed.end && edits[edits.length - 1].range.end.line < lines.length + (this.eol ? 0 : 1)) {
          changes = toTextChanges(lines, edits);
        }
        let cursor;
        let isCurrent = events_default.bufnr == this.bufnr;
        let col;
        if (move && isCurrent && !isAppend) {
          let pos = import_vscode_languageserver_protocol21.Position.is(move) ? move : void 0;
          if (move === true && this.bufnr === ((_a = events_default.cursor) == null ? void 0 : _a.bufnr)) {
            let { col: col2, lnum } = events_default.cursor;
            pos = import_vscode_languageserver_protocol21.Position.create(lnum - 1, characterIndex(this.lines[lnum - 1], col2 - 1));
          }
          if (pos) {
            let position = getPositionFromEdits(pos, edits);
            if (comparePosition(pos, position) !== 0) {
              let content = newLines[position.line] ?? "";
              let col2 = byteIndex(content, position.character) + 1;
              cursor = [position.line + 1, col2];
            }
            col = byteIndex(this.lines[pos.line], pos.character) + 1;
          }
        }
        this.nvim.pauseNotification();
        if (isCurrent && joinUndo)
          this.nvim.command("undojoin", true);
        if (isAppend) {
          this.buffer.setLines(changed.replacement, { start: -1, end: -1 }, true);
        } else {
          this.nvim.call("coc#ui#set_lines", [
            this.bufnr,
            this._changedtick,
            original,
            changed.replacement,
            changed.start,
            changed.end,
            changes,
            cursor,
            col
          ], true);
        }
        this.nvim.resumeNotification(isCurrent, true);
        let textEdit = edits.length == 1 ? edits[0] : mergeTextEdits(edits, lines, newLines);
        await waitNextTick();
        this.lines = newLines;
        fireLinesChanged(this.bufnr);
        this.fireContentChanges.clear();
        this._fireContentChanges(textEdit);
        let range2 = import_vscode_languageserver_protocol21.Range.create(changed.start, 0, changed.start + changed.replacement.length, 0);
        return import_vscode_languageserver_protocol21.TextEdit.replace(range2, original.join("\n") + (original.length > 0 ? "\n" : ""));
      }
      async changeLines(lines) {
        let filtered = [];
        let newLines = this.lines.slice();
        for (let [lnum, text] of lines) {
          if (newLines[lnum] != text) {
            filtered.push([lnum, text]);
            newLines[lnum] = text;
          }
        }
        if (!filtered.length)
          return;
        this.nvim.call("coc#ui#change_lines", [this.bufnr, filtered], true);
        this.nvim.redrawVim();
        this.lines = newLines;
        fireLinesChanged(this.bufnr);
        this._forceSync();
      }
      _forceSync() {
        this.fireContentChanges.clear();
        this._fireContentChanges();
      }
      forceSync() {
        if (global.hasOwnProperty("__TEST__")) {
          this._forceSync();
        }
      }
      getOffset(lnum, col) {
        return this.textDocument.offsetAt({
          line: lnum - 1,
          character: col
        });
      }
      isWord(word) {
        return this.chars.isKeyword(word);
      }
      async matchWords(token) {
        return await this.chars.matchLines(this.textDocument.lines, 2, token);
      }
      getWordRangeAtPosition(position, extraChars, current = true) {
        let chars = this.chars.clone();
        if (extraChars && extraChars.length) {
          for (let ch2 of extraChars) {
            chars.addKeyword(ch2);
          }
        }
        let line = this.getline(position.line, current);
        let ch = line[position.character];
        if (ch == null || !chars.isKeywordChar(ch))
          return null;
        let start = position.character;
        let end = position.character + 1;
        while (start >= 0) {
          let ch2 = line[start - 1];
          if (!ch2 || !chars.isKeywordChar(ch2))
            break;
          start = start - 1;
        }
        while (end <= line.length) {
          let ch2 = line[end];
          if (!ch2 || !chars.isKeywordChar(ch2))
            break;
          end = end + 1;
        }
        return import_vscode_languageserver_protocol21.Range.create(position.line, start, position.line, end);
      }
      createTextDocument(version2, lines) {
        let { uri, languageId, eol } = this;
        let textDocument = this._textDocument = new LinesTextDocument(uri, languageId, version2, lines, this.bufnr, eol);
        return textDocument;
      }
      async _fetchContent(sync) {
        if (!this.env.isVim || !this._attached)
          return;
        let { nvim, bufnr, changedtick } = this;
        let o = await nvim.call("coc#util#get_buf_lines", [bufnr, changedtick]);
        this._noFetch = true;
        if (o) {
          this._changedtick = o.changedtick;
          this.lines = o.lines;
          fireLinesChanged(this.bufnr);
          if (sync) {
            this._forceSync();
          } else {
            this.fireContentChanges();
          }
        } else if (sync) {
          this._forceSync();
        }
      }
      changeLine(lnum, line, changedtick) {
        let curr = this.lines[lnum - 1];
        if (curr === void 0)
          return;
        let newLines = this.lines.slice();
        newLines[lnum - 1] = line;
        this.lines = newLines;
        fireLinesChanged(this.bufnr);
        this._changedtick = changedtick;
      }
      async patchChange(currentLine) {
        if (!this._attached)
          return;
        if (this.env.isVim) {
          if (currentLine) {
            let change = await this.nvim.call("coc#util#get_changeinfo", []);
            if (change.bufnr !== this.bufnr)
              return;
            if (change.changedtick < this._changedtick) {
              this._forceSync();
              return;
            }
            let { lnum, line, changedtick } = change;
            let curr = this.getline(lnum - 1);
            this._changedtick = changedtick;
            if (curr == line) {
              this._forceSync();
            } else {
              let newLines = this.lines.slice();
              newLines[lnum - 1] = line;
              this.lines = newLines;
              fireLinesChanged(this.bufnr);
              this._forceSync();
            }
          } else {
            this.fetchContent.clear();
            await this._fetchContent(true);
          }
        } else {
          this._changedtick = await this.buffer.getVar("changedtick");
          this._forceSync();
        }
      }
      getSymbolRanges(word) {
        let { version: version2, filetype, uri } = this;
        let textDocument = new LinesTextDocument(uri, filetype, version2, this.lines, this.bufnr, this.eol);
        let res = [];
        let content = textDocument.getText();
        let str = "";
        for (let i = 0, l = content.length; i < l; i++) {
          let ch = content[i];
          if (ch == "-" && str.length == 0) {
            continue;
          }
          let isKeyword = this.chars.isKeywordChar(ch);
          if (isKeyword) {
            str = str + ch;
          }
          if (str.length > 0 && !isKeyword && str == word) {
            res.push(import_vscode_languageserver_protocol21.Range.create(textDocument.positionAt(i - str.length), textDocument.positionAt(i)));
          }
          if (!isKeyword) {
            str = "";
          }
        }
        return res;
      }
      fixStartcol(position, valids) {
        let line = this.getline(position.line);
        if (!line)
          return null;
        let { character } = position;
        let start = line.slice(0, character);
        let col = byteLength(start);
        let { chars } = this;
        for (let i = start.length - 1; i >= 0; i--) {
          let c = start[i];
          if (c == " ")
            break;
          if (!chars.isKeywordChar(c) && !valids.includes(c)) {
            break;
          }
          col = col - byteLength(c);
        }
        return col;
      }
      addHighlights(items, hlGroup, range2, opts = {}) {
        let { start, end } = range2;
        if (emptyRange(range2))
          return;
        for (let line = start.line; line <= end.line; line++) {
          const text = this.getline(line, false);
          let colStart = line == start.line ? byteIndex(text, start.character) : 0;
          let colEnd = line == end.line ? byteIndex(text, end.character) : global.Buffer.byteLength(text);
          if (colStart >= colEnd)
            continue;
          items.push(Object.assign({ hlGroup, lnum: line, colStart, colEnd }, opts));
        }
      }
      getline(line, current = true) {
        if (current)
          return this.lines[line] || "";
        return this.syncLines[line] || "";
      }
      getLines(start, end) {
        return this.lines.slice(start ?? 0, end ?? this.lines.length);
      }
      getDocumentContent() {
        let content = this.lines.join("\n");
        return this.eol ? content + "\n" : content;
      }
      getVar(key, defaultValue) {
        let val = this.variables[`coc_${key}`];
        return val === void 0 ? defaultValue : val;
      }
      getPosition(lnum, col) {
        let line = this.getline(lnum - 1);
        if (!line || col == 0)
          return { line: lnum - 1, character: 0 };
        let pre = byteSlice(line, 0, col - 1);
        return { line: lnum - 1, character: pre.length };
      }
      getEndOffset(lnum, col, insert) {
        let total = 0;
        let len = this.lines.length;
        for (let i = lnum - 1; i < len; i++) {
          let line = this.lines[i];
          let l = line.length;
          if (i == lnum - 1 && l != 0) {
            let buf = global.Buffer.from(line, "utf8");
            let isEnd = buf.byteLength <= col - 1;
            if (!isEnd) {
              total = total + buf.slice(col - 1, buf.length).toString("utf8").length;
              if (!insert)
                total = total - 1;
            }
          } else {
            total = total + l;
          }
          if (!this.eol && i == len - 1)
            break;
          total = total + 1;
        }
        return total;
      }
      setFiletype(filetype) {
        this._filetype = this.convertFiletype(filetype);
        let lines = this._textDocument.lines;
        this._textDocument = new LinesTextDocument(this.uri, this.languageId, 1, lines, this.bufnr, this.eol);
      }
      setIskeyword(iskeyword) {
        let chars = this.chars = new Chars(iskeyword);
        let additional = this.getVar("additional_keywords", []);
        if (additional && Array.isArray(additional)) {
          for (let ch of additional) {
            chars.addKeyword(ch);
          }
        }
      }
      detach() {
        if (this._disposed)
          return;
        disposeAll(this.disposables);
        this._disposed = true;
        this._attached = false;
        this.lines = [];
        this.fetchContent.clear();
        this.fireContentChanges.clear();
        this._onDocumentChange.dispose();
      }
      getLocalifyBonus(sp, ep, max) {
        return this.chars.getLocalifyBonus(sp, ep, this.lines, max);
      }
      async synchronize() {
        if (!this.attached)
          return;
        let { changedtick } = this;
        await this.patchChange();
        if (changedtick != this.changedtick) {
          await wait(50);
        }
      }
      onTextChange(event, change) {
        if (event === "TextChanged" || event === "TextChangedI" && !change.insertChar || !this._noFetch) {
          this._noFetch = false;
          this.fetchContent();
          return;
        }
        let { line, changedtick, lnum } = change;
        if (changedtick === this.changedtick)
          return;
        this.changeLine(lnum, line, changedtick);
        if (event !== "TextChangedP")
          this._forceSync();
      }
    };
  }
});

// src/core/documents.ts
var import_bytes, import_fs7, import_os5, import_path6, import_vscode_languageserver_protocol22, logger26, Documents;
var init_documents = __esm({
  "src/core/documents.ts"() {
    "use strict";
    import_bytes = __toESM(require_bytes());
    import_fs7 = __toESM(require("fs"));
    import_os5 = __toESM(require("os"));
    import_path6 = __toESM(require("path"));
    import_vscode_languageserver_protocol22 = __toESM(require_main2());
    init_esm();
    init_events();
    init_document();
    init_util();
    init_fs();
    init_string();
    logger26 = require_logger2()("core-documents");
    Documents = class {
      constructor(configurations, workspaceFolder) {
        this.configurations = configurations;
        this.workspaceFolder = workspaceFolder;
        this._initialized = false;
        this._attached = false;
        this._currentResolve = false;
        this.disposables = [];
        this.creating = /* @__PURE__ */ new Map();
        this.buffers = /* @__PURE__ */ new Map();
        this.winids = /* @__PURE__ */ new Set();
        this.resolves = [];
        this._onDidOpenTextDocument = new import_vscode_languageserver_protocol22.Emitter();
        this._onDidCloseDocument = new import_vscode_languageserver_protocol22.Emitter();
        this._onDidChangeDocument = new import_vscode_languageserver_protocol22.Emitter();
        this._onDidSaveDocument = new import_vscode_languageserver_protocol22.Emitter();
        this._onWillSaveDocument = new import_vscode_languageserver_protocol22.Emitter();
        this.onDidOpenTextDocument = this._onDidOpenTextDocument.event;
        this.onDidCloseDocument = this._onDidCloseDocument.event;
        this.onDidChangeDocument = this._onDidChangeDocument.event;
        this.onDidSaveTextDocument = this._onDidSaveDocument.event;
        this.onWillSaveTextDocument = this._onWillSaveDocument.event;
        this._cwd = process.cwd();
        this.config = { willSaveHandlerTimeout: 500, maxFileSize: 2097152 };
      }
      async attach(nvim, env) {
        if (this._attached)
          return;
        this.nvim = nvim;
        this._env = env;
        this._attached = true;
        this.getConfiguration();
        this.configurations.onDidChange(this.getConfiguration, this, this.disposables);
        let { bufnrs, winid, bufnr, winids } = await this.nvim.call("coc#util#all_state");
        this.winids = new Set(winids);
        this._bufnr = bufnr;
        await Promise.all(bufnrs.map((bufnr2) => this.createDocument(bufnr2)));
        events_default.on("BufDetach", this.onBufDetach, this, this.disposables);
        events_default.on("VimLeavePre", () => {
          this.resolveCurrent(void 0);
        }, null, this.disposables);
        events_default.on("WinEnter", (winid2) => {
          this.winids.add(winid2);
        }, null, this.disposables);
        events_default.on("BufWinEnter", (_, winid2) => {
          this.winids.add(winid2);
        }, null, this.disposables);
        events_default.on("DirChanged", (cwd) => {
          this._cwd = cwd;
        }, null, this.disposables);
        events_default.on("CursorHold", async () => {
          let { bufnrs: bufnrs2, winids: winids2 } = await this.nvim.call("coc#util#all_state");
          for (let bufnr2 of this.buffers.keys()) {
            if (!bufnrs2.includes(bufnr2))
              void events_default.fire("BufUnload", [bufnr2]);
          }
          for (let winid2 of this.winids) {
            if (!winids2.includes(winid2))
              void events_default.fire("WinClosed", [winid2]);
          }
          this.winids = new Set(winids2);
        }, null, this.disposables);
        const checkCurrentBuffer = (bufnr2) => {
          this._bufnr = bufnr2;
          void this.createDocument(bufnr2);
        };
        events_default.on("CursorMoved", checkCurrentBuffer, null, this.disposables);
        events_default.on("CursorMovedI", checkCurrentBuffer, null, this.disposables);
        events_default.on("BufUnload", this.onBufUnload, this, this.disposables);
        events_default.on("BufEnter", this.onBufEnter, this, this.disposables);
        events_default.on("BufCreate", this.onBufCreate, this, this.disposables);
        events_default.on("TermOpen", this.onBufCreate, this, this.disposables);
        events_default.on("BufWritePost", this.onBufWritePost, this, this.disposables);
        events_default.on("BufWritePre", this.onBufWritePre, this, this.disposables);
        events_default.on("FileType", this.onFileTypeChange, this, this.disposables);
        void events_default.fire("BufEnter", [bufnr]);
        void events_default.fire("BufWinEnter", [bufnr, winid]);
        events_default.on("BufEnter", (bufnr2) => {
          void this.createDocument(bufnr2);
        }, null, this.disposables);
        if (this._env.isVim) {
          ["TextChangedP", "TextChangedI", "TextChanged"].forEach((event) => {
            events_default.on(event, (bufnr2, info) => {
              let doc = this.buffers.get(bufnr2);
              if (doc == null ? void 0 : doc.attached)
                doc.onTextChange(event, info);
            }, null, this.disposables);
          });
        } else {
          events_default.on("CompleteDone", async (item) => {
            if (!item.isSnippet) {
              let doc = this.buffers.get(events_default.bufnr);
              if (doc == null ? void 0 : doc.attached)
                doc._forceSync();
            }
          }, null, this.disposables);
        }
        this._initialized = true;
      }
      getConfiguration(e) {
        if (!e || e.affectsConfiguration("coc.preferences")) {
          let config = this.configurations.getConfiguration("coc.preferences");
          let maxFileSize = config.get("maxFileSize", "10MB");
          this.config = {
            maxFileSize: import_bytes.default.parse(maxFileSize),
            willSaveHandlerTimeout: config.get("willSaveHandlerTimeout", 500)
          };
        }
      }
      get bufnr() {
        return this._bufnr;
      }
      get root() {
        return this._root;
      }
      get cwd() {
        return this._cwd;
      }
      get documents() {
        return Array.from(this.buffers.values()).filter((o) => o.attached && !o.isCommandLine);
      }
      get bufnrs() {
        return Array.from(this.buffers.keys());
      }
      detach() {
        if (!this._attached)
          return;
        this._attached = false;
        for (let bufnr of this.buffers.keys()) {
          this.onBufUnload(bufnr);
        }
        disposeAll(this.disposables);
      }
      get textDocuments() {
        let docs = [];
        for (let b of this.buffers.values()) {
          if (b.attached)
            docs.push(b.textDocument);
        }
        return docs;
      }
      getDocument(uri) {
        if (typeof uri === "number") {
          return this.buffers.get(uri);
        }
        const caseInsensitive = platform_exports.isWindows || platform_exports.isMacintosh;
        uri = URI2.parse(uri).toString();
        for (let doc of this.buffers.values()) {
          if (doc.uri === uri)
            return doc;
          if (caseInsensitive && doc.uri.toLowerCase() === uri.toLowerCase())
            return doc;
        }
        return null;
      }
      expand(input) {
        if (input.startsWith("~")) {
          input = import_os5.default.homedir() + input.slice(1);
        }
        if (input.includes("$")) {
          let doc = this.getDocument(this.bufnr);
          let fsPath2 = doc ? URI2.parse(doc.uri).fsPath : "";
          input = input.replace(/\$\{(.*?)\}/g, (match, name2) => {
            if (name2.startsWith("env:")) {
              let key = name2.split(":")[1];
              let val = key ? process.env[key] : "";
              return val;
            }
            switch (name2) {
              case "workspace":
              case "workspaceRoot":
              case "workspaceFolder":
                return this._root;
              case "workspaceFolderBasename":
                return import_path6.default.dirname(this._root);
              case "cwd":
                return this._cwd;
              case "file":
                return fsPath2;
              case "fileDirname":
                return fsPath2 ? import_path6.default.dirname(fsPath2) : "";
              case "fileExtname":
                return fsPath2 ? import_path6.default.extname(fsPath2) : "";
              case "fileBasename":
                return fsPath2 ? import_path6.default.basename(fsPath2) : "";
              case "fileBasenameNoExtension": {
                let basename = fsPath2 ? import_path6.default.basename(fsPath2) : "";
                return basename ? basename.slice(0, basename.length - import_path6.default.extname(basename).length) : "";
              }
              default:
                return match;
            }
          });
          input = input.replace(/\$[\w]+/g, (match) => {
            if (match == "$HOME")
              return import_os5.default.homedir();
            return process.env[match.slice(1)] || match;
          });
        }
        return input;
      }
      get document() {
        if (this._currentResolve) {
          return new Promise((resolve3) => {
            this.resolves.push(resolve3);
          });
        }
        this._currentResolve = true;
        return new Promise((resolve3, reject) => {
          this.nvim.eval(`coc#util#get_bufoptions(bufnr("%"),${this.config.maxFileSize})`).then((opts) => {
            let doc;
            if (opts != null) {
              this.creating.delete(opts.bufnr);
              doc = this._createDocument(opts);
            }
            this.resolveCurrent(doc);
            resolve3(doc);
            this._currentResolve = false;
          }, reject);
        });
      }
      resolveCurrent(document2) {
        if (this.resolves.length > 0) {
          while (this.resolves.length) {
            const fn = this.resolves.pop();
            if (fn)
              fn(document2);
          }
        }
      }
      get uri() {
        let { bufnr } = this;
        if (bufnr) {
          let doc = this.getDocument(bufnr);
          if (doc)
            return doc.uri;
        }
        return null;
      }
      get filetypes() {
        let res = /* @__PURE__ */ new Set();
        for (let doc of this.documents) {
          res.add(doc.filetype);
        }
        return res;
      }
      get languageIds() {
        let res = /* @__PURE__ */ new Set();
        for (let doc of this.documents) {
          res.add(doc.languageId);
        }
        return res;
      }
      async getFormatOptions(uri) {
        let doc;
        if (uri)
          doc = this.getDocument(uri);
        let bufnr = doc ? doc.bufnr : 0;
        let res = await this.nvim.call("coc#util#get_format_opts", [bufnr]);
        let obj = { tabSize: res.tabsize, insertSpaces: res.expandtab == 1 };
        obj.insertFinalNewline = res.insertFinalNewline == 1;
        if (res.trimTrailingWhitespace)
          obj.trimTrailingWhitespace = true;
        if (res.trimFinalNewlines)
          obj.trimFinalNewlines = true;
        return obj;
      }
      async createDocument(bufnr) {
        let doc = this.buffers.get(bufnr);
        if (doc)
          return doc;
        if (this.creating.has(bufnr))
          return await this.creating.get(bufnr);
        let promise = new Promise((resolve3) => {
          this.nvim.call("coc#util#get_bufoptions", [bufnr, this.config.maxFileSize]).then((opts) => {
            if (!this.creating.has(bufnr)) {
              resolve3(void 0);
              return;
            }
            this.creating.delete(bufnr);
            if (!opts) {
              resolve3(void 0);
              return;
            }
            doc = this._createDocument(opts);
            resolve3(doc);
          }, () => {
            this.creating.delete(bufnr);
            resolve3(void 0);
          });
        });
        this.creating.set(bufnr, promise);
        return await promise;
      }
      async onBufCreate(bufnr) {
        this.onBufUnload(bufnr);
        await this.createDocument(bufnr);
      }
      _createDocument(opts) {
        let { bufnr } = opts;
        if (this.buffers.has(bufnr))
          return this.buffers.get(bufnr);
        let buffer = this.nvim.createBuffer(bufnr);
        let doc = new Document(buffer, this._env, this.nvim, opts);
        if (opts.size > this.config.maxFileSize)
          logger26.warn(`buffer ${opts.bufnr} size exceed maxFileSize ${this.config.maxFileSize}, not attached.`);
        this.buffers.set(bufnr, doc);
        if (doc.attached) {
          if (doc.schema == "file") {
            let configfile = this.configurations.resolveFolderConfigution(doc.uri);
            let root = this.workspaceFolder.resolveRoot(doc, this._cwd, this._initialized, this.expand.bind(this));
            if (bufnr == this._bufnr) {
              if (configfile)
                this.configurations.setFolderConfiguration(doc.uri);
              if (root)
                this._root = root;
            }
          }
          this._onDidOpenTextDocument.fire(doc.textDocument);
          doc.onDocumentChange((e) => this._onDidChangeDocument.fire(e));
        }
        logger26.debug("buffer created", bufnr, doc.attached, doc.uri);
        return doc;
      }
      onBufEnter(bufnr) {
        this._bufnr = bufnr;
        let doc = this.buffers.get(bufnr);
        if (doc) {
          this.configurations.setFolderConfiguration(doc.uri);
          let workspaceFolder = this.workspaceFolder.getWorkspaceFolder(URI2.parse(doc.uri));
          if (workspaceFolder)
            this._root = URI2.parse(workspaceFolder.uri).fsPath;
        }
      }
      onBufUnload(bufnr) {
        this.creating.delete(bufnr);
        void this.onBufDetach(bufnr, false);
      }
      async onBufDetach(bufnr, checkReload = true) {
        this.detachBuffer(bufnr);
        if (checkReload) {
          let loaded = await this.nvim.call("bufloaded", [bufnr]);
          if (loaded)
            await this.createDocument(bufnr);
        }
      }
      detachBuffer(bufnr) {
        let doc = this.buffers.get(bufnr);
        if (!doc)
          return;
        logger26.debug("document detach", bufnr, doc.uri);
        this._onDidCloseDocument.fire(doc.textDocument);
        this.buffers.delete(bufnr);
        doc.detach();
      }
      async onBufWritePost(bufnr, changedtick) {
        let doc = this.buffers.get(bufnr);
        if (doc) {
          if (doc.changedtick != changedtick)
            await doc.patchChange();
          this._onDidSaveDocument.fire(doc.textDocument);
        }
      }
      async onBufWritePre(bufnr, bufname, changedtick) {
        let doc = this.buffers.get(bufnr);
        if (!doc || !doc.attached)
          return;
        if (doc.bufname != bufname) {
          this.detachBuffer(bufnr);
          doc = await this.createDocument(bufnr);
          if (!doc.attached)
            return;
        }
        if (doc.changedtick != changedtick) {
          await doc.synchronize();
        } else {
          await doc.patchChange();
        }
        let firing = true;
        let thenables = [];
        let event = {
          document: doc.textDocument,
          reason: import_vscode_languageserver_protocol22.TextDocumentSaveReason.Manual,
          waitUntil: (thenable) => {
            if (!firing) {
              logger26.error(`Can't call waitUntil in async manner:`, Error().stack);
              this.nvim.echoError(`waitUntil can't be used in async manner, check log for details`);
            } else {
              thenables.push(thenable);
            }
          }
        };
        this._onWillSaveDocument.fire(event);
        firing = false;
        let total = thenables.length;
        if (total) {
          let promise = new Promise((resolve3) => {
            const willSaveHandlerTimeout = this.config.willSaveHandlerTimeout;
            let timer = setTimeout(() => {
              this.nvim.outWriteLine(`Will save handler timeout after ${willSaveHandlerTimeout}ms`);
              resolve3(void 0);
            }, willSaveHandlerTimeout);
            let i = 0;
            let called = false;
            for (let p of thenables) {
              let cb = (res) => {
                if (called)
                  return;
                called = true;
                clearTimeout(timer);
                resolve3(res);
              };
              p.then((res) => {
                if (Array.isArray(res) && res.length && import_vscode_languageserver_protocol22.TextEdit.is(res[0])) {
                  return cb(res);
                }
                i = i + 1;
                if (i == total)
                  cb(void 0);
              }, (e) => {
                logger26.error(`Error on will save handler:`, e);
                i = i + 1;
                if (i == total)
                  cb(void 0);
              });
            }
          });
          let edits = await promise;
          if (edits)
            await doc.applyEdits(edits, false, this.bufnr === doc.bufnr);
        }
      }
      onFileTypeChange(filetype, bufnr) {
        let doc = this.getDocument(bufnr);
        if (!doc)
          return;
        let converted = doc.convertFiletype(filetype);
        if (converted == doc.filetype)
          return;
        this._onDidCloseDocument.fire(doc.textDocument);
        doc.setFiletype(filetype);
        this._onDidOpenTextDocument.fire(doc.textDocument);
      }
      async getQuickfixList(locations) {
        let filesLines = {};
        let filepathList = locations.reduce((pre, curr) => {
          let u = URI2.parse(curr.uri);
          if (u.scheme == "file" && !pre.includes(u.fsPath) && !this.getDocument(curr.uri)) {
            pre.push(u.fsPath);
          }
          return pre;
        }, []);
        await Promise.all(filepathList.map((fsPath2) => {
          return new Promise((resolve3) => {
            import_fs7.default.readFile(fsPath2, "utf8", (err, content) => {
              if (err)
                return resolve3(void 0);
              filesLines[fsPath2] = content.split(/\r?\n/);
              resolve3(void 0);
            });
          });
        }));
        return await Promise.all(locations.map((loc) => {
          let { uri, range: range2 } = loc;
          let { fsPath: fsPath2 } = URI2.parse(uri);
          let text;
          let lines = filesLines[fsPath2];
          if (lines)
            text = lines[range2.start.line];
          return this.getQuickfixItem(loc, text);
        }));
      }
      async getQuickfixItem(loc, text, type = "", module2) {
        if (import_vscode_languageserver_protocol22.LocationLink.is(loc)) {
          loc = import_vscode_languageserver_protocol22.Location.create(loc.targetUri, loc.targetRange);
        }
        let doc = this.getDocument(loc.uri);
        let { uri, range: range2 } = loc;
        let { start, end } = range2;
        let u = URI2.parse(uri);
        if (!text && u.scheme == "file") {
          text = await this.getLine(uri, start.line);
        }
        let endLine = start.line == end.line ? text : await this.getLine(uri, end.line);
        let item = {
          uri,
          filename: u.scheme == "file" ? u.fsPath : uri,
          lnum: start.line + 1,
          end_lnum: end.line + 1,
          col: text ? byteIndex(text, start.character) + 1 : start.character + 1,
          end_col: endLine ? byteIndex(endLine, end.character) + 1 : end.character + 1,
          text: text || "",
          range: range2
        };
        if (module2)
          item.module = module2;
        if (type)
          item.type = type;
        if (doc)
          item.bufnr = doc.bufnr;
        return item;
      }
      async getLine(uri, line) {
        let document2 = this.getDocument(uri);
        if (document2 && document2.attached)
          return document2.getline(line) || "";
        if (!uri.startsWith("file:"))
          return "";
        let fsPath2 = URI2.parse(uri).fsPath;
        if (!import_fs7.default.existsSync(fsPath2))
          return "";
        return await readFileLine(fsPath2, line);
      }
      async readFile(uri) {
        let document2 = this.getDocument(uri);
        if (document2) {
          await document2.patchChange();
          return document2.content;
        }
        let u = URI2.parse(uri);
        if (u.scheme != "file")
          return "";
        let lines = await this.nvim.call("readfile", [u.fsPath]);
        return lines.join("\n") + "\n";
      }
      reset() {
        this.creating.clear();
        for (let bufnr of this.buffers.keys()) {
          this.onBufUnload(bufnr);
        }
        this.buffers.clear();
        this._root = process.cwd();
      }
      dispose() {
        for (let bufnr of this.buffers.keys()) {
          this.onBufUnload(bufnr);
        }
        this._attached = false;
        this.buffers.clear();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/model/editInspect.ts
function grouByAnnotation(changes, annotations) {
  let map = /* @__PURE__ */ new Map();
  for (let change of changes) {
    let id = getAnnotationKey(change) ?? null;
    let key = id ? annotations[id].label ?? null : null;
    let arr = map.get(key);
    if (arr) {
      arr.push(change);
    } else {
      map.set(key, [change]);
    }
  }
  return map;
}
var import_fast_diff2, import_path7, logger27, global_id, EditInspect;
var init_editInspect = __esm({
  "src/model/editInspect.ts"() {
    "use strict";
    import_fast_diff2 = __toESM(require_diff());
    import_path7 = __toESM(require("path"));
    init_main();
    init_esm();
    init_events();
    init_util();
    init_fs();
    init_textedit();
    init_highligher();
    logger27 = require_logger2()("mdoe-editInspect");
    global_id = 0;
    EditInspect = class {
      constructor(nvim, keymaps) {
        this.nvim = nvim;
        this.keymaps = keymaps;
        this.disposables = [];
        this.items = [];
        this.renameMap = /* @__PURE__ */ new Map();
        events_default.on("BufUnload", (bufnr) => {
          if (bufnr == this.bufnr)
            this.dispose();
        }, null, this.disposables);
      }
      addFile(filepath, highligher, lnum) {
        this.items.push({
          index: highligher.length,
          filepath,
          lnum
        });
      }
      async show(state) {
        let { nvim } = this;
        let id = global_id++;
        nvim.pauseNotification();
        nvim.command(`tabe +setl\\ buftype=nofile CocWorkspaceEdit${id}`, true);
        nvim.command(`setl bufhidden=wipe nolist`, true);
        nvim.command("setl nobuflisted wrap undolevels=-1 filetype=cocedits noswapfile", true);
        await nvim.resumeNotification(true);
        let buffer = await nvim.buffer;
        let cwd = await nvim.call("getcwd");
        this.bufnr = buffer.id;
        const relpath = (uri) => {
          let fsPath2 = URI2.parse(uri).fsPath;
          return isParentFolder(cwd, fsPath2, true) ? import_path7.default.relative(cwd, fsPath2) : fsPath2;
        };
        const absPath = (filepath) => {
          return import_path7.default.isAbsolute(filepath) ? filepath : import_path7.default.join(cwd, filepath);
        };
        let highligher = new Highlighter();
        let map = grouByAnnotation(state.edit.documentChanges ?? [], state.edit.changeAnnotations ?? {});
        for (let [label, changes] of map.entries()) {
          if (label) {
            highligher.addLine(label, "MoreMsg");
            highligher.addLine("");
          }
          for (let change of changes) {
            if (TextDocumentEdit.is(change)) {
              let linesChange = state.changes[change.textDocument.uri];
              let fsPath2 = relpath(change.textDocument.uri);
              highligher.addTexts([
                { text: "Change", hlGroup: "Title" },
                { text: " " },
                { text: fsPath2, hlGroup: "Directory" },
                { text: `:${linesChange.lnum}`, hlGroup: "LineNr" }
              ]);
              this.addFile(fsPath2, highligher, linesChange.lnum);
              highligher.addLine("");
              this.addChangedLines(highligher, linesChange, fsPath2, linesChange.lnum);
              highligher.addLine("");
            } else if (CreateFile.is(change) || DeleteFile.is(change)) {
              let title = DeleteFile.is(change) ? "Delete" : "Create";
              let fsPath2 = relpath(change.uri);
              highligher.addTexts([
                { text: title, hlGroup: "Title" },
                { text: " " },
                { text: fsPath2, hlGroup: "Directory" }
              ]);
              this.addFile(fsPath2, highligher);
              highligher.addLine("");
            } else if (RenameFile.is(change)) {
              let oldPath = relpath(change.oldUri);
              let newPath = relpath(change.newUri);
              highligher.addTexts([
                { text: "Rename", hlGroup: "Title" },
                { text: " " },
                { text: oldPath, hlGroup: "Directory" },
                { text: "->", hlGroup: "Comment" },
                { text: newPath, hlGroup: "Directory" }
              ]);
              this.renameMap.set(oldPath, newPath);
              this.addFile(newPath, highligher);
              highligher.addLine("");
            }
          }
        }
        nvim.pauseNotification();
        highligher.render(buffer);
        buffer.setOption("modifiable", false, true);
        await nvim.resumeNotification(true);
        this.disposables.push(this.keymaps.registerLocalKeymap("n", "<CR>", async () => {
          let lnum = await nvim.call("line", ".");
          let col = await nvim.call("col", ".");
          let find;
          for (let i = this.items.length - 1; i >= 0; i--) {
            let item = this.items[i];
            if (lnum >= item.index) {
              find = item;
              break;
            }
          }
          if (!find)
            return;
          let uri = URI2.file(absPath(find.filepath)).toString();
          let filepath = this.renameMap.has(find.filepath) ? this.renameMap.get(find.filepath) : find.filepath;
          await nvim.call("coc#util#open_file", ["tab drop", absPath(filepath)]);
          if (typeof find.lnum === "number") {
            let changes = state.edit.documentChanges ?? [];
            let change = changes.find((o) => TextDocumentEdit.is(o) && o.textDocument.uri == uri);
            let lnum2 = find.lnum;
            if (change) {
              let edits = mergeSort2(change.edits, (a, b) => {
                let diff = a.range.start.line - b.range.start.line;
                if (diff === 0) {
                  return a.range.start.character - b.range.start.character;
                }
                return diff;
              });
              let pos = getPositionFromEdits(Position.create(lnum2 - 1, 0), edits);
              lnum2 = pos.line + 1;
            }
            await nvim.call("cursor", [lnum2, col]);
          }
          nvim.redrawVim();
        }, true));
        this.disposables.push(this.keymaps.registerLocalKeymap("n", "<esc>", async () => {
          nvim.command("bwipeout!", true);
        }, true));
      }
      addChangedLines(highligher, linesChange, fsPath2, lnum) {
        let diffs = (0, import_fast_diff2.default)(linesChange.oldLines.join("\n"), linesChange.newLines.join("\n"));
        for (let i = 0; i < diffs.length; i++) {
          let diff = diffs[i];
          if (diff[0] == import_fast_diff2.default.EQUAL) {
            let text = diff[1];
            if (!text.includes("\n")) {
              highligher.addText(text);
            } else {
              let parts = text.split("\n");
              highligher.addText(parts[0]);
              let curr = lnum + parts.length - 1;
              highligher.addLine("");
              highligher.addTexts([
                { text: "Change", hlGroup: "Title" },
                { text: " " },
                { text: fsPath2, hlGroup: "Directory" },
                { text: `:${curr}`, hlGroup: "LineNr" }
              ]);
              this.addFile(fsPath2, highligher, curr);
              highligher.addLine("");
              let last = parts[parts.length - 1];
              if (last.length > 0)
                highligher.addText(last);
            }
            lnum += text.split("\n").length - 1;
          } else if (diff[0] == import_fast_diff2.default.DELETE) {
            lnum += diff[1].split("\n").length - 1;
            highligher.addText(diff[1], "DiffDelete");
          } else if (diff[0] == import_fast_diff2.default.INSERT) {
            highligher.addText(diff[1], "DiffAdd");
          }
        }
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
  }
});

// src/util/errors.ts
function illegalArgument(name2) {
  if (name2) {
    return new Error(`Illegal argument: ${name2}`);
  } else {
    return new Error("Illegal argument");
  }
}
function fileExists(filepath) {
  return new Error(`File ${filepath} already exists`);
}
function fileNotExists(filepath) {
  return new Error(`File ${filepath} not exists`);
}
function shouldNotAsync(method) {
  return new Error(`${method} should not be called in an asynchronize manner`);
}
function badScheme(scheme) {
  return new Error(`Change of ${scheme} not supported`);
}
var canceledName, CancellationError;
var init_errors = __esm({
  "src/util/errors.ts"() {
    "use strict";
    canceledName = "Canceled";
    CancellationError = class extends Error {
      constructor() {
        super(canceledName);
        this.name = this.message;
      }
    };
  }
});

// src/core/files.ts
function fileMatch(root, relpath, pattern) {
  let filepath = import_path8.default.join(root, relpath);
  if (typeof pattern !== "string") {
    let base = pattern.baseUri.fsPath;
    if (!isParentFolder(base, filepath))
      return false;
    let rp = import_path8.default.relative(base, filepath);
    return (0, import_minimatch2.default)(rp, pattern.pattern, { dot: true });
  }
  return (0, import_minimatch2.default)(relpath, pattern, { dot: true });
}
function fsPath(uri) {
  return URI2.parse(uri).fsPath;
}
var import_fs_extra3, import_glob2, import_minimatch2, import_os6, import_path8, import_util21, import_vscode_languageserver_protocol23, logger28, Files;
var init_files = __esm({
  "src/core/files.ts"() {
    "use strict";
    import_fs_extra3 = __toESM(require_lib4());
    import_glob2 = __toESM(require_glob());
    import_minimatch2 = __toESM(require_minimatch());
    import_os6 = __toESM(require("os"));
    import_path8 = __toESM(require("path"));
    import_util21 = require("util");
    init_esm_node();
    import_vscode_languageserver_protocol23 = __toESM(require_main2());
    init_esm();
    init_events();
    init_editInspect();
    init_errors();
    init_fs();
    init_string();
    init_textedit();
    init_ui();
    logger28 = require_logger2()("core-files");
    Files = class {
      constructor(documents, configurations, workspaceFolderControl, keymaps) {
        this.documents = documents;
        this.configurations = configurations;
        this.workspaceFolderControl = workspaceFolderControl;
        this.keymaps = keymaps;
        this.operationTimeout = 500;
        this._onDidCreateFiles = new import_vscode_languageserver_protocol23.Emitter();
        this._onDidRenameFiles = new import_vscode_languageserver_protocol23.Emitter();
        this._onDidDeleteFiles = new import_vscode_languageserver_protocol23.Emitter();
        this._onWillCreateFiles = new import_vscode_languageserver_protocol23.Emitter();
        this._onWillRenameFiles = new import_vscode_languageserver_protocol23.Emitter();
        this._onWillDeleteFiles = new import_vscode_languageserver_protocol23.Emitter();
        this.onDidCreateFiles = this._onDidCreateFiles.event;
        this.onDidRenameFiles = this._onDidRenameFiles.event;
        this.onDidDeleteFiles = this._onDidDeleteFiles.event;
        this.onWillCreateFiles = this._onWillCreateFiles.event;
        this.onWillRenameFiles = this._onWillRenameFiles.event;
        this.onWillDeleteFiles = this._onWillDeleteFiles.event;
      }
      attach(nvim, env, window2) {
        this.nvim = nvim;
        this.env = env;
        this.window = window2;
      }
      async openTextDocument(uri) {
        uri = typeof uri === "string" ? URI2.file(uri) : uri;
        let doc = this.documents.getDocument(uri.toString());
        if (doc) {
          await this.jumpTo(uri.toString(), null, "drop");
          return doc;
        }
        const scheme = uri.scheme;
        if (scheme == "file") {
          if (!import_fs_extra3.default.existsSync(uri.fsPath))
            throw fileNotExists(uri.fsPath);
          import_fs_extra3.default.accessSync(uri.fsPath, import_fs_extra3.default.constants.R_OK);
        }
        if (scheme == "untitled") {
          await this.nvim.call("coc#util#open_file", ["tab drop", uri.path]);
          return await this.documents.document;
        }
        return await this.loadResource(uri.toString());
      }
      async jumpTo(uri, position, openCommand) {
        const preferences = this.configurations.getConfiguration("coc.preferences");
        let jumpCommand = openCommand || preferences.get("jumpCommand", "edit");
        let { nvim } = this;
        let doc = this.documents.getDocument(uri);
        let bufnr = doc ? doc.bufnr : -1;
        if (bufnr != -1 && jumpCommand == "edit") {
          nvim.pauseNotification();
          nvim.command(`silent! normal! m'`, true);
          nvim.command(`buffer ${bufnr}`, true);
          nvim.command(`if &filetype ==# '' | filetype detect | endif`, true);
          if (position) {
            let line = doc.getline(position.line);
            let col = byteLength(line.slice(0, position.character)) + 1;
            nvim.call("cursor", [position.line + 1, col], true);
          }
          await nvim.resumeNotification(true);
        } else {
          let { fsPath: fsPath2, scheme } = URI2.parse(uri);
          let pos = position == null ? null : [position.line, position.character];
          if (scheme == "file") {
            let bufname = fixDriver(import_path8.default.normalize(fsPath2));
            await this.nvim.call("coc#util#jump", [jumpCommand, bufname, pos]);
          } else {
            await this.nvim.call("coc#util#jump", [jumpCommand, uri, pos]);
          }
        }
      }
      async openResource(uri) {
        let { nvim } = this;
        let u = URI2.parse(uri);
        if (/^https?/.test(u.scheme)) {
          await nvim.call("coc#ui#open_url", uri);
          return;
        }
        let wildignore = await nvim.getOption("wildignore");
        await nvim.setOption("wildignore", "");
        await this.jumpTo(uri);
        await nvim.setOption("wildignore", wildignore);
      }
      async loadResource(uri, cmd) {
        let doc = this.documents.getDocument(uri);
        if (doc)
          return doc;
        if (!cmd) {
          const preferences = this.configurations.getConfiguration("workspace");
          cmd = preferences.get("openResourceCommand", "tab drop");
        }
        let u = URI2.parse(uri);
        let bufname = u.scheme === "file" ? u.fsPath : uri;
        let bufnr;
        if (cmd) {
          let winid = await this.nvim.call("win_getid");
          bufnr = await this.nvim.call("coc#util#open_file", [cmd, bufname]);
          await this.nvim.call("win_gotoid", [winid]);
        } else {
          let arr = await this.nvim.call("coc#ui#open_files", [[bufname]]);
          bufnr = arr[0];
        }
        return await this.documents.createDocument(bufnr);
      }
      async loadResources(uris) {
        let { documents } = this;
        let files = uris.map((uri) => {
          let u = URI2.parse(uri);
          return u.scheme == "file" ? u.fsPath : uri;
        });
        let bufnrs = await this.nvim.call("coc#ui#open_files", [files]);
        return await Promise.all(bufnrs.map((bufnr) => {
          return documents.createDocument(bufnr);
        }));
      }
      async createFile(filepath, opts = {}, recovers) {
        let { nvim } = this;
        let exists = import_fs_extra3.default.existsSync(filepath);
        if (exists && !opts.overwrite && !opts.ignoreIfExists) {
          throw fileExists(filepath);
        }
        if (!exists || opts.overwrite) {
          let tokenSource = new import_vscode_languageserver_protocol23.CancellationTokenSource();
          await this.fireWaitUntilEvent(this._onWillCreateFiles, {
            files: [URI2.file(filepath)],
            token: tokenSource.token
          }, recovers);
          tokenSource.cancel();
          let dir = import_path8.default.dirname(filepath);
          if (!import_fs_extra3.default.existsSync(dir)) {
            let folder;
            let curr = dir;
            while (![".", "/", import_path8.default.parse(dir).root].includes(curr)) {
              if (import_fs_extra3.default.existsSync(import_path8.default.dirname(curr))) {
                folder = curr;
                break;
              }
              curr = import_path8.default.dirname(curr);
            }
            await import_fs_extra3.default.mkdirp(dir);
            recovers && recovers.push(async () => {
              if (import_fs_extra3.default.existsSync(folder)) {
                await import_fs_extra3.default.remove(folder);
              }
            });
          }
          import_fs_extra3.default.writeFileSync(filepath, "", "utf8");
          recovers && recovers.push(async () => {
            if (import_fs_extra3.default.existsSync(filepath)) {
              await import_fs_extra3.default.unlink(filepath);
            }
          });
          let doc = await this.loadResource(filepath);
          let bufnr = doc.bufnr;
          recovers && recovers.push(() => {
            void events_default.fire("BufUnload", [bufnr]);
            return nvim.command(`silent! bd! ${bufnr}`);
          });
          this._onDidCreateFiles.fire({ files: [URI2.file(filepath)] });
        }
      }
      async deleteFile(filepath, opts = {}, recovers) {
        let { ignoreIfNotExists, recursive } = opts;
        let stat = await statAsync(filepath);
        let isDir = stat && stat.isDirectory();
        if (!stat && !ignoreIfNotExists) {
          throw fileNotExists(filepath);
        }
        if (stat == null)
          return;
        let uri = URI2.file(filepath);
        await this.fireWaitUntilEvent(this._onWillDeleteFiles, { files: [uri] }, recovers);
        if (!isDir) {
          let bufnr = await this.nvim.call("bufnr", [filepath]);
          if (bufnr) {
            void events_default.fire("BufUnload", [bufnr]);
            await this.nvim.command(`silent! bwipeout ${bufnr}`);
            recovers && recovers.push(() => {
              return this.loadResource(uri.toString());
            });
          }
        }
        if (isDir && recursive) {
          let folder = import_path8.default.join(import_os6.default.tmpdir(), "coc-" + v4_default());
          await import_fs_extra3.default.mkdir(folder);
          await import_fs_extra3.default.copy(filepath, folder, { recursive: true });
          await import_fs_extra3.default.remove(filepath);
          recovers && recovers.push(async () => {
            await import_fs_extra3.default.mkdir(filepath);
            await import_fs_extra3.default.copy(folder, filepath, { recursive: true });
            await import_fs_extra3.default.remove(folder);
          });
        } else if (isDir) {
          await import_fs_extra3.default.rmdir(filepath);
          recovers && recovers.push(() => {
            return import_fs_extra3.default.mkdir(filepath);
          });
        } else {
          let dest = import_path8.default.join(import_os6.default.tmpdir(), "coc-" + v4_default());
          await import_fs_extra3.default.copyFile(filepath, dest);
          await import_fs_extra3.default.unlink(filepath);
          recovers && recovers.push(() => {
            return import_fs_extra3.default.move(dest, filepath, { overwrite: true });
          });
        }
        this._onDidDeleteFiles.fire({ files: [uri] });
      }
      async renameFile(oldPath, newPath, opts = {}, recovers) {
        let { nvim } = this;
        let { overwrite, ignoreIfExists } = opts;
        if (newPath === oldPath)
          return;
        let exists = import_fs_extra3.default.existsSync(newPath);
        if (exists && ignoreIfExists && !overwrite)
          return;
        if (exists && !overwrite)
          throw fileExists(newPath);
        let oldStat = await statAsync(oldPath);
        let loaded = oldStat && oldStat.isDirectory() ? 0 : await nvim.call("bufloaded", [oldPath]);
        if (!loaded && !oldStat)
          throw fileNotExists(oldPath);
        let file = { newUri: URI2.parse(newPath), oldUri: URI2.parse(oldPath) };
        if (!opts.skipEvent)
          await this.fireWaitUntilEvent(this._onWillRenameFiles, { files: [file] }, recovers);
        if (loaded) {
          let bufnr = await nvim.call("coc#ui#rename_file", [oldPath, newPath, oldStat != null]);
          await this.documents.onBufCreate(bufnr);
        } else {
          if (oldStat == null ? void 0 : oldStat.isDirectory()) {
            for (let doc of this.documents.documents) {
              let u = URI2.parse(doc.uri);
              if (u.scheme === "file" && isParentFolder(oldPath, u.fsPath, false)) {
                let filepath = u.fsPath.replace(oldPath, newPath);
                let bufnr = await nvim.call("coc#ui#rename_file", [u.fsPath, filepath, false]);
                await this.documents.onBufCreate(bufnr);
              }
            }
          }
          import_fs_extra3.default.renameSync(oldPath, newPath);
        }
        recovers && recovers.push(() => {
          return this.renameFile(newPath, oldPath, { skipEvent: true });
        });
        if (!opts.skipEvent)
          this._onDidRenameFiles.fire({ files: [file] });
      }
      async renameCurrent() {
        let { nvim } = this;
        let oldPath = await nvim.call("expand", ["%:p"]);
        let newPath = await nvim.callAsync("coc#util#with_callback", ["input", ["New path: ", oldPath, "file"]]);
        newPath = newPath ? newPath.trim() : null;
        if (newPath === oldPath || !newPath)
          return;
        if (oldPath.toLowerCase() != newPath.toLowerCase() && import_fs_extra3.default.existsSync(newPath)) {
          let overwrite = await showPrompt(this.nvim, `${newPath} exists, overwrite?`);
          if (!overwrite)
            return;
        }
        await this.renameFile(oldPath, newPath, { overwrite: true });
      }
      get currentUri() {
        let document2 = this.documents.getDocument(this.documents.bufnr);
        return document2 ? document2.uri : null;
      }
      async applyEdit(edit2, nested) {
        let documentChanges = toDocumentChanges(edit2);
        let recovers = [];
        let currentOnly = false;
        try {
          let { changeAnnotations } = edit2;
          let { currentUri } = this;
          let toConfirm = changeAnnotations ? getConfirmAnnotations(documentChanges, changeAnnotations) : [];
          let changes = {};
          let denied = [];
          for (let key of toConfirm) {
            let annotation = changeAnnotations[key];
            annotation.needsConfirmation = false;
            let res = await this.window.showMenuPicker(["Yes", "No"], {
              position: "center",
              title: "Confirm edits",
              content: annotation.label + (annotation.description ? " " + annotation.description : "")
            });
            if (res !== 0)
              denied.push(key);
          }
          documentChanges = documentChanges.filter((c) => !denied.includes(getAnnotationKey(c)));
          if (!documentChanges.length)
            return true;
          currentOnly = documentChanges.every((o) => import_vscode_languageserver_protocol23.TextDocumentEdit.is(o) && o.textDocument.uri === currentUri);
          this.validateChanges(documentChanges);
          for (const change of documentChanges) {
            if (import_vscode_languageserver_protocol23.TextDocumentEdit.is(change)) {
              let { textDocument, edits } = change;
              let { uri } = textDocument;
              let doc = await this.loadResource(uri);
              let revertEdit = await doc.applyEdits(edits, false, uri === currentUri);
              if (revertEdit) {
                let version2 = doc.version;
                let { newText, range: range2 } = revertEdit;
                changes[uri] = {
                  uri,
                  lnum: range2.start.line + 1,
                  newLines: doc.getLines(range2.start.line, range2.end.line),
                  oldLines: newText.endsWith("\n") ? newText.slice(0, -1).split("\n") : newText.split("\n")
                };
                recovers.push(async () => {
                  let doc2 = this.documents.getDocument(uri);
                  if (!doc2 || !doc2.attached || doc2.version !== version2)
                    return;
                  await doc2.applyEdits([revertEdit]);
                  textDocument.version = doc2.version;
                });
              }
            } else if (import_vscode_languageserver_protocol23.CreateFile.is(change)) {
              await this.createFile(fsPath(change.uri), change.options, recovers);
            } else if (import_vscode_languageserver_protocol23.DeleteFile.is(change)) {
              await this.deleteFile(fsPath(change.uri), change.options, recovers);
            } else if (import_vscode_languageserver_protocol23.RenameFile.is(change)) {
              await this.renameFile(fsPath(change.oldUri), fsPath(change.newUri), change.options, recovers);
            }
          }
          if (recovers.length === 0)
            return true;
          if (!nested)
            this.editState = { edit: { documentChanges, changeAnnotations: edit2.changeAnnotations }, changes, recovers, applied: true };
          this.nvim.redrawVim();
        } catch (e) {
          logger28.error("Error on applyEdits:", edit2, e);
          await this.undoChanges(recovers);
          if (!nested)
            void this.window.showErrorMessage(`Error on applyEdits: ${e}`);
          return false;
        }
        if (nested || currentOnly)
          return true;
        void this.window.showInformationMessage(`Use ':wa' to save changes or ':CocCommand workspace.inspectEdit' to inspect.`);
        return true;
      }
      async undoChanges(recovers) {
        while (recovers.length > 0) {
          let fn = recovers.pop();
          await fn();
        }
      }
      async inspectEdit() {
        if (!this.editState) {
          void this.window.showWarningMessage("No workspace edit to inspect");
          return;
        }
        let inspect = new EditInspect(this.nvim, this.keymaps);
        await inspect.show(this.editState);
      }
      async undoWorkspaceEdit() {
        let { editState } = this;
        if (!editState || !editState.applied) {
          void this.window.showWarningMessage(`No workspace edit to undo`);
          return;
        }
        editState.applied = false;
        await this.undoChanges(editState.recovers);
      }
      async redoWorkspaceEdit() {
        let { editState } = this;
        if (!editState || editState.applied) {
          void this.window.showWarningMessage(`No workspace edit to redo`);
          return;
        }
        this.editState = void 0;
        await this.applyEdit(editState.edit);
      }
      validateChanges(documentChanges) {
        let { documents } = this;
        for (let change of documentChanges) {
          if (import_vscode_languageserver_protocol23.TextDocumentEdit.is(change)) {
            let { uri, version: version2 } = change.textDocument;
            let doc = documents.getDocument(uri);
            if (typeof version2 === "number" && version2 > 0) {
              if (!doc)
                throw new Error(`File ${uri} not loaded`);
              if (doc.version != version2)
                throw new Error(`${uri} changed before apply edit`);
            } else if (!doc) {
              if (!isFile(uri))
                throw badScheme(URI2.parse(uri).scheme);
            }
          } else if (import_vscode_languageserver_protocol23.CreateFile.is(change) || import_vscode_languageserver_protocol23.DeleteFile.is(change)) {
            if (!isFile(change.uri))
              throw badScheme(URI2.parse(change.uri).scheme);
          } else if (import_vscode_languageserver_protocol23.RenameFile.is(change)) {
            if (!isFile(change.oldUri) || !isFile(change.newUri)) {
              throw badScheme(URI2.parse(change.oldUri).scheme);
            }
          }
        }
      }
      async findFiles(include, exclude, maxResults, token) {
        let folders = this.workspaceFolderControl.workspaceFolders;
        if ((token == null ? void 0 : token.isCancellationRequested) || !folders.length || maxResults === 0)
          return [];
        maxResults = maxResults ?? Infinity;
        let roots = folders.map((o) => URI2.parse(o.uri).fsPath);
        if (typeof include !== "string") {
          let base = include.baseUri.fsPath;
          roots = roots.filter((r) => isParentFolder(base, r, true));
        }
        let pattern = typeof include === "string" ? include : include.pattern;
        let res = [];
        for (let root of roots) {
          if (res.length >= maxResults)
            break;
          let files = await (0, import_util21.promisify)(import_glob2.default)(pattern, {
            dot: true,
            cwd: root,
            nodir: true,
            absolute: false
          });
          if (token == null ? void 0 : token.isCancellationRequested)
            return [];
          for (let file of files) {
            if (exclude && fileMatch(root, file, exclude))
              continue;
            res.push(URI2.file(import_path8.default.join(root, file)));
            if (res.length === maxResults)
              break;
          }
        }
        return res;
      }
      async fireWaitUntilEvent(emitter, properties, recovers) {
        let firing = true;
        let promises = [];
        emitter.fire(__spreadProps(__spreadValues({}, properties), {
          waitUntil: (thenable) => {
            if (!firing)
              throw shouldNotAsync("waitUntil");
            let tp = new Promise((resolve3) => {
              setTimeout(resolve3, this.operationTimeout);
            });
            let promise = Promise.race([thenable, tp]).then((edit2) => {
              if (edit2 && import_vscode_languageserver_protocol23.WorkspaceEdit.is(edit2)) {
                return this.applyEdit(edit2, true);
              }
            });
            promises.push(promise);
          }
        }));
        firing = false;
        await Promise.all(promises);
      }
    };
  }
});

// src/util/array.ts
function intersect(array, other) {
  for (let item of other) {
    if (array.includes(item)) {
      return true;
    }
  }
  return false;
}
function findIndex(array, val, start = 0) {
  let idx = -1;
  for (let i = start; i < array.length; i++) {
    if (array[i] === val) {
      idx = i;
      break;
    }
  }
  return idx;
}
function splitArray(array, fn) {
  let res = [[], []];
  for (let item of array) {
    if (fn(item)) {
      res[0].push(item);
    } else {
      res[1].push(item);
    }
  }
  return res;
}
function groupBy(array, fn) {
  let res = [[], []];
  array.forEach((v) => {
    if (fn(v)) {
      res[0].push(v);
    } else {
      res[1].push(v);
    }
  });
  return res;
}
function distinct(array, keyFn) {
  if (!keyFn) {
    return array.filter((element, position) => array.indexOf(element) === position);
  }
  const seen = /* @__PURE__ */ Object.create(null);
  return array.filter((elem) => {
    const key = keyFn(elem);
    if (seen[key]) {
      return false;
    }
    seen[key] = true;
    return true;
  });
}
var init_array = __esm({
  "src/util/array.ts"() {
    "use strict";
  }
});

// node_modules/node-int64/Int64.js
var require_Int64 = __commonJS({
  "node_modules/node-int64/Int64.js"(exports, module2) {
    var VAL32 = 4294967296;
    var _HEX = [];
    for (i = 0; i < 256; i++) {
      _HEX[i] = (i > 15 ? "" : "0") + i.toString(16);
    }
    var i;
    var Int64 = module2.exports = function(a1, a2) {
      if (a1 instanceof Buffer) {
        this.buffer = a1;
        this.offset = a2 || 0;
      } else if (Object.prototype.toString.call(a1) == "[object Uint8Array]") {
        this.buffer = new Buffer(a1);
        this.offset = a2 || 0;
      } else {
        this.buffer = this.buffer || new Buffer(8);
        this.offset = 0;
        this.setValue.apply(this, arguments);
      }
    };
    Int64.MAX_INT = Math.pow(2, 53);
    Int64.MIN_INT = -Math.pow(2, 53);
    Int64.prototype = {
      constructor: Int64,
      _2scomp: function() {
        var b = this.buffer, o = this.offset, carry = 1;
        for (var i2 = o + 7; i2 >= o; i2--) {
          var v = (b[i2] ^ 255) + carry;
          b[i2] = v & 255;
          carry = v >> 8;
        }
      },
      setValue: function(hi, lo) {
        var negate = false;
        if (arguments.length == 1) {
          if (typeof hi == "number") {
            negate = hi < 0;
            hi = Math.abs(hi);
            lo = hi % VAL32;
            hi = hi / VAL32;
            if (hi > VAL32)
              throw new RangeError(hi + " is outside Int64 range");
            hi = hi | 0;
          } else if (typeof hi == "string") {
            hi = (hi + "").replace(/^0x/, "");
            lo = hi.substr(-8);
            hi = hi.length > 8 ? hi.substr(0, hi.length - 8) : "";
            hi = parseInt(hi, 16);
            lo = parseInt(lo, 16);
          } else {
            throw new Error(hi + " must be a Number or String");
          }
        }
        var b = this.buffer, o = this.offset;
        for (var i2 = 7; i2 >= 0; i2--) {
          b[o + i2] = lo & 255;
          lo = i2 == 4 ? hi : lo >>> 8;
        }
        if (negate)
          this._2scomp();
      },
      toNumber: function(allowImprecise) {
        var b = this.buffer, o = this.offset;
        var negate = b[o] & 128, x = 0, carry = 1;
        for (var i2 = 7, m = 1; i2 >= 0; i2--, m *= 256) {
          var v = b[o + i2];
          if (negate) {
            v = (v ^ 255) + carry;
            carry = v >> 8;
            v = v & 255;
          }
          x += v * m;
        }
        if (!allowImprecise && x >= Int64.MAX_INT) {
          return negate ? -Infinity : Infinity;
        }
        return negate ? -x : x;
      },
      valueOf: function() {
        return this.toNumber(false);
      },
      toString: function(radix) {
        return this.valueOf().toString(radix || 10);
      },
      toOctetString: function(sep) {
        var out = new Array(8);
        var b = this.buffer, o = this.offset;
        for (var i2 = 0; i2 < 8; i2++) {
          out[i2] = _HEX[b[o + i2]];
        }
        return out.join(sep || "");
      },
      toBuffer: function(rawBuffer) {
        if (rawBuffer && this.offset === 0)
          return this.buffer;
        var out = new Buffer(8);
        this.buffer.copy(out, 0, this.offset, this.offset + 8);
        return out;
      },
      copy: function(targetBuffer, targetOffset) {
        this.buffer.copy(targetBuffer, targetOffset || 0, this.offset, this.offset + 8);
      },
      compare: function(other) {
        if ((this.buffer[this.offset] & 128) != (other.buffer[other.offset] & 128)) {
          return other.buffer[other.offset] - this.buffer[this.offset];
        }
        for (var i2 = 0; i2 < 8; i2++) {
          if (this.buffer[this.offset + i2] !== other.buffer[other.offset + i2]) {
            return this.buffer[this.offset + i2] - other.buffer[other.offset + i2];
          }
        }
        return 0;
      },
      equals: function(other) {
        return this.compare(other) === 0;
      },
      inspect: function() {
        return "[Int64 value:" + this + " octets:" + this.toOctetString(" ") + "]";
      }
    };
  }
});

// node_modules/bser/index.js
var require_bser = __commonJS({
  "node_modules/bser/index.js"(exports) {
    var EE = require("events").EventEmitter;
    var util4 = require("util");
    var os13 = require("os");
    var assert = require("assert");
    var Int64 = require_Int64();
    var isBigEndian = os13.endianness() == "BE";
    function nextPow2(size) {
      return Math.pow(2, Math.ceil(Math.log(size) / Math.LN2));
    }
    function Accumulator(initsize) {
      this.buf = Buffer.alloc(nextPow2(initsize || 8192));
      this.readOffset = 0;
      this.writeOffset = 0;
    }
    exports.Accumulator = Accumulator;
    Accumulator.prototype.writeAvail = function() {
      return this.buf.length - this.writeOffset;
    };
    Accumulator.prototype.readAvail = function() {
      return this.writeOffset - this.readOffset;
    };
    Accumulator.prototype.reserve = function(size) {
      if (size < this.writeAvail()) {
        return;
      }
      if (this.readOffset > 0) {
        this.buf.copy(this.buf, 0, this.readOffset, this.writeOffset);
        this.writeOffset -= this.readOffset;
        this.readOffset = 0;
      }
      if (size < this.writeAvail()) {
        return;
      }
      var buf = Buffer.alloc(nextPow2(this.buf.length + size - this.writeAvail()));
      this.buf.copy(buf);
      this.buf = buf;
    };
    Accumulator.prototype.append = function(buf) {
      if (Buffer.isBuffer(buf)) {
        this.reserve(buf.length);
        buf.copy(this.buf, this.writeOffset, 0, buf.length);
        this.writeOffset += buf.length;
      } else {
        var size = Buffer.byteLength(buf);
        this.reserve(size);
        this.buf.write(buf, this.writeOffset);
        this.writeOffset += size;
      }
    };
    Accumulator.prototype.assertReadableSize = function(size) {
      if (this.readAvail() < size) {
        throw new Error("wanted to read " + size + " bytes but only have " + this.readAvail());
      }
    };
    Accumulator.prototype.peekString = function(size) {
      this.assertReadableSize(size);
      return this.buf.toString("utf-8", this.readOffset, this.readOffset + size);
    };
    Accumulator.prototype.readString = function(size) {
      var str = this.peekString(size);
      this.readOffset += size;
      return str;
    };
    Accumulator.prototype.peekInt = function(size) {
      this.assertReadableSize(size);
      switch (size) {
        case 1:
          return this.buf.readInt8(this.readOffset, size);
        case 2:
          return isBigEndian ? this.buf.readInt16BE(this.readOffset, size) : this.buf.readInt16LE(this.readOffset, size);
        case 4:
          return isBigEndian ? this.buf.readInt32BE(this.readOffset, size) : this.buf.readInt32LE(this.readOffset, size);
        case 8:
          var big = this.buf.slice(this.readOffset, this.readOffset + 8);
          if (isBigEndian) {
            return new Int64(big);
          }
          return new Int64(byteswap64(big));
        default:
          throw new Error("invalid integer size " + size);
      }
    };
    Accumulator.prototype.readInt = function(bytes2) {
      var ival = this.peekInt(bytes2);
      if (ival instanceof Int64 && isFinite(ival.valueOf())) {
        ival = ival.valueOf();
      }
      this.readOffset += bytes2;
      return ival;
    };
    Accumulator.prototype.peekDouble = function() {
      this.assertReadableSize(8);
      return isBigEndian ? this.buf.readDoubleBE(this.readOffset) : this.buf.readDoubleLE(this.readOffset);
    };
    Accumulator.prototype.readDouble = function() {
      var dval = this.peekDouble();
      this.readOffset += 8;
      return dval;
    };
    Accumulator.prototype.readAdvance = function(size) {
      if (size > 0) {
        this.assertReadableSize(size);
      } else if (size < 0 && this.readOffset + size < 0) {
        throw new Error("advance with negative offset " + size + " would seek off the start of the buffer");
      }
      this.readOffset += size;
    };
    Accumulator.prototype.writeByte = function(value) {
      this.reserve(1);
      this.buf.writeInt8(value, this.writeOffset);
      ++this.writeOffset;
    };
    Accumulator.prototype.writeInt = function(value, size) {
      this.reserve(size);
      switch (size) {
        case 1:
          this.buf.writeInt8(value, this.writeOffset);
          break;
        case 2:
          if (isBigEndian) {
            this.buf.writeInt16BE(value, this.writeOffset);
          } else {
            this.buf.writeInt16LE(value, this.writeOffset);
          }
          break;
        case 4:
          if (isBigEndian) {
            this.buf.writeInt32BE(value, this.writeOffset);
          } else {
            this.buf.writeInt32LE(value, this.writeOffset);
          }
          break;
        default:
          throw new Error("unsupported integer size " + size);
      }
      this.writeOffset += size;
    };
    Accumulator.prototype.writeDouble = function(value) {
      this.reserve(8);
      if (isBigEndian) {
        this.buf.writeDoubleBE(value, this.writeOffset);
      } else {
        this.buf.writeDoubleLE(value, this.writeOffset);
      }
      this.writeOffset += 8;
    };
    var BSER_ARRAY = 0;
    var BSER_OBJECT = 1;
    var BSER_STRING = 2;
    var BSER_INT8 = 3;
    var BSER_INT16 = 4;
    var BSER_INT32 = 5;
    var BSER_INT64 = 6;
    var BSER_REAL = 7;
    var BSER_TRUE = 8;
    var BSER_FALSE = 9;
    var BSER_NULL = 10;
    var BSER_TEMPLATE = 11;
    var BSER_SKIP = 12;
    var ST_NEED_PDU = 0;
    var ST_FILL_PDU = 1;
    var MAX_INT8 = 127;
    var MAX_INT16 = 32767;
    var MAX_INT32 = 2147483647;
    function BunserBuf() {
      EE.call(this);
      this.buf = new Accumulator();
      this.state = ST_NEED_PDU;
    }
    util4.inherits(BunserBuf, EE);
    exports.BunserBuf = BunserBuf;
    BunserBuf.prototype.append = function(buf, synchronous) {
      if (synchronous) {
        this.buf.append(buf);
        return this.process(synchronous);
      }
      try {
        this.buf.append(buf);
      } catch (err) {
        this.emit("error", err);
        return;
      }
      this.processLater();
    };
    BunserBuf.prototype.processLater = function() {
      var self2 = this;
      process.nextTick(function() {
        try {
          self2.process(false);
        } catch (err) {
          self2.emit("error", err);
        }
      });
    };
    BunserBuf.prototype.process = function(synchronous) {
      if (this.state == ST_NEED_PDU) {
        if (this.buf.readAvail() < 2) {
          return;
        }
        this.expectCode(0);
        this.expectCode(1);
        this.pduLen = this.decodeInt(true);
        if (this.pduLen === false) {
          this.buf.readAdvance(-2);
          return;
        }
        this.buf.reserve(this.pduLen);
        this.state = ST_FILL_PDU;
      }
      if (this.state == ST_FILL_PDU) {
        if (this.buf.readAvail() < this.pduLen) {
          return;
        }
        var val = this.decodeAny();
        if (synchronous) {
          return val;
        }
        this.emit("value", val);
        this.state = ST_NEED_PDU;
      }
      if (!synchronous && this.buf.readAvail() > 0) {
        this.processLater();
      }
    };
    BunserBuf.prototype.raise = function(reason) {
      throw new Error(reason + ", in Buffer of length " + this.buf.buf.length + " (" + this.buf.readAvail() + " readable) at offset " + this.buf.readOffset + " buffer: " + JSON.stringify(this.buf.buf.slice(this.buf.readOffset, this.buf.readOffset + 32).toJSON()));
    };
    BunserBuf.prototype.expectCode = function(expected) {
      var code = this.buf.readInt(1);
      if (code != expected) {
        this.raise("expected bser opcode " + expected + " but got " + code);
      }
    };
    BunserBuf.prototype.decodeAny = function() {
      var code = this.buf.peekInt(1);
      switch (code) {
        case BSER_INT8:
        case BSER_INT16:
        case BSER_INT32:
        case BSER_INT64:
          return this.decodeInt();
        case BSER_REAL:
          this.buf.readAdvance(1);
          return this.buf.readDouble();
        case BSER_TRUE:
          this.buf.readAdvance(1);
          return true;
        case BSER_FALSE:
          this.buf.readAdvance(1);
          return false;
        case BSER_NULL:
          this.buf.readAdvance(1);
          return null;
        case BSER_STRING:
          return this.decodeString();
        case BSER_ARRAY:
          return this.decodeArray();
        case BSER_OBJECT:
          return this.decodeObject();
        case BSER_TEMPLATE:
          return this.decodeTemplate();
        default:
          this.raise("unhandled bser opcode " + code);
      }
    };
    BunserBuf.prototype.decodeArray = function() {
      this.expectCode(BSER_ARRAY);
      var nitems = this.decodeInt();
      var arr = [];
      for (var i = 0; i < nitems; ++i) {
        arr.push(this.decodeAny());
      }
      return arr;
    };
    BunserBuf.prototype.decodeObject = function() {
      this.expectCode(BSER_OBJECT);
      var nitems = this.decodeInt();
      var res = {};
      for (var i = 0; i < nitems; ++i) {
        var key = this.decodeString();
        var val = this.decodeAny();
        res[key] = val;
      }
      return res;
    };
    BunserBuf.prototype.decodeTemplate = function() {
      this.expectCode(BSER_TEMPLATE);
      var keys = this.decodeArray();
      var nitems = this.decodeInt();
      var arr = [];
      for (var i = 0; i < nitems; ++i) {
        var obj = {};
        for (var keyidx = 0; keyidx < keys.length; ++keyidx) {
          if (this.buf.peekInt(1) == BSER_SKIP) {
            this.buf.readAdvance(1);
            continue;
          }
          var val = this.decodeAny();
          obj[keys[keyidx]] = val;
        }
        arr.push(obj);
      }
      return arr;
    };
    BunserBuf.prototype.decodeString = function() {
      this.expectCode(BSER_STRING);
      var len = this.decodeInt();
      return this.buf.readString(len);
    };
    BunserBuf.prototype.decodeInt = function(relaxSizeAsserts) {
      if (relaxSizeAsserts && this.buf.readAvail() < 1) {
        return false;
      } else {
        this.buf.assertReadableSize(1);
      }
      var code = this.buf.peekInt(1);
      var size = 0;
      switch (code) {
        case BSER_INT8:
          size = 1;
          break;
        case BSER_INT16:
          size = 2;
          break;
        case BSER_INT32:
          size = 4;
          break;
        case BSER_INT64:
          size = 8;
          break;
        default:
          this.raise("invalid bser int encoding " + code);
      }
      if (relaxSizeAsserts && this.buf.readAvail() < 1 + size) {
        return false;
      }
      this.buf.readAdvance(1);
      return this.buf.readInt(size);
    };
    function loadFromBuffer(input) {
      var buf = new BunserBuf();
      var result = buf.append(input, true);
      if (buf.buf.readAvail()) {
        throw Error("excess data found after input buffer, use BunserBuf instead");
      }
      if (typeof result === "undefined") {
        throw Error("no bser found in string and no error raised!?");
      }
      return result;
    }
    exports.loadFromBuffer = loadFromBuffer;
    function byteswap64(buf) {
      var swap = Buffer.alloc(buf.length);
      for (var i = 0; i < buf.length; i++) {
        swap[i] = buf[buf.length - 1 - i];
      }
      return swap;
    }
    function dump_int64(buf, val) {
      var be = val.toBuffer();
      if (isBigEndian) {
        buf.writeByte(BSER_INT64);
        buf.append(be);
        return;
      }
      var le = byteswap64(be);
      buf.writeByte(BSER_INT64);
      buf.append(le);
    }
    function dump_int(buf, val) {
      var abs = Math.abs(val);
      if (abs <= MAX_INT8) {
        buf.writeByte(BSER_INT8);
        buf.writeInt(val, 1);
      } else if (abs <= MAX_INT16) {
        buf.writeByte(BSER_INT16);
        buf.writeInt(val, 2);
      } else if (abs <= MAX_INT32) {
        buf.writeByte(BSER_INT32);
        buf.writeInt(val, 4);
      } else {
        dump_int64(buf, new Int64(val));
      }
    }
    function dump_any(buf, val) {
      switch (typeof val) {
        case "number":
          if (isFinite(val) && Math.floor(val) === val) {
            dump_int(buf, val);
          } else {
            buf.writeByte(BSER_REAL);
            buf.writeDouble(val);
          }
          return;
        case "string":
          buf.writeByte(BSER_STRING);
          dump_int(buf, Buffer.byteLength(val));
          buf.append(val);
          return;
        case "boolean":
          buf.writeByte(val ? BSER_TRUE : BSER_FALSE);
          return;
        case "object":
          if (val === null) {
            buf.writeByte(BSER_NULL);
            return;
          }
          if (val instanceof Int64) {
            dump_int64(buf, val);
            return;
          }
          if (Array.isArray(val)) {
            buf.writeByte(BSER_ARRAY);
            dump_int(buf, val.length);
            for (var i = 0; i < val.length; ++i) {
              dump_any(buf, val[i]);
            }
            return;
          }
          buf.writeByte(BSER_OBJECT);
          var keys = Object.keys(val);
          var num_keys = keys.length;
          for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var v = val[key];
            if (typeof v == "undefined") {
              num_keys--;
            }
          }
          dump_int(buf, num_keys);
          for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            var v = val[key];
            if (typeof v == "undefined") {
              continue;
            }
            dump_any(buf, key);
            try {
              dump_any(buf, v);
            } catch (e) {
              throw new Error(e.message + " (while serializing object property with name `" + key + "')");
            }
          }
          return;
        default:
          throw new Error("cannot serialize type " + typeof val + " to BSER");
      }
    }
    function dumpToBuffer(val) {
      var buf = new Accumulator();
      buf.writeByte(0);
      buf.writeByte(1);
      buf.writeByte(BSER_INT32);
      buf.writeInt(0, 4);
      dump_any(buf, val);
      var off = buf.writeOffset;
      var len = off - 7;
      buf.writeOffset = 3;
      buf.writeInt(len, 4);
      buf.writeOffset = off;
      return buf.buf.slice(0, off);
    }
    exports.dumpToBuffer = dumpToBuffer;
  }
});

// node_modules/fb-watchman/index.js
var require_fb_watchman = __commonJS({
  "node_modules/fb-watchman/index.js"(exports, module2) {
    "use strict";
    var net2 = require("net");
    var EE = require("events").EventEmitter;
    var util4 = require("util");
    var childProcess = require("child_process");
    var bser = require_bser();
    var unilateralTags = ["subscription", "log"];
    function Client2(options2) {
      var self2 = this;
      EE.call(this);
      this.watchmanBinaryPath = "watchman";
      if (options2 && options2.watchmanBinaryPath) {
        this.watchmanBinaryPath = options2.watchmanBinaryPath.trim();
      }
      ;
      this.commands = [];
    }
    util4.inherits(Client2, EE);
    module2.exports.Client = Client2;
    Client2.prototype.sendNextCommand = function() {
      if (this.currentCommand) {
        return;
      }
      this.currentCommand = this.commands.shift();
      if (!this.currentCommand) {
        return;
      }
      this.socket.write(bser.dumpToBuffer(this.currentCommand.cmd));
    };
    Client2.prototype.cancelCommands = function(why) {
      var error = new Error(why);
      var cmds = this.commands;
      this.commands = [];
      if (this.currentCommand) {
        cmds.unshift(this.currentCommand);
        this.currentCommand = null;
      }
      cmds.forEach(function(cmd) {
        cmd.cb(error);
      });
    };
    Client2.prototype.connect = function() {
      var self2 = this;
      function makeSock(sockname) {
        self2.bunser = new bser.BunserBuf();
        self2.bunser.on("value", function(obj) {
          var unilateral = false;
          for (var i = 0; i < unilateralTags.length; i++) {
            var tag = unilateralTags[i];
            if (tag in obj) {
              unilateral = tag;
            }
          }
          if (unilateral) {
            self2.emit(unilateral, obj);
          } else if (self2.currentCommand) {
            var cmd = self2.currentCommand;
            self2.currentCommand = null;
            if ("error" in obj) {
              var error = new Error(obj.error);
              error.watchmanResponse = obj;
              cmd.cb(error);
            } else {
              cmd.cb(null, obj);
            }
          }
          self2.sendNextCommand();
        });
        self2.bunser.on("error", function(err) {
          self2.emit("error", err);
        });
        self2.socket = net2.createConnection(sockname);
        self2.socket.on("connect", function() {
          self2.connecting = false;
          self2.emit("connect");
          self2.sendNextCommand();
        });
        self2.socket.on("error", function(err) {
          self2.connecting = false;
          self2.emit("error", err);
        });
        self2.socket.on("data", function(buf) {
          if (self2.bunser) {
            self2.bunser.append(buf);
          }
        });
        self2.socket.on("end", function() {
          self2.socket = null;
          self2.bunser = null;
          self2.cancelCommands("The watchman connection was closed");
          self2.emit("end");
        });
      }
      if (process.env.WATCHMAN_SOCK) {
        makeSock(process.env.WATCHMAN_SOCK);
        return;
      }
      var args = ["--no-pretty", "get-sockname"];
      var proc = null;
      var spawnFailed = false;
      function spawnError(error) {
        if (spawnFailed) {
          return;
        }
        spawnFailed = true;
        if (error.errno === "EACCES") {
          error.message = "The Watchman CLI is installed but cannot be spawned because of a permission problem";
        } else if (error.errno === "ENOENT") {
          error.message = "Watchman was not found in PATH.  See https://facebook.github.io/watchman/docs/install.html for installation instructions";
        }
        console.error("Watchman: ", error.message);
        self2.emit("error", error);
      }
      try {
        proc = childProcess.spawn(this.watchmanBinaryPath, args, {
          stdio: ["ignore", "pipe", "pipe"]
        });
      } catch (error) {
        spawnError(error);
        return;
      }
      var stdout = [];
      var stderr = [];
      proc.stdout.on("data", function(data) {
        stdout.push(data);
      });
      proc.stderr.on("data", function(data) {
        data = data.toString("utf8");
        stderr.push(data);
        console.error(data);
      });
      proc.on("error", function(error) {
        spawnError(error);
      });
      proc.on("close", function(code, signal) {
        if (code !== 0) {
          spawnError(new Error(self2.watchmanBinaryPath + " " + args.join(" ") + " returned with exit code=" + code + ", signal=" + signal + ", stderr= " + stderr.join("")));
          return;
        }
        try {
          var obj = JSON.parse(stdout.join(""));
          if ("error" in obj) {
            var error = new Error(obj.error);
            error.watchmanResponse = obj;
            self2.emit("error", error);
            return;
          }
          makeSock(obj.sockname);
        } catch (e) {
          self2.emit("error", e);
        }
      });
    };
    Client2.prototype.command = function(args, done) {
      done = done || function() {
      };
      this.commands.push({ cmd: args, cb: done });
      if (!this.socket) {
        if (!this.connecting) {
          this.connecting = true;
          this.connect();
          return;
        }
        return;
      }
      this.sendNextCommand();
    };
    var cap_versions = {
      "cmd-watch-del-all": "3.1.1",
      "cmd-watch-project": "3.1",
      "relative_root": "3.3",
      "term-dirname": "3.1",
      "term-idirname": "3.1",
      "wildmatch": "3.7"
    };
    function vers_compare(a, b) {
      a = a.split(".");
      b = b.split(".");
      for (var i = 0; i < 3; i++) {
        var d = parseInt(a[i] || "0") - parseInt(b[i] || "0");
        if (d != 0) {
          return d;
        }
      }
      return 0;
    }
    function have_cap(vers, name2) {
      if (name2 in cap_versions) {
        return vers_compare(vers, cap_versions[name2]) >= 0;
      }
      return false;
    }
    Client2.prototype._synthesizeCapabilityCheck = function(resp, optional, required) {
      resp.capabilities = {};
      var version2 = resp.version;
      optional.forEach(function(name2) {
        resp.capabilities[name2] = have_cap(version2, name2);
      });
      required.forEach(function(name2) {
        var have = have_cap(version2, name2);
        resp.capabilities[name2] = have;
        if (!have) {
          resp.error = "client required capability `" + name2 + "` is not supported by this server";
        }
      });
      return resp;
    };
    Client2.prototype.capabilityCheck = function(caps, done) {
      var optional = caps.optional || [];
      var required = caps.required || [];
      var self2 = this;
      this.command(["version", {
        optional,
        required
      }], function(error, resp) {
        if (error) {
          done(error);
          return;
        }
        if (!("capabilities" in resp)) {
          resp = self2._synthesizeCapabilityCheck(resp, optional, required);
          if (resp.error) {
            error = new Error(resp.error);
            error.watchmanResponse = resp;
            done(error);
            return;
          }
        }
        done(null, resp);
      });
    };
    Client2.prototype.end = function() {
      this.cancelCommands("The client was ended");
      if (this.socket) {
        this.socket.end();
        this.socket = null;
      }
      this.bunser = null;
    };
  }
});

// src/core/watchman.ts
function isValidWatchRoot(root) {
  if (root == "/" || root == "/tmp" || root == "/private/tmp")
    return false;
  if (isParentFolder(root, import_os7.default.homedir(), true))
    return false;
  if (import_path9.default.parse(root).base == root)
    return false;
  if (root.startsWith("/tmp/") || root.startsWith("/private/tmp/"))
    return false;
  if (isParentFolder(import_os7.default.tmpdir(), root, true))
    return false;
  return true;
}
var import_fb_watchman, import_minimatch3, import_os7, import_path9, logger29, requiredCapabilities, Watchman;
var init_watchman = __esm({
  "src/core/watchman.ts"() {
    "use strict";
    import_fb_watchman = __toESM(require_fb_watchman());
    import_minimatch3 = __toESM(require_minimatch());
    import_os7 = __toESM(require("os"));
    import_path9 = __toESM(require("path"));
    init_esm_node();
    init_fs();
    logger29 = require_logger2()("core-watchman");
    requiredCapabilities = ["relative_root", "cmd-watch-project", "wildmatch", "field-new"];
    Watchman = class {
      constructor(binaryPath, channel) {
        this.channel = channel;
        this._disposed = false;
        this.client = new import_fb_watchman.default.Client({
          watchmanBinaryPath: binaryPath
        });
        this.client.setMaxListeners(300);
      }
      checkCapability() {
        let { client } = this;
        return new Promise((resolve3, reject) => {
          client.capabilityCheck({
            optional: [],
            required: requiredCapabilities
          }, (error, resp) => {
            if (error)
              return resolve3(false);
            let { capabilities } = resp;
            for (let key of Object.keys(capabilities)) {
              if (!capabilities[key])
                return resolve3(false);
            }
            resolve3(true);
          });
        });
      }
      async watchProject(root) {
        let resp = await this.command(["watch-project", root]);
        let { watch, warning, relative_path } = resp;
        if (!watch)
          return false;
        if (warning)
          logger29.warn(warning);
        this.watch = watch;
        this.relative_path = relative_path;
        logger29.info(`watchman watching project: ${root}`);
        this.appendOutput(`watchman watching project: ${root}`);
        return true;
      }
      command(args) {
        return new Promise((resolve3, reject) => {
          this.client.command(args, (error, resp) => {
            if (error)
              return reject(error);
            resolve3(resp);
          });
        });
      }
      async subscribe(globPattern, cb) {
        let { watch, relative_path } = this;
        if (!watch)
          throw new Error("watchman not watching");
        let { clock } = await this.command(["clock", watch]);
        let uid = v1_default();
        let sub = {
          expression: ["allof", ["match", "**/*", "wholename"]],
          fields: ["name", "size", "new", "exists", "type", "mtime_ms", "ctime_ms"],
          since: clock
        };
        let root = watch;
        if (relative_path) {
          sub.relative_root = relative_path;
          root = import_path9.default.join(watch, relative_path);
        }
        let { subscribe } = await this.command(["subscribe", watch, uid, sub]);
        this.appendOutput(`subscribing "${globPattern}" in ${root}`);
        this.client.on("subscription", (resp) => {
          if (!resp || resp.subscription != uid)
            return;
          let { files } = resp;
          if (!files)
            return;
          files = files.filter((f) => f.type == "f" && (0, import_minimatch3.default)(f.name, globPattern, { dot: true }));
          if (!files.length)
            return;
          let ev = Object.assign({}, resp);
          if (this.relative_path)
            ev.root = import_path9.default.resolve(resp.root, this.relative_path);
          this.appendOutput(`file change detected: ${JSON.stringify(ev, null, 2)}`);
          cb(ev);
        });
        return {
          dispose: () => {
            void this.unsubscribe(subscribe);
          },
          subscribe
        };
      }
      unsubscribe(subscription) {
        if (this._disposed)
          return Promise.resolve();
        let { watch } = this;
        if (!watch)
          return;
        this.appendOutput(`unsubscribe "${subscription}" in: ${watch}`);
        return this.command(["unsubscribe", watch, subscription]).catch((e) => {
          var _a;
          if ((_a = e.message) == null ? void 0 : _a.includes("The client was ended"))
            logger29.error(e);
        });
      }
      dispose() {
        if (this._disposed)
          return;
        this._disposed = true;
        if (this.client) {
          this.client.removeAllListeners();
          this.client.end();
          this.client = void 0;
        }
      }
      appendOutput(message, type = "Info") {
        if (this.channel) {
          this.channel.appendLine(`[${type}  - ${new Date().toLocaleTimeString()}] ${message}`);
        }
      }
      static async createClient(binaryPath, root, channel) {
        if (!isValidWatchRoot(root))
          throw new Error(`Watch for ${root} is ignored`);
        let watchman2;
        try {
          watchman2 = new Watchman(binaryPath, channel);
          let valid = await watchman2.checkCapability();
          if (!valid)
            throw new Error("required capabilities do not exist.");
          let watching = await watchman2.watchProject(root);
          if (!watching)
            throw new Error("unable to watch");
          return watchman2;
        } catch (e) {
          if (watchman2)
            watchman2.dispose();
          throw e;
        }
      }
    };
  }
});

// src/core/fileSystemWatcher.ts
var import_minimatch4, import_path10, import_vscode_languageserver_protocol24, logger30, _FileSystemWatcherManager, FileSystemWatcherManager, FileSystemWatcher;
var init_fileSystemWatcher = __esm({
  "src/core/fileSystemWatcher.ts"() {
    "use strict";
    import_minimatch4 = __toESM(require_minimatch());
    import_path10 = __toESM(require("path"));
    import_vscode_languageserver_protocol24 = __toESM(require_main2());
    init_esm();
    init_util();
    init_array();
    init_fs();
    init_watchman();
    logger30 = require_logger2()("filesystem-watcher");
    _FileSystemWatcherManager = class {
      constructor(workspaceFolder, watchmanPath) {
        this.workspaceFolder = workspaceFolder;
        this.watchmanPath = watchmanPath;
        this.clientsMap = /* @__PURE__ */ new Map();
        this.disposables = [];
        this.creating = /* @__PURE__ */ new Set();
        this._onDidCreateClient = new import_vscode_languageserver_protocol24.Emitter();
        this.onDidCreateClient = this._onDidCreateClient.event;
      }
      attach(channel) {
        this.channel = channel;
        let createClient = (folder) => {
          let root = URI2.parse(folder.uri).fsPath;
          void this.createClient(root);
        };
        this.workspaceFolder.workspaceFolders.forEach((folder) => {
          createClient(folder);
        });
        this.workspaceFolder.onDidChangeWorkspaceFolders((e) => {
          e.added.forEach((folder) => {
            createClient(folder);
          });
          e.removed.forEach((folder) => {
            let root = URI2.parse(folder.uri).fsPath;
            let client = this.clientsMap.get(root);
            if (client) {
              this.clientsMap.delete(root);
              client.dispose();
            }
          });
        }, null, this.disposables);
      }
      waitClient(root) {
        if (this.clientsMap.has(root))
          return Promise.resolve();
        return new Promise((resolve3) => {
          let disposable = this.onDidCreateClient((r) => {
            if (r == root) {
              disposable.dispose();
              resolve3();
            }
          });
        });
      }
      async createClient(root) {
        if (this.watchmanPath == null || this.has(root))
          return;
        try {
          this.creating.add(root);
          let client = await Watchman.createClient(this.watchmanPath, root, this.channel);
          this.creating.delete(root);
          this.clientsMap.set(root, client);
          for (let watcher of _FileSystemWatcherManager.watchers) {
            watcher.listen(root, client);
          }
          this._onDidCreateClient.fire(root);
        } catch (e) {
          this.creating.delete(root);
          if (this.channel)
            this.channel.appendLine(`Error on create watchman client:` + (e instanceof Error ? e.message : e));
        }
      }
      has(root) {
        let curr = Array.from(this.clientsMap.keys());
        curr.push(...this.creating);
        return curr.some((r) => sameFile(r, root));
      }
      createFileSystemWatcher(globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {
        let fileWatcher = new FileSystemWatcher(globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents);
        let base = typeof globPattern === "string" ? void 0 : globPattern.baseUri.fsPath;
        for (let [root, client] of this.clientsMap.entries()) {
          if (base && isParentFolder(root, base, true)) {
            base = void 0;
          }
          fileWatcher.listen(root, client);
        }
        if (base)
          void this.createClient(base);
        _FileSystemWatcherManager.watchers.add(fileWatcher);
        return fileWatcher;
      }
      dispose() {
        this._onDidCreateClient.dispose();
        for (let client of this.clientsMap.values()) {
          if (client)
            client.dispose();
        }
        this.clientsMap.clear();
        _FileSystemWatcherManager.watchers.clear();
        disposeAll(this.disposables);
      }
    };
    FileSystemWatcherManager = _FileSystemWatcherManager;
    FileSystemWatcherManager.watchers = /* @__PURE__ */ new Set();
    FileSystemWatcher = class {
      constructor(globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {
        this.globPattern = globPattern;
        this.ignoreCreateEvents = ignoreCreateEvents;
        this.ignoreChangeEvents = ignoreChangeEvents;
        this.ignoreDeleteEvents = ignoreDeleteEvents;
        this._onDidCreate = new import_vscode_languageserver_protocol24.Emitter();
        this._onDidChange = new import_vscode_languageserver_protocol24.Emitter();
        this._onDidDelete = new import_vscode_languageserver_protocol24.Emitter();
        this._onDidRename = new import_vscode_languageserver_protocol24.Emitter();
        this.disposables = [];
        this._disposed = false;
        this.onDidCreate = this._onDidCreate.event;
        this.onDidChange = this._onDidChange.event;
        this.onDidDelete = this._onDidDelete.event;
        this.onDidRename = this._onDidRename.event;
      }
      listen(root, client) {
        let {
          globPattern,
          ignoreCreateEvents,
          ignoreChangeEvents,
          ignoreDeleteEvents
        } = this;
        let pattern;
        let basePath;
        if (typeof globPattern === "string") {
          pattern = globPattern;
        } else {
          pattern = globPattern.pattern;
          basePath = globPattern.baseUri.fsPath;
          if (!isParentFolder(root, basePath, true))
            return;
        }
        const onChange = (change) => {
          let { root: root2, files } = change;
          if (basePath && !sameFile(root2, basePath)) {
            files = files.filter((f) => {
              if (f.type != "f")
                return false;
              let fullpath = import_path10.default.join(root2, f.name);
              if (!isParentFolder(basePath, fullpath))
                return false;
              return (0, import_minimatch4.default)(import_path10.default.relative(basePath, fullpath), pattern, { dot: true });
            });
          } else {
            files = files.filter((f) => f.type == "f" && (0, import_minimatch4.default)(f.name, pattern, { dot: true }));
          }
          for (let file of files) {
            let uri = URI2.file(import_path10.default.join(root2, file.name));
            if (!file.exists) {
              if (!ignoreDeleteEvents)
                this._onDidDelete.fire(uri);
            } else {
              if (file.new === true) {
                if (!ignoreCreateEvents)
                  this._onDidCreate.fire(uri);
              } else {
                if (!ignoreChangeEvents)
                  this._onDidChange.fire(uri);
              }
            }
          }
          if (files.length == 2 && files[0].exists !== files[1].exists) {
            let oldFile = files.find((o) => o.exists !== true);
            let newFile = files.find((o) => o.exists === true);
            if (oldFile.size == newFile.size) {
              this._onDidRename.fire({
                oldUri: URI2.file(import_path10.default.join(root2, oldFile.name)),
                newUri: URI2.file(import_path10.default.join(root2, newFile.name))
              });
            }
          }
          if (files.length > 2 && files.length % 2 == 0) {
            let [oldFiles, newFiles] = splitArray(files, (o) => o.exists === false);
            if (oldFiles.length == newFiles.length) {
              for (let oldFile of oldFiles) {
                let newFile = newFiles.find((o) => o.size == oldFile.size && o.mtime_ms == oldFile.mtime_ms);
                if (newFile) {
                  this._onDidRename.fire({
                    oldUri: URI2.file(import_path10.default.join(root2, oldFile.name)),
                    newUri: URI2.file(import_path10.default.join(root2, newFile.name))
                  });
                }
              }
            }
          }
        };
        client.subscribe(pattern, onChange).then((disposable) => {
          this.subscribe = disposable.subscribe;
          if (this._disposed)
            return disposable.dispose();
          this.disposables.push(disposable);
        }).logError();
      }
      dispose() {
        this._disposed = true;
        FileSystemWatcherManager.watchers.delete(this);
        this._onDidRename.dispose();
        this._onDidCreate.dispose();
        this._onDidChange.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports, module2) {
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH2 = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    module2.exports = {
      SEMVER_SPEC_VERSION,
      MAX_LENGTH: MAX_LENGTH2,
      MAX_SAFE_INTEGER,
      MAX_SAFE_COMPONENT_LENGTH
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS({
  "node_modules/semver/internal/debug.js"(exports, module2) {
    var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module2.exports = debug;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports, module2) {
    var { MAX_SAFE_COMPONENT_LENGTH } = require_constants();
    var debug = require_debug();
    exports = module2.exports = {};
    var re = exports.re = [];
    var src = exports.src = [];
    var t = exports.t = {};
    var R = 0;
    var createToken = (name2, value, isGlobal) => {
      const index = R++;
      debug(name2, index, value);
      t[name2] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
    };
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "[0-9]+");
    createToken("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports, module2) {
    var opts = ["includePrerelease", "loose", "rtl"];
    var parseOptions = (options2) => !options2 ? {} : typeof options2 !== "object" ? { loose: true } : opts.filter((k) => options2[k]).reduce((o, k) => {
      o[k] = true;
      return o;
    }, {});
    module2.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports, module2) {
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = (a, b) => {
      const anum = numeric.test(a);
      const bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    };
    var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
    module2.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports, module2) {
    var debug = require_debug();
    var { MAX_LENGTH: MAX_LENGTH2, MAX_SAFE_INTEGER } = require_constants();
    var { re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class {
      constructor(version2, options2) {
        options2 = parseOptions(options2);
        if (version2 instanceof SemVer) {
          if (version2.loose === !!options2.loose && version2.includePrerelease === !!options2.includePrerelease) {
            return version2;
          } else {
            version2 = version2.version;
          }
        } else if (typeof version2 !== "string") {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        if (version2.length > MAX_LENGTH2) {
          throw new TypeError(`version is longer than ${MAX_LENGTH2} characters`);
        }
        debug("SemVer", version2, options2);
        this.options = options2;
        this.loose = !!options2.loose;
        this.includePrerelease = !!options2.includePrerelease;
        const m = version2.trim().match(options2.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
          throw new TypeError(`Invalid Version: ${version2}`);
        }
        this.raw = version2;
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a = this.prerelease[i];
          const b = other.prerelease[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof SemVer)) {
          other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a = this.build[i];
          const b = other.build[i];
          debug("prerelease compare", i, a, b);
          if (a === void 0 && b === void 0) {
            return 0;
          } else if (b === void 0) {
            return 1;
          } else if (a === void 0) {
            return -1;
          } else if (a === b) {
            continue;
          } else {
            return compareIdentifiers(a, b);
          }
        } while (++i);
      }
      inc(release, identifier) {
        switch (release) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier);
            this.inc("pre", identifier);
            break;
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier);
            }
            this.inc("pre", identifier);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          case "pre":
            if (this.prerelease.length === 0) {
              this.prerelease = [0];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                this.prerelease.push(0);
              }
            }
            if (identifier) {
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = [identifier, 0];
                }
              } else {
                this.prerelease = [identifier, 0];
              }
            }
            break;
          default:
            throw new Error(`invalid increment argument: ${release}`);
        }
        this.format();
        this.raw = this.version;
        return this;
      }
    };
    module2.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse = __commonJS({
  "node_modules/semver/functions/parse.js"(exports, module2) {
    var { MAX_LENGTH: MAX_LENGTH2 } = require_constants();
    var { re, t } = require_re();
    var SemVer = require_semver();
    var parseOptions = require_parse_options();
    var parse4 = (version2, options2) => {
      options2 = parseOptions(options2);
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 !== "string") {
        return null;
      }
      if (version2.length > MAX_LENGTH2) {
        return null;
      }
      const r = options2.loose ? re[t.LOOSE] : re[t.FULL];
      if (!r.test(version2)) {
        return null;
      }
      try {
        return new SemVer(version2, options2);
      } catch (er) {
        return null;
      }
    };
    module2.exports = parse4;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports, module2) {
    var parse4 = require_parse();
    var valid = (version2, options2) => {
      const v = parse4(version2, options2);
      return v ? v.version : null;
    };
    module2.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports, module2) {
    var parse4 = require_parse();
    var clean = (version2, options2) => {
      const s = parse4(version2.trim().replace(/^[=v]+/, ""), options2);
      return s ? s.version : null;
    };
    module2.exports = clean;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports, module2) {
    var SemVer = require_semver();
    var inc = (version2, release, options2, identifier) => {
      if (typeof options2 === "string") {
        identifier = options2;
        options2 = void 0;
      }
      try {
        return new SemVer(version2 instanceof SemVer ? version2.version : version2, options2).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    };
    module2.exports = inc;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports, module2) {
    var SemVer = require_semver();
    var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
    module2.exports = compare;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports, module2) {
    var compare = require_compare();
    var eq = (a, b, loose) => compare(a, b, loose) === 0;
    module2.exports = eq;
  }
});

// node_modules/semver/functions/diff.js
var require_diff2 = __commonJS({
  "node_modules/semver/functions/diff.js"(exports, module2) {
    var parse4 = require_parse();
    var eq = require_eq();
    var diff = (version1, version2) => {
      if (eq(version1, version2)) {
        return null;
      } else {
        const v12 = parse4(version1);
        const v2 = parse4(version2);
        const hasPre = v12.prerelease.length || v2.prerelease.length;
        const prefix = hasPre ? "pre" : "";
        const defaultResult = hasPre ? "prerelease" : "";
        for (const key in v12) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v12[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    };
    module2.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports, module2) {
    var SemVer = require_semver();
    var major = (a, loose) => new SemVer(a, loose).major;
    module2.exports = major;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports, module2) {
    var SemVer = require_semver();
    var minor = (a, loose) => new SemVer(a, loose).minor;
    module2.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports, module2) {
    var SemVer = require_semver();
    var patch = (a, loose) => new SemVer(a, loose).patch;
    module2.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports, module2) {
    var parse4 = require_parse();
    var prerelease = (version2, options2) => {
      const parsed = parse4(version2, options2);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    };
    module2.exports = prerelease;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports, module2) {
    var compare = require_compare();
    var rcompare = (a, b, loose) => compare(b, a, loose);
    module2.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports, module2) {
    var compare = require_compare();
    var compareLoose = (a, b) => compare(a, b, true);
    module2.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports, module2) {
    var SemVer = require_semver();
    var compareBuild = (a, b, loose) => {
      const versionA = new SemVer(a, loose);
      const versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    };
    module2.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports, module2) {
    var compareBuild = require_compare_build();
    var sort = (list2, loose) => list2.sort((a, b) => compareBuild(a, b, loose));
    module2.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports, module2) {
    var compareBuild = require_compare_build();
    var rsort = (list2, loose) => list2.sort((a, b) => compareBuild(b, a, loose));
    module2.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports, module2) {
    var compare = require_compare();
    var gt = (a, b, loose) => compare(a, b, loose) > 0;
    module2.exports = gt;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports, module2) {
    var compare = require_compare();
    var lt = (a, b, loose) => compare(a, b, loose) < 0;
    module2.exports = lt;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports, module2) {
    var compare = require_compare();
    var neq = (a, b, loose) => compare(a, b, loose) !== 0;
    module2.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports, module2) {
    var compare = require_compare();
    var gte = (a, b, loose) => compare(a, b, loose) >= 0;
    module2.exports = gte;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports, module2) {
    var compare = require_compare();
    var lte = (a, b, loose) => compare(a, b, loose) <= 0;
    module2.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports, module2) {
    var eq = require_eq();
    var neq = require_neq();
    var gt = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = (a, op, b, loose) => {
      switch (op) {
        case "===":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a === b;
        case "!==":
          if (typeof a === "object") {
            a = a.version;
          }
          if (typeof b === "object") {
            b = b.version;
          }
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    };
    module2.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports, module2) {
    var SemVer = require_semver();
    var parse4 = require_parse();
    var { re, t } = require_re();
    var coerce = (version2, options2) => {
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 === "number") {
        version2 = String(version2);
      }
      if (typeof version2 !== "string") {
        return null;
      }
      options2 = options2 || {};
      let match = null;
      if (!options2.rtl) {
        match = version2.match(re[t.COERCE]);
      } else {
        let next;
        while ((next = re[t.COERCERTL].exec(version2)) && (!match || match.index + match[0].length !== version2.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re[t.COERCERTL].lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      return parse4(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options2);
    };
    module2.exports = coerce;
  }
});

// node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/yallist/iterator.js"(exports, module2) {
    "use strict";
    module2.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/yallist/yallist.js"(exports, module2) {
    "use strict";
    module2.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list2) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list2 && typeof list2.forEach === "function") {
        list2.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value, prev, next, list2) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list2);
      }
      this.list = list2;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/lru-cache/index.js"(exports, module2) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache = class {
      constructor(options2) {
        if (typeof options2 === "number")
          options2 = { max: options2 };
        if (!options2)
          options2 = {};
        if (options2.max && (typeof options2.max !== "number" || options2.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options2.max || Infinity;
        const lc = options2.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options2.stale || false;
        if (options2.maxAge && typeof options2.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options2.maxAge || 0;
        this[DISPOSE] = options2.dispose;
        this[NO_DISPOSE_ON_SET] = options2.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options2.updateAgeOnGet || false;
        this.reset();
      }
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key))
          return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get(this, key, false));
      }
    };
    var get = (self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    };
    var Entry = class {
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module2.exports = LRUCache;
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports, module2) {
    var Range53 = class {
      constructor(range2, options2) {
        options2 = parseOptions(options2);
        if (range2 instanceof Range53) {
          if (range2.loose === !!options2.loose && range2.includePrerelease === !!options2.includePrerelease) {
            return range2;
          } else {
            return new Range53(range2.raw, options2);
          }
        }
        if (range2 instanceof Comparator) {
          this.raw = range2.value;
          this.set = [[range2]];
          this.format();
          return this;
        }
        this.options = options2;
        this.loose = !!options2.loose;
        this.includePrerelease = !!options2.includePrerelease;
        this.raw = range2;
        this.set = range2.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${range2}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => {
          return comps.join(" ").trim();
        }).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range2) {
        range2 = range2.trim();
        const memoOpts = Object.keys(this.options).join(",");
        const memoKey = `parseRange:${memoOpts}:${range2}`;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range2 = range2.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range2);
        range2 = range2.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range2);
        range2 = range2.replace(re[t.TILDETRIM], tildeTrimReplace);
        range2 = range2.replace(re[t.CARETTRIM], caretTrimReplace);
        range2 = range2.split(/\s+/).join(" ");
        let rangeList = range2.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range2, options2) {
        if (!(range2 instanceof Range53)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options2) && range2.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options2) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options2);
              });
            });
          });
        });
      }
      test(version2) {
        if (!version2) {
          return false;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version2, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = Range53;
    var LRU = require_lru_cache();
    var cache = new LRU({ max: 1e3 });
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug = require_debug();
    var SemVer = require_semver();
    var {
      re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var isNullSet = (c) => c.value === "<0.0.0-0";
    var isAny = (c) => c.value === "";
    var isSatisfiable = (comparators, options2) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options2);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    };
    var parseComparator = (comp, options2) => {
      debug("comp", comp, options2);
      comp = replaceCarets(comp, options2);
      debug("caret", comp);
      comp = replaceTildes(comp, options2);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options2);
      debug("xrange", comp);
      comp = replaceStars(comp, options2);
      debug("stars", comp);
      return comp;
    };
    var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
    var replaceTildes = (comp, options2) => comp.trim().split(/\s+/).map((c) => {
      return replaceTilde(c, options2);
    }).join(" ");
    var replaceTilde = (comp, options2) => {
      const r = options2.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
          ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
      });
    };
    var replaceCarets = (comp, options2) => comp.trim().split(/\s+/).map((c) => {
      return replaceCaret(c, options2);
    }).join(" ");
    var replaceCaret = (comp, options2) => {
      debug("caret", comp, options2);
      const r = options2.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z = options2.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m, p, pr) => {
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
          if (M === "0") {
            ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
          } else {
            ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
            } else {
              ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
          }
        }
        debug("caret return", ret);
        return ret;
      });
    };
    var replaceXRanges = (comp, options2) => {
      debug("replaceXRanges", comp, options2);
      return comp.split(/\s+/).map((c) => {
        return replaceXRange(c, options2);
      }).join(" ");
    };
    var replaceXRange = (comp, options2) => {
      comp = comp.trim();
      const r = options2.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options2.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          if (gtlt === "<") {
            pr = "-0";
          }
          ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
      });
    };
    var replaceStars = (comp, options2) => {
      debug("replaceStars", comp, options2);
      return comp.trim().replace(re[t.STAR], "");
    };
    var replaceGTE0 = (comp, options2) => {
      debug("replaceGTE0", comp, options2);
      return comp.trim().replace(re[options2.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    };
    var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    };
    var testSet = (set, version2, options2) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version2)) {
          return false;
        }
      }
      if (version2.prerelease.length && !options2.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    };
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports, module2) {
    var ANY = Symbol("SemVer ANY");
    var Comparator = class {
      static get ANY() {
        return ANY;
      }
      constructor(comp, options2) {
        options2 = parseOptions(options2);
        if (comp instanceof Comparator) {
          if (comp.loose === !!options2.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        debug("comparator", comp, options2);
        this.options = options2;
        this.loose = !!options2.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== void 0 ? m[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version2) {
        debug("Comparator.test", version2, this.options.loose);
        if (this.semver === ANY || version2 === ANY) {
          return true;
        }
        if (typeof version2 === "string") {
          try {
            version2 = new SemVer(version2, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version2, this.operator, this.semver, this.options);
      }
      intersects(comp, options2) {
        if (!(comp instanceof Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (!options2 || typeof options2 !== "object") {
          options2 = {
            loose: !!options2,
            includePrerelease: false
          };
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range53(comp.value, options2).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range53(this.value, options2).test(comp.semver);
        }
        const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
        const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
        const sameSemVer = this.semver.version === comp.semver.version;
        const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
        const oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options2) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
        const oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options2) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
        return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
      }
    };
    module2.exports = Comparator;
    var parseOptions = require_parse_options();
    var { re, t } = require_re();
    var cmp = require_cmp();
    var debug = require_debug();
    var SemVer = require_semver();
    var Range53 = require_range();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports, module2) {
    var Range53 = require_range();
    var satisfies = (version2, range2, options2) => {
      try {
        range2 = new Range53(range2, options2);
      } catch (er) {
        return false;
      }
      return range2.test(version2);
    };
    module2.exports = satisfies;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports, module2) {
    var Range53 = require_range();
    var toComparators = (range2, options2) => new Range53(range2, options2).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
    module2.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports, module2) {
    var SemVer = require_semver();
    var Range53 = require_range();
    var maxSatisfying = (versions, range2, options2) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range53(range2, options2);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options2);
          }
        }
      });
      return max;
    };
    module2.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports, module2) {
    var SemVer = require_semver();
    var Range53 = require_range();
    var minSatisfying = (versions, range2, options2) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range53(range2, options2);
      } catch (er) {
        return null;
      }
      versions.forEach((v) => {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options2);
          }
        }
      });
      return min;
    };
    module2.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports, module2) {
    var SemVer = require_semver();
    var Range53 = require_range();
    var gt = require_gt();
    var minVersion = (range2, loose) => {
      range2 = new Range53(range2, loose);
      let minver = new SemVer("0.0.0");
      if (range2.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range2.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range2.set.length; ++i) {
        const comparators = range2.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!setMin || gt(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range2.test(minver)) {
        return minver;
      }
      return null;
    };
    module2.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports, module2) {
    var Range53 = require_range();
    var validRange = (range2, options2) => {
      try {
        return new Range53(range2, options2).range || "*";
      } catch (er) {
        return null;
      }
    };
    module2.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports, module2) {
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range53 = require_range();
    var satisfies = require_satisfies();
    var gt = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = (version2, range2, hilo, options2) => {
      version2 = new SemVer(version2, options2);
      range2 = new Range53(range2, options2);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version2, range2, options2)) {
        return false;
      }
      for (let i = 0; i < range2.set.length; ++i) {
        const comparators = range2.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options2)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options2)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
          return false;
        }
      }
      return true;
    };
    module2.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports, module2) {
    var outside = require_outside();
    var gtr = (version2, range2, options2) => outside(version2, range2, ">", options2);
    module2.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports, module2) {
    var outside = require_outside();
    var ltr = (version2, range2, options2) => outside(version2, range2, "<", options2);
    module2.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports, module2) {
    var Range53 = require_range();
    var intersects = (r1, r2, options2) => {
      r1 = new Range53(r1, options2);
      r2 = new Range53(r2, options2);
      return r1.intersects(r2);
    };
    module2.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports, module2) {
    var satisfies = require_satisfies();
    var compare = require_compare();
    module2.exports = (versions, range2, options2) => {
      const set = [];
      let first = null;
      let prev = null;
      const v = versions.sort((a, b) => compare(a, b, options2));
      for (const version2 of v) {
        const included = satisfies(version2, range2, options2);
        if (included) {
          prev = version2;
          if (!first) {
            first = version2;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range2.raw === "string" ? range2.raw : String(range2);
      return simplified.length < original.length ? simplified : range2;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports, module2) {
    var Range53 = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = (sub, dom, options2 = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range53(sub, options2);
      dom = new Range53(dom, options2);
      let sawNonNull = false;
      OUTER:
        for (const simpleSub of sub.set) {
          for (const simpleDom of dom.set) {
            const isSub = simpleSubset(simpleSub, simpleDom, options2);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) {
              continue OUTER;
            }
          }
          if (sawNonNull) {
            return false;
          }
        }
      return true;
    };
    var simpleSubset = (sub, dom, options2) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options2.includePrerelease) {
          sub = [new Comparator(">=0.0.0-0")];
        } else {
          sub = [new Comparator(">=0.0.0")];
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options2.includePrerelease) {
          return true;
        } else {
          dom = [new Comparator(">=0.0.0")];
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt = higherGT(gt, c, options2);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options2);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options2);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt && !satisfies(eq, String(gt), options2)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options2)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options2)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options2.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt && !options2.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt, c, options2);
            if (higher === c && higher !== gt) {
              return false;
            }
          } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options2)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options2);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options2)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    };
    var higherGT = (a, b, options2) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options2);
      return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
    };
    var lowerLT = (a, b, options2) => {
      if (!a) {
        return b;
      }
      const comp = compare(a.semver, b.semver, options2);
      return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
    };
    module2.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports, module2) {
    var internalRe = require_re();
    module2.exports = {
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: require_constants().SEMVER_SPEC_VERSION,
      SemVer: require_semver(),
      compareIdentifiers: require_identifiers().compareIdentifiers,
      rcompareIdentifiers: require_identifiers().rcompareIdentifiers,
      parse: require_parse(),
      valid: require_valid(),
      clean: require_clean(),
      inc: require_inc(),
      diff: require_diff2(),
      major: require_major(),
      minor: require_minor(),
      patch: require_patch(),
      prerelease: require_prerelease(),
      compare: require_compare(),
      rcompare: require_rcompare(),
      compareLoose: require_compare_loose(),
      compareBuild: require_compare_build(),
      sort: require_sort(),
      rsort: require_rsort(),
      gt: require_gt(),
      lt: require_lt(),
      eq: require_eq(),
      neq: require_neq(),
      gte: require_gte(),
      lte: require_lte(),
      cmp: require_cmp(),
      coerce: require_coerce(),
      Comparator: require_comparator(),
      Range: require_range(),
      satisfies: require_satisfies(),
      toComparators: require_to_comparators(),
      maxSatisfying: require_max_satisfying(),
      minSatisfying: require_min_satisfying(),
      minVersion: require_min_version(),
      validRange: require_valid2(),
      outside: require_outside(),
      gtr: require_gtr(),
      ltr: require_ltr(),
      intersects: require_intersects(),
      simplifyRange: require_simplify(),
      subset: require_subset()
    };
  }
});

// src/model/resolver.ts
var import_path11, import_fs13, import_strip_ansi2, logger31, Resolver;
var init_resolver = __esm({
  "src/model/resolver.ts"() {
    "use strict";
    import_path11 = __toESM(require("path"));
    import_fs13 = __toESM(require("fs"));
    init_util();
    init_fs();
    import_strip_ansi2 = __toESM(require_strip_ansi());
    logger31 = require_logger2()("model-resolver");
    Resolver = class {
      get nodeFolder() {
        if (!executable("npm"))
          return Promise.resolve("");
        if (this._npmFolder)
          return Promise.resolve(this._npmFolder);
        return runCommand("npm --loglevel silent root -g", {}, 3e3).then((root) => {
          this._npmFolder = (0, import_strip_ansi2.default)(root).trim();
          return this._npmFolder;
        });
      }
      get yarnFolder() {
        if (!executable("yarnpkg"))
          return Promise.resolve("");
        if (this._yarnFolder)
          return Promise.resolve(this._yarnFolder);
        return runCommand("yarnpkg global dir", {}, 3e3).then((root) => {
          let folder = import_path11.default.join((0, import_strip_ansi2.default)(root).trim(), "node_modules");
          let exists = import_fs13.default.existsSync(folder);
          if (exists)
            this._yarnFolder = folder;
          return exists ? folder : "";
        });
      }
      async resolveModule(mod) {
        let nodeFolder = await this.nodeFolder;
        let yarnFolder = await this.yarnFolder;
        if (yarnFolder) {
          let s = await statAsync(import_path11.default.join(yarnFolder, mod, "package.json"));
          if (s && s.isFile())
            return import_path11.default.join(yarnFolder, mod);
        }
        if (nodeFolder) {
          let s = await statAsync(import_path11.default.join(nodeFolder, mod, "package.json"));
          if (s && s.isFile())
            return import_path11.default.join(nodeFolder, mod);
        }
        return null;
      }
    };
  }
});

// src/core/funcs.ts
function has(env, feature) {
  if (!feature.startsWith("nvim-") && !feature.startsWith("patch-")) {
    throw new Error("Feature param could only starts with nvim and patch");
  }
  if (!env.isVim && feature.startsWith("patch-")) {
    return false;
  }
  if (env.isVim && feature.startsWith("nvim-")) {
    return false;
  }
  if (env.isVim) {
    let [_, major, minor, patch] = env.version.match(/^(\d)(\d{2})(\d+)$/);
    let version2 = `${major}.${parseInt(minor, 10)}.${parseInt(patch, 10)}`;
    return import_semver.default.gte(version2, feature.slice(6));
  }
  return import_semver.default.gte(env.version, feature.slice(5));
}
function createNameSpace(name2 = "") {
  if (namespaceMap.has(name2))
    return namespaceMap.get(name2);
  NAME_SPACE = NAME_SPACE + 1;
  namespaceMap.set(name2, NAME_SPACE);
  return NAME_SPACE;
}
function getWatchmanPath(configurations) {
  const preferences = configurations.getConfiguration("coc.preferences");
  let watchmanPath = preferences.get("watchmanPath", "watchman");
  try {
    return import_which2.default.sync(watchmanPath);
  } catch (e) {
    return null;
  }
}
async function findUp2(nvim, cwd, filename) {
  let filepath = await nvim.call("expand", "%:p");
  filepath = import_path12.default.normalize(filepath);
  let isFile2 = filepath && import_path12.default.isAbsolute(filepath);
  if (isFile2 && !isParentFolder(cwd, filepath, true)) {
    return findUp(filename, import_path12.default.dirname(filepath));
  }
  let res = findUp(filename, cwd);
  if (res && res != import_os8.default.homedir())
    return res;
  if (isFile2)
    return findUp(filename, import_path12.default.dirname(filepath));
  return null;
}
function resolveModule(name2) {
  return resolver.resolveModule(name2);
}
function score2(selector, uri, languageId) {
  if (Array.isArray(selector)) {
    let ret = 0;
    for (const filter2 of selector) {
      const value = score2(filter2, uri, languageId);
      if (value === 10) {
        return value;
      }
      if (value > ret) {
        ret = value;
      }
    }
    return ret;
  } else if (typeof selector === "string") {
    if (selector === "*") {
      return 5;
    } else if (selector === languageId) {
      return 10;
    } else {
      return 0;
    }
  } else if (selector && import_vscode_languageserver_protocol25.TextDocumentFilter.is(selector)) {
    let u = URI2.parse(uri);
    const { language: language2, pattern, scheme } = selector;
    let ret = 0;
    if (scheme) {
      if (scheme === u.scheme) {
        ret = 5;
      } else if (scheme === "*") {
        ret = 3;
      } else {
        return 0;
      }
    }
    if (language2) {
      if (language2 === languageId) {
        ret = 10;
      } else if (language2 === "*") {
        ret = Math.max(ret, 5);
      } else {
        return 0;
      }
    }
    if (pattern) {
      let caseInsensitive = isWindows || isMacintosh;
      let p = caseInsensitive ? pattern.toLowerCase() : pattern;
      let f = caseInsensitive ? u.fsPath.toLowerCase() : u.fsPath;
      if (p === f || (0, import_minimatch5.default)(f, p, { dot: true })) {
        ret = 5;
      } else {
        return 0;
      }
    }
    return ret;
  } else {
    return 0;
  }
}
var import_minimatch5, import_os8, import_path12, import_semver, import_vscode_languageserver_protocol25, import_which2, NAME_SPACE, resolver, namespaceMap;
var init_funcs = __esm({
  "src/core/funcs.ts"() {
    "use strict";
    import_minimatch5 = __toESM(require_minimatch());
    import_os8 = __toESM(require("os"));
    import_path12 = __toESM(require("path"));
    import_semver = __toESM(require_semver2());
    import_vscode_languageserver_protocol25 = __toESM(require_main2());
    init_esm();
    import_which2 = __toESM(require_which());
    init_resolver();
    init_fs();
    init_platform();
    NAME_SPACE = 2e3;
    resolver = new Resolver();
    namespaceMap = /* @__PURE__ */ new Map();
  }
});

// src/core/keymaps.ts
var import_vscode_languageserver_protocol26, logger32, Keymaps;
var init_keymaps = __esm({
  "src/core/keymaps.ts"() {
    "use strict";
    init_esm_node();
    import_vscode_languageserver_protocol26 = __toESM(require_main2());
    init_util();
    logger32 = require_logger2()("core-keymaps");
    Keymaps = class {
      constructor(documents) {
        this.documents = documents;
        this.keymaps = /* @__PURE__ */ new Map();
      }
      attach(nvim) {
        this.nvim = nvim;
      }
      async doKeymap(key, defaultReturn = "", pressed) {
        let keymap = this.keymaps.get(key);
        if (!keymap) {
          logger32.error(`keymap for ${key} not found`);
          if (pressed)
            this.nvim.command(`silent! unmap <buffer> ${pressed.startsWith("{") && pressed.endsWith("}") ? `<${pressed.slice(1, -1)}>` : pressed}`, true);
          return defaultReturn;
        }
        let [fn, repeat2] = keymap;
        let res = await Promise.resolve(fn());
        if (repeat2)
          await this.nvim.command(`silent! call repeat#set("\\<Plug>(coc-${key})", -1)`);
        return res ?? defaultReturn;
      }
      registerKeymap(modes, key, fn, opts = {}) {
        if (!key)
          throw new Error(`Invalid key ${key} of registerKeymap`);
        if (this.keymaps.has(key))
          throw new Error(`${key} already exists.`);
        opts = Object.assign({ sync: true, cancel: true, silent: true, repeat: false }, opts);
        let { nvim } = this;
        this.keymaps.set(key, [fn, !!opts.repeat]);
        let method = opts.sync ? "request" : "notify";
        let silent = opts.silent ? "<silent>" : "";
        for (let m of modes) {
          if (m == "i") {
            nvim.command(`inoremap ${silent}<expr> <Plug>(coc-${key}) coc#_insert_key('${method}', '${key}', ${opts.cancel ? 1 : 0})`, true);
          } else {
            let modify2 = getKeymapModifier(m);
            nvim.command(`${m}noremap ${silent} <Plug>(coc-${key}) :${modify2}call coc#rpc#${method}('doKeymap', ['${key}'])<cr>`, true);
          }
        }
        return import_vscode_languageserver_protocol26.Disposable.create(() => {
          this.keymaps.delete(key);
          for (let m of modes) {
            nvim.command(`${m}unmap <Plug>(coc-${key})`, true);
          }
        });
      }
      registerExprKeymap(mode, key, fn, buffer = false) {
        let id = `${mode}${global.Buffer.from(key).toString("base64")}${buffer ? "1" : "0"}`;
        let { nvim } = this;
        this.keymaps.set(id, [fn, false]);
        if (mode == "i") {
          nvim.command(`inoremap <silent><expr>${buffer ? "<nowait><buffer>" : ""} ${key} coc#_insert_key('request', '${id}')`, true);
        } else {
          nvim.command(`${mode}noremap <silent><expr>${buffer ? "<nowait><buffer>" : ""} ${key} coc#rpc#request('doKeymap', ['${id}'])`, true);
        }
        return import_vscode_languageserver_protocol26.Disposable.create(() => {
          this.keymaps.delete(id);
          nvim.command(`${mode}unmap ${buffer ? "<buffer>" : ""} ${key}`, true);
        });
      }
      registerLocalKeymap(mode, key, fn, notify = false) {
        let id = v1_default();
        let { nvim } = this;
        let bufnr = this.documents.bufnr;
        this.keymaps.set(id, [fn, false]);
        let method = notify ? "notify" : "request";
        let modify2 = getKeymapModifier(mode);
        let escaped = key.startsWith("<") && key.endsWith(">") ? `{${key.slice(1, -1)}}` : key;
        if (this.nvim.hasFunction("nvim_buf_set_keymap") && !global.hasOwnProperty("__TEST__")) {
          nvim.call("nvim_buf_set_keymap", [0, mode, key, `:${modify2}call coc#rpc#${method}('doKeymap', ['${id}', '', '${escaped}'])<CR>`, {
            silent: true,
            nowait: true
          }], true);
        } else {
          let cmd = `${mode}noremap <silent><nowait><buffer> ${key} :${modify2}call coc#rpc#${method}('doKeymap', ['${id}', '', '${escaped}'])<CR>`;
          nvim.command(cmd, true);
        }
        return import_vscode_languageserver_protocol26.Disposable.create(() => {
          this.keymaps.delete(id);
          nvim.call("coc#compat#buf_del_keymap", [bufnr, mode, key], true);
        });
      }
    };
  }
});

// src/core/locations.ts
var logger33, Locations;
var init_locations = __esm({
  "src/core/locations.ts"() {
    "use strict";
    init_util();
    logger33 = require_logger2()("core-locations");
    Locations = class {
      constructor(configurations, documents, contentProvider) {
        this.configurations = configurations;
        this.documents = documents;
        this.contentProvider = contentProvider;
        this.disposables = [];
      }
      attach(nvim, env) {
        this.nvim = nvim;
        this.env = env;
      }
      async showLocations(locations) {
        let { documents, nvim, env, configurations } = this;
        let items = await documents.getQuickfixList(locations);
        const preferences = configurations.getConfiguration("coc.preferences");
        if (preferences.get("useQuickfixForLocations", false)) {
          let openCommand = await nvim.getVar("coc_quickfix_open_command");
          if (typeof openCommand != "string") {
            openCommand = items.length < 10 ? `copen ${items.length}` : "copen";
          }
          nvim.pauseNotification();
          nvim.call("setqflist", [items], true);
          nvim.command(openCommand, true);
          nvim.resumeNotification(false, true);
        } else {
          await nvim.setVar("coc_jump_locations", items);
          if (env.locationlist) {
            nvim.command("CocList --normal --auto-preview location", true);
          } else {
            nvim.call("coc#util#do_autocmd", ["CocLocationsChange"], true);
          }
        }
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
  }
});

// src/core/watchers.ts
var import_vscode_languageserver_protocol27, logger34, Watchers;
var init_watchers = __esm({
  "src/core/watchers.ts"() {
    "use strict";
    init_events();
    import_vscode_languageserver_protocol27 = __toESM(require_main2());
    init_util();
    logger34 = require_logger2()("core-watchers");
    Watchers = class {
      constructor() {
        this.watchedOptions = /* @__PURE__ */ new Set();
        this.disposables = [];
        this._onDidRuntimePathChange = new import_vscode_languageserver_protocol27.Emitter();
        this._onDidOptionChange = new import_vscode_languageserver_protocol27.Emitter();
        this.onDidRuntimePathChange = this._onDidRuntimePathChange.event;
        this.onDidOptionChange = this._onDidOptionChange.event;
      }
      get options() {
        return Array.from(this.watchedOptions);
      }
      attach(nvim, env) {
        this.nvim = nvim;
        this.env = env;
        this.watchOption("runtimepath", (oldValue, newValue) => {
          let oldList = oldValue.split(",");
          let newList = newValue.split(",");
          let paths = newList.filter((x) => !oldList.includes(x));
          if (paths.length > 0) {
            this._onDidRuntimePathChange.fire(paths);
          }
          this.env.runtimepath = newValue;
        }, this.disposables);
      }
      watchOption(key, callback, disposables) {
        let watching = this.watchedOptions.has(key);
        if (!watching) {
          this.watchedOptions.add(key);
          this._onDidOptionChange.fire();
        }
        let disposable = events_default.on("OptionSet", async (changed, oldValue, newValue) => {
          if (changed == key && callback) {
            await Promise.resolve(callback(oldValue, newValue));
          }
        });
        if (disposables) {
          disposables.push(import_vscode_languageserver_protocol27.Disposable.create(() => {
            disposable.dispose();
            if (watching)
              return;
            this.watchedOptions.delete(key);
            this._onDidOptionChange.fire();
          }));
        }
      }
      watchGlobal(key, callback, disposables) {
        let { nvim } = this;
        nvim.call("coc#_watch", key, true);
        let disposable = events_default.on("GlobalChange", async (changed, oldValue, newValue) => {
          if (changed == key) {
            await Promise.resolve(callback(oldValue, newValue));
          }
        });
        if (disposables) {
          disposables.push(import_vscode_languageserver_protocol27.Disposable.create(() => {
            disposable.dispose();
            nvim.call("coc#_unwatch", key, true);
          }));
        }
      }
      dispose() {
        disposeAll(this.disposables);
        this._onDidOptionChange.dispose();
        this._onDidRuntimePathChange.dispose();
      }
    };
  }
});

// src/core/editors.ts
var import_vscode_languageserver_protocol28, logger35, Editors;
var init_editors = __esm({
  "src/core/editors.ts"() {
    "use strict";
    import_vscode_languageserver_protocol28 = __toESM(require_main2());
    init_events();
    init_window();
    logger35 = require_logger2()("core-editors");
    Editors = class {
      constructor(documents) {
        this.documents = documents;
        this.disposables = [];
        this.editors = /* @__PURE__ */ new Map();
        this._onDidChangeActiveTextEditor = new import_vscode_languageserver_protocol28.Emitter();
        this._onDidChangeVisibleTextEditors = new import_vscode_languageserver_protocol28.Emitter();
        this.onDidChangeActiveTextEditor = this._onDidChangeActiveTextEditor.event;
        this.onDidChangeVisibleTextEditors = this._onDidChangeVisibleTextEditors.event;
      }
      get activeTextEditor() {
        return this.editors.get(this.winid);
      }
      get visibleTextEditors() {
        return Array.from(this.editors.values());
      }
      onChange(editor) {
        let id = `${editor.winid}-${editor.document.bufnr}-${editor.document.uri}`;
        if (id == this.previousId)
          return;
        this.previousId = id;
        this._onDidChangeActiveTextEditor.fire(editor);
      }
      async attach(nvim) {
        this.nvim = nvim;
        let { documents } = this;
        let doc = documents.getDocument(documents.bufnr);
        if (doc && doc.winid > 0) {
          this.winid = doc.winid;
          await this.createTextEditor(this.winid);
        }
        events_default.on("WinEnter", (winid) => {
          this.winid = winid;
          let editor = this.editors.get(winid);
          if (editor)
            this.onChange(editor);
        }, null, this.disposables);
        events_default.on("CursorHold", async () => {
          let [winid, buftype, isFloat] = await nvim.eval(`[win_getid(),&buftype,coc#window#is_float(win_getid())]`);
          let changed = false;
          if (!isFloat && ["", "acwrite"].includes(buftype) && !this.editors.has(winid)) {
            let created = await this.createTextEditor(winid);
            if (created)
              changed = true;
          }
          if (changed)
            this._onDidChangeVisibleTextEditors.fire(this.visibleTextEditors);
        }, null, this.disposables);
        events_default.on("WinClosed", (winid) => {
          if (this.editors.has(winid)) {
            this.editors.delete(winid);
            this._onDidChangeVisibleTextEditors.fire(this.visibleTextEditors);
          }
        }, null, this.disposables);
        events_default.on("BufWinEnter", async (_, winid) => {
          this.winid = winid;
          await this.createTextEditor(winid, true);
        }, null, this.disposables);
      }
      async createTextEditor(winid, check = false) {
        let { documents, nvim } = this;
        let opts = await nvim.call("coc#util#get_editoroption", [winid]);
        if (!opts)
          return false;
        let changed = false;
        if (check) {
          for (let winid2 of this.editors.keys()) {
            if (!opts.winids.includes(winid2)) {
              changed = true;
              this.editors.delete(winid2);
            }
          }
        }
        let doc = documents.getDocument(opts.bufnr);
        if (doc) {
          let editor = this.fromOptions(opts, doc);
          this.editors.set(winid, editor);
          if (winid == this.winid)
            this.onChange(editor);
          this._onDidChangeVisibleTextEditors.fire(this.visibleTextEditors);
          logger35.debug("editor created winid & bufnr & tabnr: ", winid, opts.bufnr, opts.tabpagenr);
          return true;
        } else if (changed) {
          this._onDidChangeVisibleTextEditors.fire(this.visibleTextEditors);
        }
        logger35.error(`document not found for window: ${winid}`);
        return false;
      }
      fromOptions(opts, document2) {
        let { visibleRanges } = opts;
        let tid = window_default.getTabId(opts.tabpagenr);
        return {
          get tabpagenr() {
            return window_default.getTabNumber(tid);
          },
          winid: opts.winid,
          winnr: opts.winnr,
          document: document2,
          visibleRanges: visibleRanges.map((o) => import_vscode_languageserver_protocol28.Range.create(o[0] - 1, 0, o[1], 0)),
          options: {
            tabSize: opts.tabSize,
            insertSpaces: !!opts.insertSpaces
          }
        };
      }
    };
  }
});

// src/core/workspaceFolder.ts
function toWorkspaceFolder(fsPath2) {
  if (!fsPath2 || !import_path13.default.isAbsolute(fsPath2))
    return void 0;
  return {
    name: import_path13.default.basename(fsPath2),
    uri: URI2.file(fsPath2).toString()
  };
}
var import_path13, import_vscode_languageserver_protocol29, WorkspaceFolderController;
var init_workspaceFolder = __esm({
  "src/core/workspaceFolder.ts"() {
    "use strict";
    import_path13 = __toESM(require("path"));
    import_vscode_languageserver_protocol29 = __toESM(require_main2());
    init_esm();
    init_types();
    init_array();
    init_fs();
    WorkspaceFolderController = class {
      constructor(configurations) {
        this.configurations = configurations;
        this._onDidChangeWorkspaceFolders = new import_vscode_languageserver_protocol29.Emitter();
        this.onDidChangeWorkspaceFolders = this._onDidChangeWorkspaceFolders.event;
        this.rootPatterns = /* @__PURE__ */ new Map();
        this._workspaceFolders = [];
      }
      setWorkspaceFolders(folders) {
        if (!folders || !Array.isArray(folders))
          return;
        let arr = folders.map((f) => toWorkspaceFolder(f));
        this._workspaceFolders = arr.filter((o) => o != null);
      }
      getWorkspaceFolder(uri) {
        if (uri.scheme !== "file")
          return void 0;
        let folders = Array.from(this._workspaceFolders).map((o) => URI2.parse(o.uri).fsPath);
        folders.sort((a, b) => b.length - a.length);
        let fsPath2 = uri.fsPath;
        let folder = folders.find((f) => isParentFolder(f, fsPath2, true));
        return toWorkspaceFolder(folder);
      }
      getRelativePath(pathOrUri, includeWorkspace) {
        let resource;
        let p = "";
        if (typeof pathOrUri === "string") {
          resource = URI2.file(pathOrUri);
          p = pathOrUri;
        } else if (typeof pathOrUri !== "undefined") {
          resource = pathOrUri;
          p = pathOrUri.fsPath;
        }
        if (!resource)
          return p;
        const folder = this.getWorkspaceFolder(resource);
        if (!folder)
          return p;
        if (typeof includeWorkspace === "undefined" && this._workspaceFolders) {
          includeWorkspace = this._workspaceFolders.length > 1;
        }
        let result = import_path13.default.relative(URI2.parse(folder.uri).fsPath, resource.fsPath);
        result = result == "" ? resource.fsPath : result;
        if (includeWorkspace && folder.name) {
          result = `${folder.name}/${result}`;
        }
        return result;
      }
      get workspaceFolders() {
        return this._workspaceFolders;
      }
      addRootPattern(filetype, rootPatterns) {
        let patterns = this.rootPatterns.get(filetype) || [];
        for (let p of rootPatterns) {
          if (!patterns.includes(p)) {
            patterns.push(p);
          }
        }
        this.rootPatterns.set(filetype, patterns);
      }
      resolveRoot(document2, cwd, fireEvent, expand) {
        if (document2.buftype !== "" || document2.schema !== "file" || !document2.enabled)
          return null;
        let types = [0 /* Buffer */, 1 /* LanguageServer */, 2 /* Global */];
        let u = URI2.parse(document2.uri);
        let dir = import_path13.default.dirname(u.fsPath);
        let config = this.configurations.getConfiguration("workspace", document2.uri);
        let ignoredFiletypes = config.get("ignoredFiletypes", []);
        let bottomUpFiletypes = config.get("bottomUpFiletypes", []);
        let checkCwd = config.get("workspaceFolderCheckCwd", true);
        let ignored = config.get("ignoredFolders", []);
        let fallbackCwd = config.get("workspaceFolderFallbackCwd", true);
        if (ignoredFiletypes == null ? void 0 : ignoredFiletypes.includes(document2.filetype))
          return null;
        let curr = this.getWorkspaceFolder(URI2.parse(document2.uri));
        if (curr)
          return URI2.parse(curr.uri).fsPath;
        ignored = Array.isArray(ignored) ? ignored.filter((s) => s && s.length > 0).map((s) => expand(s)) : [];
        let res = null;
        for (let patternType of types) {
          let patterns = this.getRootPatterns(document2, patternType);
          if (patterns && patterns.length) {
            let isBottomUp = bottomUpFiletypes.includes("*") || bottomUpFiletypes.includes(document2.filetype);
            let root = resolveRoot(dir, patterns, cwd, isBottomUp, checkCwd, ignored);
            if (root) {
              res = root;
              break;
            }
          }
        }
        if (fallbackCwd && !res && !ignored.includes(cwd) && isParentFolder(cwd, dir, true)) {
          res = cwd;
        }
        if (res)
          this.addWorkspaceFolder(res, fireEvent);
        return res;
      }
      addWorkspaceFolder(folder, fireEvent) {
        let workspaceFolder = toWorkspaceFolder(folder);
        if (!workspaceFolder)
          return void 0;
        if (this._workspaceFolders.findIndex((o) => o.uri == workspaceFolder.uri) == -1) {
          this._workspaceFolders.push(workspaceFolder);
          if (fireEvent) {
            this._onDidChangeWorkspaceFolders.fire({
              added: [workspaceFolder],
              removed: []
            });
          }
        }
        return workspaceFolder;
      }
      renameWorkspaceFolder(oldPath, newPath) {
        let added = toWorkspaceFolder(newPath);
        if (!added)
          return;
        let idx = this._workspaceFolders.findIndex((f) => URI2.parse(f.uri).fsPath == oldPath);
        if (idx == -1)
          return;
        let removed = this.workspaceFolders[idx];
        this._workspaceFolders.splice(idx, 1, added);
        this._onDidChangeWorkspaceFolders.fire({
          removed: [removed],
          added: [added]
        });
      }
      removeWorkspaceFolder(fsPath2) {
        let removed = toWorkspaceFolder(fsPath2);
        if (!removed)
          return;
        let idx = this._workspaceFolders.findIndex((f) => f.uri == removed.uri);
        if (idx == -1)
          return;
        this._workspaceFolders.splice(idx, 1);
        this._onDidChangeWorkspaceFolders.fire({
          removed: [removed],
          added: []
        });
      }
      getRootPatterns(document2, patternType) {
        let { uri } = document2;
        if (patternType == 0 /* Buffer */)
          return document2.getVar("root_patterns", []) || [];
        if (patternType == 1 /* LanguageServer */)
          return this.getServerRootPatterns(document2.languageId);
        const preferences = this.configurations.getConfiguration("coc.preferences", uri);
        return preferences.get("rootPatterns", [".git", ".hg", ".projections.json"]).slice();
      }
      reset() {
        this.rootPatterns.clear();
        this._workspaceFolders = [];
      }
      getServerRootPatterns(filetype) {
        let lspConfig = this.configurations.getConfiguration().get("languageserver", {});
        let patterns = [];
        for (let key of Object.keys(lspConfig)) {
          let config = lspConfig[key];
          let { filetypes, rootPatterns } = config;
          if (Array.isArray(filetypes) && rootPatterns && filetypes.includes(filetype)) {
            patterns.push(...rootPatterns);
          }
        }
        patterns = patterns.concat(this.rootPatterns.get(filetype) || []);
        return patterns.length ? distinct(patterns) : [];
      }
    };
  }
});

// src/model/bufferSync.ts
var BufferSync;
var init_bufferSync = __esm({
  "src/model/bufferSync.ts"() {
    "use strict";
    init_events();
    init_util();
    BufferSync = class {
      constructor(_create, documents) {
        this._create = _create;
        this.disposables = [];
        this.itemsMap = /* @__PURE__ */ new Map();
        let { disposables } = this;
        for (let doc of documents.documents) {
          this.create(doc);
        }
        documents.onDidOpenTextDocument((e) => {
          this.create(documents.getDocument(e.bufnr));
        }, null, disposables);
        documents.onDidChangeDocument((e) => {
          this.onChange(e);
        }, null, disposables);
        documents.onDidCloseDocument((e) => {
          this.delete(e.bufnr);
        }, null, disposables);
        events_default.on("LinesChanged", (bufnr) => {
          let o = this.itemsMap.get(bufnr);
          if (o && typeof o.item.onTextChange == "function") {
            o.item.onTextChange();
          }
        }, null, disposables);
      }
      get items() {
        return Array.from(this.itemsMap.values()).map((x) => x.item);
      }
      getItem(bufnr) {
        var _a;
        if (typeof bufnr === "number") {
          return (_a = this.itemsMap.get(bufnr)) == null ? void 0 : _a.item;
        }
        let o = Array.from(this.itemsMap.values()).find((v) => {
          return v.uri == bufnr;
        });
        return o ? o.item : void 0;
      }
      create(doc) {
        if (!doc)
          return;
        let o = this.itemsMap.get(doc.bufnr);
        if (o)
          o.item.dispose();
        let item = this._create(doc);
        if (item)
          this.itemsMap.set(doc.bufnr, { uri: doc.uri, item });
      }
      onChange(e) {
        let o = this.itemsMap.get(e.bufnr);
        if (o && typeof o.item.onChange == "function") {
          o.item.onChange(e);
        }
      }
      delete(bufnr) {
        let o = this.itemsMap.get(bufnr);
        if (o) {
          o.item.dispose();
          this.itemsMap.delete(bufnr);
        }
      }
      reset() {
        for (let o of this.itemsMap.values()) {
          o.item.dispose();
        }
        this.itemsMap.clear();
      }
      dispose() {
        disposeAll(this.disposables);
        for (let o of this.itemsMap.values()) {
          o.item.dispose();
        }
        this._create = void 0;
        this.itemsMap.clear();
      }
    };
  }
});

// src/model/db.ts
var import_fs_extra4, import_path14, DB;
var init_db = __esm({
  "src/model/db.ts"() {
    "use strict";
    import_fs_extra4 = __toESM(require_lib4());
    import_path14 = __toESM(require("path"));
    DB = class {
      constructor(filepath) {
        this.filepath = filepath;
      }
      fetch(key) {
        let obj = this.load();
        if (!key)
          return obj;
        let parts = key.split(".");
        for (let part of parts) {
          if (typeof obj[part] == "undefined") {
            return void 0;
          }
          obj = obj[part];
        }
        return obj;
      }
      exists(key) {
        let obj = this.load();
        let parts = key.split(".");
        for (let part of parts) {
          if (typeof obj[part] == "undefined") {
            return false;
          }
          obj = obj[part];
        }
        return true;
      }
      delete(key) {
        let obj = this.load();
        let origin = obj;
        let parts = key.split(".");
        let len = parts.length;
        for (let i = 0; i < len; i++) {
          if (typeof obj[parts[i]] == "undefined") {
            break;
          }
          if (i == len - 1) {
            delete obj[parts[i]];
            import_fs_extra4.default.writeFileSync(this.filepath, JSON.stringify(origin, null, 2), "utf8");
            break;
          }
          obj = obj[parts[i]];
        }
      }
      push(key, data) {
        let origin = this.load() || {};
        let obj = origin;
        let parts = key.split(".");
        let len = parts.length;
        if (obj == null) {
          let dir = import_path14.default.dirname(this.filepath);
          import_fs_extra4.default.mkdirpSync(dir);
          obj = origin;
        }
        for (let i = 0; i < len; i++) {
          let key2 = parts[i];
          if (i == len - 1) {
            obj[key2] = data;
            import_fs_extra4.default.writeFileSync(this.filepath, JSON.stringify(origin, null, 2));
            break;
          }
          if (typeof obj[key2] == "undefined") {
            obj[key2] = {};
            obj = obj[key2];
          } else {
            obj = obj[key2];
          }
        }
      }
      load() {
        let dir = import_path14.default.dirname(this.filepath);
        let stat = import_fs_extra4.default.statSync(dir);
        if (!stat || !stat.isDirectory()) {
          import_fs_extra4.default.mkdirpSync(dir);
          import_fs_extra4.default.writeFileSync(this.filepath, "{}", "utf8");
          return {};
        }
        try {
          let content = import_fs_extra4.default.readFileSync(this.filepath, "utf8");
          return JSON.parse(content.trim());
        } catch (e) {
          import_fs_extra4.default.writeFileSync(this.filepath, "{}", "utf8");
          return {};
        }
      }
      clear() {
        let stat = import_fs_extra4.default.statSync(this.filepath);
        if (!stat || !stat.isFile())
          return;
        import_fs_extra4.default.writeFileSync(this.filepath, "{}", "utf8");
      }
      destroy() {
        if (import_fs_extra4.default.existsSync(this.filepath)) {
          import_fs_extra4.default.unlinkSync(this.filepath);
        }
      }
    };
  }
});

// src/model/mru.ts
var import_path15, import_fs_extra5, logger36, Mru;
var init_mru = __esm({
  "src/model/mru.ts"() {
    "use strict";
    import_path15 = __toESM(require("path"));
    import_fs_extra5 = __toESM(require_lib4());
    init_fs();
    init_array();
    logger36 = require_logger2()("model-mru");
    Mru = class {
      constructor(name2, base, maximum = 5e3) {
        this.maximum = maximum;
        this.file = import_path15.default.join(base || process.env.COC_DATA_HOME, name2);
        let dir = import_path15.default.dirname(this.file);
        import_fs_extra5.default.mkdirpSync(dir);
      }
      async load() {
        try {
          let lines = await readFileLines(this.file, 0, this.maximum);
          if (lines.length > this.maximum) {
            await writeFile(this.file, lines.join("\n"));
          }
          if (lines[lines.length - 1] == "")
            lines = lines.slice(0, -1);
          return distinct(lines);
        } catch (e) {
          return [];
        }
      }
      loadSync() {
        if (!import_fs_extra5.default.existsSync(this.file))
          return [];
        try {
          let content = import_fs_extra5.default.readFileSync(this.file, "utf8");
          content = content.trim();
          return content.length ? content.trim().split("\n") : [];
        } catch (e) {
          return [];
        }
      }
      async add(item) {
        let buf;
        try {
          buf = import_fs_extra5.default.readFileSync(this.file);
          if (buf[0] === 239 && buf[1] === 187 && buf[2] === 191) {
            buf = buf.slice(3);
          }
          buf = Buffer.concat([Buffer.from(item, "utf8"), new Uint8Array([10]), buf]);
        } catch (e) {
          buf = Buffer.concat([Buffer.from(item, "utf8"), new Uint8Array([10])]);
        }
        await import_fs_extra5.default.writeFile(this.file, buf, "utf8");
      }
      async remove(item) {
        let items = await this.load();
        let len = items.length;
        items = items.filter((s) => s != item);
        if (items.length != len) {
          await import_fs_extra5.default.writeFile(this.file, items.join("\n"), "utf8");
        }
      }
      async clean() {
        try {
          await import_fs_extra5.default.unlink(this.file);
        } catch (e) {
        }
      }
    };
  }
});

// src/model/task.ts
var import_vscode_languageserver_protocol30, Task;
var init_task = __esm({
  "src/model/task.ts"() {
    "use strict";
    import_vscode_languageserver_protocol30 = __toESM(require_main2());
    init_events();
    init_util();
    Task = class {
      constructor(nvim, id) {
        this.nvim = nvim;
        this.id = id;
        this.disposables = [];
        this._onExit = new import_vscode_languageserver_protocol30.Emitter();
        this._onStderr = new import_vscode_languageserver_protocol30.Emitter();
        this._onStdout = new import_vscode_languageserver_protocol30.Emitter();
        this.onExit = this._onExit.event;
        this.onStdout = this._onStdout.event;
        this.onStderr = this._onStderr.event;
        events_default.on("TaskExit", (id2, code) => {
          if (id2 == this.id) {
            this._onExit.fire(code);
          }
        }, null, this.disposables);
        events_default.on("TaskStderr", (id2, lines) => {
          if (id2 == this.id) {
            this._onStderr.fire(lines);
          }
        }, null, this.disposables);
        events_default.on("TaskStdout", (id2, lines) => {
          if (id2 == this.id) {
            this._onStdout.fire(lines);
          }
        }, null, this.disposables);
      }
      async start(opts) {
        let { nvim } = this;
        return await nvim.call("coc#task#start", [this.id, opts]);
      }
      async stop() {
        let { nvim } = this;
        await nvim.call("coc#task#stop", [this.id]);
      }
      get running() {
        let { nvim } = this;
        return nvim.call("coc#task#running", [this.id]);
      }
      dispose() {
        let { nvim } = this;
        nvim.call("coc#task#stop", [this.id], true);
        this._onStdout.dispose();
        this._onStderr.dispose();
        this._onExit.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/workspace.ts
var import_fs_extra6, import_os9, import_path16, APIVERSION, logger37, methods, Workspace, workspace_default;
var init_workspace = __esm({
  "src/workspace.ts"() {
    "use strict";
    import_fs_extra6 = __toESM(require_lib4());
    import_os9 = __toESM(require("os"));
    import_path16 = __toESM(require("path"));
    init_esm();
    init_package();
    init_configuration2();
    init_shape();
    init_autocmds();
    init_channels();
    init_contentProvider();
    init_documents();
    init_files();
    init_fileSystemWatcher();
    init_funcs();
    init_keymaps();
    init_locations();
    init_ui();
    init_watchers();
    init_editors();
    init_workspaceFolder();
    init_events();
    init_bufferSync();
    init_db();
    init_mru();
    init_task();
    init_util();
    APIVERSION = 32;
    logger37 = require_logger2()("workspace");
    methods = [
      "showMessage",
      "runTerminalCommand",
      "openTerminal",
      "showQuickpick",
      "menuPick",
      "openLocalConfig",
      "showPrompt",
      "createStatusBarItem",
      "createOutputChannel",
      "showOutputChannel",
      "requestInput",
      "echoLines",
      "getCursorPosition",
      "moveTo",
      "getOffset",
      "getSelectedRange",
      "selectRange",
      "createTerminal"
    ];
    Workspace = class {
      constructor() {
        this.version = version;
        let home = import_path16.default.normalize(process.env.COC_VIMCONFIG) || import_path16.default.join(import_os9.default.homedir(), ".vim");
        let userConfigFile = import_path16.default.join(home, CONFIG_FILE_NAME);
        this.configurations = new Configurations(userConfigFile, new ConfigurationProxy(this));
        this.workspaceFolderControl = new WorkspaceFolderController(this.configurations);
        let documents = this.documentsManager = new Documents(this.configurations, this.workspaceFolderControl);
        this.contentProvider = new ContentProvider(documents);
        this.watchers = new Watchers();
        this.autocmds = new Autocmds(this.contentProvider, this.watchers);
        this.keymaps = new Keymaps(documents);
        this.locations = new Locations(this.configurations, documents, this.contentProvider);
        this.files = new Files(documents, this.configurations, this.workspaceFolderControl, this.keymaps);
        this.editors = new Editors(documents);
        this.onDidRuntimePathChange = this.watchers.onDidRuntimePathChange;
        this.onDidChangeWorkspaceFolders = this.workspaceFolderControl.onDidChangeWorkspaceFolders;
        this.onDidChangeConfiguration = this.configurations.onDidChange;
        this.onDidOpenTextDocument = documents.onDidOpenTextDocument;
        this.onDidChangeTextDocument = documents.onDidChangeDocument;
        this.onDidCloseTextDocument = documents.onDidCloseDocument;
        this.onDidSaveTextDocument = documents.onDidSaveTextDocument;
        this.onWillSaveTextDocument = documents.onWillSaveTextDocument;
        this.onDidCreateFiles = this.files.onDidCreateFiles;
        this.onDidRenameFiles = this.files.onDidRenameFiles;
        this.onDidDeleteFiles = this.files.onDidDeleteFiles;
        this.onWillCreateFiles = this.files.onWillCreateFiles;
        this.onWillRenameFiles = this.files.onWillRenameFiles;
        this.onWillDeleteFiles = this.files.onWillDeleteFiles;
        let watchmanPath = global.__TEST__ ? null : this.getWatchmanPath();
        this.fileSystemWatchers = new FileSystemWatcherManager(this.workspaceFolderControl, watchmanPath);
      }
      async init(window2) {
        let { nvim } = this;
        for (let method of methods) {
          Object.defineProperty(this, method, {
            get: () => {
              return (...args) => {
                let stack = "\n" + Error().stack.split("\n").slice(2, 4).join("\n");
                logger37.warn(`workspace.${method} is deprecated, please use window.${method} instead.`, stack);
                return window2[method].apply(window2, args);
              };
            }
          });
        }
        for (let name2 of ["onDidOpenTerminal", "onDidCloseTerminal"]) {
          Object.defineProperty(this, name2, {
            get: () => {
              let stack = "\n" + Error().stack.split("\n").slice(2, 4).join("\n");
              logger37.warn(`workspace.${name2} is deprecated, please use window.${name2} instead.`, stack);
              return window2[name2];
            }
          });
        }
        let env = this._env = await nvim.call("coc#util#vim_info");
        window2.init(env);
        if (this._env.apiversion != APIVERSION) {
          nvim.echoError(`API version ${this._env.apiversion} is not ${APIVERSION}, please build coc.nvim by 'yarn install' after pull source code.`);
        }
        this.workspaceFolderControl.setWorkspaceFolders(this._env.workspaceFolders);
        this.configurations.updateUserConfig(this._env.config);
        this.files.attach(nvim, env, window2);
        this.contentProvider.attach(nvim);
        this.keymaps.attach(nvim);
        this.autocmds.attach(nvim, env);
        this.locations.attach(nvim, env);
        this.watchers.attach(nvim, env);
        await this.attach();
        await this.editors.attach(nvim);
        let channel = channels_default.create("watchman", nvim);
        this.fileSystemWatchers.attach(channel);
      }
      get cwd() {
        return this.documentsManager.cwd;
      }
      get env() {
        return this._env;
      }
      get root() {
        return this.documentsManager.root || this.cwd;
      }
      get rootPath() {
        return this.root;
      }
      get bufnr() {
        return this.documentsManager.bufnr;
      }
      get insertMode() {
        return events_default.insertMode;
      }
      get floatSupported() {
        return this.env.floating || this.env.textprop;
      }
      get uri() {
        return this.documentsManager.uri;
      }
      get workspaceFolder() {
        return this.workspaceFolders[0];
      }
      get textDocuments() {
        return this.documentsManager.textDocuments;
      }
      get documents() {
        return this.documentsManager.documents;
      }
      get document() {
        return this.documentsManager.document;
      }
      get workspaceFolders() {
        return this.workspaceFolderControl.workspaceFolders;
      }
      get folderPaths() {
        return this.workspaceFolders.map((f) => URI2.parse(f.uri).fsPath);
      }
      get channelNames() {
        return channels_default.names;
      }
      get pluginRoot() {
        return import_path16.default.dirname(__dirname);
      }
      get isVim() {
        return this._env.isVim;
      }
      get isNvim() {
        return !this._env.isVim;
      }
      get completeOpt() {
        return "";
      }
      get filetypes() {
        return this.documentsManager.filetypes;
      }
      get languageIds() {
        return this.documentsManager.languageIds;
      }
      createNameSpace(name2) {
        return createNameSpace(name2);
      }
      getConfigFile(target) {
        return this.configurations.getConfigFile(target);
      }
      has(feature) {
        return has(this.env, feature);
      }
      registerAutocmd(autocmd) {
        return this.autocmds.registerAutocmd(autocmd);
      }
      watchOption(key, callback, disposables) {
        this.watchers.watchOption(key, callback, disposables);
      }
      watchGlobal(key, callback, disposables) {
        this.watchers.watchGlobal(key, callback || function() {
        }, disposables);
      }
      match(selector, document2) {
        return score2(selector, document2.uri, document2.languageId);
      }
      createFileSystemWatcher(globPattern, ignoreCreate, ignoreChange, ignoreDelete) {
        return this.fileSystemWatchers.createFileSystemWatcher(globPattern, ignoreCreate, ignoreChange, ignoreDelete);
      }
      getWatchmanPath() {
        return getWatchmanPath(this.configurations);
      }
      getConfiguration(section2, resource) {
        return this.configurations.getConfiguration(section2, resource);
      }
      getDocument(uri) {
        return this.documentsManager.getDocument(uri);
      }
      isAttached(bufnr) {
        let doc = this.documentsManager.getDocument(bufnr);
        return doc != null && doc.attached;
      }
      getAttachedDocument(uri) {
        let doc = this.getDocument(uri);
        if (!doc)
          throw new Error(`Buffer ${uri} not created.`);
        if (!doc.attached)
          throw new Error(`Buffer ${uri} not attached, ${doc.notAttachReason}`);
        return doc;
      }
      getQuickfixItem(loc, text, type = "", module2) {
        return this.documentsManager.getQuickfixItem(loc, text, type, module2);
      }
      createMru(name2) {
        return new Mru(name2);
      }
      async getQuickfixList(locations) {
        return this.documentsManager.getQuickfixList(locations);
      }
      async showLocations(locations) {
        await this.locations.showLocations(locations);
      }
      getLine(uri, line) {
        return this.documentsManager.getLine(uri, line);
      }
      getWorkspaceFolder(uri) {
        return this.workspaceFolderControl.getWorkspaceFolder(URI2.parse(uri));
      }
      readFile(uri) {
        return this.documentsManager.readFile(uri);
      }
      async getCurrentState() {
        let document2 = await this.document;
        let position = await getCursorPosition(this.nvim);
        return {
          document: document2.textDocument,
          position
        };
      }
      async getFormatOptions(uri) {
        return this.documentsManager.getFormatOptions(uri);
      }
      resolveModule(name2) {
        return resolveModule(name2);
      }
      async runCommand(cmd, cwd, timeout) {
        cwd = cwd || this.cwd;
        return runCommand(cmd, { cwd }, timeout);
      }
      expand(filepath) {
        return this.documentsManager.expand(filepath);
      }
      async callAsync(method, args) {
        if (this.isNvim)
          return await this.nvim.call(method, args);
        return await this.nvim.callAsync("coc#util#with_callback", [method, args]);
      }
      registerTextDocumentContentProvider(scheme, provider) {
        return this.contentProvider.registerTextDocumentContentProvider(scheme, provider);
      }
      registerKeymap(modes, key, fn, opts = {}) {
        return this.keymaps.registerKeymap(modes, key, fn, opts);
      }
      registerExprKeymap(mode, key, fn, buffer = false) {
        return this.keymaps.registerExprKeymap(mode, key, fn, buffer);
      }
      registerLocalKeymap(mode, key, fn, notify = false) {
        return this.keymaps.registerLocalKeymap(mode, key, fn, notify);
      }
      createTask(id) {
        return new Task(this.nvim, id);
      }
      createDatabase(name2) {
        let root;
        if (global.hasOwnProperty("__TEST__")) {
          root = import_path16.default.join(import_os9.default.tmpdir(), `coc-${process.pid}`);
          import_fs_extra6.default.mkdirpSync(root);
        } else {
          root = import_path16.default.dirname(this.env.extensionRoot);
        }
        let filepath = import_path16.default.join(root, name2 + ".json");
        return new DB(filepath);
      }
      registerBufferSync(create) {
        return new BufferSync(create, this.documentsManager);
      }
      async attach() {
        await this.documentsManager.attach(this.nvim, this._env);
      }
      jumpTo(uri, position, openCommand) {
        return this.files.jumpTo(uri, position, openCommand);
      }
      findUp(filename) {
        return findUp2(this.nvim, this.cwd, filename);
      }
      applyEdit(edit2) {
        return this.files.applyEdit(edit2);
      }
      createFile(filepath, opts = {}) {
        return this.files.createFile(filepath, opts);
      }
      loadFile(uri, cmd) {
        return this.files.loadResource(uri, cmd);
      }
      async loadFiles(uris) {
        return this.files.loadResources(uris);
      }
      async renameFile(oldPath, newPath, opts = {}) {
        await this.files.renameFile(oldPath, newPath, opts);
      }
      async deleteFile(filepath, opts = {}) {
        await this.files.deleteFile(filepath, opts);
      }
      async renameCurrent() {
        await this.files.renameCurrent();
      }
      async openResource(uri) {
        await this.files.openResource(uri);
      }
      openTextDocument(uri) {
        return this.files.openTextDocument(uri);
      }
      getRelativePath(pathOrUri, includeWorkspace) {
        return this.workspaceFolderControl.getRelativePath(pathOrUri, includeWorkspace);
      }
      async findFiles(include, exclude, maxResults, token) {
        return this.files.findFiles(include, exclude, maxResults, token);
      }
      detach() {
        this.documentsManager.detach();
      }
      reset() {
        this.configurations.reset();
        this.workspaceFolderControl.reset();
        this.documentsManager.reset();
      }
      dispose() {
        this.watchers.dispose();
        this.autocmds.dispose();
        this.contentProvider.dispose();
        this.documentsManager.dispose();
        this.configurations.dispose();
      }
    };
    workspace_default = new Workspace();
  }
});

// src/tree/filter.ts
var import_vscode_languageserver_protocol31, sessionKey, Filter;
var init_filter = __esm({
  "src/tree/filter.ts"() {
    "use strict";
    init_events();
    import_vscode_languageserver_protocol31 = __toESM(require_main2());
    init_util();
    sessionKey = "filter";
    Filter = class {
      constructor(nvim, keys) {
        this.nvim = nvim;
        this._activated = false;
        this.history = [];
        this.disposables = [];
        this._onDidUpdate = new import_vscode_languageserver_protocol31.Emitter();
        this._onDidExit = new import_vscode_languageserver_protocol31.Emitter();
        this._onDidKeyPress = new import_vscode_languageserver_protocol31.Emitter();
        this.onDidKeyPress = this._onDidKeyPress.event;
        this.onDidUpdate = this._onDidUpdate.event;
        this.onDidExit = this._onDidExit.event;
        this.text = "";
        events_default.on("InputChar", (session, character) => {
          if (session !== sessionKey || !this._activated)
            return;
          if (!keys.includes(character)) {
            if (character.length == 1) {
              this.text = this.text + character;
              this._onDidUpdate.fire(this.text);
              return;
            }
            if (character == "<bs>" || character == "<C-h>") {
              this.text = this.text.slice(0, -1);
              this._onDidUpdate.fire(this.text);
              return;
            }
            if (character == "<C-u>") {
              this.text = "";
              this._onDidUpdate.fire(this.text);
              return;
            }
            if (character == "<C-n>") {
              let idx = this.history.indexOf(this.text);
              let text = this.history[idx + 1] || this.history[0];
              if (text) {
                this.text = text;
                this._onDidUpdate.fire(this.text);
              }
              return;
            }
            if (character == "<C-p>") {
              let idx = this.history.indexOf(this.text);
              let text = this.history[idx - 1] || this.history[this.history.length - 1];
              if (text) {
                this.text = text;
                this._onDidUpdate.fire(this.text);
              }
            }
            if (character == "<esc>" || character == "<C-o>") {
              this.deactivate();
              return;
            }
          }
          this._onDidKeyPress.fire(character);
        }, null, this.disposables);
      }
      active() {
        if (this._activated)
          return;
        this._activated = true;
        this.text = "";
        this.nvim.call("coc#prompt#start_prompt", [sessionKey], true);
      }
      deactivate(node) {
        if (!this._activated)
          return;
        this.nvim.call("coc#prompt#stop_prompt", [sessionKey], true);
        this._activated = false;
        let { text } = this;
        this.text = "";
        this._onDidExit.fire(node);
        if (text && !this.history.includes(text)) {
          this.history.push(text);
        }
      }
      get activated() {
        return this._activated;
      }
      dispose() {
        this.deactivate();
        this.history = [];
        this._onDidKeyPress.dispose();
        this._onDidUpdate.dispose();
        this._onDidExit.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/tree/TreeItem.ts
var import_path17, TreeItemLabel, TreeItemCollapsibleState, TreeItem;
var init_TreeItem = __esm({
  "src/tree/TreeItem.ts"() {
    "use strict";
    init_esm();
    import_path17 = __toESM(require("path"));
    ((TreeItemLabel3) => {
      function is(obj) {
        return typeof obj.label == "string";
      }
      TreeItemLabel3.is = is;
    })(TreeItemLabel || (TreeItemLabel = {}));
    TreeItemCollapsibleState = /* @__PURE__ */ ((TreeItemCollapsibleState2) => {
      TreeItemCollapsibleState2[TreeItemCollapsibleState2["None"] = 0] = "None";
      TreeItemCollapsibleState2[TreeItemCollapsibleState2["Collapsed"] = 1] = "Collapsed";
      TreeItemCollapsibleState2[TreeItemCollapsibleState2["Expanded"] = 2] = "Expanded";
      return TreeItemCollapsibleState2;
    })(TreeItemCollapsibleState || {});
    TreeItem = class {
      constructor(label, collapsibleState = 0 /* None */) {
        this.collapsibleState = collapsibleState;
        if (URI2.isUri(label)) {
          this.resourceUri = label;
          this.label = import_path17.default.basename(label.path);
          this.id = label.toString();
        } else {
          this.label = label;
        }
      }
    };
  }
});

// src/tree/TreeView.ts
var TreeView_exports = {};
__export(TreeView_exports, {
  default: () => BasicTreeView
});
var import_vscode_languageserver_protocol32, logger38, highlightNamespace, signOffset, globalId, BasicTreeView;
var init_TreeView = __esm({
  "src/tree/TreeView.ts"() {
    "use strict";
    import_vscode_languageserver_protocol32 = __toESM(require_main2());
    init_commands2();
    init_events();
    init_util();
    init_fzy();
    init_mutex();
    init_object();
    init_string();
    init_window();
    init_workspace();
    init_filter();
    init_TreeItem();
    logger38 = require_logger2()("BasicTreeView");
    highlightNamespace = "tree";
    signOffset = 3e3;
    globalId = 1;
    BasicTreeView = class {
      constructor(viewId, opts) {
        this.viewId = viewId;
        this.opts = opts;
        this._selection = [];
        this._onDispose = new import_vscode_languageserver_protocol32.Emitter();
        this._onDidRefrash = new import_vscode_languageserver_protocol32.Emitter();
        this._onDidExpandElement = new import_vscode_languageserver_protocol32.Emitter();
        this._onDidCollapseElement = new import_vscode_languageserver_protocol32.Emitter();
        this._onDidChangeSelection = new import_vscode_languageserver_protocol32.Emitter();
        this._onDidChangeVisibility = new import_vscode_languageserver_protocol32.Emitter();
        this.onDidRefrash = this._onDidRefrash.event;
        this.onDispose = this._onDispose.event;
        this.onDidExpandElement = this._onDidExpandElement.event;
        this.onDidCollapseElement = this._onDidCollapseElement.event;
        this.onDidChangeSelection = this._onDidChangeSelection.event;
        this.onDidChangeVisibility = this._onDidChangeVisibility.event;
        this.retryTimers = 0;
        this.renderedItems = [];
        this.nodesMap = /* @__PURE__ */ new Map();
        this.mutex = new Mutex();
        this.disposables = [];
        this.lineState = { titleCount: 0, messageCount: 0 };
        this.loadConfiguration();
        workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
        if (opts.enableFilter) {
          this.filter = new Filter(this.nvim, [this.keys.selectNext, this.keys.selectPrevious, this.keys.invoke]);
        }
        this.tooltipFactory = window_default.createFloatFactory({ modes: ["n"] });
        this.provider = opts.treeDataProvider;
        this.leafIndent = opts.disableLeafIndent !== true;
        this.winfixwidth = opts.winfixwidth !== false;
        this.autoWidth = opts.autoWidth === true;
        let message;
        Object.defineProperty(this, "message", {
          set: (msg) => {
            message = msg ? msg.replace(/\r?\n/g, " ") : void 0;
            this.updateHeadLines();
          },
          get: () => {
            return message;
          }
        });
        let title = viewId.replace(/\r?\n/g, " ");
        Object.defineProperty(this, "title", {
          set: (newTitle) => {
            title = newTitle ? newTitle.replace(/\r?\n/g, " ") : void 0;
            this.updateHeadLines();
          },
          get: () => {
            return title;
          }
        });
        let description;
        Object.defineProperty(this, "description", {
          set: (desc) => {
            description = desc ? desc.replace(/\r?\n/g, " ") : void 0;
            this.updateHeadLines();
          },
          get: () => {
            return description;
          }
        });
        let filterText;
        Object.defineProperty(this, "filterText", {
          set: (text) => {
            let { titleCount, messageCount } = this.lineState;
            let start = titleCount + messageCount;
            if (text != null) {
              let highlights = [{
                lnum: start,
                colStart: byteLength(text),
                colEnd: byteLength(text) + 1,
                hlGroup: "Cursor"
              }];
              this.renderedItems = [];
              this.updateUI([text + " "], highlights, start, -1, true);
              void this.doFilter(text);
            } else if (filterText != null) {
              this.updateUI([], [], start, start + 1);
            }
            filterText = text;
          },
          get: () => {
            return filterText;
          }
        });
        if (this.provider.onDidChangeTreeData) {
          this.provider.onDidChangeTreeData(this.onDataChange, this, this.disposables);
        }
        events_default.on("BufUnload", (bufnr) => {
          if (bufnr != this.bufnr)
            return;
          let isVisible = this.winid != null;
          this.winid = void 0;
          this.bufnr = void 0;
          if (isVisible)
            this._onDidChangeVisibility.fire({ visible: false });
          this.dispose();
        }, null, this.disposables);
        events_default.on("WinClosed", (winid) => {
          if (this.winid == winid) {
            this.winid = void 0;
            this._onDidChangeVisibility.fire({ visible: false });
          }
        }, null, this.disposables);
        events_default.on("BufWinLeave", (bufnr, winid) => {
          if (bufnr == this.bufnr && winid == this.winid) {
            this.winid = void 0;
            this._onDidChangeVisibility.fire({ visible: false });
          }
        }, null, this.disposables);
        window_default.onDidTabClose((id) => {
          if (this._targetTabId === id) {
            this.dispose();
          }
        }, null, this.disposables);
        events_default.on("CursorHold", async (bufnr) => {
          if (bufnr != this.bufnr)
            return;
          await this.onHover();
        }, null, this.disposables);
        events_default.on(["CursorMoved", "BufEnter"], () => {
          this.cancelResolve();
        }, null, this.disposables);
        events_default.on("WinEnter", (winid) => {
          var _a;
          if (winid != this.windowId || !((_a = this.filter) == null ? void 0 : _a.activated))
            return;
          let buf = this.nvim.createBuffer(this.bufnr);
          let line = this.startLnum - 1;
          let len = this.filterText ? this.filterText.length : 0;
          let range2 = import_vscode_languageserver_protocol32.Range.create(line, len, line, len + 1);
          buf.highlightRanges(highlightNamespace, "Cursor", [range2]);
          this.nvim.call("coc#prompt#start_prompt", [sessionKey], true);
          this.redraw();
        }, null, this.disposables);
        events_default.on("WinLeave", (winid) => {
          var _a;
          if (winid != this.windowId || !((_a = this.filter) == null ? void 0 : _a.activated))
            return;
          let buf = this.nvim.createBuffer(this.bufnr);
          this.nvim.call("coc#prompt#stop_prompt", [sessionKey], true);
          buf.clearNamespace(highlightNamespace, this.startLnum - 1, this.startLnum);
        }, null, this.disposables);
        this.disposables.push(this._onDidChangeVisibility, this._onDidChangeSelection, this._onDidCollapseElement, this._onDidExpandElement);
        if (this.filter) {
          this.filter.onDidExit((node) => {
            this.nodesMap.clear();
            this.filterText = void 0;
            this.itemsToFilter = void 0;
            if (node && typeof this.provider.getParent === "function") {
              this.renderedItems = [];
              void this.reveal(node, { focus: true });
            } else {
              this.clearSelection();
              void this.render();
            }
          });
          this.filter.onDidUpdate((text) => {
            this.filterText = text;
          });
          this.filter.onDidKeyPress(async (character) => {
            var _a, _b;
            let items = this.renderedItems;
            if (!(items == null ? void 0 : items.length))
              return;
            let curr = this.selection[0];
            if (character == "<up>" || character == this.keys.selectPrevious) {
              let idx = items.findIndex((o) => o.node == curr);
              let index = idx == -1 || idx == 0 ? items.length - 1 : idx - 1;
              let node = (_a = items[index]) == null ? void 0 : _a.node;
              if (node)
                this.selectItem(node, true);
            }
            if (character == "<down>" || character == this.keys.selectNext) {
              let idx = items.findIndex((o) => o.node == curr);
              let index = idx == -1 || idx == items.length - 1 ? 0 : idx + 1;
              let node = (_b = items[index]) == null ? void 0 : _b.node;
              if (node)
                this.selectItem(node, true);
            }
            if (character == "<cr>" || character == this.keys.invoke) {
              if (!curr)
                return;
              await this.invokeCommand(curr);
              this.filter.deactivate(curr);
            }
          });
        }
      }
      get windowId() {
        return this.winid;
      }
      get targetTabnr() {
        return window_default.getTabNumber(this._targetTabId);
      }
      get targetWinId() {
        return this._targetWinId;
      }
      get targetBufnr() {
        return this._targetBufnr;
      }
      get startLnum() {
        let filterCount = this.filterText == null ? 0 : 1;
        return this.lineState.messageCount + this.lineState.titleCount + filterCount;
      }
      get nvim() {
        return workspace_default.nvim;
      }
      loadConfiguration(e) {
        if (!e || e.affectsConfiguration("tree")) {
          let config = workspace_default.getConfiguration("tree");
          this.config = {
            openedIcon: config.get("openedIcon", " "),
            closedIcon: config.get("closedIcon", " ")
          };
          this.keys = {
            close: config.get("key.close"),
            invoke: config.get("key.invoke"),
            toggle: config.get("key.toggle"),
            actions: config.get("key.actions"),
            collapseAll: config.get("key.collapseAll"),
            toggleSelection: config.get("key.toggleSelection"),
            activeFilter: config.get("key.activeFilter"),
            selectNext: config.get("key.selectNext"),
            selectPrevious: config.get("key.selectPrevious")
          };
          if (e) {
            void this.render();
          }
        }
      }
      async doFilter(text) {
        let items = [];
        let index = 0;
        let release = await this.mutex.acquire();
        try {
          if (!this.itemsToFilter) {
            let itemsToFilter = [];
            const addNodes = async (nodes2) => {
              for (let n of nodes2) {
                itemsToFilter.push(n);
                let arr = await Promise.resolve(this.provider.getChildren(n));
                if (arr == null ? void 0 : arr.length)
                  await addNodes(arr);
              }
            };
            let nodes = await Promise.resolve(this.provider.getChildren());
            await addNodes(nodes);
            this.itemsToFilter = itemsToFilter;
          }
          for (let n of this.itemsToFilter) {
            let item = await this.getTreeItem(n);
            let label = TreeItemLabel.is(item.label) ? item.label.label : item.label;
            if (!text || hasMatch(text, label)) {
              let idxs = text ? positions(text, label) : [];
              item.collapsibleState = 0 /* None */;
              item.label = { label, highlights: text ? groupPositions(idxs) : [] };
              let { line, highlights: highlights2 } = this.getRenderedLine(item, index, 0);
              items.push({
                level: 0,
                node: n,
                line,
                index,
                score: text ? score(text, label) : 0,
                highlights: highlights2
              });
              index += 1;
            }
          }
          items.sort((a, b) => {
            if (a.score != b.score)
              return b.score - a.score;
            return a.index - b.index;
          });
          let lnum = this.startLnum;
          let highlights = [];
          let renderedItems = this.renderedItems = items.map((o, idx) => {
            highlights.push(...o.highlights.map((h) => {
              h.lnum = lnum + idx;
              return h;
            }));
            delete o.index;
            delete o.score;
            delete o.highlights;
            return o;
          });
          this.updateUI(renderedItems.map((o) => o.line), highlights, lnum, -1, true);
          if (renderedItems.length) {
            this.selectItem(renderedItems[0].node, true);
          } else {
            this.clearSelection();
          }
          this.redraw();
          release();
        } catch (e) {
          release();
          logger38.error(`Error on tree filter:`, e);
        }
      }
      async onHover() {
        let { nvim } = this;
        let lnum = await nvim.call("line", ["."]);
        let element = this.getElementByLnum(lnum - 1);
        if (!element)
          return;
        let obj = this.nodesMap.get(element);
        if (!obj)
          return;
        let item = obj.item;
        if (!obj.resolved) {
          item = await this.resolveItem(element, item);
          if (!item)
            return;
        }
        if (!item.tooltip || !this.bufnr)
          return;
        let isMarkdown2 = import_vscode_languageserver_protocol32.MarkupContent.is(item.tooltip) && item.tooltip.kind == import_vscode_languageserver_protocol32.MarkupKind.Markdown;
        let doc = {
          filetype: isMarkdown2 ? "markdown" : "txt",
          content: import_vscode_languageserver_protocol32.MarkupContent.is(item.tooltip) ? item.tooltip.value : item.tooltip
        };
        await this.tooltipFactory.show([doc]);
      }
      async onClick(element) {
        let { nvim } = this;
        let [line, col] = await nvim.eval(`[getline('.'),col('.')]`);
        let pre = byteSlice(line, 0, col - 1);
        let character = line[pre.length];
        if (!character)
          return;
        let { openedIcon, closedIcon } = this.config;
        if (/^\s*$/.test(pre) && [openedIcon, closedIcon].includes(character)) {
          await this.toggleExpand(element);
        } else {
          await this.invokeCommand(element);
        }
      }
      async invokeCommand(element) {
        let obj = this.nodesMap.get(element);
        if (!obj)
          return;
        this.selectItem(element);
        let item = obj.item;
        if (!item.command) {
          item = await this.resolveItem(element, item);
          if (!item)
            return;
        }
        if (!item.command)
          throw new Error(`Failed to resolve command from TreeItem.`);
        await commands_default.execute(item.command);
      }
      async invokeActions(element) {
        this.selectItem(element);
        if (typeof this.provider.resolveActions !== "function") {
          await window_default.showWarningMessage("No actions");
          return;
        }
        let obj = this.nodesMap.get(element);
        let actions = await Promise.resolve(this.provider.resolveActions(obj.item, element));
        if (!actions || actions.length == 0) {
          await window_default.showWarningMessage("No actions available");
          return;
        }
        let keys = actions.map((o) => o.title);
        let res = await window_default.showMenuPicker(keys, "Choose action");
        if (res == -1)
          return;
        await Promise.resolve(actions[res].handler(element));
      }
      async onDataChange(node) {
        var _a;
        if ((_a = this.filter) == null ? void 0 : _a.activated) {
          this.itemsToFilter = void 0;
          await this.doFilter(this.filterText);
          return;
        }
        this.clearSelection();
        if (!node) {
          await this.render();
          return;
        }
        let release = await this.mutex.acquire();
        try {
          let items = this.renderedItems;
          let idx = items.findIndex((o) => o.node === node);
          if (idx != -1 && this.bufnr) {
            let obj = items[idx];
            let level = obj.level;
            let removeCount = 0;
            for (let i = idx; i < items.length; i++) {
              let o = items[i];
              if (i == idx || o && o.level > level) {
                removeCount += 1;
              }
            }
            let appendItems = [];
            let highlights = [];
            let start = idx + this.startLnum;
            await this.appendTreeNode(node, level, start, appendItems, highlights);
            items.splice(idx, removeCount, ...appendItems);
            this.updateUI(appendItems.map((o) => o.line), highlights, start, start + removeCount);
          }
          release();
        } catch (e) {
          let errMsg = `Error on tree refresh: ${e}`;
          logger38.error(errMsg, e);
          this.nvim.errWriteLine("[coc.nvim] " + errMsg);
          release();
        }
      }
      async resolveItem(element, item) {
        if (typeof this.provider.resolveTreeItem === "function") {
          let tokenSource = this.resolveTokenSource = new import_vscode_languageserver_protocol32.CancellationTokenSource();
          let token = tokenSource.token;
          item = await Promise.resolve(this.provider.resolveTreeItem(item, element, token));
          tokenSource.dispose();
          this.resolveTokenSource = void 0;
          if (token.isCancellationRequested)
            return void 0;
        }
        this.nodesMap.set(element, { item, resolved: true });
        return item;
      }
      get visible() {
        if (!this.bufnr)
          return false;
        return this.winid != null;
      }
      get valid() {
        return typeof this.bufnr === "number";
      }
      get selection() {
        return this._selection.slice();
      }
      async checkLines() {
        if (!this.bufnr)
          return;
        let buf = this.nvim.createBuffer(this.bufnr);
        let curr = await buf.lines;
        let { titleCount, messageCount } = this.lineState;
        curr = curr.slice(titleCount + messageCount);
        let lines = this.renderedItems.map((o) => o.line);
        return equals(curr, lines);
      }
      async toggleExpand(element) {
        let o = this.nodesMap.get(element);
        if (!o)
          return;
        let treeItem = o.item;
        let lnum = this.getItemLnum(element);
        let nodeIdx = lnum - this.startLnum;
        let obj = this.renderedItems[nodeIdx];
        if (!obj || treeItem.collapsibleState == 0 /* None */) {
          if (typeof this.provider.getParent === "function") {
            let node = await Promise.resolve(this.provider.getParent(element));
            if (node) {
              await this.toggleExpand(node);
              this.focusItem(node);
            }
          }
          return;
        }
        let removeCount = 0;
        if (treeItem.collapsibleState == 2 /* Expanded */) {
          let level = obj.level;
          for (let i = nodeIdx + 1; i < this.renderedItems.length; i++) {
            let o2 = this.renderedItems[i];
            if (!o2 || o2.level <= level)
              break;
            removeCount += 1;
          }
          treeItem.collapsibleState = 1 /* Collapsed */;
        } else if (treeItem.collapsibleState == 1 /* Collapsed */) {
          treeItem.collapsibleState = 2 /* Expanded */;
        }
        let newItems = [];
        let newHighlights = [];
        await this.appendTreeNode(obj.node, obj.level, lnum, newItems, newHighlights);
        this.renderedItems.splice(nodeIdx, removeCount + 1, ...newItems);
        this.updateUI(newItems.map((o2) => o2.line), newHighlights, lnum, lnum + removeCount + 1);
        this.refreshSigns();
        if (treeItem.collapsibleState == 1 /* Collapsed */) {
          this._onDidCollapseElement.fire({ element });
        } else {
          this._onDidExpandElement.fire({ element });
        }
      }
      toggleSelection(element) {
        let idx = this._selection.findIndex((o) => o === element);
        if (idx !== -1) {
          this.unselectItem(idx);
        } else {
          this.selectItem(element);
        }
      }
      clearSelection() {
        if (!this.bufnr)
          return;
        this._selection = [];
        let buf = this.nvim.createBuffer(this.bufnr);
        buf.unplaceSign({ group: "CocTree" });
        this._onDidChangeSelection.fire({ selection: [] });
      }
      selectItem(item, forceSingle, noRedraw) {
        let { nvim } = this;
        if (!this.bufnr || !workspace_default.env.sign)
          return;
        let row = this.getItemLnum(item);
        if (row == null)
          return;
        let buf = nvim.createBuffer(this.bufnr);
        let exists = this._selection.includes(item);
        if (!this.opts.canSelectMany || forceSingle) {
          this._selection = [item];
        } else if (!exists) {
          this._selection.push(item);
        }
        nvim.pauseNotification();
        if (!this.opts.canSelectMany || forceSingle) {
          buf.unplaceSign({ group: "CocTree" });
        }
        nvim.call("coc#compat#execute", [this.winid, `normal! ${row + 1}G`], true);
        buf.placeSign({ id: signOffset + row, lnum: row + 1, name: "CocTreeSelected", group: "CocTree" });
        if (!noRedraw)
          this.redraw();
        nvim.resumeNotification(false, true);
        if (!exists)
          this._onDidChangeSelection.fire({ selection: this._selection });
      }
      unselectItem(idx) {
        let item = this._selection[idx];
        let row = this.getItemLnum(item);
        if (row == null || !this.bufnr || !workspace_default.env.sign)
          return;
        this._selection.splice(idx, 1);
        let buf = this.nvim.createBuffer(this.bufnr);
        buf.unplaceSign({ group: "CocTree", id: signOffset + row });
        this._onDidChangeSelection.fire({ selection: this._selection });
      }
      focusItem(element) {
        if (!this.winid)
          return;
        let lnum = this.getItemLnum(element);
        if (lnum == null)
          return;
        this.nvim.call("coc#compat#execute", [this.winid, `exe ${lnum + 1}`], true);
      }
      getElementByLnum(lnum) {
        let item = this.renderedItems[lnum - this.startLnum];
        return item ? item.node : void 0;
      }
      getItemLnum(item) {
        let idx = this.renderedItems.findIndex((o) => o.node === item);
        if (idx == -1)
          return void 0;
        return this.startLnum + idx;
      }
      async getTreeItem(element) {
        let exists;
        let resolved = false;
        let obj = this.nodesMap.get(element);
        if (obj != null) {
          exists = obj.item;
          resolved = obj.resolved;
        }
        let item = await Promise.resolve(this.provider.getTreeItem(element));
        if (item.id && !exists) {
          for (let obj2 of this.nodesMap.values()) {
            if (obj2.item.id === item.id) {
              resolved = obj2.resolved;
              exists = obj2.item;
              break;
            }
          }
        }
        if (exists && exists.collapsibleState != 0 /* None */ && item.collapsibleState != 0 /* None */) {
          item.collapsibleState = exists.collapsibleState;
        }
        this.nodesMap.set(element, { item, resolved });
        return item;
      }
      getRenderedLine(treeItem, lnum, level) {
        let { openedIcon, closedIcon } = this.config;
        const highlights = [];
        const { label, deprecated, description } = treeItem;
        let prefix = "  ".repeat(level);
        const addHighlight = (text, hlGroup) => {
          let colStart = byteLength(prefix);
          highlights.push({
            lnum,
            hlGroup,
            colStart,
            colEnd: colStart + byteLength(text)
          });
        };
        switch (treeItem.collapsibleState) {
          case 2 /* Expanded */: {
            addHighlight(openedIcon, "CocTreeOpenClose");
            prefix += openedIcon + " ";
            break;
          }
          case 1 /* Collapsed */: {
            addHighlight(closedIcon, "CocTreeOpenClose");
            prefix += closedIcon + " ";
            break;
          }
          default:
            prefix += this.leafIndent ? "  " : "";
        }
        if (treeItem.icon) {
          let { text, hlGroup } = treeItem.icon;
          addHighlight(text, hlGroup);
          prefix += text + " ";
        }
        if (TreeItemLabel.is(label) && Array.isArray(label.highlights)) {
          let colStart = byteLength(prefix);
          for (let o of label.highlights) {
            highlights.push({
              lnum,
              hlGroup: "CocSearch",
              colStart: colStart + o[0],
              colEnd: colStart + o[1]
            });
          }
        }
        let labelText = typeof label === "string" ? label : label.label;
        if (deprecated) {
          addHighlight(labelText, "CocDeprecatedHighlight");
        }
        prefix += labelText;
        if (description && description.indexOf("\n") == -1) {
          prefix += " ";
          addHighlight(description, "CocTreeDescription");
          prefix += description;
        }
        return { line: prefix, highlights };
      }
      async appendTreeNode(element, level, lnum, items, highlights) {
        let takes = 1;
        let treeItem = await this.getTreeItem(element);
        let res = this.getRenderedLine(treeItem, lnum, level);
        highlights.push(...res.highlights);
        items.push({ level, line: res.line, node: element });
        if (treeItem.collapsibleState == 2 /* Expanded */) {
          let l = level + 1;
          let children = await Promise.resolve(this.provider.getChildren(element)) || [];
          for (let el of children) {
            let n = await this.appendTreeNode(el, l, lnum + takes, items, highlights);
            takes = takes + n;
          }
        }
        return takes;
      }
      updateUI(lines, highlights, start = 0, end = -1, noRedraw = false) {
        if (!this.bufnr)
          return;
        let { nvim, winid } = this;
        let buf = nvim.createBuffer(this.bufnr);
        nvim.pauseNotification();
        buf.setOption("modifiable", true, true);
        void buf.setLines(lines, { start, end, strictIndexing: false }, true);
        if (this.autoWidth)
          this.nvim.call("coc#window#adjust_width", [winid], true);
        if (highlights.length) {
          let highlightEnd = end == -1 ? -1 : start + lines.length;
          nvim.call("coc#highlight#update_highlights", [this.bufnr, highlightNamespace, highlights, start, highlightEnd], true);
        }
        buf.setOption("modifiable", false, true);
        if (!noRedraw)
          this.redraw();
        nvim.resumeNotification(false, true);
      }
      async reveal(element, options2 = {}) {
        var _a;
        if ((_a = this.filter) == null ? void 0 : _a.activated)
          return;
        let isShown = this.getItemLnum(element) != null;
        let { select, focus, expand } = options2;
        let curr = element;
        if (typeof this.provider.getParent !== "function") {
          throw new Error("missing getParent function from provider for reveal.");
        }
        if (!isShown) {
          while (curr) {
            let parentNode = await Promise.resolve(this.provider.getParent(curr));
            if (parentNode) {
              let item = await this.getTreeItem(parentNode);
              item.collapsibleState = 2 /* Expanded */;
              curr = parentNode;
            } else {
              break;
            }
          }
        }
        if (expand) {
          let item = await this.getTreeItem(element);
          if (item.collapsibleState == 0 /* None */)
            return;
          item.collapsibleState = 2 /* Expanded */;
          if (typeof expand === "number" && expand > 1) {
            let curr2 = Math.min(expand, 2);
            let nodes = await Promise.resolve(this.provider.getChildren(element));
            while ((nodes == null ? void 0 : nodes.length) > 0) {
              let arr = [];
              for (let n of nodes) {
                let item2 = await this.getTreeItem(n);
                if (item2.collapsibleState == 0 /* None */)
                  continue;
                item2.collapsibleState = 2 /* Expanded */;
                if (curr2 > 1) {
                  let res = await Promise.resolve(this.provider.getChildren(n));
                  arr.push(...res);
                }
              }
              nodes = arr;
              curr2 = curr2 - 1;
            }
          }
        }
        if (!isShown || expand) {
          await this.render();
        }
        if (select !== false)
          this.selectItem(element);
        if (focus)
          this.focusItem(element);
      }
      updateHeadLines(initialize = false) {
        let { titleCount, messageCount } = this.lineState;
        let end = initialize ? -1 : titleCount + messageCount;
        let lines = [];
        let highlights = [];
        try {
          if (this.message) {
            highlights.push({ hlGroup: "MoreMsg", colStart: 0, colEnd: byteLength(this.message), lnum: 0 });
            lines.push(this.message);
            lines.push("");
          }
          if (this.title) {
            highlights.push({ hlGroup: "CocTreeTitle", colStart: 0, colEnd: byteLength(this.title), lnum: lines.length });
            if (this.description) {
              let colStart = byteLength(this.title) + 1;
              highlights.push({ hlGroup: "Comment", colStart, colEnd: colStart + byteLength(this.description), lnum: lines.length });
            }
            lines.push(this.title + (this.description ? " " + this.description : ""));
          }
          this.lineState.messageCount = this.message ? 2 : 0;
          this.lineState.titleCount = this.title ? 1 : 0;
          this.updateUI(lines, highlights, 0, end);
          if (!initialize) {
            this.refreshSigns();
          }
        } catch (e) {
          this.nvim.echoError(e);
        }
      }
      refreshSigns() {
        let { selection, nvim, bufnr } = this;
        if (!selection.length || !bufnr || !workspace_default.env.sign)
          return;
        let buf = nvim.createBuffer(bufnr);
        nvim.pauseNotification();
        buf.unplaceSign({ group: "CocTree" });
        for (let n of selection) {
          let row = this.getItemLnum(n);
          if (row == null)
            continue;
          buf.placeSign({ id: signOffset + row, lnum: row + 1, name: "CocTreeSelected", group: "CocTree" });
        }
        nvim.resumeNotification(false, true);
      }
      async render() {
        if (!this.bufnr)
          return;
        let release = await this.mutex.acquire();
        try {
          let lines = [];
          let highlights = [];
          let { startLnum } = this;
          let nodes = await Promise.resolve(this.provider.getChildren());
          let level = 0;
          let lnum = startLnum;
          let renderedItems = [];
          if (!(nodes == null ? void 0 : nodes.length)) {
            this.message = "No results";
          } else {
            if (this.message == "No results")
              this.message = "";
            for (let node of nodes) {
              let n = await this.appendTreeNode(node, level, lnum, renderedItems, highlights);
              lnum += n;
            }
          }
          lines.push(...renderedItems.map((o) => o.line));
          this.renderedItems = renderedItems;
          let delta = this.startLnum - startLnum;
          if (delta)
            highlights.forEach((o) => o.lnum = o.lnum + delta);
          this.updateUI(lines, highlights, this.startLnum, -1);
          this._onDidRefrash.fire();
          this.retryTimers = 0;
          release();
        } catch (e) {
          this.renderedItems = [];
          this.nodesMap.clear();
          this.lineState = { titleCount: 0, messageCount: 1 };
          release();
          let errMsg = `${e}`.replace(/\r?\n/g, " ");
          this.updateUI([errMsg], [{ hlGroup: "WarningMsg", colStart: 0, colEnd: byteLength(errMsg), lnum: 0 }]);
          if (this.retryTimers == 5)
            return;
          this.timer = setTimeout(() => {
            this.retryTimers = this.retryTimers + 1;
            void this.render();
          }, 500);
        }
      }
      async show(splitCommand = "belowright 30vs") {
        if (this._creating)
          return false;
        this._creating = true;
        let { nvim } = this;
        let oldWinId = this.winid;
        let [bufnr, windowId, tabnr, loaded] = await nvim.eval(`[bufnr("%"),win_getid(),tabpagenr(),bufloaded(${this.bufnr || -1})]`);
        this._targetBufnr = bufnr;
        this._targetWinId = windowId;
        this._targetTabId = window_default.getTabId(tabnr);
        if (!loaded)
          this.bufnr = void 0;
        let winid = await nvim.call("coc#window#find", ["cocViewId", this.viewId]);
        if (this.bufnr && winid !== -1) {
          let bufnr2 = await nvim.call("winbufnr", [winid]);
          if (bufnr2 == this.bufnr) {
            this._creating = false;
            return;
          }
        }
        nvim.pauseNotification();
        if (this.bufnr) {
          if (winid != -1) {
            nvim.call("win_gotoid", [winid], true);
            nvim.command(`b ${this.bufnr}`, true);
          } else {
            nvim.command(`silent keepalt ${splitCommand} ${this.bufname}`, true);
          }
        } else {
          let id = globalId;
          globalId = globalId + 1;
          if (winid != -1) {
            nvim.call("win_gotoid", [winid], true);
            nvim.command(`silent edit +setl\\ buftype=nofile CocTree${id}`, true);
          } else {
            nvim.command(`silent keepalt ${splitCommand} +setl\\ buftype=nofile CocTree${id}`, true);
          }
        }
        nvim.command(`setl bufhidden=${this.opts.bufhidden || "wipe"} nolist nonumber norelativenumber foldcolumn=0`, true);
        nvim.command(`setl signcolumn=${this.opts.canSelectMany ? "yes" : "no"}${this.winfixwidth ? " winfixwidth" : ""}`, true);
        nvim.command("setl nocursorline nobuflisted wrap undolevels=-1 filetype=coctree nomodifiable noswapfile", true);
        nvim.command(`let w:cocViewId = "${this.viewId.replace(/"/g, '\\"')}"`, true);
        nvim.call("bufname", ["%"], true);
        nvim.call("bufnr", ["%"], true);
        nvim.call("win_getid", [], true);
        let res = await nvim.resumeNotification();
        if (!this.bufnr)
          this.registerKeymaps();
        let arr = res[0];
        this.bufname = arr[arr.length - 3];
        this.bufnr = arr[arr.length - 2];
        this.winid = arr[arr.length - 1];
        if (!oldWinId)
          this._onDidChangeVisibility.fire({ visible: true });
        if (oldWinId && oldWinId !== this.winid) {
          nvim.call("coc#window#close", [oldWinId], true);
        }
        this._creating = false;
        this.updateHeadLines(true);
        void this.render();
        return true;
      }
      registerLocalKeymap(mode, key, fn, notify = false) {
        this.disposables.push(workspace_default.registerLocalKeymap(mode, key, async () => {
          let lnum = await this.nvim.call("line", ["."]);
          let element = this.getElementByLnum(lnum - 1);
          await Promise.resolve(fn(element));
        }, notify));
      }
      registerKeymaps() {
        let { toggleSelection, actions, close, invoke, toggle, collapseAll, activeFilter } = this.keys;
        let { nvim } = this;
        const regist4 = (mode, key, fn) => {
          this.registerLocalKeymap(mode, key, async (element) => {
            if (element && !this.nodesMap.has(element))
              return;
            await Promise.resolve(fn(element));
          }, true);
        };
        this.disposables.push(workspace_default.registerLocalKeymap("n", "<C-o>", () => {
          nvim.call("win_gotoid", [this._targetWinId], true);
        }, true));
        regist4("n", "<LeftRelease>", async (element) => {
          if (element)
            await this.onClick(element);
        });
        this.filter && activeFilter && regist4("n", activeFilter, async () => {
          this.nvim.command(`exe ${this.startLnum}`, true);
          this.filter.active();
          this.filterText = "";
        });
        toggleSelection && regist4("n", toggleSelection, async (element) => {
          if (element)
            this.toggleSelection(element);
        });
        invoke && regist4("n", invoke, async (element) => {
          if (element)
            await this.invokeCommand(element);
        });
        actions && regist4("n", actions, async (element) => {
          if (element)
            await this.invokeActions(element);
        });
        toggle && regist4("n", toggle, async (element) => {
          if (element)
            await this.toggleExpand(element);
        });
        collapseAll && regist4("n", collapseAll, async () => {
          for (let obj of this.nodesMap.values()) {
            let item = obj.item;
            if (item.collapsibleState == 2 /* Expanded */) {
              item.collapsibleState = 1 /* Collapsed */;
            }
          }
          await this.render();
        });
        close && regist4("n", close, async () => {
          this.hide();
        });
      }
      hide() {
        let { winid } = this;
        if (!winid)
          return;
        this.nvim.call("coc#window#close", [winid], true);
        this.redraw();
        this.winid = void 0;
        this._onDidChangeVisibility.fire({ visible: false });
      }
      redraw() {
        var _a;
        if (workspace_default.isVim || ((_a = this.filter) == null ? void 0 : _a.activated)) {
          this.nvim.command("redraw", true);
        }
      }
      cancelResolve() {
        if (this.resolveTokenSource) {
          this.resolveTokenSource.cancel();
          this.resolveTokenSource = void 0;
        }
      }
      dispose() {
        var _a;
        if (!this.provider)
          return;
        if (this.timer)
          clearTimeout(this.timer);
        this.cancelResolve();
        let { bufnr } = this;
        if (this.winid)
          this._onDidChangeVisibility.fire({ visible: false });
        if (bufnr)
          this.nvim.command(`silent! bwipeout! ${bufnr}`, true);
        this.winid = void 0;
        this.bufnr = void 0;
        (_a = this.filter) == null ? void 0 : _a.dispose();
        this._selection = [];
        this.itemsToFilter = [];
        this.tooltipFactory.dispose();
        this.renderedItems = [];
        this.nodesMap.clear();
        this.provider = void 0;
        this._onDispose.fire();
        this._onDispose.dispose();
        disposeAll(this.disposables);
      }
    };
  }
});

// src/provider/manager.ts
function addLocation(arr, location) {
  let { range: range2, uri } = location;
  if (arr.find((o) => o.uri == uri && equals(o.range, range2)) != null)
    return;
  arr.push(location);
}
var import_vscode_languageserver_protocol33, logger39, Manager;
var init_manager = __esm({
  "src/provider/manager.ts"() {
    "use strict";
    import_vscode_languageserver_protocol33 = __toESM(require_main2());
    init_object();
    init_workspace();
    logger39 = require_logger2()("provider-manager");
    Manager = class {
      constructor() {
        this.providers = /* @__PURE__ */ new Set();
      }
      hasProvider(document2) {
        return this.getProvider(document2) != null;
      }
      addProvider(item) {
        this.providers.add(item);
        return import_vscode_languageserver_protocol33.Disposable.create(() => {
          this.providers.delete(item);
        });
      }
      handleResults(results, name2) {
        results.forEach((res) => {
          if (res.status === "rejected") {
            logger39.error(`Provider error on ${name2}:`, res.reason);
          }
        });
      }
      getProvider(document2) {
        let currScore = 0;
        let providerItem;
        for (let item of this.providers) {
          let { selector, priority } = item;
          let score5 = workspace_default.match(selector, document2);
          if (score5 == 0)
            continue;
          if (typeof priority == "number" && priority > 0) {
            score5 = score5 + priority;
          }
          if (score5 < currScore)
            continue;
          currScore = score5;
          providerItem = item;
        }
        return providerItem;
      }
      getProviderById(id) {
        let item = Array.from(this.providers).find((o) => o.id == id);
        return item ? item.provider : null;
      }
      getProviders(document2) {
        let items = Array.from(this.providers);
        items = items.filter((item) => workspace_default.match(item.selector, document2) > 0);
        return items.sort((a, b) => workspace_default.match(b.selector, document2) - workspace_default.match(a.selector, document2));
      }
      addLocation(locations, location) {
        if (Array.isArray(location)) {
          location.forEach((loc) => {
            if (import_vscode_languageserver_protocol33.Location.is(loc)) {
              addLocation(locations, loc);
            } else if (loc && typeof loc.targetUri === "string") {
              let { targetUri, targetSelectionRange, targetRange } = loc;
              addLocation(locations, import_vscode_languageserver_protocol33.Location.create(targetUri, targetSelectionRange ?? targetRange));
            }
          });
        } else if (import_vscode_languageserver_protocol33.Location.is(location)) {
          addLocation(locations, location);
        }
      }
    };
  }
});

// src/provider/callHierarchyManager.ts
var CallHierarchyManager;
var init_callHierarchyManager = __esm({
  "src/provider/callHierarchyManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager();
    CallHierarchyManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async prepareCallHierarchy(document2, position, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        return await Promise.resolve(provider.prepareCallHierarchy(document2, position, token));
      }
      async provideCallHierarchyOutgoingCalls(document2, item, token) {
        let providerItem = this.getProvider(document2);
        if (!providerItem)
          return null;
        let { provider } = providerItem;
        return await Promise.resolve(provider.provideCallHierarchyOutgoingCalls(item, token));
      }
      async provideCallHierarchyIncomingCalls(document2, item, token) {
        let providerItem = this.getProvider(document2);
        if (!providerItem)
          return null;
        let { provider } = providerItem;
        return await Promise.resolve(provider.provideCallHierarchyIncomingCalls(item, token));
      }
    };
  }
});

// src/util/lodash.ts
function defaults2(obj, ...sources) {
  obj = Object(obj);
  sources.forEach((source) => {
    if (source != null) {
      source = Object(source);
      for (const key in source) {
        const value = obj[key];
        if (value === void 0 || value === objectProto[key] && !hasOwnProperty2.call(obj, key)) {
          obj[key] = source[key];
        }
      }
    }
  });
  return obj;
}
function omit(obj, properties) {
  let o = {};
  for (let key of Object.keys(obj)) {
    if (!properties.includes(key)) {
      o[key] = obj[key];
    }
  }
  return o;
}
var objectProto, hasOwnProperty2;
var init_lodash = __esm({
  "src/util/lodash.ts"() {
    "use strict";
    objectProto = Object.prototype;
    hasOwnProperty2 = objectProto.hasOwnProperty;
  }
});

// src/provider/codeActionManager.ts
var import_vscode_languageserver_protocol34, logger40, CodeActionManager;
var init_codeActionManager = __esm({
  "src/provider/codeActionManager.ts"() {
    "use strict";
    init_esm_node();
    import_vscode_languageserver_protocol34 = __toESM(require_main2());
    init_lodash();
    init_manager();
    logger40 = require_logger2()("codeActionManager");
    CodeActionManager = class extends Manager {
      register(selector, provider, clientId, codeActionKinds) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider,
          kinds: codeActionKinds,
          clientId
        });
      }
      async provideCodeActions(document2, range2, context, token) {
        let providers = this.getProviders(document2);
        if (context.only && providers.length > 0) {
          let { only } = context;
          providers = providers.filter((p) => {
            if (Array.isArray(p.kinds) && !p.kinds.some((kind) => only.includes(kind))) {
              return false;
            }
            return true;
          });
        }
        let res = [];
        let results = await Promise.allSettled(providers.map((item) => {
          let { provider, id } = item;
          return Promise.resolve(provider.provideCodeActions(document2, range2, context, token)).then((actions) => {
            if (!actions || actions.length == 0)
              return;
            let noCheck = res.length === 0;
            for (let action of actions) {
              if (import_vscode_languageserver_protocol34.Command.is(action)) {
                let codeAction = {
                  title: action.title,
                  command: action,
                  providerId: id
                };
                res.push(codeAction);
              } else {
                if (context.only && context.only.length > 0) {
                  let match = context.only.some((k) => {
                    var _a;
                    return (_a = action.kind) == null ? void 0 : _a.startsWith(k);
                  });
                  if (!match)
                    continue;
                }
                if (noCheck || res.findIndex((o) => o.title == action.title) === -1) {
                  res.push(Object.assign({ providerId: id }, action));
                }
              }
            }
          });
        }));
        this.handleResults(results, "provideCodeActions");
        return res;
      }
      async resolveCodeAction(codeAction, token) {
        if (codeAction.edit != null || codeAction.providerId == null)
          return codeAction;
        let provider = this.getProviderById(codeAction.providerId);
        if (!provider || typeof provider.resolveCodeAction !== "function") {
          return codeAction;
        }
        let resolved = await Promise.resolve(provider.resolveCodeAction(omit(codeAction, ["providerId"]), token));
        return resolved ?? codeAction;
      }
    };
  }
});

// src/provider/codeLensManager.ts
var CodeLensManager;
var init_codeLensManager = __esm({
  "src/provider/codeLensManager.ts"() {
    "use strict";
    init_esm_node();
    init_lodash();
    init_manager();
    CodeLensManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideCodeLenses(document2, token) {
        let providers = this.getProviders(document2);
        let codeLens = [];
        let results = await Promise.allSettled(providers.map((item) => {
          let { provider, id } = item;
          return Promise.resolve(provider.provideCodeLenses(document2, token)).then((res) => {
            if (Array.isArray(res)) {
              for (let item2 of res) {
                codeLens.push(Object.assign({ source: id }, item2));
              }
            }
          });
        }));
        this.handleResults(results, "provideCodeLenses");
        return codeLens;
      }
      async resolveCodeLens(codeLens, token) {
        if (codeLens.command)
          return codeLens;
        let provider = this.getProviderById(codeLens.source);
        if (!provider || typeof provider.resolveCodeLens != "function") {
          return codeLens;
        }
        let res = await Promise.resolve(provider.resolveCodeLens(omit(codeLens, ["source"]), token));
        Object.assign(codeLens, res);
        return codeLens;
      }
    };
  }
});

// src/provider/declarationManager.ts
var logger41, DeclarationManager;
var init_declarationManager = __esm({
  "src/provider/declarationManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager();
    logger41 = require_logger2()("definitionManager");
    DeclarationManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideDeclaration(document2, position, token) {
        const providers = this.getProviders(document2);
        let locations = [];
        const results = await Promise.allSettled(providers.map((item) => {
          return Promise.resolve(item.provider.provideDeclaration(document2, position, token)).then((location) => {
            this.addLocation(locations, location);
          });
        }));
        this.handleResults(results, "provideDeclaration");
        return locations;
      }
    };
  }
});

// src/provider/definitionManager.ts
var import_vscode_languageserver_protocol35, logger42, DefinitionManager;
var init_definitionManager = __esm({
  "src/provider/definitionManager.ts"() {
    "use strict";
    init_esm_node();
    import_vscode_languageserver_protocol35 = __toESM(require_main2());
    init_manager();
    logger42 = require_logger2()("definitionManager");
    DefinitionManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideDefinition(document2, position, token) {
        const providers = this.getProviders(document2);
        let locations = [];
        const results = await Promise.allSettled(providers.map((item) => {
          return Promise.resolve(item.provider.provideDefinition(document2, position, token)).then((location) => {
            this.addLocation(locations, location);
          });
        }));
        this.handleResults(results, "provideDefinition");
        return locations;
      }
      async provideDefinitionLinks(document2, position, token) {
        const providers = this.getProviders(document2);
        let locations = [];
        const results = await Promise.allSettled(providers.map((item) => {
          return Promise.resolve(item.provider.provideDefinition(document2, position, token)).then((location) => {
            if (Array.isArray(location)) {
              location.forEach((loc) => {
                if (import_vscode_languageserver_protocol35.LocationLink.is(loc)) {
                  locations.push(loc);
                }
              });
            }
          });
        }));
        this.handleResults(results, "provideDefinition");
        return locations;
      }
    };
  }
});

// src/provider/documentColorManager.ts
var DocumentColorManager;
var init_documentColorManager = __esm({
  "src/provider/documentColorManager.ts"() {
    "use strict";
    init_esm_node();
    init_object();
    init_manager();
    DocumentColorManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideDocumentColors(document2, token) {
        let items = this.getProviders(document2);
        let colors = [];
        const results = await Promise.allSettled(items.map((item) => {
          let { id } = item;
          return Promise.resolve(item.provider.provideDocumentColors(document2, token)).then((arr) => {
            let noCheck = colors.length == 0;
            if (Array.isArray(arr)) {
              for (let color of arr) {
                if (noCheck || !colors.some((o) => equals(o.range, color.range))) {
                  colors.push(Object.assign({ source: id }, color));
                }
              }
            }
          });
        }));
        this.handleResults(results, "provideDefinition");
        return colors;
      }
      async provideColorPresentations(colorInformation, document2, token) {
        let provider = this.getProviderById(colorInformation.source);
        if (!provider)
          return null;
        let { range: range2, color } = colorInformation;
        return await Promise.resolve(provider.provideColorPresentations(color, { document: document2, range: range2 }, token));
      }
    };
  }
});

// src/provider/documentHighlightManager.ts
var DocumentHighlightManager;
var init_documentHighlightManager = __esm({
  "src/provider/documentHighlightManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager();
    DocumentHighlightManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideDocumentHighlights(document2, position, token) {
        let items = this.getProviders(document2);
        let res = null;
        for (const item of items) {
          try {
            res = await Promise.resolve(item.provider.provideDocumentHighlights(document2, position, token));
            if (res != null)
              break;
          } catch (e) {
            this.handleResults([{ status: "rejected", reason: e }], "provideDocumentHighlights");
          }
        }
        return res;
      }
    };
  }
});

// src/provider/documentLinkManager.ts
var DocumentLinkManager;
var init_documentLinkManager = __esm({
  "src/provider/documentLinkManager.ts"() {
    "use strict";
    init_esm_node();
    init_lodash();
    init_object();
    init_manager();
    DocumentLinkManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideDocumentLinks(document2, token) {
        let items = this.getProviders(document2);
        if (items.length == 0)
          return null;
        const links2 = [];
        const results = await Promise.allSettled(items.map((item) => {
          let { id, provider } = item;
          return Promise.resolve(provider.provideDocumentLinks(document2, token)).then((arr) => {
            if (Array.isArray(arr)) {
              arr.forEach((link) => {
                if (!links2.some((l) => equals(l.range, link.range))) {
                  links2.push(Object.assign({ source: id }, link));
                }
              });
            }
          });
        }));
        this.handleResults(results, "provideDocumentLinks");
        return links2;
      }
      async resolveDocumentLink(link, token) {
        let provider = this.getProviderById(link.source);
        if (typeof provider.resolveDocumentLink === "function") {
          let resolved = await Promise.resolve(provider.resolveDocumentLink(omit(link, ["source"]), token));
          if (resolved)
            Object.assign(link, resolved);
        }
        return link;
      }
    };
  }
});

// src/provider/documentSymbolManager.ts
var DocumentSymbolManager;
var init_documentSymbolManager = __esm({
  "src/provider/documentSymbolManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager();
    DocumentSymbolManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      getMetaData(document2) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        return item.provider.meta ?? {};
      }
      async provideDocumentSymbols(document2, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        return await Promise.resolve(provider.provideDocumentSymbols(document2, token)) ?? [];
      }
    };
  }
});

// src/provider/foldingRangeManager.ts
function getParent(line, sortedRanges) {
  for (let r of sortedRanges) {
    if (line >= r.startLine) {
      if (line <= r.endLine) {
        return r;
      } else {
        continue;
      }
    } else {
      break;
    }
  }
  return void 0;
}
var FoldingRangeManager;
var init_foldingRangeManager = __esm({
  "src/provider/foldingRangeManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager();
    FoldingRangeManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideFoldingRanges(document2, context, token) {
        let items = this.getProviders(document2);
        let ranges = [];
        let results = await Promise.allSettled(items.map((item) => {
          return Promise.resolve(item.provider.provideFoldingRanges(document2, context, token)).then((res) => {
            if (Array.isArray(res) && res.length > 0) {
              if (ranges.length == 0) {
                ranges.push(...res);
              } else {
                for (let r of res) {
                  let sp = getParent(r.startLine, ranges);
                  if ((sp == null ? void 0 : sp.startLine) === r.startLine)
                    continue;
                  let ep = getParent(r.endLine, ranges);
                  if (sp === ep) {
                    ranges.push(r);
                  }
                }
              }
              ranges.sort((a, b) => a.startLine - b.startLine);
            }
          });
        }));
        this.handleResults(results, "provideFoldingRanges");
        return ranges;
      }
    };
  }
});

// src/provider/formatManager.ts
var FormatManager;
var init_formatManager = __esm({
  "src/provider/formatManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager();
    FormatManager = class extends Manager {
      register(selector, provider, priority) {
        return this.addProvider({
          id: v4_default(),
          selector,
          priority,
          provider
        });
      }
      async provideDocumentFormattingEdits(document2, options2, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        return await Promise.resolve(provider.provideDocumentFormattingEdits(document2, options2, token));
      }
    };
  }
});

// src/provider/formatRangeManager.ts
var FormatRangeManager;
var init_formatRangeManager = __esm({
  "src/provider/formatRangeManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager();
    FormatRangeManager = class extends Manager {
      register(selector, provider, priority) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider,
          priority
        });
      }
      async provideDocumentRangeFormattingEdits(document2, range2, options2, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        return await Promise.resolve(provider.provideDocumentRangeFormattingEdits(document2, range2, options2, token));
      }
    };
  }
});

// src/provider/hoverManager.ts
var import_vscode_languageserver_protocol36, HoverManager;
var init_hoverManager = __esm({
  "src/provider/hoverManager.ts"() {
    "use strict";
    init_esm_node();
    import_vscode_languageserver_protocol36 = __toESM(require_main2());
    init_object();
    init_manager();
    HoverManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideHover(document2, position, token) {
        let items = this.getProviders(document2);
        let hovers = [];
        let results = await Promise.allSettled(items.map((item) => {
          return Promise.resolve(item.provider.provideHover(document2, position, token)).then((hover) => {
            if (!import_vscode_languageserver_protocol36.Hover.is(hover))
              return;
            if (hovers.findIndex((o) => equals(o.contents, hover.contents)) == -1) {
              hovers.push(hover);
            }
          });
        }));
        this.handleResults(results, "provideHover");
        return hovers;
      }
    };
  }
});

// src/provider/implementationManager.ts
var ImplementationManager;
var init_implementationManager = __esm({
  "src/provider/implementationManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager();
    ImplementationManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideImplementations(document2, position, token) {
        const providers = this.getProviders(document2);
        let locations = [];
        const results = await Promise.allSettled(providers.map((item) => {
          return Promise.resolve(item.provider.provideImplementation(document2, position, token)).then((location) => {
            this.addLocation(locations, location);
          });
        }));
        this.handleResults(results, "provideImplementations");
        return locations;
      }
    };
  }
});

// src/provider/inlayHintManager.ts
function sameHint(one, other) {
  if (comparePosition(one.position, other.position) !== 0)
    return false;
  return getLabel(one) === getLabel(other);
}
function isValidInlayHint(hint, range2) {
  if (hint.label.length === 0 || Array.isArray(hint.label) && hint.label.every((part) => part.value.length === 0)) {
    logger43.warn("INVALID inlay hint, empty label", hint);
    return false;
  }
  if (!import_vscode_languageserver_protocol37.InlayHint.is(hint)) {
    logger43.warn("INVALID inlay hint", hint);
    return false;
  }
  if (range2 && positionInRange(hint.position, range2) !== 0) {
    return false;
  }
  return true;
}
function getLabel(hint) {
  if (typeof hint.label === "string")
    return hint.label;
  return hint.label.map((o) => o.value).join("");
}
var import_vscode_languageserver_protocol37, logger43, InlayHintManger;
var init_inlayHintManager = __esm({
  "src/provider/inlayHintManager.ts"() {
    "use strict";
    init_esm_node();
    import_vscode_languageserver_protocol37 = __toESM(require_main2());
    init_position();
    init_manager();
    logger43 = require_logger2()("inlayHintManger");
    InlayHintManger = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideInlayHints(document2, range2, token) {
        let items = this.getProviders(document2);
        let inlayHints = [];
        let results = await Promise.allSettled(items.map((item) => {
          let { id, provider } = item;
          return Promise.resolve(provider.provideInlayHints(document2, range2, token)).then((hints) => {
            if (!Array.isArray(hints) || token.isCancellationRequested)
              return;
            let noCheck = inlayHints.length == 0;
            for (let hint of hints) {
              if (!isValidInlayHint(hint, range2))
                continue;
              if (!noCheck && inlayHints.findIndex((o) => sameHint(o, hint)) != -1)
                continue;
              inlayHints.push(__spreadValues({ providerId: id }, hint));
            }
          });
        }));
        this.handleResults(results, "provideInlayHints");
        return inlayHints;
      }
      async resolveInlayHint(hint, token) {
        let provider = this.getProviderById(hint.providerId);
        if (!provider || typeof provider.resolveInlayHint !== "function" || hint.resolved === true)
          return hint;
        let res = await Promise.resolve(provider.resolveInlayHint(hint, token));
        if (token.isCancellationRequested)
          return hint;
        return Object.assign(hint, res, { resolved: true });
      }
    };
  }
});

// src/provider/inlineValueManager.ts
var InlineValueManager;
var init_inlineValueManager = __esm({
  "src/provider/inlineValueManager.ts"() {
    "use strict";
    init_esm_node();
    init_object();
    init_manager();
    InlineValueManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideInlineValues(document2, viewPort, context, token) {
        const items = this.getProviders(document2);
        const values = [];
        const results = await Promise.allSettled(items.map((item) => {
          return Promise.resolve(item.provider.provideInlineValues(document2, viewPort, context, token)).then((arr) => {
            if (!Array.isArray(arr))
              return;
            let noCheck = values.length === 0;
            for (let value of arr) {
              if (noCheck || values.every((o) => !equals(o, value))) {
                values.push(value);
              }
            }
          });
        }));
        this.handleResults(results, "provideInlineValues");
        return values;
      }
    };
  }
});

// src/provider/linkedEditingRangeManager.ts
var logger44, LinkedEditingRangeManager;
var init_linkedEditingRangeManager = __esm({
  "src/provider/linkedEditingRangeManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager();
    logger44 = require_logger2()("linkedEditingManager");
    LinkedEditingRangeManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideLinkedEditingRanges(document2, position, token) {
        let items = this.getProviders(document2);
        for (let item of items) {
          let res = await Promise.resolve(item.provider.provideLinkedEditingRanges(document2, position, token));
          if (res != null)
            return res;
        }
        return null;
      }
    };
  }
});

// src/provider/onTypeFormatManager.ts
var logger45, OnTypeFormatManager;
var init_onTypeFormatManager = __esm({
  "src/provider/onTypeFormatManager.ts"() {
    "use strict";
    init_esm_node();
    init_workspace();
    init_manager();
    logger45 = require_logger2()("onTypeFormatManager");
    OnTypeFormatManager = class extends Manager {
      register(selector, provider, triggerCharacters) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider,
          triggerCharacters: triggerCharacters ?? []
        });
      }
      couldTrigger(document2, triggerCharacter) {
        for (let o of this.providers) {
          let { triggerCharacters, selector } = o;
          if (workspace_default.match(selector, document2) > 0 && triggerCharacters.includes(triggerCharacter)) {
            return o.provider;
          }
        }
        return null;
      }
      async onCharacterType(character, document2, position, token) {
        let items = this.getProviders(document2);
        let item = items.find((o) => o.triggerCharacters.includes(character));
        if (!item)
          return null;
        let formatOpts = await workspace_default.getFormatOptions(document2.uri);
        return await Promise.resolve(item.provider.provideOnTypeFormattingEdits(document2, position, character, formatOpts, token));
      }
    };
  }
});

// src/provider/referenceManager.ts
var ReferenceManager;
var init_referenceManager = __esm({
  "src/provider/referenceManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager();
    ReferenceManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideReferences(document2, position, context, token) {
        const providers = this.getProviders(document2);
        let locations = [];
        const results = await Promise.allSettled(providers.map((item) => {
          return Promise.resolve(item.provider.provideReferences(document2, position, context, token)).then((location) => {
            this.addLocation(locations, location);
          });
        }));
        this.handleResults(results, "provideReferences");
        return locations;
      }
    };
  }
});

// src/provider/renameManager.ts
var RenameManager;
var init_renameManager = __esm({
  "src/provider/renameManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager();
    RenameManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideRenameEdits(document2, position, newName, token) {
        let items = this.getProviders(document2);
        let edit2 = null;
        for (const item of items) {
          try {
            edit2 = await Promise.resolve(item.provider.provideRenameEdits(document2, position, newName, token));
          } catch (e) {
            this.handleResults([{ status: "rejected", reason: e }], "provideRenameEdits");
          }
          if (edit2 != null)
            break;
        }
        return edit2;
      }
      async prepareRename(document2, position, token) {
        let items = this.getProviders(document2);
        items = items.filter((o) => typeof o.provider.prepareRename === "function");
        if (items.length === 0)
          return null;
        for (const item of items) {
          let res = await Promise.resolve(item.provider.prepareRename(document2, position, token));
          if (res != null)
            return res;
        }
        return false;
      }
    };
  }
});

// src/provider/selectionRangeManager.ts
var SelectionRangeManager;
var init_selectionRangeManager = __esm({
  "src/provider/selectionRangeManager.ts"() {
    "use strict";
    init_esm_node();
    init_object();
    init_position();
    init_manager();
    SelectionRangeManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideSelectionRanges(document2, positions2, token) {
        let items = this.getProviders(document2);
        if (items.length === 0)
          return null;
        let selectionRangeResult = [];
        let results = await Promise.allSettled(items.map((item) => {
          return Promise.resolve(item.provider.provideSelectionRanges(document2, positions2, token)).then((ranges) => {
            if (Array.isArray(ranges) && ranges.length > 0) {
              selectionRangeResult.push(ranges);
            }
          });
        }));
        this.handleResults(results, "provideSelectionRanges");
        if (selectionRangeResult.length === 0)
          return null;
        let selectionRanges = selectionRangeResult[0];
        if (selectionRangeResult.length > 1) {
          for (let i = 1; i <= selectionRangeResult.length - 1; i++) {
            let start = selectionRanges[0].range;
            let end = selectionRanges[selectionRanges.length - 1].range;
            let ranges = selectionRangeResult[i];
            let len = ranges.length;
            if (rangeInRange(end, ranges[0].range) && !equals(end, ranges[0].range)) {
              selectionRanges.push(...ranges);
            } else if (rangeInRange(ranges[len - 1].range, start) && !equals(ranges[len - 1].range, start)) {
              selectionRanges.unshift(...ranges);
            }
          }
        }
        for (let i = 0; i < selectionRanges.length - 1; i++) {
          let r = selectionRanges[i];
          r.parent = selectionRanges[i + 1];
        }
        return selectionRanges;
      }
    };
  }
});

// src/provider/semanticTokensManager.ts
var logger46, SemanticTokensManager;
var init_semanticTokensManager = __esm({
  "src/provider/semanticTokensManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager();
    logger46 = require_logger2()("semanticTokensManager");
    SemanticTokensManager = class extends Manager {
      register(selector, provider, legend) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider,
          legend
        });
      }
      getLegend(document2) {
        const item = this.getProvider(document2);
        if (!item)
          return;
        return item.legend;
      }
      hasSemanticTokensEdits(document2) {
        var _a;
        let provider = (_a = this.getProvider(document2)) == null ? void 0 : _a.provider;
        if (!provider)
          return false;
        return typeof provider.provideDocumentSemanticTokensEdits === "function";
      }
      async provideDocumentSemanticTokens(document2, token) {
        var _a;
        let provider = (_a = this.getProvider(document2)) == null ? void 0 : _a.provider;
        if (!provider || typeof provider.provideDocumentSemanticTokens !== "function")
          return null;
        return await Promise.resolve(provider.provideDocumentSemanticTokens(document2, token));
      }
      async provideDocumentSemanticTokensEdits(document2, previousResultId, token) {
        let item = this.getProvider(document2);
        if (!item || typeof item.provider.provideDocumentSemanticTokensEdits !== "function")
          return null;
        return await Promise.resolve(item.provider.provideDocumentSemanticTokensEdits(document2, previousResultId, token));
      }
    };
  }
});

// src/provider/semanticTokensRangeManager.ts
var logger47, SemanticTokensRangeManager;
var init_semanticTokensRangeManager = __esm({
  "src/provider/semanticTokensRangeManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager();
    logger47 = require_logger2()("semanticTokensRangeManager");
    SemanticTokensRangeManager = class extends Manager {
      register(selector, provider, legend) {
        return this.addProvider({
          id: v4_default(),
          selector,
          legend,
          provider
        });
      }
      getLegend(document2) {
        const item = this.getProvider(document2);
        if (!item)
          return;
        return item.legend;
      }
      async provideDocumentRangeSemanticTokens(document2, range2, token) {
        let item = this.getProvider(document2);
        if (!item)
          return null;
        let { provider } = item;
        return await Promise.resolve(provider.provideDocumentRangeSemanticTokens(document2, range2, token));
      }
    };
  }
});

// src/provider/signatureManager.ts
var SignatureManager;
var init_signatureManager = __esm({
  "src/provider/signatureManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager();
    SignatureManager = class extends Manager {
      register(selector, provider, triggerCharacters) {
        triggerCharacters = triggerCharacters ?? [];
        let characters = triggerCharacters.reduce((p, c) => p.concat(c.length == 1 ? [c] : c.split(/\s*/g)), []);
        return this.addProvider({
          id: v4_default(),
          selector,
          provider,
          triggerCharacters: characters
        });
      }
      shouldTrigger(document2, triggerCharacter) {
        let items = this.getProviders(document2);
        if (items.length === 0)
          return false;
        for (let item of items) {
          if (item.triggerCharacters.includes(triggerCharacter)) {
            return true;
          }
        }
        return false;
      }
      async provideSignatureHelp(document2, position, token, context) {
        let items = this.getProviders(document2);
        for (const item of items) {
          let res = await Promise.resolve(item.provider.provideSignatureHelp(document2, position, token, context));
          if (res && res.signatures && res.signatures.length > 0)
            return res;
        }
        return null;
      }
    };
  }
});

// src/provider/typeDefinitionManager.ts
var TypeDefinitionManager;
var init_typeDefinitionManager = __esm({
  "src/provider/typeDefinitionManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager();
    TypeDefinitionManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async provideTypeDefinition(document2, position, token) {
        const providers = this.getProviders(document2);
        let locations = [];
        const results = await Promise.allSettled(providers.map((item) => {
          return Promise.resolve(item.provider.provideTypeDefinition(document2, position, token)).then((location) => {
            this.addLocation(locations, location);
          });
        }));
        this.handleResults(results, "provideTypeDefinition");
        return locations;
      }
    };
  }
});

// src/provider/typeHierarchyManager.ts
var TypeHierarchyManager;
var init_typeHierarchyManager = __esm({
  "src/provider/typeHierarchyManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager();
    TypeHierarchyManager = class extends Manager {
      register(selector, provider) {
        return this.addProvider({
          id: v4_default(),
          selector,
          provider
        });
      }
      async prepareTypeHierarchy(document2, position, token) {
        const items = this.getProviders(document2);
        let hierarchyItems = [];
        let results = await Promise.allSettled(items.map((item) => {
          let { provider, id } = item;
          return Promise.resolve(provider.prepareTypeHierarchy(document2, position, token)).then((arr) => {
            if (Array.isArray(arr)) {
              let noCheck = hierarchyItems.length === 0;
              arr.forEach((item2) => {
                if (noCheck || hierarchyItems.every((o) => o.name !== item2.name)) {
                  hierarchyItems.push(Object.assign({ source: id }, item2));
                }
              });
            }
          });
        }));
        this.handleResults(results, "prepareTypeHierarchy");
        return hierarchyItems;
      }
      async provideTypeHierarchySupertypes(item, token) {
        let { source } = item;
        const provider = this.getProviderById(source);
        if (!provider)
          return [];
        return await Promise.resolve(provider.provideTypeHierarchySupertypes(item, token)).then((arr) => {
          if (Array.isArray(arr)) {
            return arr.map((item2) => {
              return Object.assign({ source }, item2);
            });
          }
          return [];
        });
      }
      async provideTypeHierarchySubtypes(item, token) {
        let { source } = item;
        const provider = this.getProviderById(source);
        if (!provider)
          return [];
        return await Promise.resolve(provider.provideTypeHierarchySubtypes(item, token)).then((arr) => {
          if (Array.isArray(arr)) {
            return arr.map((item2) => {
              return Object.assign({ source }, item2);
            });
          }
          return [];
        });
      }
    };
  }
});

// src/provider/workspaceSymbolsManager.ts
var WorkspaceSymbolManager;
var init_workspaceSymbolsManager = __esm({
  "src/provider/workspaceSymbolsManager.ts"() {
    "use strict";
    init_esm_node();
    init_manager();
    WorkspaceSymbolManager = class extends Manager {
      register(provider) {
        return this.addProvider({
          id: v4_default(),
          selector: [{ language: "*" }],
          provider
        });
      }
      async provideWorkspaceSymbols(query, token) {
        let entries = Array.from(this.providers);
        let infos = [];
        let results = await Promise.allSettled(entries.map((o) => {
          let { id, provider } = o;
          return Promise.resolve(provider.provideWorkspaceSymbols(query, token)).then((list2) => {
            if (list2)
              infos.push(...list2.map((item) => Object.assign({ source: id }, item)));
          });
        }));
        this.handleResults(results, "provideWorkspaceSymbols");
        return infos;
      }
      async resolveWorkspaceSymbol(symbolInfo, token) {
        let provider = this.getProviderById(symbolInfo.source);
        if (!provider || typeof provider.resolveWorkspaceSymbol !== "function")
          return symbolInfo;
        return provider.resolveWorkspaceSymbol(symbolInfo, token);
      }
      hasProvider() {
        return this.providers.size > 0;
      }
    };
  }
});

// src/model/installBuffer.ts
var import_events23, logger48, InstallBuffer;
var init_installBuffer = __esm({
  "src/model/installBuffer.ts"() {
    "use strict";
    import_events23 = require("events");
    init_status();
    logger48 = require_logger2()("model-installBuffer");
    InstallBuffer = class extends import_events23.EventEmitter {
      constructor(isUpdate = false, isSync = false, channel = void 0) {
        super();
        this.isUpdate = isUpdate;
        this.isSync = isSync;
        this.channel = channel;
        this.statMap = /* @__PURE__ */ new Map();
        this.messagesMap = /* @__PURE__ */ new Map();
        this.names = [];
      }
      setExtensions(names) {
        this.statMap.clear();
        this.names = names;
        for (let name2 of names) {
          this.statMap.set(name2, 0 /* Waiting */);
        }
      }
      addMessage(name2, msg, isProgress = false) {
        if (isProgress && this.channel)
          return;
        let lines = this.messagesMap.get(name2) || [];
        this.messagesMap.set(name2, lines.concat(msg.trim().split(/\r?\n/)));
        if (this.channel)
          this.channel.appendLine(`[${name2}] ${msg}`);
      }
      startProgress(names) {
        for (let name2 of names) {
          this.statMap.set(name2, 2 /* Progressing */);
        }
      }
      finishProgress(name2, succeed = true) {
        if (this.channel) {
          if (succeed) {
            this.channel.appendLine(`[${name2}] install succeed!`);
          } else {
            this.channel.appendLine(`[${name2}] install failed!`);
          }
        }
        this.statMap.set(name2, succeed ? 3 /* Success */ : 1 /* Failed */);
      }
      get remains() {
        let count = 0;
        for (let name2 of this.names) {
          let stat = this.statMap.get(name2);
          if (![3 /* Success */, 1 /* Failed */].includes(stat)) {
            count = count + 1;
          }
        }
        return count;
      }
      getLines() {
        let lines = [];
        for (let name2 of this.names) {
          let state = this.statMap.get(name2);
          let processText = "*";
          switch (state) {
            case 2 /* Progressing */: {
              let d = new Date();
              let idx = Math.floor(d.getMilliseconds() / 100);
              processText = frames[idx];
              break;
            }
            case 1 /* Failed */:
              processText = "\u2717";
              break;
            case 3 /* Success */:
              processText = "\u2713";
              break;
          }
          let msgs = this.messagesMap.get(name2) || [];
          lines.push(`- ${processText} ${name2} ${msgs.length ? msgs[msgs.length - 1] : ""}`);
        }
        return lines;
      }
      getMessages(line) {
        if (line <= 1)
          return [];
        let name2 = this.names[line - 2];
        if (!name2)
          return [];
        return this.messagesMap.get(name2);
      }
      draw(nvim, buffer) {
        let { remains } = this;
        let first = remains == 0 ? `${this.isUpdate ? "Update" : "Install"} finished` : `Installing, ${remains} remaining...`;
        let lines = [first, "", ...this.getLines()];
        buffer.setLines(lines, { start: 0, end: -1, strictIndexing: false }, true);
        if (remains == 0 && this.interval) {
          clearInterval(this.interval);
          this.interval = null;
        }
        if (process.env.VIM_NODE_RPC) {
          nvim.command("redraw", true);
        }
      }
      highlight(nvim) {
        nvim.call("matchadd", ["CocListFgCyan", "^\\-\\s\\zs\\*"], true);
        nvim.call("matchadd", ["CocListFgGreen", "^\\-\\s\\zs\u2713"], true);
        nvim.call("matchadd", ["CocListFgRed", "^\\-\\s\\zs\u2717"], true);
        nvim.call("matchadd", ["CocListFgYellow", "^-.\\{3\\}\\zs\\S\\+"], true);
      }
      async show(nvim) {
        let { isSync } = this;
        if (this.channel)
          return;
        nvim.pauseNotification();
        nvim.command(isSync ? "enew" : "vs +enew", true);
        nvim.call("bufnr", ["%"], true);
        nvim.command("setl buftype=nofile bufhidden=wipe noswapfile nobuflisted wrap undolevels=-1", true);
        if (!isSync) {
          nvim.command("nnoremap <silent><nowait><buffer> q :q<CR>", true);
        }
        this.highlight(nvim);
        let res = await nvim.resumeNotification();
        this.bufnr = res[0][1];
        let buffer = nvim.createBuffer(this.bufnr);
        this.interval = setInterval(() => {
          this.draw(nvim, buffer);
        }, 100);
      }
      dispose() {
        if (this.interval) {
          clearInterval(this.interval);
        }
      }
    };
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module2) {
    var buffer = require("buffer");
    var Buffer3 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer3(arg, encodingOrOffset, length);
    }
    copyProps(Buffer3, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer3(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer3(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer3(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/content-disposition/index.js
var require_content_disposition = __commonJS({
  "node_modules/content-disposition/index.js"(exports, module2) {
    "use strict";
    module2.exports = contentDisposition2;
    module2.exports.parse = parse4;
    var basename = require("path").basename;
    var Buffer3 = require_safe_buffer().Buffer;
    var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
    var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
    var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
    var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
    var QESC_REGEXP = /\\([\u0000-\u007f])/g;
    var QUOTE_REGEXP = /([\\"])/g;
    var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
    var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
    var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
    var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
    var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
    function contentDisposition2(filename, options2) {
      var opts = options2 || {};
      var type = opts.type || "attachment";
      var params = createparams(filename, opts.fallback);
      return format2(new ContentDisposition(type, params));
    }
    function createparams(filename, fallback) {
      if (filename === void 0) {
        return;
      }
      var params = {};
      if (typeof filename !== "string") {
        throw new TypeError("filename must be a string");
      }
      if (fallback === void 0) {
        fallback = true;
      }
      if (typeof fallback !== "string" && typeof fallback !== "boolean") {
        throw new TypeError("fallback must be a string or boolean");
      }
      if (typeof fallback === "string" && NON_LATIN1_REGEXP.test(fallback)) {
        throw new TypeError("fallback must be ISO-8859-1 string");
      }
      var name2 = basename(filename);
      var isQuotedString = TEXT_REGEXP.test(name2);
      var fallbackName = typeof fallback !== "string" ? fallback && getlatin1(name2) : basename(fallback);
      var hasFallback = typeof fallbackName === "string" && fallbackName !== name2;
      if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name2)) {
        params["filename*"] = name2;
      }
      if (isQuotedString || hasFallback) {
        params.filename = hasFallback ? fallbackName : name2;
      }
      return params;
    }
    function format2(obj) {
      var parameters = obj.parameters;
      var type = obj.type;
      if (!type || typeof type !== "string" || !TOKEN_REGEXP.test(type)) {
        throw new TypeError("invalid type");
      }
      var string2 = String(type).toLowerCase();
      if (parameters && typeof parameters === "object") {
        var param;
        var params = Object.keys(parameters).sort();
        for (var i = 0; i < params.length; i++) {
          param = params[i];
          var val = param.substr(-1) === "*" ? ustring(parameters[param]) : qstring(parameters[param]);
          string2 += "; " + param + "=" + val;
        }
      }
      return string2;
    }
    function decodefield(str) {
      var match = EXT_VALUE_REGEXP.exec(str);
      if (!match) {
        throw new TypeError("invalid extended field value");
      }
      var charset = match[1].toLowerCase();
      var encoded = match[2];
      var value;
      var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
      switch (charset) {
        case "iso-8859-1":
          value = getlatin1(binary);
          break;
        case "utf-8":
          value = Buffer3.from(binary, "binary").toString("utf8");
          break;
        default:
          throw new TypeError("unsupported charset in extended field");
      }
      return value;
    }
    function getlatin1(val) {
      return String(val).replace(NON_LATIN1_REGEXP, "?");
    }
    function parse4(string2) {
      if (!string2 || typeof string2 !== "string") {
        throw new TypeError("argument string is required");
      }
      var match = DISPOSITION_TYPE_REGEXP.exec(string2);
      if (!match) {
        throw new TypeError("invalid type format");
      }
      var index = match[0].length;
      var type = match[1].toLowerCase();
      var key;
      var names = [];
      var params = {};
      var value;
      index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ";" ? index - 1 : index;
      while (match = PARAM_REGEXP.exec(string2)) {
        if (match.index !== index) {
          throw new TypeError("invalid parameter format");
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (names.indexOf(key) !== -1) {
          throw new TypeError("invalid duplicate parameter");
        }
        names.push(key);
        if (key.indexOf("*") + 1 === key.length) {
          key = key.slice(0, -1);
          value = decodefield(value);
          params[key] = value;
          continue;
        }
        if (typeof params[key] === "string") {
          continue;
        }
        if (value[0] === '"') {
          value = value.substr(1, value.length - 2).replace(QESC_REGEXP, "$1");
        }
        params[key] = value;
      }
      if (index !== -1 && index !== string2.length) {
        throw new TypeError("invalid parameter format");
      }
      return new ContentDisposition(type, params);
    }
    function pdecode(str, hex) {
      return String.fromCharCode(parseInt(hex, 16));
    }
    function pencode(char) {
      return "%" + String(char).charCodeAt(0).toString(16).toUpperCase();
    }
    function qstring(val) {
      var str = String(val);
      return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
    }
    function ustring(val) {
      var str = String(val);
      var encoded = encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
      return "UTF-8''" + encoded;
    }
    function ContentDisposition(type, parameters) {
      this.type = type;
      this.parameters = parameters;
    }
  }
});

// node_modules/follow-redirects/debug.js
var require_debug2 = __commonJS({
  "node_modules/follow-redirects/debug.js"(exports, module2) {
    var debug;
    module2.exports = function() {
      if (!debug) {
        try {
          debug = require_src()("follow-redirects");
        } catch (error) {
        }
        if (typeof debug !== "function") {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "node_modules/follow-redirects/index.js"(exports, module2) {
    var url = require("url");
    var URL = url.URL;
    var http3 = require("http");
    var https3 = require("https");
    var Writable = require("stream").Writable;
    var assert = require("assert");
    var debug = require_debug2();
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var RedirectionError = createErrorType("ERR_FR_REDIRECTION_FAILURE", "Redirected request failed");
    var TooManyRedirectsError = createErrorType("ERR_FR_TOO_MANY_REDIRECTS", "Maximum number of redirects exceeded");
    var MaxBodyLengthExceededError = createErrorType("ERR_FR_MAX_BODY_LENGTH_EXCEEDED", "Request body larger than maxBodyLength limit");
    var WriteAfterEndError = createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    function RedirectableRequest(options2, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options2);
      this._options = options2;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        self2._processResponse(response);
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      abortRequest(this._currentRequest);
      this.emit("abort");
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!(typeof data === "string" || typeof data === "object" && "length" in data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (typeof data === "function") {
        callback = data;
        data = encoding = null;
      } else if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name2, value) {
      this._options.headers[name2] = value;
      this._currentRequest.setHeader(name2, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name2) {
      delete this._options.headers[name2];
      this._currentRequest.removeHeader(name2);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options2) {
      if (!options2.headers) {
        options2.headers = {};
      }
      if (options2.host) {
        if (!options2.hostname) {
          options2.hostname = options2.host;
        }
        delete options2.host;
      }
      if (!options2.pathname && options2.path) {
        var searchPos = options2.path.indexOf("?");
        if (searchPos < 0) {
          options2.pathname = options2.path;
        } else {
          options2.pathname = options2.path.substring(0, searchPos);
          options2.search = options2.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol2 = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol2];
      if (!nativeProtocol) {
        this.emit("error", new TypeError("Unsupported protocol " + protocol2));
        return;
      }
      if (this._options.agents) {
        var scheme = protocol2.substr(0, protocol2.length - 1);
        this._options.agent = this._options.agents[scheme];
      }
      var request2 = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      this._currentUrl = url.format(this._options);
      request2._redirectable = this;
      for (var e = 0; e < events.length; e++) {
        request2.on(events[e], eventHandlers[events[e]]);
      }
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request2 === self2._currentRequest) {
            if (error) {
              self2.emit("error", error);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request2.finished) {
                request2.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request2.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (location && this._options.followRedirects !== false && statusCode >= 300 && statusCode < 400) {
        abortRequest(this._currentRequest);
        response.destroy();
        if (++this._redirectCount > this._options.maxRedirects) {
          this.emit("error", new TooManyRedirectsError());
          return;
        }
        if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
          this._options.method = "GET";
          this._requestBodyBuffers = [];
          removeMatchingHeaders(/^content-/i, this._options.headers);
        }
        var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
        var currentUrlParts = url.parse(this._currentUrl);
        var currentHost = currentHostHeader || currentUrlParts.host;
        var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
        var redirectUrl;
        try {
          redirectUrl = url.resolve(currentUrl, location);
        } catch (cause) {
          this.emit("error", new RedirectionError(cause));
          return;
        }
        debug("redirecting to", redirectUrl);
        this._isRedirect = true;
        var redirectUrlParts = url.parse(redirectUrl);
        Object.assign(this._options, redirectUrlParts);
        if (redirectUrlParts.protocol !== currentUrlParts.protocol || !isSameOrSubdomain(redirectUrlParts.host, currentHost)) {
          removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);
        }
        if (typeof this._options.beforeRedirect === "function") {
          var responseDetails = { headers: response.headers };
          try {
            this._options.beforeRedirect.call(null, this._options, responseDetails);
          } catch (err) {
            this.emit("error", err);
            return;
          }
          this._sanitizeOptions(this._options);
        }
        try {
          this._performRequest();
        } catch (cause) {
          this.emit("error", new RedirectionError(cause));
        }
      } else {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
      }
    };
    function wrap(protocols) {
      var exports2 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol2 = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol2] = protocols[scheme];
        var wrappedProtocol = exports2[scheme] = Object.create(nativeProtocol);
        function request2(input, options2, callback) {
          if (typeof input === "string") {
            var urlStr = input;
            try {
              input = urlToOptions(new URL(urlStr));
            } catch (err) {
              input = url.parse(urlStr);
            }
          } else if (URL && input instanceof URL) {
            input = urlToOptions(input);
          } else {
            callback = options2;
            options2 = input;
            input = { protocol: protocol2 };
          }
          if (typeof options2 === "function") {
            callback = options2;
            options2 = null;
          }
          options2 = Object.assign({
            maxRedirects: exports2.maxRedirects,
            maxBodyLength: exports2.maxBodyLength
          }, input, options2);
          options2.nativeProtocols = nativeProtocols;
          assert.equal(options2.protocol, protocol2, "protocol mismatch");
          debug("options", options2);
          return new RedirectableRequest(options2, callback);
        }
        function get(input, options2, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options2, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request2, configurable: true, enumerable: true, writable: true },
          get: { value: get, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports2;
    }
    function noop() {
    }
    function urlToOptions(urlObject) {
      var options2 = {
        protocol: urlObject.protocol,
        hostname: urlObject.hostname.startsWith("[") ? urlObject.hostname.slice(1, -1) : urlObject.hostname,
        hash: urlObject.hash,
        search: urlObject.search,
        pathname: urlObject.pathname,
        path: urlObject.pathname + urlObject.search,
        href: urlObject.href
      };
      if (urlObject.port !== "") {
        options2.port = Number(urlObject.port);
      }
      return options2;
    }
    function removeMatchingHeaders(regex3, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex3.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code, defaultMessage) {
      function CustomError(cause) {
        Error.captureStackTrace(this, this.constructor);
        if (!cause) {
          this.message = defaultMessage;
        } else {
          this.message = defaultMessage + ": " + cause.message;
          this.cause = cause;
        }
      }
      CustomError.prototype = new Error();
      CustomError.prototype.constructor = CustomError;
      CustomError.prototype.name = "Error [" + code + "]";
      CustomError.prototype.code = code;
      return CustomError;
    }
    function abortRequest(request2) {
      for (var e = 0; e < events.length; e++) {
        request2.removeListener(events[e], eventHandlers[events[e]]);
      }
      request2.on("error", noop);
      request2.abort();
    }
    function isSameOrSubdomain(subdomain, domain2) {
      if (subdomain === domain2) {
        return true;
      }
      const dot = subdomain.length - domain2.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain2);
    }
    module2.exports = wrap({ http: http3, https: https3 });
    module2.exports.wrap = wrap;
  }
});

// node_modules/tar/lib/high-level-opt.js
var require_high_level_opt = __commonJS({
  "node_modules/tar/lib/high-level-opt.js"(exports, module2) {
    "use strict";
    var argmap = /* @__PURE__ */ new Map([
      ["C", "cwd"],
      ["f", "file"],
      ["z", "gzip"],
      ["P", "preservePaths"],
      ["U", "unlink"],
      ["strip-components", "strip"],
      ["stripComponents", "strip"],
      ["keep-newer", "newer"],
      ["keepNewer", "newer"],
      ["keep-newer-files", "newer"],
      ["keepNewerFiles", "newer"],
      ["k", "keep"],
      ["keep-existing", "keep"],
      ["keepExisting", "keep"],
      ["m", "noMtime"],
      ["no-mtime", "noMtime"],
      ["p", "preserveOwner"],
      ["L", "follow"],
      ["h", "follow"]
    ]);
    module2.exports = (opt) => opt ? Object.keys(opt).map((k) => [
      argmap.has(k) ? argmap.get(k) : k,
      opt[k]
    ]).reduce((set, kv) => (set[kv[0]] = kv[1], set), /* @__PURE__ */ Object.create(null)) : {};
  }
});

// node_modules/minipass/index.js
var require_minipass = __commonJS({
  "node_modules/minipass/index.js"(exports, module2) {
    "use strict";
    var EE = require("events");
    var Stream = require("stream");
    var Yallist = require_yallist();
    var SD = require("string_decoder").StringDecoder;
    var EOF = Symbol("EOF");
    var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    var EMITTED_END = Symbol("emittedEnd");
    var EMITTING_END = Symbol("emittingEnd");
    var CLOSED = Symbol("closed");
    var READ = Symbol("read");
    var FLUSH = Symbol("flush");
    var FLUSHCHUNK = Symbol("flushChunk");
    var ENCODING = Symbol("encoding");
    var DECODER = Symbol("decoder");
    var FLOWING = Symbol("flowing");
    var PAUSED = Symbol("paused");
    var RESUME = Symbol("resume");
    var BUFFERLENGTH = Symbol("bufferLength");
    var BUFFERPUSH = Symbol("bufferPush");
    var BUFFERSHIFT = Symbol("bufferShift");
    var OBJECTMODE = Symbol("objectMode");
    var DESTROYED = Symbol("destroyed");
    var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
    var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
    var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
    var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
    var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
    module2.exports = class Minipass extends Stream {
      constructor(options2) {
        super();
        this[FLOWING] = false;
        this[PAUSED] = false;
        this.pipes = new Yallist();
        this.buffer = new Yallist();
        this[OBJECTMODE] = options2 && options2.objectMode || false;
        if (this[OBJECTMODE])
          this[ENCODING] = null;
        else
          this[ENCODING] = options2 && options2.encoding || null;
        if (this[ENCODING] === "buffer")
          this[ENCODING] = null;
        this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
        this[EOF] = false;
        this[EMITTED_END] = false;
        this[EMITTING_END] = false;
        this[CLOSED] = false;
        this.writable = true;
        this.readable = true;
        this[BUFFERLENGTH] = 0;
        this[DESTROYED] = false;
      }
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      get encoding() {
        return this[ENCODING];
      }
      set encoding(enc) {
        if (this[OBJECTMODE])
          throw new Error("cannot set encoding in objectMode");
        if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
          throw new Error("cannot change encoding");
        if (this[ENCODING] !== enc) {
          this[DECODER] = enc ? new SD(enc) : null;
          if (this.buffer.length)
            this.buffer = this.buffer.map((chunk) => this[DECODER].write(chunk));
        }
        this[ENCODING] = enc;
      }
      setEncoding(enc) {
        this.encoding = enc;
      }
      get objectMode() {
        return this[OBJECTMODE];
      }
      set objectMode(om) {
        this[OBJECTMODE] = this[OBJECTMODE] || !!om;
      }
      write(chunk, encoding, cb) {
        if (this[EOF])
          throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
          return true;
        }
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (!encoding)
          encoding = "utf8";
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk))
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          else if (isArrayBuffer(chunk))
            chunk = Buffer.from(chunk);
          else if (typeof chunk !== "string")
            this.objectMode = true;
        }
        if (!this.objectMode && !chunk.length) {
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            cb();
          return this.flowing;
        }
        if (typeof chunk === "string" && !this[OBJECTMODE] && !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
          chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING])
          chunk = this[DECODER].write(chunk);
        if (this.flowing) {
          if (this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
          this.emit("data", chunk);
        } else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          cb();
        return this.flowing;
      }
      read(n) {
        if (this[DESTROYED])
          return null;
        try {
          if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH])
            return null;
          if (this[OBJECTMODE])
            n = null;
          if (this.buffer.length > 1 && !this[OBJECTMODE]) {
            if (this.encoding)
              this.buffer = new Yallist([
                Array.from(this.buffer).join("")
              ]);
            else
              this.buffer = new Yallist([
                Buffer.concat(Array.from(this.buffer), this[BUFFERLENGTH])
              ]);
          }
          return this[READ](n || null, this.buffer.head.value);
        } finally {
          this[MAYBE_EMIT_END]();
        }
      }
      [READ](n, chunk) {
        if (n === chunk.length || n === null)
          this[BUFFERSHIFT]();
        else {
          this.buffer.head.value = chunk.slice(n);
          chunk = chunk.slice(0, n);
          this[BUFFERLENGTH] -= n;
        }
        this.emit("data", chunk);
        if (!this.buffer.length && !this[EOF])
          this.emit("drain");
        return chunk;
      }
      end(chunk, encoding, cb) {
        if (typeof chunk === "function")
          cb = chunk, chunk = null;
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (chunk)
          this.write(chunk, encoding);
        if (cb)
          this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this.flowing || !this[PAUSED])
          this[MAYBE_EMIT_END]();
        return this;
      }
      [RESUME]() {
        if (this[DESTROYED])
          return;
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this.buffer.length)
          this[FLUSH]();
        else if (this[EOF])
          this[MAYBE_EMIT_END]();
        else
          this.emit("drain");
      }
      resume() {
        return this[RESUME]();
      }
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
      }
      get destroyed() {
        return this[DESTROYED];
      }
      get flowing() {
        return this[FLOWING];
      }
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] += 1;
        else
          this[BUFFERLENGTH] += chunk.length;
        return this.buffer.push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this.buffer.length) {
          if (this[OBJECTMODE])
            this[BUFFERLENGTH] -= 1;
          else
            this[BUFFERLENGTH] -= this.buffer.head.value.length;
        }
        return this.buffer.shift();
      }
      [FLUSH](noDrain) {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
        if (!noDrain && !this.buffer.length && !this[EOF])
          this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        return chunk ? (this.emit("data", chunk), this.flowing) : false;
      }
      pipe(dest, opts) {
        if (this[DESTROYED])
          return;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === process.stdout || dest === process.stderr)
          opts.end = false;
        else
          opts.end = opts.end !== false;
        const p = { dest, opts, ondrain: (_) => this[RESUME]() };
        this.pipes.push(p);
        dest.on("drain", p.ondrain);
        this[RESUME]();
        if (ended && p.opts.end)
          p.dest.end();
        return dest;
      }
      addListener(ev, fn) {
        return this.on(ev, fn);
      }
      on(ev, fn) {
        try {
          return super.on(ev, fn);
        } finally {
          if (ev === "data" && !this.pipes.length && !this.flowing)
            this[RESUME]();
          else if (isEndish(ev) && this[EMITTED_END]) {
            super.emit(ev);
            this.removeAllListeners(ev);
          }
        }
      }
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED])
            this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      emit(ev, data) {
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
          return;
        else if (ev === "data") {
          if (!data)
            return;
          if (this.pipes.length)
            this.pipes.forEach((p) => p.dest.write(data) === false && this.pause());
        } else if (ev === "end") {
          if (this[EMITTED_END] === true)
            return;
          this[EMITTED_END] = true;
          this.readable = false;
          if (this[DECODER]) {
            data = this[DECODER].end();
            if (data) {
              this.pipes.forEach((p) => p.dest.write(data));
              super.emit("data", data);
            }
          }
          this.pipes.forEach((p) => {
            p.dest.removeListener("drain", p.ondrain);
            if (p.opts.end)
              p.dest.end();
          });
        } else if (ev === "close") {
          this[CLOSED] = true;
          if (!this[EMITTED_END] && !this[DESTROYED])
            return;
        }
        const args = new Array(arguments.length);
        args[0] = ev;
        args[1] = data;
        if (arguments.length > 2) {
          for (let i = 2; i < arguments.length; i++) {
            args[i] = arguments[i];
          }
        }
        try {
          return super.emit.apply(this, args);
        } finally {
          if (!isEndish(ev))
            this[MAYBE_EMIT_END]();
          else
            this.removeAllListeners(ev);
        }
      }
      collect() {
        const buf = [];
        if (!this[OBJECTMODE])
          buf.dataLength = 0;
        const p = this.promise();
        this.on("data", (c) => {
          buf.push(c);
          if (!this[OBJECTMODE])
            buf.dataLength += c.length;
        });
        return p.then(() => buf);
      }
      concat() {
        return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then((buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength));
      }
      promise() {
        return new Promise((resolve3, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("end", () => resolve3());
          this.on("error", (er) => reject(er));
        });
      }
      [ASYNCITERATOR]() {
        const next = () => {
          const res = this.read();
          if (res !== null)
            return Promise.resolve({ done: false, value: res });
          if (this[EOF])
            return Promise.resolve({ done: true });
          let resolve3 = null;
          let reject = null;
          const onerr = (er) => {
            this.removeListener("data", ondata);
            this.removeListener("end", onend);
            reject(er);
          };
          const ondata = (value) => {
            this.removeListener("error", onerr);
            this.removeListener("end", onend);
            this.pause();
            resolve3({ value, done: !!this[EOF] });
          };
          const onend = () => {
            this.removeListener("error", onerr);
            this.removeListener("data", ondata);
            resolve3({ done: true });
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve3 = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return { next };
      }
      [ITERATOR]() {
        const next = () => {
          const value = this.read();
          const done = value === null;
          return { value, done };
        };
        return { next };
      }
      destroy(er) {
        if (this[DESTROYED]) {
          if (er)
            this.emit("error", er);
          else
            this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this.buffer = new Yallist();
        this[BUFFERLENGTH] = 0;
        if (typeof this.close === "function" && !this[CLOSED])
          this.close();
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      static isStream(s) {
        return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === "function" || typeof s.write === "function" && typeof s.end === "function"));
      }
    };
  }
});

// node_modules/minizlib/constants.js
var require_constants2 = __commonJS({
  "node_modules/minizlib/constants.js"(exports, module2) {
    var realZlibConstants = require("zlib").constants || { ZLIB_VERNUM: 4736 };
    module2.exports = Object.freeze(Object.assign(/* @__PURE__ */ Object.create(null), {
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      Z_VERSION_ERROR: -6,
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      DEFLATE: 1,
      INFLATE: 2,
      GZIP: 3,
      GUNZIP: 4,
      DEFLATERAW: 5,
      INFLATERAW: 6,
      UNZIP: 7,
      BROTLI_DECODE: 8,
      BROTLI_ENCODE: 9,
      Z_MIN_WINDOWBITS: 8,
      Z_MAX_WINDOWBITS: 15,
      Z_DEFAULT_WINDOWBITS: 15,
      Z_MIN_CHUNK: 64,
      Z_MAX_CHUNK: Infinity,
      Z_DEFAULT_CHUNK: 16384,
      Z_MIN_MEMLEVEL: 1,
      Z_MAX_MEMLEVEL: 9,
      Z_DEFAULT_MEMLEVEL: 8,
      Z_MIN_LEVEL: -1,
      Z_MAX_LEVEL: 9,
      Z_DEFAULT_LEVEL: -1,
      BROTLI_OPERATION_PROCESS: 0,
      BROTLI_OPERATION_FLUSH: 1,
      BROTLI_OPERATION_FINISH: 2,
      BROTLI_OPERATION_EMIT_METADATA: 3,
      BROTLI_MODE_GENERIC: 0,
      BROTLI_MODE_TEXT: 1,
      BROTLI_MODE_FONT: 2,
      BROTLI_DEFAULT_MODE: 0,
      BROTLI_MIN_QUALITY: 0,
      BROTLI_MAX_QUALITY: 11,
      BROTLI_DEFAULT_QUALITY: 11,
      BROTLI_MIN_WINDOW_BITS: 10,
      BROTLI_MAX_WINDOW_BITS: 24,
      BROTLI_LARGE_MAX_WINDOW_BITS: 30,
      BROTLI_DEFAULT_WINDOW: 22,
      BROTLI_MIN_INPUT_BLOCK_BITS: 16,
      BROTLI_MAX_INPUT_BLOCK_BITS: 24,
      BROTLI_PARAM_MODE: 0,
      BROTLI_PARAM_QUALITY: 1,
      BROTLI_PARAM_LGWIN: 2,
      BROTLI_PARAM_LGBLOCK: 3,
      BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
      BROTLI_PARAM_SIZE_HINT: 5,
      BROTLI_PARAM_LARGE_WINDOW: 6,
      BROTLI_PARAM_NPOSTFIX: 7,
      BROTLI_PARAM_NDIRECT: 8,
      BROTLI_DECODER_RESULT_ERROR: 0,
      BROTLI_DECODER_RESULT_SUCCESS: 1,
      BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
      BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
      BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
      BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
      BROTLI_DECODER_NO_ERROR: 0,
      BROTLI_DECODER_SUCCESS: 1,
      BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
      BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
      BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
      BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
      BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
      BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
      BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
      BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
      BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
      BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
      BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
      BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
      BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
      BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
      BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
      BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
      BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
      BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
      BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
      BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
      BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
      BROTLI_DECODER_ERROR_UNREACHABLE: -31
    }, realZlibConstants));
  }
});

// node_modules/minizlib/index.js
var require_minizlib = __commonJS({
  "node_modules/minizlib/index.js"(exports) {
    "use strict";
    var assert = require("assert");
    var Buffer3 = require("buffer").Buffer;
    var realZlib = require("zlib");
    var constants = exports.constants = require_constants2();
    var Minipass = require_minipass();
    var OriginalBufferConcat = Buffer3.concat;
    var _superWrite = Symbol("_superWrite");
    var ZlibError = class extends Error {
      constructor(err) {
        super("zlib: " + err.message);
        this.code = err.code;
        this.errno = err.errno;
        if (!this.code)
          this.code = "ZLIB_ERROR";
        this.message = "zlib: " + err.message;
        Error.captureStackTrace(this, this.constructor);
      }
      get name() {
        return "ZlibError";
      }
    };
    var _opts = Symbol("opts");
    var _flushFlag = Symbol("flushFlag");
    var _finishFlushFlag = Symbol("finishFlushFlag");
    var _fullFlushFlag = Symbol("fullFlushFlag");
    var _handle = Symbol("handle");
    var _onError = Symbol("onError");
    var _sawError = Symbol("sawError");
    var _level = Symbol("level");
    var _strategy = Symbol("strategy");
    var _ended = Symbol("ended");
    var _defaultFullFlush = Symbol("_defaultFullFlush");
    var ZlibBase = class extends Minipass {
      constructor(opts, mode) {
        if (!opts || typeof opts !== "object")
          throw new TypeError("invalid options for ZlibBase constructor");
        super(opts);
        this[_sawError] = false;
        this[_ended] = false;
        this[_opts] = opts;
        this[_flushFlag] = opts.flush;
        this[_finishFlushFlag] = opts.finishFlush;
        try {
          this[_handle] = new realZlib[mode](opts);
        } catch (er) {
          throw new ZlibError(er);
        }
        this[_onError] = (err) => {
          if (this[_sawError])
            return;
          this[_sawError] = true;
          this.close();
          this.emit("error", err);
        };
        this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
        this.once("end", () => this.close);
      }
      close() {
        if (this[_handle]) {
          this[_handle].close();
          this[_handle] = null;
          this.emit("close");
        }
      }
      reset() {
        if (!this[_sawError]) {
          assert(this[_handle], "zlib binding closed");
          return this[_handle].reset();
        }
      }
      flush(flushFlag) {
        if (this.ended)
          return;
        if (typeof flushFlag !== "number")
          flushFlag = this[_fullFlushFlag];
        this.write(Object.assign(Buffer3.alloc(0), { [_flushFlag]: flushFlag }));
      }
      end(chunk, encoding, cb) {
        if (chunk)
          this.write(chunk, encoding);
        this.flush(this[_finishFlushFlag]);
        this[_ended] = true;
        return super.end(null, null, cb);
      }
      get ended() {
        return this[_ended];
      }
      write(chunk, encoding, cb) {
        if (typeof encoding === "function")
          cb = encoding, encoding = "utf8";
        if (typeof chunk === "string")
          chunk = Buffer3.from(chunk, encoding);
        if (this[_sawError])
          return;
        assert(this[_handle], "zlib binding closed");
        const nativeHandle = this[_handle]._handle;
        const originalNativeClose = nativeHandle.close;
        nativeHandle.close = () => {
        };
        const originalClose = this[_handle].close;
        this[_handle].close = () => {
        };
        Buffer3.concat = (args) => args;
        let result;
        try {
          const flushFlag = typeof chunk[_flushFlag] === "number" ? chunk[_flushFlag] : this[_flushFlag];
          result = this[_handle]._processChunk(chunk, flushFlag);
          Buffer3.concat = OriginalBufferConcat;
        } catch (err) {
          Buffer3.concat = OriginalBufferConcat;
          this[_onError](new ZlibError(err));
        } finally {
          if (this[_handle]) {
            this[_handle]._handle = nativeHandle;
            nativeHandle.close = originalNativeClose;
            this[_handle].close = originalClose;
            this[_handle].removeAllListeners("error");
          }
        }
        if (this[_handle])
          this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
        let writeReturn;
        if (result) {
          if (Array.isArray(result) && result.length > 0) {
            writeReturn = this[_superWrite](Buffer3.from(result[0]));
            for (let i = 1; i < result.length; i++) {
              writeReturn = this[_superWrite](result[i]);
            }
          } else {
            writeReturn = this[_superWrite](Buffer3.from(result));
          }
        }
        if (cb)
          cb();
        return writeReturn;
      }
      [_superWrite](data) {
        return super.write(data);
      }
    };
    var Zlib = class extends ZlibBase {
      constructor(opts, mode) {
        opts = opts || {};
        opts.flush = opts.flush || constants.Z_NO_FLUSH;
        opts.finishFlush = opts.finishFlush || constants.Z_FINISH;
        super(opts, mode);
        this[_fullFlushFlag] = constants.Z_FULL_FLUSH;
        this[_level] = opts.level;
        this[_strategy] = opts.strategy;
      }
      params(level, strategy) {
        if (this[_sawError])
          return;
        if (!this[_handle])
          throw new Error("cannot switch params when binding is closed");
        if (!this[_handle].params)
          throw new Error("not supported in this implementation");
        if (this[_level] !== level || this[_strategy] !== strategy) {
          this.flush(constants.Z_SYNC_FLUSH);
          assert(this[_handle], "zlib binding closed");
          const origFlush = this[_handle].flush;
          this[_handle].flush = (flushFlag, cb) => {
            this.flush(flushFlag);
            cb();
          };
          try {
            this[_handle].params(level, strategy);
          } finally {
            this[_handle].flush = origFlush;
          }
          if (this[_handle]) {
            this[_level] = level;
            this[_strategy] = strategy;
          }
        }
      }
    };
    var Deflate = class extends Zlib {
      constructor(opts) {
        super(opts, "Deflate");
      }
    };
    var Inflate = class extends Zlib {
      constructor(opts) {
        super(opts, "Inflate");
      }
    };
    var _portable = Symbol("_portable");
    var Gzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Gzip");
        this[_portable] = opts && !!opts.portable;
      }
      [_superWrite](data) {
        if (!this[_portable])
          return super[_superWrite](data);
        this[_portable] = false;
        data[9] = 255;
        return super[_superWrite](data);
      }
    };
    var Gunzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Gunzip");
      }
    };
    var DeflateRaw = class extends Zlib {
      constructor(opts) {
        super(opts, "DeflateRaw");
      }
    };
    var InflateRaw = class extends Zlib {
      constructor(opts) {
        super(opts, "InflateRaw");
      }
    };
    var Unzip = class extends Zlib {
      constructor(opts) {
        super(opts, "Unzip");
      }
    };
    var Brotli = class extends ZlibBase {
      constructor(opts, mode) {
        opts = opts || {};
        opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS;
        opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH;
        super(opts, mode);
        this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH;
      }
    };
    var BrotliCompress = class extends Brotli {
      constructor(opts) {
        super(opts, "BrotliCompress");
      }
    };
    var BrotliDecompress = class extends Brotli {
      constructor(opts) {
        super(opts, "BrotliDecompress");
      }
    };
    exports.Deflate = Deflate;
    exports.Inflate = Inflate;
    exports.Gzip = Gzip;
    exports.Gunzip = Gunzip;
    exports.DeflateRaw = DeflateRaw;
    exports.InflateRaw = InflateRaw;
    exports.Unzip = Unzip;
    if (typeof realZlib.BrotliCompress === "function") {
      exports.BrotliCompress = BrotliCompress;
      exports.BrotliDecompress = BrotliDecompress;
    } else {
      exports.BrotliCompress = exports.BrotliDecompress = class {
        constructor() {
          throw new Error("Brotli is not supported in this version of Node.js");
        }
      };
    }
  }
});

// node_modules/tar/lib/normalize-windows-path.js
var require_normalize_windows_path = __commonJS({
  "node_modules/tar/lib/normalize-windows-path.js"(exports, module2) {
    var platform2 = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
    module2.exports = platform2 !== "win32" ? (p) => p : (p) => p && p.replace(/\\/g, "/");
  }
});

// node_modules/tar/lib/read-entry.js
var require_read_entry = __commonJS({
  "node_modules/tar/lib/read-entry.js"(exports, module2) {
    "use strict";
    var MiniPass = require_minipass();
    var normPath = require_normalize_windows_path();
    var SLURP = Symbol("slurp");
    module2.exports = class ReadEntry extends MiniPass {
      constructor(header, ex, gex) {
        super();
        this.pause();
        this.extended = ex;
        this.globalExtended = gex;
        this.header = header;
        this.startBlockSize = 512 * Math.ceil(header.size / 512);
        this.blockRemain = this.startBlockSize;
        this.remain = header.size;
        this.type = header.type;
        this.meta = false;
        this.ignore = false;
        switch (this.type) {
          case "File":
          case "OldFile":
          case "Link":
          case "SymbolicLink":
          case "CharacterDevice":
          case "BlockDevice":
          case "Directory":
          case "FIFO":
          case "ContiguousFile":
          case "GNUDumpDir":
            break;
          case "NextFileHasLongLinkpath":
          case "NextFileHasLongPath":
          case "OldGnuLongPath":
          case "GlobalExtendedHeader":
          case "ExtendedHeader":
          case "OldExtendedHeader":
            this.meta = true;
            break;
          default:
            this.ignore = true;
        }
        this.path = normPath(header.path);
        this.mode = header.mode;
        if (this.mode)
          this.mode = this.mode & 4095;
        this.uid = header.uid;
        this.gid = header.gid;
        this.uname = header.uname;
        this.gname = header.gname;
        this.size = header.size;
        this.mtime = header.mtime;
        this.atime = header.atime;
        this.ctime = header.ctime;
        this.linkpath = normPath(header.linkpath);
        this.uname = header.uname;
        this.gname = header.gname;
        if (ex)
          this[SLURP](ex);
        if (gex)
          this[SLURP](gex, true);
      }
      write(data) {
        const writeLen = data.length;
        if (writeLen > this.blockRemain)
          throw new Error("writing more to entry than is appropriate");
        const r = this.remain;
        const br = this.blockRemain;
        this.remain = Math.max(0, r - writeLen);
        this.blockRemain = Math.max(0, br - writeLen);
        if (this.ignore)
          return true;
        if (r >= writeLen)
          return super.write(data);
        return super.write(data.slice(0, r));
      }
      [SLURP](ex, global2) {
        for (const k in ex) {
          if (ex[k] !== null && ex[k] !== void 0 && !(global2 && k === "path"))
            this[k] = k === "path" || k === "linkpath" ? normPath(ex[k]) : ex[k];
        }
      }
    };
  }
});

// node_modules/tar/lib/types.js
var require_types2 = __commonJS({
  "node_modules/tar/lib/types.js"(exports) {
    "use strict";
    exports.name = /* @__PURE__ */ new Map([
      ["0", "File"],
      ["", "OldFile"],
      ["1", "Link"],
      ["2", "SymbolicLink"],
      ["3", "CharacterDevice"],
      ["4", "BlockDevice"],
      ["5", "Directory"],
      ["6", "FIFO"],
      ["7", "ContiguousFile"],
      ["g", "GlobalExtendedHeader"],
      ["x", "ExtendedHeader"],
      ["A", "SolarisACL"],
      ["D", "GNUDumpDir"],
      ["I", "Inode"],
      ["K", "NextFileHasLongLinkpath"],
      ["L", "NextFileHasLongPath"],
      ["M", "ContinuationFile"],
      ["N", "OldGnuLongPath"],
      ["S", "SparseFile"],
      ["V", "TapeVolumeHeader"],
      ["X", "OldExtendedHeader"]
    ]);
    exports.code = new Map(Array.from(exports.name).map((kv) => [kv[1], kv[0]]));
  }
});

// node_modules/tar/lib/large-numbers.js
var require_large_numbers = __commonJS({
  "node_modules/tar/lib/large-numbers.js"(exports, module2) {
    "use strict";
    var encode = (num, buf) => {
      if (!Number.isSafeInteger(num))
        throw Error("cannot encode number outside of javascript safe integer range");
      else if (num < 0)
        encodeNegative(num, buf);
      else
        encodePositive(num, buf);
      return buf;
    };
    var encodePositive = (num, buf) => {
      buf[0] = 128;
      for (var i = buf.length; i > 1; i--) {
        buf[i - 1] = num & 255;
        num = Math.floor(num / 256);
      }
    };
    var encodeNegative = (num, buf) => {
      buf[0] = 255;
      var flipped = false;
      num = num * -1;
      for (var i = buf.length; i > 1; i--) {
        var byte = num & 255;
        num = Math.floor(num / 256);
        if (flipped)
          buf[i - 1] = onesComp(byte);
        else if (byte === 0)
          buf[i - 1] = 0;
        else {
          flipped = true;
          buf[i - 1] = twosComp(byte);
        }
      }
    };
    var parse4 = (buf) => {
      const pre = buf[0];
      const value = pre === 128 ? pos(buf.slice(1, buf.length)) : pre === 255 ? twos(buf) : null;
      if (value === null)
        throw Error("invalid base256 encoding");
      if (!Number.isSafeInteger(value))
        throw Error("parsed number outside of javascript safe integer range");
      return value;
    };
    var twos = (buf) => {
      var len = buf.length;
      var sum = 0;
      var flipped = false;
      for (var i = len - 1; i > -1; i--) {
        var byte = buf[i];
        var f;
        if (flipped)
          f = onesComp(byte);
        else if (byte === 0)
          f = byte;
        else {
          flipped = true;
          f = twosComp(byte);
        }
        if (f !== 0)
          sum -= f * Math.pow(256, len - i - 1);
      }
      return sum;
    };
    var pos = (buf) => {
      var len = buf.length;
      var sum = 0;
      for (var i = len - 1; i > -1; i--) {
        var byte = buf[i];
        if (byte !== 0)
          sum += byte * Math.pow(256, len - i - 1);
      }
      return sum;
    };
    var onesComp = (byte) => (255 ^ byte) & 255;
    var twosComp = (byte) => (255 ^ byte) + 1 & 255;
    module2.exports = {
      encode,
      parse: parse4
    };
  }
});

// node_modules/tar/lib/header.js
var require_header = __commonJS({
  "node_modules/tar/lib/header.js"(exports, module2) {
    "use strict";
    var types = require_types2();
    var pathModule = require("path").posix;
    var large = require_large_numbers();
    var SLURP = Symbol("slurp");
    var TYPE = Symbol("type");
    var Header = class {
      constructor(data, off, ex, gex) {
        this.cksumValid = false;
        this.needPax = false;
        this.nullBlock = false;
        this.block = null;
        this.path = null;
        this.mode = null;
        this.uid = null;
        this.gid = null;
        this.size = null;
        this.mtime = null;
        this.cksum = null;
        this[TYPE] = "0";
        this.linkpath = null;
        this.uname = null;
        this.gname = null;
        this.devmaj = 0;
        this.devmin = 0;
        this.atime = null;
        this.ctime = null;
        if (Buffer.isBuffer(data))
          this.decode(data, off || 0, ex, gex);
        else if (data)
          this.set(data);
      }
      decode(buf, off, ex, gex) {
        if (!off)
          off = 0;
        if (!buf || !(buf.length >= off + 512))
          throw new Error("need 512 bytes for header");
        this.path = decString(buf, off, 100);
        this.mode = decNumber(buf, off + 100, 8);
        this.uid = decNumber(buf, off + 108, 8);
        this.gid = decNumber(buf, off + 116, 8);
        this.size = decNumber(buf, off + 124, 12);
        this.mtime = decDate(buf, off + 136, 12);
        this.cksum = decNumber(buf, off + 148, 12);
        this[SLURP](ex);
        this[SLURP](gex, true);
        this[TYPE] = decString(buf, off + 156, 1);
        if (this[TYPE] === "")
          this[TYPE] = "0";
        if (this[TYPE] === "0" && this.path.substr(-1) === "/")
          this[TYPE] = "5";
        if (this[TYPE] === "5")
          this.size = 0;
        this.linkpath = decString(buf, off + 157, 100);
        if (buf.slice(off + 257, off + 265).toString() === "ustar\x0000") {
          this.uname = decString(buf, off + 265, 32);
          this.gname = decString(buf, off + 297, 32);
          this.devmaj = decNumber(buf, off + 329, 8);
          this.devmin = decNumber(buf, off + 337, 8);
          if (buf[off + 475] !== 0) {
            const prefix = decString(buf, off + 345, 155);
            this.path = prefix + "/" + this.path;
          } else {
            const prefix = decString(buf, off + 345, 130);
            if (prefix)
              this.path = prefix + "/" + this.path;
            this.atime = decDate(buf, off + 476, 12);
            this.ctime = decDate(buf, off + 488, 12);
          }
        }
        let sum = 8 * 32;
        for (let i = off; i < off + 148; i++)
          sum += buf[i];
        for (let i = off + 156; i < off + 512; i++)
          sum += buf[i];
        this.cksumValid = sum === this.cksum;
        if (this.cksum === null && sum === 8 * 32)
          this.nullBlock = true;
      }
      [SLURP](ex, global2) {
        for (const k in ex) {
          if (ex[k] !== null && ex[k] !== void 0 && !(global2 && k === "path"))
            this[k] = ex[k];
        }
      }
      encode(buf, off) {
        if (!buf) {
          buf = this.block = Buffer.alloc(512);
          off = 0;
        }
        if (!off)
          off = 0;
        if (!(buf.length >= off + 512))
          throw new Error("need 512 bytes for header");
        const prefixSize = this.ctime || this.atime ? 130 : 155;
        const split = splitPrefix(this.path || "", prefixSize);
        const path41 = split[0];
        const prefix = split[1];
        this.needPax = split[2];
        this.needPax = encString(buf, off, 100, path41) || this.needPax;
        this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax;
        this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax;
        this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax;
        this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax;
        this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax;
        buf[off + 156] = this[TYPE].charCodeAt(0);
        this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax;
        buf.write("ustar\x0000", off + 257, 8);
        this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax;
        this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax;
        this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax;
        this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax;
        this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax;
        if (buf[off + 475] !== 0)
          this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax;
        else {
          this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax;
          this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax;
          this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax;
        }
        let sum = 8 * 32;
        for (let i = off; i < off + 148; i++)
          sum += buf[i];
        for (let i = off + 156; i < off + 512; i++)
          sum += buf[i];
        this.cksum = sum;
        encNumber(buf, off + 148, 8, this.cksum);
        this.cksumValid = true;
        return this.needPax;
      }
      set(data) {
        for (const i in data) {
          if (data[i] !== null && data[i] !== void 0)
            this[i] = data[i];
        }
      }
      get type() {
        return types.name.get(this[TYPE]) || this[TYPE];
      }
      get typeKey() {
        return this[TYPE];
      }
      set type(type) {
        if (types.code.has(type))
          this[TYPE] = types.code.get(type);
        else
          this[TYPE] = type;
      }
    };
    var splitPrefix = (p, prefixSize) => {
      const pathSize = 100;
      let pp = p;
      let prefix = "";
      let ret;
      const root = pathModule.parse(p).root || ".";
      if (Buffer.byteLength(pp) < pathSize)
        ret = [pp, prefix, false];
      else {
        prefix = pathModule.dirname(pp);
        pp = pathModule.basename(pp);
        do {
          if (Buffer.byteLength(pp) <= pathSize && Buffer.byteLength(prefix) <= prefixSize)
            ret = [pp, prefix, false];
          else if (Buffer.byteLength(pp) > pathSize && Buffer.byteLength(prefix) <= prefixSize)
            ret = [pp.substr(0, pathSize - 1), prefix, true];
          else {
            pp = pathModule.join(pathModule.basename(prefix), pp);
            prefix = pathModule.dirname(prefix);
          }
        } while (prefix !== root && !ret);
        if (!ret)
          ret = [p.substr(0, pathSize - 1), "", true];
      }
      return ret;
    };
    var decString = (buf, off, size) => buf.slice(off, off + size).toString("utf8").replace(/\0.*/, "");
    var decDate = (buf, off, size) => numToDate(decNumber(buf, off, size));
    var numToDate = (num) => num === null ? null : new Date(num * 1e3);
    var decNumber = (buf, off, size) => buf[off] & 128 ? large.parse(buf.slice(off, off + size)) : decSmallNumber(buf, off, size);
    var nanNull = (value) => isNaN(value) ? null : value;
    var decSmallNumber = (buf, off, size) => nanNull(parseInt(buf.slice(off, off + size).toString("utf8").replace(/\0.*$/, "").trim(), 8));
    var MAXNUM = {
      12: 8589934591,
      8: 2097151
    };
    var encNumber = (buf, off, size, number2) => number2 === null ? false : number2 > MAXNUM[size] || number2 < 0 ? (large.encode(number2, buf.slice(off, off + size)), true) : (encSmallNumber(buf, off, size, number2), false);
    var encSmallNumber = (buf, off, size, number2) => buf.write(octalString(number2, size), off, size, "ascii");
    var octalString = (number2, size) => padOctal(Math.floor(number2).toString(8), size);
    var padOctal = (string2, size) => (string2.length === size - 1 ? string2 : new Array(size - string2.length - 1).join("0") + string2 + " ") + "\0";
    var encDate = (buf, off, size, date) => date === null ? false : encNumber(buf, off, size, date.getTime() / 1e3);
    var NULLS = new Array(156).join("\0");
    var encString = (buf, off, size, string2) => string2 === null ? false : (buf.write(string2 + NULLS, off, size, "utf8"), string2.length !== Buffer.byteLength(string2) || string2.length > size);
    module2.exports = Header;
  }
});

// node_modules/tar/lib/pax.js
var require_pax = __commonJS({
  "node_modules/tar/lib/pax.js"(exports, module2) {
    "use strict";
    var Header = require_header();
    var path41 = require("path");
    var Pax = class {
      constructor(obj, global2) {
        this.atime = obj.atime || null;
        this.charset = obj.charset || null;
        this.comment = obj.comment || null;
        this.ctime = obj.ctime || null;
        this.gid = obj.gid || null;
        this.gname = obj.gname || null;
        this.linkpath = obj.linkpath || null;
        this.mtime = obj.mtime || null;
        this.path = obj.path || null;
        this.size = obj.size || null;
        this.uid = obj.uid || null;
        this.uname = obj.uname || null;
        this.dev = obj.dev || null;
        this.ino = obj.ino || null;
        this.nlink = obj.nlink || null;
        this.global = global2 || false;
      }
      encode() {
        const body = this.encodeBody();
        if (body === "")
          return null;
        const bodyLen = Buffer.byteLength(body);
        const bufLen = 512 * Math.ceil(1 + bodyLen / 512);
        const buf = Buffer.allocUnsafe(bufLen);
        for (let i = 0; i < 512; i++)
          buf[i] = 0;
        new Header({
          path: ("PaxHeader/" + path41.basename(this.path)).slice(0, 99),
          mode: this.mode || 420,
          uid: this.uid || null,
          gid: this.gid || null,
          size: bodyLen,
          mtime: this.mtime || null,
          type: this.global ? "GlobalExtendedHeader" : "ExtendedHeader",
          linkpath: "",
          uname: this.uname || "",
          gname: this.gname || "",
          devmaj: 0,
          devmin: 0,
          atime: this.atime || null,
          ctime: this.ctime || null
        }).encode(buf);
        buf.write(body, 512, bodyLen, "utf8");
        for (let i = bodyLen + 512; i < buf.length; i++)
          buf[i] = 0;
        return buf;
      }
      encodeBody() {
        return this.encodeField("path") + this.encodeField("ctime") + this.encodeField("atime") + this.encodeField("dev") + this.encodeField("ino") + this.encodeField("nlink") + this.encodeField("charset") + this.encodeField("comment") + this.encodeField("gid") + this.encodeField("gname") + this.encodeField("linkpath") + this.encodeField("mtime") + this.encodeField("size") + this.encodeField("uid") + this.encodeField("uname");
      }
      encodeField(field) {
        if (this[field] === null || this[field] === void 0)
          return "";
        const v = this[field] instanceof Date ? this[field].getTime() / 1e3 : this[field];
        const s = " " + (field === "dev" || field === "ino" || field === "nlink" ? "SCHILY." : "") + field + "=" + v + "\n";
        const byteLen = Buffer.byteLength(s);
        let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1;
        if (byteLen + digits >= Math.pow(10, digits))
          digits += 1;
        const len = digits + byteLen;
        return len + s;
      }
    };
    Pax.parse = (string2, ex, g) => new Pax(merge2(parseKV(string2), ex), g);
    var merge2 = (a, b) => b ? Object.keys(a).reduce((s, k) => (s[k] = a[k], s), b) : a;
    var parseKV = (string2) => string2.replace(/\n$/, "").split("\n").reduce(parseKVLine, /* @__PURE__ */ Object.create(null));
    var parseKVLine = (set, line) => {
      const n = parseInt(line, 10);
      if (n !== Buffer.byteLength(line) + 1)
        return set;
      line = line.substr((n + " ").length);
      const kv = line.split("=");
      const k = kv.shift().replace(/^SCHILY\.(dev|ino|nlink)/, "$1");
      if (!k)
        return set;
      const v = kv.join("=");
      set[k] = /^([A-Z]+\.)?([mac]|birth|creation)time$/.test(k) ? new Date(v * 1e3) : /^[0-9]+$/.test(v) ? +v : v;
      return set;
    };
    module2.exports = Pax;
  }
});

// node_modules/tar/lib/strip-trailing-slashes.js
var require_strip_trailing_slashes = __commonJS({
  "node_modules/tar/lib/strip-trailing-slashes.js"(exports, module2) {
    module2.exports = (str) => {
      let i = str.length - 1;
      let slashesStart = -1;
      while (i > -1 && str.charAt(i) === "/") {
        slashesStart = i;
        i--;
      }
      return slashesStart === -1 ? str : str.slice(0, slashesStart);
    };
  }
});

// node_modules/tar/lib/warn-mixin.js
var require_warn_mixin = __commonJS({
  "node_modules/tar/lib/warn-mixin.js"(exports, module2) {
    "use strict";
    module2.exports = (Base) => class extends Base {
      warn(code, message, data = {}) {
        if (this.file)
          data.file = this.file;
        if (this.cwd)
          data.cwd = this.cwd;
        data.code = message instanceof Error && message.code || code;
        data.tarCode = code;
        if (!this.strict && data.recoverable !== false) {
          if (message instanceof Error) {
            data = Object.assign(message, data);
            message = message.message;
          }
          this.emit("warn", data.tarCode, message, data);
        } else if (message instanceof Error)
          this.emit("error", Object.assign(message, data));
        else
          this.emit("error", Object.assign(new Error(`${code}: ${message}`), data));
      }
    };
  }
});

// node_modules/tar/lib/winchars.js
var require_winchars = __commonJS({
  "node_modules/tar/lib/winchars.js"(exports, module2) {
    "use strict";
    var raw = [
      "|",
      "<",
      ">",
      "?",
      ":"
    ];
    var win = raw.map((char) => String.fromCharCode(61440 + char.charCodeAt(0)));
    var toWin = new Map(raw.map((char, i) => [char, win[i]]));
    var toRaw = new Map(win.map((char, i) => [char, raw[i]]));
    module2.exports = {
      encode: (s) => raw.reduce((s2, c) => s2.split(c).join(toWin.get(c)), s),
      decode: (s) => win.reduce((s2, c) => s2.split(c).join(toRaw.get(c)), s)
    };
  }
});

// node_modules/tar/lib/strip-absolute-path.js
var require_strip_absolute_path = __commonJS({
  "node_modules/tar/lib/strip-absolute-path.js"(exports, module2) {
    var { isAbsolute, parse: parse4 } = require("path").win32;
    module2.exports = (path41) => {
      let r = "";
      let parsed = parse4(path41);
      while (isAbsolute(path41) || parsed.root) {
        const root = path41.charAt(0) === "/" && path41.slice(0, 4) !== "//?/" ? "/" : parsed.root;
        path41 = path41.substr(root.length);
        r += root;
        parsed = parse4(path41);
      }
      return [r, path41];
    };
  }
});

// node_modules/tar/lib/mode-fix.js
var require_mode_fix = __commonJS({
  "node_modules/tar/lib/mode-fix.js"(exports, module2) {
    "use strict";
    module2.exports = (mode, isDir, portable) => {
      mode &= 4095;
      if (portable)
        mode = (mode | 384) & ~18;
      if (isDir) {
        if (mode & 256)
          mode |= 64;
        if (mode & 32)
          mode |= 8;
        if (mode & 4)
          mode |= 1;
      }
      return mode;
    };
  }
});

// node_modules/tar/lib/write-entry.js
var require_write_entry = __commonJS({
  "node_modules/tar/lib/write-entry.js"(exports, module2) {
    "use strict";
    var MiniPass = require_minipass();
    var Pax = require_pax();
    var Header = require_header();
    var fs29 = require("fs");
    var path41 = require("path");
    var normPath = require_normalize_windows_path();
    var stripSlash = require_strip_trailing_slashes();
    var prefixPath = (path42, prefix) => {
      if (!prefix)
        return normPath(path42);
      path42 = normPath(path42).replace(/^\.(\/|$)/, "");
      return stripSlash(prefix) + "/" + path42;
    };
    var maxReadSize = 16 * 1024 * 1024;
    var PROCESS = Symbol("process");
    var FILE = Symbol("file");
    var DIRECTORY = Symbol("directory");
    var SYMLINK = Symbol("symlink");
    var HARDLINK = Symbol("hardlink");
    var HEADER = Symbol("header");
    var READ = Symbol("read");
    var LSTAT = Symbol("lstat");
    var ONLSTAT = Symbol("onlstat");
    var ONREAD = Symbol("onread");
    var ONREADLINK = Symbol("onreadlink");
    var OPENFILE = Symbol("openfile");
    var ONOPENFILE = Symbol("onopenfile");
    var CLOSE = Symbol("close");
    var MODE = Symbol("mode");
    var AWAITDRAIN = Symbol("awaitDrain");
    var ONDRAIN = Symbol("ondrain");
    var PREFIX = Symbol("prefix");
    var HAD_ERROR = Symbol("hadError");
    var warner = require_warn_mixin();
    var winchars = require_winchars();
    var stripAbsolutePath = require_strip_absolute_path();
    var modeFix = require_mode_fix();
    var WriteEntry = warner(class WriteEntry extends MiniPass {
      constructor(p, opt) {
        opt = opt || {};
        super(opt);
        if (typeof p !== "string")
          throw new TypeError("path is required");
        this.path = normPath(p);
        this.portable = !!opt.portable;
        this.myuid = process.getuid && process.getuid() || 0;
        this.myuser = process.env.USER || "";
        this.maxReadSize = opt.maxReadSize || maxReadSize;
        this.linkCache = opt.linkCache || /* @__PURE__ */ new Map();
        this.statCache = opt.statCache || /* @__PURE__ */ new Map();
        this.preservePaths = !!opt.preservePaths;
        this.cwd = normPath(opt.cwd || process.cwd());
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.noMtime = !!opt.noMtime;
        this.mtime = opt.mtime || null;
        this.prefix = opt.prefix ? normPath(opt.prefix) : null;
        this.fd = null;
        this.blockLen = null;
        this.blockRemain = null;
        this.buf = null;
        this.offset = null;
        this.length = null;
        this.pos = null;
        this.remain = null;
        if (typeof opt.onwarn === "function")
          this.on("warn", opt.onwarn);
        let pathWarn = false;
        if (!this.preservePaths) {
          const [root, stripped] = stripAbsolutePath(this.path);
          if (root) {
            this.path = stripped;
            pathWarn = root;
          }
        }
        this.win32 = !!opt.win32 || process.platform === "win32";
        if (this.win32) {
          this.path = winchars.decode(this.path.replace(/\\/g, "/"));
          p = p.replace(/\\/g, "/");
        }
        this.absolute = normPath(opt.absolute || path41.resolve(this.cwd, p));
        if (this.path === "")
          this.path = "./";
        if (pathWarn) {
          this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
            entry: this,
            path: pathWarn + this.path
          });
        }
        if (this.statCache.has(this.absolute))
          this[ONLSTAT](this.statCache.get(this.absolute));
        else
          this[LSTAT]();
      }
      emit(ev, ...data) {
        if (ev === "error")
          this[HAD_ERROR] = true;
        return super.emit(ev, ...data);
      }
      [LSTAT]() {
        fs29.lstat(this.absolute, (er, stat) => {
          if (er)
            return this.emit("error", er);
          this[ONLSTAT](stat);
        });
      }
      [ONLSTAT](stat) {
        this.statCache.set(this.absolute, stat);
        this.stat = stat;
        if (!stat.isFile())
          stat.size = 0;
        this.type = getType(stat);
        this.emit("stat", stat);
        this[PROCESS]();
      }
      [PROCESS]() {
        switch (this.type) {
          case "File":
            return this[FILE]();
          case "Directory":
            return this[DIRECTORY]();
          case "SymbolicLink":
            return this[SYMLINK]();
          default:
            return this.end();
        }
      }
      [MODE](mode) {
        return modeFix(mode, this.type === "Directory", this.portable);
      }
      [PREFIX](path42) {
        return prefixPath(path42, this.prefix);
      }
      [HEADER]() {
        if (this.type === "Directory" && this.portable)
          this.noMtime = true;
        this.header = new Header({
          path: this[PREFIX](this.path),
          linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
          mode: this[MODE](this.stat.mode),
          uid: this.portable ? null : this.stat.uid,
          gid: this.portable ? null : this.stat.gid,
          size: this.stat.size,
          mtime: this.noMtime ? null : this.mtime || this.stat.mtime,
          type: this.type,
          uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : "",
          atime: this.portable ? null : this.stat.atime,
          ctime: this.portable ? null : this.stat.ctime
        });
        if (this.header.encode() && !this.noPax) {
          super.write(new Pax({
            atime: this.portable ? null : this.header.atime,
            ctime: this.portable ? null : this.header.ctime,
            gid: this.portable ? null : this.header.gid,
            mtime: this.noMtime ? null : this.mtime || this.header.mtime,
            path: this[PREFIX](this.path),
            linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
            size: this.header.size,
            uid: this.portable ? null : this.header.uid,
            uname: this.portable ? null : this.header.uname,
            dev: this.portable ? null : this.stat.dev,
            ino: this.portable ? null : this.stat.ino,
            nlink: this.portable ? null : this.stat.nlink
          }).encode());
        }
        super.write(this.header.block);
      }
      [DIRECTORY]() {
        if (this.path.substr(-1) !== "/")
          this.path += "/";
        this.stat.size = 0;
        this[HEADER]();
        this.end();
      }
      [SYMLINK]() {
        fs29.readlink(this.absolute, (er, linkpath) => {
          if (er)
            return this.emit("error", er);
          this[ONREADLINK](linkpath);
        });
      }
      [ONREADLINK](linkpath) {
        this.linkpath = normPath(linkpath);
        this[HEADER]();
        this.end();
      }
      [HARDLINK](linkpath) {
        this.type = "Link";
        this.linkpath = normPath(path41.relative(this.cwd, linkpath));
        this.stat.size = 0;
        this[HEADER]();
        this.end();
      }
      [FILE]() {
        if (this.stat.nlink > 1) {
          const linkKey = this.stat.dev + ":" + this.stat.ino;
          if (this.linkCache.has(linkKey)) {
            const linkpath = this.linkCache.get(linkKey);
            if (linkpath.indexOf(this.cwd) === 0)
              return this[HARDLINK](linkpath);
          }
          this.linkCache.set(linkKey, this.absolute);
        }
        this[HEADER]();
        if (this.stat.size === 0)
          return this.end();
        this[OPENFILE]();
      }
      [OPENFILE]() {
        fs29.open(this.absolute, "r", (er, fd) => {
          if (er)
            return this.emit("error", er);
          this[ONOPENFILE](fd);
        });
      }
      [ONOPENFILE](fd) {
        this.fd = fd;
        if (this[HAD_ERROR])
          return this[CLOSE]();
        this.blockLen = 512 * Math.ceil(this.stat.size / 512);
        this.blockRemain = this.blockLen;
        const bufLen = Math.min(this.blockLen, this.maxReadSize);
        this.buf = Buffer.allocUnsafe(bufLen);
        this.offset = 0;
        this.pos = 0;
        this.remain = this.stat.size;
        this.length = this.buf.length;
        this[READ]();
      }
      [READ]() {
        const { fd, buf, offset, length, pos } = this;
        fs29.read(fd, buf, offset, length, pos, (er, bytesRead) => {
          if (er) {
            return this[CLOSE](() => this.emit("error", er));
          }
          this[ONREAD](bytesRead);
        });
      }
      [CLOSE](cb) {
        fs29.close(this.fd, cb);
      }
      [ONREAD](bytesRead) {
        if (bytesRead <= 0 && this.remain > 0) {
          const er = new Error("encountered unexpected EOF");
          er.path = this.absolute;
          er.syscall = "read";
          er.code = "EOF";
          return this[CLOSE](() => this.emit("error", er));
        }
        if (bytesRead > this.remain) {
          const er = new Error("did not encounter expected EOF");
          er.path = this.absolute;
          er.syscall = "read";
          er.code = "EOF";
          return this[CLOSE](() => this.emit("error", er));
        }
        if (bytesRead === this.remain) {
          for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {
            this.buf[i + this.offset] = 0;
            bytesRead++;
            this.remain++;
          }
        }
        const writeBuf = this.offset === 0 && bytesRead === this.buf.length ? this.buf : this.buf.slice(this.offset, this.offset + bytesRead);
        const flushed = this.write(writeBuf);
        if (!flushed)
          this[AWAITDRAIN](() => this[ONDRAIN]());
        else
          this[ONDRAIN]();
      }
      [AWAITDRAIN](cb) {
        this.once("drain", cb);
      }
      write(writeBuf) {
        if (this.blockRemain < writeBuf.length) {
          const er = new Error("writing more data than expected");
          er.path = this.absolute;
          return this.emit("error", er);
        }
        this.remain -= writeBuf.length;
        this.blockRemain -= writeBuf.length;
        this.pos += writeBuf.length;
        this.offset += writeBuf.length;
        return super.write(writeBuf);
      }
      [ONDRAIN]() {
        if (!this.remain) {
          if (this.blockRemain)
            super.write(Buffer.alloc(this.blockRemain));
          return this[CLOSE]((er) => er ? this.emit("error", er) : this.end());
        }
        if (this.offset >= this.length) {
          this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length));
          this.offset = 0;
        }
        this.length = this.buf.length - this.offset;
        this[READ]();
      }
    });
    var WriteEntrySync = class extends WriteEntry {
      [LSTAT]() {
        this[ONLSTAT](fs29.lstatSync(this.absolute));
      }
      [SYMLINK]() {
        this[ONREADLINK](fs29.readlinkSync(this.absolute));
      }
      [OPENFILE]() {
        this[ONOPENFILE](fs29.openSync(this.absolute, "r"));
      }
      [READ]() {
        let threw = true;
        try {
          const { fd, buf, offset, length, pos } = this;
          const bytesRead = fs29.readSync(fd, buf, offset, length, pos);
          this[ONREAD](bytesRead);
          threw = false;
        } finally {
          if (threw) {
            try {
              this[CLOSE](() => {
              });
            } catch (er) {
            }
          }
        }
      }
      [AWAITDRAIN](cb) {
        cb();
      }
      [CLOSE](cb) {
        fs29.closeSync(this.fd);
        cb();
      }
    };
    var WriteEntryTar = warner(class WriteEntryTar extends MiniPass {
      constructor(readEntry, opt) {
        opt = opt || {};
        super(opt);
        this.preservePaths = !!opt.preservePaths;
        this.portable = !!opt.portable;
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.noMtime = !!opt.noMtime;
        this.readEntry = readEntry;
        this.type = readEntry.type;
        if (this.type === "Directory" && this.portable)
          this.noMtime = true;
        this.prefix = opt.prefix || null;
        this.path = normPath(readEntry.path);
        this.mode = this[MODE](readEntry.mode);
        this.uid = this.portable ? null : readEntry.uid;
        this.gid = this.portable ? null : readEntry.gid;
        this.uname = this.portable ? null : readEntry.uname;
        this.gname = this.portable ? null : readEntry.gname;
        this.size = readEntry.size;
        this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime;
        this.atime = this.portable ? null : readEntry.atime;
        this.ctime = this.portable ? null : readEntry.ctime;
        this.linkpath = normPath(readEntry.linkpath);
        if (typeof opt.onwarn === "function")
          this.on("warn", opt.onwarn);
        let pathWarn = false;
        if (!this.preservePaths) {
          const [root, stripped] = stripAbsolutePath(this.path);
          if (root) {
            this.path = stripped;
            pathWarn = root;
          }
        }
        this.remain = readEntry.size;
        this.blockRemain = readEntry.startBlockSize;
        this.header = new Header({
          path: this[PREFIX](this.path),
          linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
          mode: this.mode,
          uid: this.portable ? null : this.uid,
          gid: this.portable ? null : this.gid,
          size: this.size,
          mtime: this.noMtime ? null : this.mtime,
          type: this.type,
          uname: this.portable ? null : this.uname,
          atime: this.portable ? null : this.atime,
          ctime: this.portable ? null : this.ctime
        });
        if (pathWarn) {
          this.warn("TAR_ENTRY_INFO", `stripping ${pathWarn} from absolute path`, {
            entry: this,
            path: pathWarn + this.path
          });
        }
        if (this.header.encode() && !this.noPax) {
          super.write(new Pax({
            atime: this.portable ? null : this.atime,
            ctime: this.portable ? null : this.ctime,
            gid: this.portable ? null : this.gid,
            mtime: this.noMtime ? null : this.mtime,
            path: this[PREFIX](this.path),
            linkpath: this.type === "Link" ? this[PREFIX](this.linkpath) : this.linkpath,
            size: this.size,
            uid: this.portable ? null : this.uid,
            uname: this.portable ? null : this.uname,
            dev: this.portable ? null : this.readEntry.dev,
            ino: this.portable ? null : this.readEntry.ino,
            nlink: this.portable ? null : this.readEntry.nlink
          }).encode());
        }
        super.write(this.header.block);
        readEntry.pipe(this);
      }
      [PREFIX](path42) {
        return prefixPath(path42, this.prefix);
      }
      [MODE](mode) {
        return modeFix(mode, this.type === "Directory", this.portable);
      }
      write(data) {
        const writeLen = data.length;
        if (writeLen > this.blockRemain)
          throw new Error("writing more to entry than is appropriate");
        this.blockRemain -= writeLen;
        return super.write(data);
      }
      end() {
        if (this.blockRemain)
          super.write(Buffer.alloc(this.blockRemain));
        return super.end();
      }
    });
    WriteEntry.Sync = WriteEntrySync;
    WriteEntry.Tar = WriteEntryTar;
    var getType = (stat) => stat.isFile() ? "File" : stat.isDirectory() ? "Directory" : stat.isSymbolicLink() ? "SymbolicLink" : "Unsupported";
    module2.exports = WriteEntry;
  }
});

// node_modules/tar/lib/pack.js
var require_pack = __commonJS({
  "node_modules/tar/lib/pack.js"(exports, module2) {
    "use strict";
    var PackJob = class {
      constructor(path42, absolute) {
        this.path = path42 || "./";
        this.absolute = absolute;
        this.entry = null;
        this.stat = null;
        this.readdir = null;
        this.pending = false;
        this.ignore = false;
        this.piped = false;
      }
    };
    var MiniPass = require_minipass();
    var zlib = require_minizlib();
    var ReadEntry = require_read_entry();
    var WriteEntry = require_write_entry();
    var WriteEntrySync = WriteEntry.Sync;
    var WriteEntryTar = WriteEntry.Tar;
    var Yallist = require_yallist();
    var EOF = Buffer.alloc(1024);
    var ONSTAT = Symbol("onStat");
    var ENDED = Symbol("ended");
    var QUEUE = Symbol("queue");
    var CURRENT = Symbol("current");
    var PROCESS = Symbol("process");
    var PROCESSING = Symbol("processing");
    var PROCESSJOB = Symbol("processJob");
    var JOBS = Symbol("jobs");
    var JOBDONE = Symbol("jobDone");
    var ADDFSENTRY = Symbol("addFSEntry");
    var ADDTARENTRY = Symbol("addTarEntry");
    var STAT = Symbol("stat");
    var READDIR = Symbol("readdir");
    var ONREADDIR = Symbol("onreaddir");
    var PIPE = Symbol("pipe");
    var ENTRY = Symbol("entry");
    var ENTRYOPT = Symbol("entryOpt");
    var WRITEENTRYCLASS = Symbol("writeEntryClass");
    var WRITE = Symbol("write");
    var ONDRAIN = Symbol("ondrain");
    var fs29 = require("fs");
    var path41 = require("path");
    var warner = require_warn_mixin();
    var normPath = require_normalize_windows_path();
    var Pack = warner(class Pack extends MiniPass {
      constructor(opt) {
        super(opt);
        opt = opt || /* @__PURE__ */ Object.create(null);
        this.opt = opt;
        this.file = opt.file || "";
        this.cwd = opt.cwd || process.cwd();
        this.maxReadSize = opt.maxReadSize;
        this.preservePaths = !!opt.preservePaths;
        this.strict = !!opt.strict;
        this.noPax = !!opt.noPax;
        this.prefix = normPath(opt.prefix || "");
        this.linkCache = opt.linkCache || /* @__PURE__ */ new Map();
        this.statCache = opt.statCache || /* @__PURE__ */ new Map();
        this.readdirCache = opt.readdirCache || /* @__PURE__ */ new Map();
        this[WRITEENTRYCLASS] = WriteEntry;
        if (typeof opt.onwarn === "function")
          this.on("warn", opt.onwarn);
        this.portable = !!opt.portable;
        this.zip = null;
        if (opt.gzip) {
          if (typeof opt.gzip !== "object")
            opt.gzip = {};
          if (this.portable)
            opt.gzip.portable = true;
          this.zip = new zlib.Gzip(opt.gzip);
          this.zip.on("data", (chunk) => super.write(chunk));
          this.zip.on("end", (_) => super.end());
          this.zip.on("drain", (_) => this[ONDRAIN]());
          this.on("resume", (_) => this.zip.resume());
        } else
          this.on("drain", this[ONDRAIN]);
        this.noDirRecurse = !!opt.noDirRecurse;
        this.follow = !!opt.follow;
        this.noMtime = !!opt.noMtime;
        this.mtime = opt.mtime || null;
        this.filter = typeof opt.filter === "function" ? opt.filter : (_) => true;
        this[QUEUE] = new Yallist();
        this[JOBS] = 0;
        this.jobs = +opt.jobs || 4;
        this[PROCESSING] = false;
        this[ENDED] = false;
      }
      [WRITE](chunk) {
        return super.write(chunk);
      }
      add(path42) {
        this.write(path42);
        return this;
      }
      end(path42) {
        if (path42)
          this.write(path42);
        this[ENDED] = true;
        this[PROCESS]();
        return this;
      }
      write(path42) {
        if (this[ENDED])
          throw new Error("write after end");
        if (path42 instanceof ReadEntry)
          this[ADDTARENTRY](path42);
        else
          this[ADDFSENTRY](path42);
        return this.flowing;
      }
      [ADDTARENTRY](p) {
        const absolute = normPath(path41.resolve(this.cwd, p.path));
        if (!this.filter(p.path, p))
          p.resume();
        else {
          const job = new PackJob(p.path, absolute, false);
          job.entry = new WriteEntryTar(p, this[ENTRYOPT](job));
          job.entry.on("end", (_) => this[JOBDONE](job));
          this[JOBS] += 1;
          this[QUEUE].push(job);
        }
        this[PROCESS]();
      }
      [ADDFSENTRY](p) {
        const absolute = normPath(path41.resolve(this.cwd, p));
        this[QUEUE].push(new PackJob(p, absolute));
        this[PROCESS]();
      }
      [STAT](job) {
        job.pending = true;
        this[JOBS] += 1;
        const stat = this.follow ? "stat" : "lstat";
        fs29[stat](job.absolute, (er, stat2) => {
          job.pending = false;
          this[JOBS] -= 1;
          if (er)
            this.emit("error", er);
          else
            this[ONSTAT](job, stat2);
        });
      }
      [ONSTAT](job, stat) {
        this.statCache.set(job.absolute, stat);
        job.stat = stat;
        if (!this.filter(job.path, stat))
          job.ignore = true;
        this[PROCESS]();
      }
      [READDIR](job) {
        job.pending = true;
        this[JOBS] += 1;
        fs29.readdir(job.absolute, (er, entries) => {
          job.pending = false;
          this[JOBS] -= 1;
          if (er)
            return this.emit("error", er);
          this[ONREADDIR](job, entries);
        });
      }
      [ONREADDIR](job, entries) {
        this.readdirCache.set(job.absolute, entries);
        job.readdir = entries;
        this[PROCESS]();
      }
      [PROCESS]() {
        if (this[PROCESSING])
          return;
        this[PROCESSING] = true;
        for (let w = this[QUEUE].head; w !== null && this[JOBS] < this.jobs; w = w.next) {
          this[PROCESSJOB](w.value);
          if (w.value.ignore) {
            const p = w.next;
            this[QUEUE].removeNode(w);
            w.next = p;
          }
        }
        this[PROCESSING] = false;
        if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {
          if (this.zip)
            this.zip.end(EOF);
          else {
            super.write(EOF);
            super.end();
          }
        }
      }
      get [CURRENT]() {
        return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value;
      }
      [JOBDONE](job) {
        this[QUEUE].shift();
        this[JOBS] -= 1;
        this[PROCESS]();
      }
      [PROCESSJOB](job) {
        if (job.pending)
          return;
        if (job.entry) {
          if (job === this[CURRENT] && !job.piped)
            this[PIPE](job);
          return;
        }
        if (!job.stat) {
          if (this.statCache.has(job.absolute))
            this[ONSTAT](job, this.statCache.get(job.absolute));
          else
            this[STAT](job);
        }
        if (!job.stat)
          return;
        if (job.ignore)
          return;
        if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {
          if (this.readdirCache.has(job.absolute))
            this[ONREADDIR](job, this.readdirCache.get(job.absolute));
          else
            this[READDIR](job);
          if (!job.readdir)
            return;
        }
        job.entry = this[ENTRY](job);
        if (!job.entry) {
          job.ignore = true;
          return;
        }
        if (job === this[CURRENT] && !job.piped)
          this[PIPE](job);
      }
      [ENTRYOPT](job) {
        return {
          onwarn: (code, msg, data) => this.warn(code, msg, data),
          noPax: this.noPax,
          cwd: this.cwd,
          absolute: job.absolute,
          preservePaths: this.preservePaths,
          maxReadSize: this.maxReadSize,
          strict: this.strict,
          portable: this.portable,
          linkCache: this.linkCache,
          statCache: this.statCache,
          noMtime: this.noMtime,
          mtime: this.mtime,
          prefix: this.prefix
        };
      }
      [ENTRY](job) {
        this[JOBS] += 1;
        try {
          return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job)).on("end", () => this[JOBDONE](job)).on("error", (er) => this.emit("error", er));
        } catch (er) {
          this.emit("error", er);
        }
      }
      [ONDRAIN]() {
        if (this[CURRENT] && this[CURRENT].entry)
          this[CURRENT].entry.resume();
      }
      [PIPE](job) {
        job.piped = true;
        if (job.readdir) {
          job.readdir.forEach((entry) => {
            const p = job.path;
            const base = p === "./" ? "" : p.replace(/\/*$/, "/");
            this[ADDFSENTRY](base + entry);
          });
        }
        const source = job.entry;
        const zip = this.zip;
        if (zip) {
          source.on("data", (chunk) => {
            if (!zip.write(chunk))
              source.pause();
          });
        } else {
          source.on("data", (chunk) => {
            if (!super.write(chunk))
              source.pause();
          });
        }
      }
      pause() {
        if (this.zip)
          this.zip.pause();
        return super.pause();
      }
    });
    var PackSync = class extends Pack {
      constructor(opt) {
        super(opt);
        this[WRITEENTRYCLASS] = WriteEntrySync;
      }
      pause() {
      }
      resume() {
      }
      [STAT](job) {
        const stat = this.follow ? "statSync" : "lstatSync";
        this[ONSTAT](job, fs29[stat](job.absolute));
      }
      [READDIR](job, stat) {
        this[ONREADDIR](job, fs29.readdirSync(job.absolute));
      }
      [PIPE](job) {
        const source = job.entry;
        const zip = this.zip;
        if (job.readdir) {
          job.readdir.forEach((entry) => {
            const p = job.path;
            const base = p === "./" ? "" : p.replace(/\/*$/, "/");
            this[ADDFSENTRY](base + entry);
          });
        }
        if (zip) {
          source.on("data", (chunk) => {
            zip.write(chunk);
          });
        } else {
          source.on("data", (chunk) => {
            super[WRITE](chunk);
          });
        }
      }
    };
    Pack.Sync = PackSync;
    module2.exports = Pack;
  }
});

// node_modules/fs-minipass/index.js
var require_fs_minipass = __commonJS({
  "node_modules/fs-minipass/index.js"(exports) {
    "use strict";
    var MiniPass = require_minipass();
    var EE = require("events").EventEmitter;
    var fs29 = require("fs");
    var writev = fs29.writev;
    if (!writev) {
      const binding = process.binding("fs");
      const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback;
      writev = (fd, iovec, pos, cb) => {
        const done = (er, bw) => cb(er, bw, iovec);
        const req = new FSReqWrap();
        req.oncomplete = done;
        binding.writeBuffers(fd, iovec, pos, req);
      };
    }
    var _autoClose = Symbol("_autoClose");
    var _close = Symbol("_close");
    var _ended = Symbol("_ended");
    var _fd = Symbol("_fd");
    var _finished = Symbol("_finished");
    var _flags = Symbol("_flags");
    var _flush = Symbol("_flush");
    var _handleChunk = Symbol("_handleChunk");
    var _makeBuf = Symbol("_makeBuf");
    var _mode = Symbol("_mode");
    var _needDrain = Symbol("_needDrain");
    var _onerror = Symbol("_onerror");
    var _onopen = Symbol("_onopen");
    var _onread = Symbol("_onread");
    var _onwrite = Symbol("_onwrite");
    var _open = Symbol("_open");
    var _path = Symbol("_path");
    var _pos = Symbol("_pos");
    var _queue = Symbol("_queue");
    var _read = Symbol("_read");
    var _readSize = Symbol("_readSize");
    var _reading = Symbol("_reading");
    var _remain = Symbol("_remain");
    var _size = Symbol("_size");
    var _write = Symbol("_write");
    var _writing = Symbol("_writing");
    var _defaultFlag = Symbol("_defaultFlag");
    var _errored = Symbol("_errored");
    var ReadStream = class extends MiniPass {
      constructor(path41, opt) {
        opt = opt || {};
        super(opt);
        this.readable = true;
        this.writable = false;
        if (typeof path41 !== "string")
          throw new TypeError("path must be a string");
        this[_errored] = false;
        this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
        this[_path] = path41;
        this[_readSize] = opt.readSize || 16 * 1024 * 1024;
        this[_reading] = false;
        this[_size] = typeof opt.size === "number" ? opt.size : Infinity;
        this[_remain] = this[_size];
        this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
        if (typeof this[_fd] === "number")
          this[_read]();
        else
          this[_open]();
      }
      get fd() {
        return this[_fd];
      }
      get path() {
        return this[_path];
      }
      write() {
        throw new TypeError("this is a readable stream");
      }
      end() {
        throw new TypeError("this is a readable stream");
      }
      [_open]() {
        fs29.open(this[_path], "r", (er, fd) => this[_onopen](er, fd));
      }
      [_onopen](er, fd) {
        if (er)
          this[_onerror](er);
        else {
          this[_fd] = fd;
          this.emit("open", fd);
          this[_read]();
        }
      }
      [_makeBuf]() {
        return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));
      }
      [_read]() {
        if (!this[_reading]) {
          this[_reading] = true;
          const buf = this[_makeBuf]();
          if (buf.length === 0)
            return process.nextTick(() => this[_onread](null, 0, buf));
          fs29.read(this[_fd], buf, 0, buf.length, null, (er, br, buf2) => this[_onread](er, br, buf2));
        }
      }
      [_onread](er, br, buf) {
        this[_reading] = false;
        if (er)
          this[_onerror](er);
        else if (this[_handleChunk](br, buf))
          this[_read]();
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs29.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
        }
      }
      [_onerror](er) {
        this[_reading] = true;
        this[_close]();
        this.emit("error", er);
      }
      [_handleChunk](br, buf) {
        let ret = false;
        this[_remain] -= br;
        if (br > 0)
          ret = super.write(br < buf.length ? buf.slice(0, br) : buf);
        if (br === 0 || this[_remain] <= 0) {
          ret = false;
          this[_close]();
          super.end();
        }
        return ret;
      }
      emit(ev, data) {
        switch (ev) {
          case "prefinish":
          case "finish":
            break;
          case "drain":
            if (typeof this[_fd] === "number")
              this[_read]();
            break;
          case "error":
            if (this[_errored])
              return;
            this[_errored] = true;
            return super.emit(ev, data);
          default:
            return super.emit(ev, data);
        }
      }
    };
    var ReadStreamSync = class extends ReadStream {
      [_open]() {
        let threw = true;
        try {
          this[_onopen](null, fs29.openSync(this[_path], "r"));
          threw = false;
        } finally {
          if (threw)
            this[_close]();
        }
      }
      [_read]() {
        let threw = true;
        try {
          if (!this[_reading]) {
            this[_reading] = true;
            do {
              const buf = this[_makeBuf]();
              const br = buf.length === 0 ? 0 : fs29.readSync(this[_fd], buf, 0, buf.length, null);
              if (!this[_handleChunk](br, buf))
                break;
            } while (true);
            this[_reading] = false;
          }
          threw = false;
        } finally {
          if (threw)
            this[_close]();
        }
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs29.closeSync(fd);
          this.emit("close");
        }
      }
    };
    var WriteStream = class extends EE {
      constructor(path41, opt) {
        opt = opt || {};
        super(opt);
        this.readable = false;
        this.writable = true;
        this[_errored] = false;
        this[_writing] = false;
        this[_ended] = false;
        this[_needDrain] = false;
        this[_queue] = [];
        this[_path] = path41;
        this[_fd] = typeof opt.fd === "number" ? opt.fd : null;
        this[_mode] = opt.mode === void 0 ? 438 : opt.mode;
        this[_pos] = typeof opt.start === "number" ? opt.start : null;
        this[_autoClose] = typeof opt.autoClose === "boolean" ? opt.autoClose : true;
        const defaultFlag = this[_pos] !== null ? "r+" : "w";
        this[_defaultFlag] = opt.flags === void 0;
        this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags;
        if (this[_fd] === null)
          this[_open]();
      }
      emit(ev, data) {
        if (ev === "error") {
          if (this[_errored])
            return;
          this[_errored] = true;
        }
        return super.emit(ev, data);
      }
      get fd() {
        return this[_fd];
      }
      get path() {
        return this[_path];
      }
      [_onerror](er) {
        this[_close]();
        this[_writing] = true;
        this.emit("error", er);
      }
      [_open]() {
        fs29.open(this[_path], this[_flags], this[_mode], (er, fd) => this[_onopen](er, fd));
      }
      [_onopen](er, fd) {
        if (this[_defaultFlag] && this[_flags] === "r+" && er && er.code === "ENOENT") {
          this[_flags] = "w";
          this[_open]();
        } else if (er)
          this[_onerror](er);
        else {
          this[_fd] = fd;
          this.emit("open", fd);
          this[_flush]();
        }
      }
      end(buf, enc) {
        if (buf)
          this.write(buf, enc);
        this[_ended] = true;
        if (!this[_writing] && !this[_queue].length && typeof this[_fd] === "number")
          this[_onwrite](null, 0);
        return this;
      }
      write(buf, enc) {
        if (typeof buf === "string")
          buf = Buffer.from(buf, enc);
        if (this[_ended]) {
          this.emit("error", new Error("write() after end()"));
          return false;
        }
        if (this[_fd] === null || this[_writing] || this[_queue].length) {
          this[_queue].push(buf);
          this[_needDrain] = true;
          return false;
        }
        this[_writing] = true;
        this[_write](buf);
        return true;
      }
      [_write](buf) {
        fs29.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));
      }
      [_onwrite](er, bw) {
        if (er)
          this[_onerror](er);
        else {
          if (this[_pos] !== null)
            this[_pos] += bw;
          if (this[_queue].length)
            this[_flush]();
          else {
            this[_writing] = false;
            if (this[_ended] && !this[_finished]) {
              this[_finished] = true;
              this[_close]();
              this.emit("finish");
            } else if (this[_needDrain]) {
              this[_needDrain] = false;
              this.emit("drain");
            }
          }
        }
      }
      [_flush]() {
        if (this[_queue].length === 0) {
          if (this[_ended])
            this[_onwrite](null, 0);
        } else if (this[_queue].length === 1)
          this[_write](this[_queue].pop());
        else {
          const iovec = this[_queue];
          this[_queue] = [];
          writev(this[_fd], iovec, this[_pos], (er, bw) => this[_onwrite](er, bw));
        }
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs29.close(fd, (er) => er ? this.emit("error", er) : this.emit("close"));
        }
      }
    };
    var WriteStreamSync = class extends WriteStream {
      [_open]() {
        let fd;
        if (this[_defaultFlag] && this[_flags] === "r+") {
          try {
            fd = fs29.openSync(this[_path], this[_flags], this[_mode]);
          } catch (er) {
            if (er.code === "ENOENT") {
              this[_flags] = "w";
              return this[_open]();
            } else
              throw er;
          }
        } else
          fd = fs29.openSync(this[_path], this[_flags], this[_mode]);
        this[_onopen](null, fd);
      }
      [_close]() {
        if (this[_autoClose] && typeof this[_fd] === "number") {
          const fd = this[_fd];
          this[_fd] = null;
          fs29.closeSync(fd);
          this.emit("close");
        }
      }
      [_write](buf) {
        let threw = true;
        try {
          this[_onwrite](null, fs29.writeSync(this[_fd], buf, 0, buf.length, this[_pos]));
          threw = false;
        } finally {
          if (threw)
            try {
              this[_close]();
            } catch (_) {
            }
        }
      }
    };
    exports.ReadStream = ReadStream;
    exports.ReadStreamSync = ReadStreamSync;
    exports.WriteStream = WriteStream;
    exports.WriteStreamSync = WriteStreamSync;
  }
});

// node_modules/tar/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/tar/lib/parse.js"(exports, module2) {
    "use strict";
    var warner = require_warn_mixin();
    var Header = require_header();
    var EE = require("events");
    var Yallist = require_yallist();
    var maxMetaEntrySize = 1024 * 1024;
    var Entry = require_read_entry();
    var Pax = require_pax();
    var zlib = require_minizlib();
    var gzipHeader = Buffer.from([31, 139]);
    var STATE = Symbol("state");
    var WRITEENTRY = Symbol("writeEntry");
    var READENTRY = Symbol("readEntry");
    var NEXTENTRY = Symbol("nextEntry");
    var PROCESSENTRY = Symbol("processEntry");
    var EX = Symbol("extendedHeader");
    var GEX = Symbol("globalExtendedHeader");
    var META = Symbol("meta");
    var EMITMETA = Symbol("emitMeta");
    var BUFFER = Symbol("buffer");
    var QUEUE = Symbol("queue");
    var ENDED = Symbol("ended");
    var EMITTEDEND = Symbol("emittedEnd");
    var EMIT = Symbol("emit");
    var UNZIP = Symbol("unzip");
    var CONSUMECHUNK = Symbol("consumeChunk");
    var CONSUMECHUNKSUB = Symbol("consumeChunkSub");
    var CONSUMEBODY = Symbol("consumeBody");
    var CONSUMEMETA = Symbol("consumeMeta");
    var CONSUMEHEADER = Symbol("consumeHeader");
    var CONSUMING = Symbol("consuming");
    var BUFFERCONCAT = Symbol("bufferConcat");
    var MAYBEEND = Symbol("maybeEnd");
    var WRITING = Symbol("writing");
    var ABORTED = Symbol("aborted");
    var DONE = Symbol("onDone");
    var SAW_VALID_ENTRY = Symbol("sawValidEntry");
    var SAW_NULL_BLOCK = Symbol("sawNullBlock");
    var SAW_EOF = Symbol("sawEOF");
    var noop = (_) => true;
    module2.exports = warner(class Parser extends EE {
      constructor(opt) {
        opt = opt || {};
        super(opt);
        this.file = opt.file || "";
        this[SAW_VALID_ENTRY] = null;
        this.on(DONE, (_) => {
          if (this[STATE] === "begin" || this[SAW_VALID_ENTRY] === false) {
            this.warn("TAR_BAD_ARCHIVE", "Unrecognized archive format");
          }
        });
        if (opt.ondone)
          this.on(DONE, opt.ondone);
        else {
          this.on(DONE, (_) => {
            this.emit("prefinish");
            this.emit("finish");
            this.emit("end");
            this.emit("close");
          });
        }
        this.strict = !!opt.strict;
        this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize;
        this.filter = typeof opt.filter === "function" ? opt.filter : noop;
        this.writable = true;
        this.readable = false;
        this[QUEUE] = new Yallist();
        this[BUFFER] = null;
        this[READENTRY] = null;
        this[WRITEENTRY] = null;
        this[STATE] = "begin";
        this[META] = "";
        this[EX] = null;
        this[GEX] = null;
        this[ENDED] = false;
        this[UNZIP] = null;
        this[ABORTED] = false;
        this[SAW_NULL_BLOCK] = false;
        this[SAW_EOF] = false;
        if (typeof opt.onwarn === "function")
          this.on("warn", opt.onwarn);
        if (typeof opt.onentry === "function")
          this.on("entry", opt.onentry);
      }
      [CONSUMEHEADER](chunk, position) {
        if (this[SAW_VALID_ENTRY] === null)
          this[SAW_VALID_ENTRY] = false;
        let header;
        try {
          header = new Header(chunk, position, this[EX], this[GEX]);
        } catch (er) {
          return this.warn("TAR_ENTRY_INVALID", er);
        }
        if (header.nullBlock) {
          if (this[SAW_NULL_BLOCK]) {
            this[SAW_EOF] = true;
            if (this[STATE] === "begin")
              this[STATE] = "header";
            this[EMIT]("eof");
          } else {
            this[SAW_NULL_BLOCK] = true;
            this[EMIT]("nullBlock");
          }
        } else {
          this[SAW_NULL_BLOCK] = false;
          if (!header.cksumValid)
            this.warn("TAR_ENTRY_INVALID", "checksum failure", { header });
          else if (!header.path)
            this.warn("TAR_ENTRY_INVALID", "path is required", { header });
          else {
            const type = header.type;
            if (/^(Symbolic)?Link$/.test(type) && !header.linkpath)
              this.warn("TAR_ENTRY_INVALID", "linkpath required", { header });
            else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath)
              this.warn("TAR_ENTRY_INVALID", "linkpath forbidden", { header });
            else {
              const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX]);
              if (!this[SAW_VALID_ENTRY]) {
                if (entry.remain) {
                  const onend = () => {
                    if (!entry.invalid)
                      this[SAW_VALID_ENTRY] = true;
                  };
                  entry.on("end", onend);
                } else
                  this[SAW_VALID_ENTRY] = true;
              }
              if (entry.meta) {
                if (entry.size > this.maxMetaEntrySize) {
                  entry.ignore = true;
                  this[EMIT]("ignoredEntry", entry);
                  this[STATE] = "ignore";
                  entry.resume();
                } else if (entry.size > 0) {
                  this[META] = "";
                  entry.on("data", (c) => this[META] += c);
                  this[STATE] = "meta";
                }
              } else {
                this[EX] = null;
                entry.ignore = entry.ignore || !this.filter(entry.path, entry);
                if (entry.ignore) {
                  this[EMIT]("ignoredEntry", entry);
                  this[STATE] = entry.remain ? "ignore" : "header";
                  entry.resume();
                } else {
                  if (entry.remain)
                    this[STATE] = "body";
                  else {
                    this[STATE] = "header";
                    entry.end();
                  }
                  if (!this[READENTRY]) {
                    this[QUEUE].push(entry);
                    this[NEXTENTRY]();
                  } else
                    this[QUEUE].push(entry);
                }
              }
            }
          }
        }
      }
      [PROCESSENTRY](entry) {
        let go = true;
        if (!entry) {
          this[READENTRY] = null;
          go = false;
        } else if (Array.isArray(entry))
          this.emit.apply(this, entry);
        else {
          this[READENTRY] = entry;
          this.emit("entry", entry);
          if (!entry.emittedEnd) {
            entry.on("end", (_) => this[NEXTENTRY]());
            go = false;
          }
        }
        return go;
      }
      [NEXTENTRY]() {
        do {
        } while (this[PROCESSENTRY](this[QUEUE].shift()));
        if (!this[QUEUE].length) {
          const re = this[READENTRY];
          const drainNow = !re || re.flowing || re.size === re.remain;
          if (drainNow) {
            if (!this[WRITING])
              this.emit("drain");
          } else
            re.once("drain", (_) => this.emit("drain"));
        }
      }
      [CONSUMEBODY](chunk, position) {
        const entry = this[WRITEENTRY];
        const br = entry.blockRemain;
        const c = br >= chunk.length && position === 0 ? chunk : chunk.slice(position, position + br);
        entry.write(c);
        if (!entry.blockRemain) {
          this[STATE] = "header";
          this[WRITEENTRY] = null;
          entry.end();
        }
        return c.length;
      }
      [CONSUMEMETA](chunk, position) {
        const entry = this[WRITEENTRY];
        const ret = this[CONSUMEBODY](chunk, position);
        if (!this[WRITEENTRY])
          this[EMITMETA](entry);
        return ret;
      }
      [EMIT](ev, data, extra) {
        if (!this[QUEUE].length && !this[READENTRY])
          this.emit(ev, data, extra);
        else
          this[QUEUE].push([ev, data, extra]);
      }
      [EMITMETA](entry) {
        this[EMIT]("meta", this[META]);
        switch (entry.type) {
          case "ExtendedHeader":
          case "OldExtendedHeader":
            this[EX] = Pax.parse(this[META], this[EX], false);
            break;
          case "GlobalExtendedHeader":
            this[GEX] = Pax.parse(this[META], this[GEX], true);
            break;
          case "NextFileHasLongPath":
          case "OldGnuLongPath":
            this[EX] = this[EX] || /* @__PURE__ */ Object.create(null);
            this[EX].path = this[META].replace(/\0.*/, "");
            break;
          case "NextFileHasLongLinkpath":
            this[EX] = this[EX] || /* @__PURE__ */ Object.create(null);
            this[EX].linkpath = this[META].replace(/\0.*/, "");
            break;
          default:
            throw new Error("unknown meta: " + entry.type);
        }
      }
      abort(error) {
        this[ABORTED] = true;
        this.emit("abort", error);
        this.warn("TAR_ABORT", error, { recoverable: false });
      }
      write(chunk) {
        if (this[ABORTED])
          return;
        if (this[UNZIP] === null && chunk) {
          if (this[BUFFER]) {
            chunk = Buffer.concat([this[BUFFER], chunk]);
            this[BUFFER] = null;
          }
          if (chunk.length < gzipHeader.length) {
            this[BUFFER] = chunk;
            return true;
          }
          for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {
            if (chunk[i] !== gzipHeader[i])
              this[UNZIP] = false;
          }
          if (this[UNZIP] === null) {
            const ended = this[ENDED];
            this[ENDED] = false;
            this[UNZIP] = new zlib.Unzip();
            this[UNZIP].on("data", (chunk2) => this[CONSUMECHUNK](chunk2));
            this[UNZIP].on("error", (er) => this.abort(er));
            this[UNZIP].on("end", (_) => {
              this[ENDED] = true;
              this[CONSUMECHUNK]();
            });
            this[WRITING] = true;
            const ret2 = this[UNZIP][ended ? "end" : "write"](chunk);
            this[WRITING] = false;
            return ret2;
          }
        }
        this[WRITING] = true;
        if (this[UNZIP])
          this[UNZIP].write(chunk);
        else
          this[CONSUMECHUNK](chunk);
        this[WRITING] = false;
        const ret = this[QUEUE].length ? false : this[READENTRY] ? this[READENTRY].flowing : true;
        if (!ret && !this[QUEUE].length)
          this[READENTRY].once("drain", (_) => this.emit("drain"));
        return ret;
      }
      [BUFFERCONCAT](c) {
        if (c && !this[ABORTED])
          this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c;
      }
      [MAYBEEND]() {
        if (this[ENDED] && !this[EMITTEDEND] && !this[ABORTED] && !this[CONSUMING]) {
          this[EMITTEDEND] = true;
          const entry = this[WRITEENTRY];
          if (entry && entry.blockRemain) {
            const have = this[BUFFER] ? this[BUFFER].length : 0;
            this.warn("TAR_BAD_ARCHIVE", `Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`, { entry });
            if (this[BUFFER])
              entry.write(this[BUFFER]);
            entry.end();
          }
          this[EMIT](DONE);
        }
      }
      [CONSUMECHUNK](chunk) {
        if (this[CONSUMING])
          this[BUFFERCONCAT](chunk);
        else if (!chunk && !this[BUFFER])
          this[MAYBEEND]();
        else {
          this[CONSUMING] = true;
          if (this[BUFFER]) {
            this[BUFFERCONCAT](chunk);
            const c = this[BUFFER];
            this[BUFFER] = null;
            this[CONSUMECHUNKSUB](c);
          } else
            this[CONSUMECHUNKSUB](chunk);
          while (this[BUFFER] && this[BUFFER].length >= 512 && !this[ABORTED] && !this[SAW_EOF]) {
            const c = this[BUFFER];
            this[BUFFER] = null;
            this[CONSUMECHUNKSUB](c);
          }
          this[CONSUMING] = false;
        }
        if (!this[BUFFER] || this[ENDED])
          this[MAYBEEND]();
      }
      [CONSUMECHUNKSUB](chunk) {
        let position = 0;
        const length = chunk.length;
        while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {
          switch (this[STATE]) {
            case "begin":
            case "header":
              this[CONSUMEHEADER](chunk, position);
              position += 512;
              break;
            case "ignore":
            case "body":
              position += this[CONSUMEBODY](chunk, position);
              break;
            case "meta":
              position += this[CONSUMEMETA](chunk, position);
              break;
            default:
              throw new Error("invalid state: " + this[STATE]);
          }
        }
        if (position < length) {
          if (this[BUFFER])
            this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]]);
          else
            this[BUFFER] = chunk.slice(position);
        }
      }
      end(chunk) {
        if (!this[ABORTED]) {
          if (this[UNZIP])
            this[UNZIP].end(chunk);
          else {
            this[ENDED] = true;
            this.write(chunk);
          }
        }
      }
    });
  }
});

// node_modules/tar/lib/list.js
var require_list = __commonJS({
  "node_modules/tar/lib/list.js"(exports, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Parser2 = require_parse2();
    var fs29 = require("fs");
    var fsm = require_fs_minipass();
    var path41 = require("path");
    var stripSlash = require_strip_trailing_slashes();
    module2.exports = (opt_, files, cb) => {
      if (typeof opt_ === "function")
        cb = opt_, files = null, opt_ = {};
      else if (Array.isArray(opt_))
        files = opt_, opt_ = {};
      if (typeof files === "function")
        cb = files, files = null;
      if (!files)
        files = [];
      else
        files = Array.from(files);
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function")
        throw new TypeError("callback not supported for sync tar functions");
      if (!opt.file && typeof cb === "function")
        throw new TypeError("callback only supported with file option");
      if (files.length)
        filesFilter(opt, files);
      if (!opt.noResume)
        onentryFunction(opt);
      return opt.file && opt.sync ? listFileSync(opt) : opt.file ? listFile(opt, cb) : list2(opt);
    };
    var onentryFunction = (opt) => {
      const onentry = opt.onentry;
      opt.onentry = onentry ? (e) => {
        onentry(e);
        e.resume();
      } : (e) => e.resume();
    };
    var filesFilter = (opt, files) => {
      const map = new Map(files.map((f) => [stripSlash(f), true]));
      const filter2 = opt.filter;
      const mapHas = (file, r) => {
        const root = r || path41.parse(file).root || ".";
        const ret = file === root ? false : map.has(file) ? map.get(file) : mapHas(path41.dirname(file), root);
        map.set(file, ret);
        return ret;
      };
      opt.filter = filter2 ? (file, entry) => filter2(file, entry) && mapHas(stripSlash(file)) : (file) => mapHas(stripSlash(file));
    };
    var listFileSync = (opt) => {
      const p = list2(opt);
      const file = opt.file;
      let threw = true;
      let fd;
      try {
        const stat = fs29.statSync(file);
        const readSize = opt.maxReadSize || 16 * 1024 * 1024;
        if (stat.size < readSize)
          p.end(fs29.readFileSync(file));
        else {
          let pos = 0;
          const buf = Buffer.allocUnsafe(readSize);
          fd = fs29.openSync(file, "r");
          while (pos < stat.size) {
            const bytesRead = fs29.readSync(fd, buf, 0, readSize, pos);
            pos += bytesRead;
            p.write(buf.slice(0, bytesRead));
          }
          p.end();
        }
        threw = false;
      } finally {
        if (threw && fd) {
          try {
            fs29.closeSync(fd);
          } catch (er) {
          }
        }
      }
    };
    var listFile = (opt, cb) => {
      const parse4 = new Parser2(opt);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const file = opt.file;
      const p = new Promise((resolve3, reject) => {
        parse4.on("error", reject);
        parse4.on("end", resolve3);
        fs29.stat(file, (er, stat) => {
          if (er)
            reject(er);
          else {
            const stream = new fsm.ReadStream(file, {
              readSize,
              size: stat.size
            });
            stream.on("error", reject);
            stream.pipe(parse4);
          }
        });
      });
      return cb ? p.then(cb, cb) : p;
    };
    var list2 = (opt) => new Parser2(opt);
  }
});

// node_modules/tar/lib/create.js
var require_create = __commonJS({
  "node_modules/tar/lib/create.js"(exports, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Pack = require_pack();
    var fsm = require_fs_minipass();
    var t = require_list();
    var path41 = require("path");
    module2.exports = (opt_, files, cb) => {
      if (typeof files === "function")
        cb = files;
      if (Array.isArray(opt_))
        files = opt_, opt_ = {};
      if (!files || !Array.isArray(files) || !files.length)
        throw new TypeError("no files or directories specified");
      files = Array.from(files);
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function")
        throw new TypeError("callback not supported for sync tar functions");
      if (!opt.file && typeof cb === "function")
        throw new TypeError("callback only supported with file option");
      return opt.file && opt.sync ? createFileSync(opt, files) : opt.file ? createFile(opt, files, cb) : opt.sync ? createSync(opt, files) : create(opt, files);
    };
    var createFileSync = (opt, files) => {
      const p = new Pack.Sync(opt);
      const stream = new fsm.WriteStreamSync(opt.file, {
        mode: opt.mode || 438
      });
      p.pipe(stream);
      addFilesSync(p, files);
    };
    var createFile = (opt, files, cb) => {
      const p = new Pack(opt);
      const stream = new fsm.WriteStream(opt.file, {
        mode: opt.mode || 438
      });
      p.pipe(stream);
      const promise = new Promise((res, rej) => {
        stream.on("error", rej);
        stream.on("close", res);
        p.on("error", rej);
      });
      addFilesAsync(p, files);
      return cb ? promise.then(cb, cb) : promise;
    };
    var addFilesSync = (p, files) => {
      files.forEach((file) => {
        if (file.charAt(0) === "@") {
          t({
            file: path41.resolve(p.cwd, file.substr(1)),
            sync: true,
            noResume: true,
            onentry: (entry) => p.add(entry)
          });
        } else
          p.add(file);
      });
      p.end();
    };
    var addFilesAsync = (p, files) => {
      while (files.length) {
        const file = files.shift();
        if (file.charAt(0) === "@") {
          return t({
            file: path41.resolve(p.cwd, file.substr(1)),
            noResume: true,
            onentry: (entry) => p.add(entry)
          }).then((_) => addFilesAsync(p, files));
        } else
          p.add(file);
      }
      p.end();
    };
    var createSync = (opt, files) => {
      const p = new Pack.Sync(opt);
      addFilesSync(p, files);
      return p;
    };
    var create = (opt, files) => {
      const p = new Pack(opt);
      addFilesAsync(p, files);
      return p;
    };
  }
});

// node_modules/tar/lib/replace.js
var require_replace = __commonJS({
  "node_modules/tar/lib/replace.js"(exports, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Pack = require_pack();
    var fs29 = require("fs");
    var fsm = require_fs_minipass();
    var t = require_list();
    var path41 = require("path");
    var Header = require_header();
    module2.exports = (opt_, files, cb) => {
      const opt = hlo(opt_);
      if (!opt.file)
        throw new TypeError("file is required");
      if (opt.gzip)
        throw new TypeError("cannot append to compressed archives");
      if (!files || !Array.isArray(files) || !files.length)
        throw new TypeError("no files or directories specified");
      files = Array.from(files);
      return opt.sync ? replaceSync(opt, files) : replace(opt, files, cb);
    };
    var replaceSync = (opt, files) => {
      const p = new Pack.Sync(opt);
      let threw = true;
      let fd;
      let position;
      try {
        try {
          fd = fs29.openSync(opt.file, "r+");
        } catch (er) {
          if (er.code === "ENOENT")
            fd = fs29.openSync(opt.file, "w+");
          else
            throw er;
        }
        const st = fs29.fstatSync(fd);
        const headBuf = Buffer.alloc(512);
        POSITION:
          for (position = 0; position < st.size; position += 512) {
            for (let bufPos = 0, bytes2 = 0; bufPos < 512; bufPos += bytes2) {
              bytes2 = fs29.readSync(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos);
              if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139)
                throw new Error("cannot append to compressed archives");
              if (!bytes2)
                break POSITION;
            }
            const h = new Header(headBuf);
            if (!h.cksumValid)
              break;
            const entryBlockSize = 512 * Math.ceil(h.size / 512);
            if (position + entryBlockSize + 512 > st.size)
              break;
            position += entryBlockSize;
            if (opt.mtimeCache)
              opt.mtimeCache.set(h.path, h.mtime);
          }
        threw = false;
        streamSync(opt, p, position, fd, files);
      } finally {
        if (threw) {
          try {
            fs29.closeSync(fd);
          } catch (er) {
          }
        }
      }
    };
    var streamSync = (opt, p, position, fd, files) => {
      const stream = new fsm.WriteStreamSync(opt.file, {
        fd,
        start: position
      });
      p.pipe(stream);
      addFilesSync(p, files);
    };
    var replace = (opt, files, cb) => {
      files = Array.from(files);
      const p = new Pack(opt);
      const getPos = (fd, size, cb_) => {
        const cb2 = (er, pos) => {
          if (er)
            fs29.close(fd, (_) => cb_(er));
          else
            cb_(null, pos);
        };
        let position = 0;
        if (size === 0)
          return cb2(null, 0);
        let bufPos = 0;
        const headBuf = Buffer.alloc(512);
        const onread = (er, bytes2) => {
          if (er)
            return cb2(er);
          bufPos += bytes2;
          if (bufPos < 512 && bytes2) {
            return fs29.read(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos, onread);
          }
          if (position === 0 && headBuf[0] === 31 && headBuf[1] === 139)
            return cb2(new Error("cannot append to compressed archives"));
          if (bufPos < 512)
            return cb2(null, position);
          const h = new Header(headBuf);
          if (!h.cksumValid)
            return cb2(null, position);
          const entryBlockSize = 512 * Math.ceil(h.size / 512);
          if (position + entryBlockSize + 512 > size)
            return cb2(null, position);
          position += entryBlockSize + 512;
          if (position >= size)
            return cb2(null, position);
          if (opt.mtimeCache)
            opt.mtimeCache.set(h.path, h.mtime);
          bufPos = 0;
          fs29.read(fd, headBuf, 0, 512, position, onread);
        };
        fs29.read(fd, headBuf, 0, 512, position, onread);
      };
      const promise = new Promise((resolve3, reject) => {
        p.on("error", reject);
        let flag = "r+";
        const onopen = (er, fd) => {
          if (er && er.code === "ENOENT" && flag === "r+") {
            flag = "w+";
            return fs29.open(opt.file, flag, onopen);
          }
          if (er)
            return reject(er);
          fs29.fstat(fd, (er2, st) => {
            if (er2)
              return fs29.close(fd, () => reject(er2));
            getPos(fd, st.size, (er3, position) => {
              if (er3)
                return reject(er3);
              const stream = new fsm.WriteStream(opt.file, {
                fd,
                start: position
              });
              p.pipe(stream);
              stream.on("error", reject);
              stream.on("close", resolve3);
              addFilesAsync(p, files);
            });
          });
        };
        fs29.open(opt.file, flag, onopen);
      });
      return cb ? promise.then(cb, cb) : promise;
    };
    var addFilesSync = (p, files) => {
      files.forEach((file) => {
        if (file.charAt(0) === "@") {
          t({
            file: path41.resolve(p.cwd, file.substr(1)),
            sync: true,
            noResume: true,
            onentry: (entry) => p.add(entry)
          });
        } else
          p.add(file);
      });
      p.end();
    };
    var addFilesAsync = (p, files) => {
      while (files.length) {
        const file = files.shift();
        if (file.charAt(0) === "@") {
          return t({
            file: path41.resolve(p.cwd, file.substr(1)),
            noResume: true,
            onentry: (entry) => p.add(entry)
          }).then((_) => addFilesAsync(p, files));
        } else
          p.add(file);
      }
      p.end();
    };
  }
});

// node_modules/tar/lib/update.js
var require_update = __commonJS({
  "node_modules/tar/lib/update.js"(exports, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var r = require_replace();
    module2.exports = (opt_, files, cb) => {
      const opt = hlo(opt_);
      if (!opt.file)
        throw new TypeError("file is required");
      if (opt.gzip)
        throw new TypeError("cannot append to compressed archives");
      if (!files || !Array.isArray(files) || !files.length)
        throw new TypeError("no files or directories specified");
      files = Array.from(files);
      mtimeFilter(opt);
      return r(opt, files, cb);
    };
    var mtimeFilter = (opt) => {
      const filter2 = opt.filter;
      if (!opt.mtimeCache)
        opt.mtimeCache = /* @__PURE__ */ new Map();
      opt.filter = filter2 ? (path41, stat) => filter2(path41, stat) && !(opt.mtimeCache.get(path41) > stat.mtime) : (path41, stat) => !(opt.mtimeCache.get(path41) > stat.mtime);
    };
  }
});

// node_modules/tar/node_modules/mkdirp/lib/opts-arg.js
var require_opts_arg = __commonJS({
  "node_modules/tar/node_modules/mkdirp/lib/opts-arg.js"(exports, module2) {
    var { promisify: promisify3 } = require("util");
    var fs29 = require("fs");
    var optsArg = (opts) => {
      if (!opts)
        opts = { mode: 511, fs: fs29 };
      else if (typeof opts === "object")
        opts = __spreadValues({ mode: 511, fs: fs29 }, opts);
      else if (typeof opts === "number")
        opts = { mode: opts, fs: fs29 };
      else if (typeof opts === "string")
        opts = { mode: parseInt(opts, 8), fs: fs29 };
      else
        throw new TypeError("invalid options argument");
      opts.mkdir = opts.mkdir || opts.fs.mkdir || fs29.mkdir;
      opts.mkdirAsync = promisify3(opts.mkdir);
      opts.stat = opts.stat || opts.fs.stat || fs29.stat;
      opts.statAsync = promisify3(opts.stat);
      opts.statSync = opts.statSync || opts.fs.statSync || fs29.statSync;
      opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs29.mkdirSync;
      return opts;
    };
    module2.exports = optsArg;
  }
});

// node_modules/tar/node_modules/mkdirp/lib/path-arg.js
var require_path_arg = __commonJS({
  "node_modules/tar/node_modules/mkdirp/lib/path-arg.js"(exports, module2) {
    var platform2 = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform;
    var { resolve: resolve3, parse: parse4 } = require("path");
    var pathArg = (path41) => {
      if (/\0/.test(path41)) {
        throw Object.assign(new TypeError("path must be a string without null bytes"), {
          path: path41,
          code: "ERR_INVALID_ARG_VALUE"
        });
      }
      path41 = resolve3(path41);
      if (platform2 === "win32") {
        const badWinChars = /[*|"<>?:]/;
        const { root } = parse4(path41);
        if (badWinChars.test(path41.substr(root.length))) {
          throw Object.assign(new Error("Illegal characters in path."), {
            path: path41,
            code: "EINVAL"
          });
        }
      }
      return path41;
    };
    module2.exports = pathArg;
  }
});

// node_modules/tar/node_modules/mkdirp/lib/find-made.js
var require_find_made = __commonJS({
  "node_modules/tar/node_modules/mkdirp/lib/find-made.js"(exports, module2) {
    var { dirname: dirname3 } = require("path");
    var findMade = (opts, parent, path41 = void 0) => {
      if (path41 === parent)
        return Promise.resolve();
      return opts.statAsync(parent).then((st) => st.isDirectory() ? path41 : void 0, (er) => er.code === "ENOENT" ? findMade(opts, dirname3(parent), parent) : void 0);
    };
    var findMadeSync = (opts, parent, path41 = void 0) => {
      if (path41 === parent)
        return void 0;
      try {
        return opts.statSync(parent).isDirectory() ? path41 : void 0;
      } catch (er) {
        return er.code === "ENOENT" ? findMadeSync(opts, dirname3(parent), parent) : void 0;
      }
    };
    module2.exports = { findMade, findMadeSync };
  }
});

// node_modules/tar/node_modules/mkdirp/lib/mkdirp-manual.js
var require_mkdirp_manual = __commonJS({
  "node_modules/tar/node_modules/mkdirp/lib/mkdirp-manual.js"(exports, module2) {
    var { dirname: dirname3 } = require("path");
    var mkdirpManual = (path41, opts, made) => {
      opts.recursive = false;
      const parent = dirname3(path41);
      if (parent === path41) {
        return opts.mkdirAsync(path41, opts).catch((er) => {
          if (er.code !== "EISDIR")
            throw er;
        });
      }
      return opts.mkdirAsync(path41, opts).then(() => made || path41, (er) => {
        if (er.code === "ENOENT")
          return mkdirpManual(parent, opts).then((made2) => mkdirpManual(path41, opts, made2));
        if (er.code !== "EEXIST" && er.code !== "EROFS")
          throw er;
        return opts.statAsync(path41).then((st) => {
          if (st.isDirectory())
            return made;
          else
            throw er;
        }, () => {
          throw er;
        });
      });
    };
    var mkdirpManualSync = (path41, opts, made) => {
      const parent = dirname3(path41);
      opts.recursive = false;
      if (parent === path41) {
        try {
          return opts.mkdirSync(path41, opts);
        } catch (er) {
          if (er.code !== "EISDIR")
            throw er;
          else
            return;
        }
      }
      try {
        opts.mkdirSync(path41, opts);
        return made || path41;
      } catch (er) {
        if (er.code === "ENOENT")
          return mkdirpManualSync(path41, opts, mkdirpManualSync(parent, opts, made));
        if (er.code !== "EEXIST" && er.code !== "EROFS")
          throw er;
        try {
          if (!opts.statSync(path41).isDirectory())
            throw er;
        } catch (_) {
          throw er;
        }
      }
    };
    module2.exports = { mkdirpManual, mkdirpManualSync };
  }
});

// node_modules/tar/node_modules/mkdirp/lib/mkdirp-native.js
var require_mkdirp_native = __commonJS({
  "node_modules/tar/node_modules/mkdirp/lib/mkdirp-native.js"(exports, module2) {
    var { dirname: dirname3 } = require("path");
    var { findMade, findMadeSync } = require_find_made();
    var { mkdirpManual, mkdirpManualSync } = require_mkdirp_manual();
    var mkdirpNative = (path41, opts) => {
      opts.recursive = true;
      const parent = dirname3(path41);
      if (parent === path41)
        return opts.mkdirAsync(path41, opts);
      return findMade(opts, path41).then((made) => opts.mkdirAsync(path41, opts).then(() => made).catch((er) => {
        if (er.code === "ENOENT")
          return mkdirpManual(path41, opts);
        else
          throw er;
      }));
    };
    var mkdirpNativeSync = (path41, opts) => {
      opts.recursive = true;
      const parent = dirname3(path41);
      if (parent === path41)
        return opts.mkdirSync(path41, opts);
      const made = findMadeSync(opts, path41);
      try {
        opts.mkdirSync(path41, opts);
        return made;
      } catch (er) {
        if (er.code === "ENOENT")
          return mkdirpManualSync(path41, opts);
        else
          throw er;
      }
    };
    module2.exports = { mkdirpNative, mkdirpNativeSync };
  }
});

// node_modules/tar/node_modules/mkdirp/lib/use-native.js
var require_use_native = __commonJS({
  "node_modules/tar/node_modules/mkdirp/lib/use-native.js"(exports, module2) {
    var fs29 = require("fs");
    var version2 = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version;
    var versArr = version2.replace(/^v/, "").split(".");
    var hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12;
    var useNative = !hasNative ? () => false : (opts) => opts.mkdir === fs29.mkdir;
    var useNativeSync = !hasNative ? () => false : (opts) => opts.mkdirSync === fs29.mkdirSync;
    module2.exports = { useNative, useNativeSync };
  }
});

// node_modules/tar/node_modules/mkdirp/index.js
var require_mkdirp = __commonJS({
  "node_modules/tar/node_modules/mkdirp/index.js"(exports, module2) {
    var optsArg = require_opts_arg();
    var pathArg = require_path_arg();
    var { mkdirpNative, mkdirpNativeSync } = require_mkdirp_native();
    var { mkdirpManual, mkdirpManualSync } = require_mkdirp_manual();
    var { useNative, useNativeSync } = require_use_native();
    var mkdirp = (path41, opts) => {
      path41 = pathArg(path41);
      opts = optsArg(opts);
      return useNative(opts) ? mkdirpNative(path41, opts) : mkdirpManual(path41, opts);
    };
    var mkdirpSync = (path41, opts) => {
      path41 = pathArg(path41);
      opts = optsArg(opts);
      return useNativeSync(opts) ? mkdirpNativeSync(path41, opts) : mkdirpManualSync(path41, opts);
    };
    mkdirp.sync = mkdirpSync;
    mkdirp.native = (path41, opts) => mkdirpNative(pathArg(path41), optsArg(opts));
    mkdirp.manual = (path41, opts) => mkdirpManual(pathArg(path41), optsArg(opts));
    mkdirp.nativeSync = (path41, opts) => mkdirpNativeSync(pathArg(path41), optsArg(opts));
    mkdirp.manualSync = (path41, opts) => mkdirpManualSync(pathArg(path41), optsArg(opts));
    module2.exports = mkdirp;
  }
});

// node_modules/chownr/chownr.js
var require_chownr = __commonJS({
  "node_modules/chownr/chownr.js"(exports, module2) {
    "use strict";
    var fs29 = require("fs");
    var path41 = require("path");
    var LCHOWN = fs29.lchown ? "lchown" : "chown";
    var LCHOWNSYNC = fs29.lchownSync ? "lchownSync" : "chownSync";
    var needEISDIRHandled = fs29.lchown && !process.version.match(/v1[1-9]+\./) && !process.version.match(/v10\.[6-9]/);
    var lchownSync = (path42, uid, gid) => {
      try {
        return fs29[LCHOWNSYNC](path42, uid, gid);
      } catch (er) {
        if (er.code !== "ENOENT")
          throw er;
      }
    };
    var chownSync = (path42, uid, gid) => {
      try {
        return fs29.chownSync(path42, uid, gid);
      } catch (er) {
        if (er.code !== "ENOENT")
          throw er;
      }
    };
    var handleEISDIR = needEISDIRHandled ? (path42, uid, gid, cb) => (er) => {
      if (!er || er.code !== "EISDIR")
        cb(er);
      else
        fs29.chown(path42, uid, gid, cb);
    } : (_, __, ___, cb) => cb;
    var handleEISDirSync = needEISDIRHandled ? (path42, uid, gid) => {
      try {
        return lchownSync(path42, uid, gid);
      } catch (er) {
        if (er.code !== "EISDIR")
          throw er;
        chownSync(path42, uid, gid);
      }
    } : (path42, uid, gid) => lchownSync(path42, uid, gid);
    var nodeVersion = process.version;
    var readdir = (path42, options2, cb) => fs29.readdir(path42, options2, cb);
    var readdirSync = (path42, options2) => fs29.readdirSync(path42, options2);
    if (/^v4\./.test(nodeVersion))
      readdir = (path42, options2, cb) => fs29.readdir(path42, cb);
    var chown = (cpath, uid, gid, cb) => {
      fs29[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, (er) => {
        cb(er && er.code !== "ENOENT" ? er : null);
      }));
    };
    var chownrKid = (p, child, uid, gid, cb) => {
      if (typeof child === "string")
        return fs29.lstat(path41.resolve(p, child), (er, stats) => {
          if (er)
            return cb(er.code !== "ENOENT" ? er : null);
          stats.name = child;
          chownrKid(p, stats, uid, gid, cb);
        });
      if (child.isDirectory()) {
        chownr(path41.resolve(p, child.name), uid, gid, (er) => {
          if (er)
            return cb(er);
          const cpath = path41.resolve(p, child.name);
          chown(cpath, uid, gid, cb);
        });
      } else {
        const cpath = path41.resolve(p, child.name);
        chown(cpath, uid, gid, cb);
      }
    };
    var chownr = (p, uid, gid, cb) => {
      readdir(p, { withFileTypes: true }, (er, children) => {
        if (er) {
          if (er.code === "ENOENT")
            return cb();
          else if (er.code !== "ENOTDIR" && er.code !== "ENOTSUP")
            return cb(er);
        }
        if (er || !children.length)
          return chown(p, uid, gid, cb);
        let len = children.length;
        let errState = null;
        const then = (er2) => {
          if (errState)
            return;
          if (er2)
            return cb(errState = er2);
          if (--len === 0)
            return chown(p, uid, gid, cb);
        };
        children.forEach((child) => chownrKid(p, child, uid, gid, then));
      });
    };
    var chownrKidSync = (p, child, uid, gid) => {
      if (typeof child === "string") {
        try {
          const stats = fs29.lstatSync(path41.resolve(p, child));
          stats.name = child;
          child = stats;
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          else
            throw er;
        }
      }
      if (child.isDirectory())
        chownrSync(path41.resolve(p, child.name), uid, gid);
      handleEISDirSync(path41.resolve(p, child.name), uid, gid);
    };
    var chownrSync = (p, uid, gid) => {
      let children;
      try {
        children = readdirSync(p, { withFileTypes: true });
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        else if (er.code === "ENOTDIR" || er.code === "ENOTSUP")
          return handleEISDirSync(p, uid, gid);
        else
          throw er;
      }
      if (children && children.length)
        children.forEach((child) => chownrKidSync(p, child, uid, gid));
      return handleEISDirSync(p, uid, gid);
    };
    module2.exports = chownr;
    chownr.sync = chownrSync;
  }
});

// node_modules/tar/lib/mkdir.js
var require_mkdir = __commonJS({
  "node_modules/tar/lib/mkdir.js"(exports, module2) {
    "use strict";
    var mkdirp = require_mkdirp();
    var fs29 = require("fs");
    var path41 = require("path");
    var chownr = require_chownr();
    var normPath = require_normalize_windows_path();
    var SymlinkError = class extends Error {
      constructor(symlink, path42) {
        super("Cannot extract through symbolic link");
        this.path = path42;
        this.symlink = symlink;
      }
      get name() {
        return "SylinkError";
      }
    };
    var CwdError = class extends Error {
      constructor(path42, code) {
        super(code + ": Cannot cd into '" + path42 + "'");
        this.path = path42;
        this.code = code;
      }
      get name() {
        return "CwdError";
      }
    };
    var cGet = (cache, key) => cache.get(normPath(key));
    var cSet = (cache, key, val) => cache.set(normPath(key), val);
    var checkCwd = (dir, cb) => {
      fs29.stat(dir, (er, st) => {
        if (er || !st.isDirectory())
          er = new CwdError(dir, er && er.code || "ENOTDIR");
        cb(er);
      });
    };
    module2.exports = (dir, opt, cb) => {
      dir = normPath(dir);
      const umask = opt.umask;
      const mode = opt.mode | 448;
      const needChmod = (mode & umask) !== 0;
      const uid = opt.uid;
      const gid = opt.gid;
      const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
      const preserve = opt.preserve;
      const unlink = opt.unlink;
      const cache = opt.cache;
      const cwd = normPath(opt.cwd);
      const done = (er, created) => {
        if (er)
          cb(er);
        else {
          cSet(cache, dir, true);
          if (created && doChown)
            chownr(created, uid, gid, (er2) => done(er2));
          else if (needChmod)
            fs29.chmod(dir, mode, cb);
          else
            cb();
        }
      };
      if (cache && cGet(cache, dir) === true)
        return done();
      if (dir === cwd)
        return checkCwd(dir, done);
      if (preserve)
        return mkdirp(dir, { mode }).then((made) => done(null, made), done);
      const sub = normPath(path41.relative(cwd, dir));
      const parts = sub.split("/");
      mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done);
    };
    var mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {
      if (!parts.length)
        return cb(null, created);
      const p = parts.shift();
      const part = normPath(path41.resolve(base + "/" + p));
      if (cGet(cache, part))
        return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
      fs29.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));
    };
    var onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => (er) => {
      if (er) {
        fs29.lstat(part, (statEr, st) => {
          if (statEr) {
            statEr.path = statEr.path && normPath(statEr.path);
            cb(statEr);
          } else if (st.isDirectory())
            mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
          else if (unlink) {
            fs29.unlink(part, (er2) => {
              if (er2)
                return cb(er2);
              fs29.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));
            });
          } else if (st.isSymbolicLink())
            return cb(new SymlinkError(part, part + "/" + parts.join("/")));
          else
            cb(er);
        });
      } else {
        created = created || part;
        mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);
      }
    };
    var checkCwdSync = (dir) => {
      let ok = false;
      let code = "ENOTDIR";
      try {
        ok = fs29.statSync(dir).isDirectory();
      } catch (er) {
        code = er.code;
      } finally {
        if (!ok)
          throw new CwdError(dir, code);
      }
    };
    module2.exports.sync = (dir, opt) => {
      dir = normPath(dir);
      const umask = opt.umask;
      const mode = opt.mode | 448;
      const needChmod = (mode & umask) !== 0;
      const uid = opt.uid;
      const gid = opt.gid;
      const doChown = typeof uid === "number" && typeof gid === "number" && (uid !== opt.processUid || gid !== opt.processGid);
      const preserve = opt.preserve;
      const unlink = opt.unlink;
      const cache = opt.cache;
      const cwd = normPath(opt.cwd);
      const done = (created2) => {
        cSet(cache, dir, true);
        if (created2 && doChown)
          chownr.sync(created2, uid, gid);
        if (needChmod)
          fs29.chmodSync(dir, mode);
      };
      if (cache && cGet(cache, dir) === true)
        return done();
      if (dir === cwd) {
        checkCwdSync(cwd);
        return done();
      }
      if (preserve)
        return done(mkdirp.sync(dir, mode));
      const sub = normPath(path41.relative(cwd, dir));
      const parts = sub.split("/");
      let created = null;
      for (let p = parts.shift(), part = cwd; p && (part += "/" + p); p = parts.shift()) {
        part = normPath(path41.resolve(part));
        if (cGet(cache, part))
          continue;
        try {
          fs29.mkdirSync(part, mode);
          created = created || part;
          cSet(cache, part, true);
        } catch (er) {
          const st = fs29.lstatSync(part);
          if (st.isDirectory()) {
            cSet(cache, part, true);
            continue;
          } else if (unlink) {
            fs29.unlinkSync(part);
            fs29.mkdirSync(part, mode);
            created = created || part;
            cSet(cache, part, true);
            continue;
          } else if (st.isSymbolicLink())
            return new SymlinkError(part, part + "/" + parts.join("/"));
        }
      }
      return done(created);
    };
  }
});

// node_modules/tar/lib/normalize-unicode.js
var require_normalize_unicode = __commonJS({
  "node_modules/tar/lib/normalize-unicode.js"(exports, module2) {
    var normalizeCache = /* @__PURE__ */ Object.create(null);
    var { hasOwnProperty: hasOwnProperty3 } = Object.prototype;
    module2.exports = (s) => {
      if (!hasOwnProperty3.call(normalizeCache, s))
        normalizeCache[s] = s.normalize("NFKD");
      return normalizeCache[s];
    };
  }
});

// node_modules/tar/lib/path-reservations.js
var require_path_reservations = __commonJS({
  "node_modules/tar/lib/path-reservations.js"(exports, module2) {
    var assert = require("assert");
    var normalize = require_normalize_unicode();
    var stripSlashes = require_strip_trailing_slashes();
    var { join: join2 } = require("path");
    var platform2 = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
    var isWindows3 = platform2 === "win32";
    module2.exports = () => {
      const queues = /* @__PURE__ */ new Map();
      const reservations = /* @__PURE__ */ new Map();
      const getDirs = (path41) => {
        const dirs = path41.split("/").slice(0, -1).reduce((set, path42) => {
          if (set.length)
            path42 = join2(set[set.length - 1], path42);
          set.push(path42 || "/");
          return set;
        }, []);
        return dirs;
      };
      const running = /* @__PURE__ */ new Set();
      const getQueues = (fn) => {
        const res = reservations.get(fn);
        if (!res)
          throw new Error("function does not have any path reservations");
        return {
          paths: res.paths.map((path41) => queues.get(path41)),
          dirs: [...res.dirs].map((path41) => queues.get(path41))
        };
      };
      const check = (fn) => {
        const { paths, dirs } = getQueues(fn);
        return paths.every((q) => q[0] === fn) && dirs.every((q) => q[0] instanceof Set && q[0].has(fn));
      };
      const run = (fn) => {
        if (running.has(fn) || !check(fn))
          return false;
        running.add(fn);
        fn(() => clear(fn));
        return true;
      };
      const clear = (fn) => {
        if (!running.has(fn))
          return false;
        const { paths, dirs } = reservations.get(fn);
        const next = /* @__PURE__ */ new Set();
        paths.forEach((path41) => {
          const q = queues.get(path41);
          assert.equal(q[0], fn);
          if (q.length === 1)
            queues.delete(path41);
          else {
            q.shift();
            if (typeof q[0] === "function")
              next.add(q[0]);
            else
              q[0].forEach((fn2) => next.add(fn2));
          }
        });
        dirs.forEach((dir) => {
          const q = queues.get(dir);
          assert(q[0] instanceof Set);
          if (q[0].size === 1 && q.length === 1)
            queues.delete(dir);
          else if (q[0].size === 1) {
            q.shift();
            next.add(q[0]);
          } else
            q[0].delete(fn);
        });
        running.delete(fn);
        next.forEach((fn2) => run(fn2));
        return true;
      };
      const reserve = (paths, fn) => {
        paths = isWindows3 ? ["win32 parallelization disabled"] : paths.map((p) => {
          return normalize(stripSlashes(join2(p))).toLowerCase();
        });
        const dirs = new Set(paths.map((path41) => getDirs(path41)).reduce((a, b) => a.concat(b)));
        reservations.set(fn, { dirs, paths });
        paths.forEach((path41) => {
          const q = queues.get(path41);
          if (!q)
            queues.set(path41, [fn]);
          else
            q.push(fn);
        });
        dirs.forEach((dir) => {
          const q = queues.get(dir);
          if (!q)
            queues.set(dir, [/* @__PURE__ */ new Set([fn])]);
          else if (q[q.length - 1] instanceof Set)
            q[q.length - 1].add(fn);
          else
            q.push(/* @__PURE__ */ new Set([fn]));
        });
        return run(fn);
      };
      return { check, reserve };
    };
  }
});

// node_modules/tar/lib/get-write-flag.js
var require_get_write_flag = __commonJS({
  "node_modules/tar/lib/get-write-flag.js"(exports, module2) {
    var platform2 = process.env.__FAKE_PLATFORM__ || process.platform;
    var isWindows3 = platform2 === "win32";
    var fs29 = global.__FAKE_TESTING_FS__ || require("fs");
    var { O_CREAT, O_TRUNC, O_WRONLY, UV_FS_O_FILEMAP = 0 } = fs29.constants;
    var fMapEnabled = isWindows3 && !!UV_FS_O_FILEMAP;
    var fMapLimit = 512 * 1024;
    var fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY;
    module2.exports = !fMapEnabled ? () => "w" : (size) => size < fMapLimit ? fMapFlag : "w";
  }
});

// node_modules/tar/lib/unpack.js
var require_unpack = __commonJS({
  "node_modules/tar/lib/unpack.js"(exports, module2) {
    "use strict";
    var assert = require("assert");
    var Parser2 = require_parse2();
    var fs29 = require("fs");
    var fsm = require_fs_minipass();
    var path41 = require("path");
    var mkdir = require_mkdir();
    var wc = require_winchars();
    var pathReservations = require_path_reservations();
    var stripAbsolutePath = require_strip_absolute_path();
    var normPath = require_normalize_windows_path();
    var stripSlash = require_strip_trailing_slashes();
    var normalize = require_normalize_unicode();
    var ONENTRY = Symbol("onEntry");
    var CHECKFS = Symbol("checkFs");
    var CHECKFS2 = Symbol("checkFs2");
    var PRUNECACHE = Symbol("pruneCache");
    var ISREUSABLE = Symbol("isReusable");
    var MAKEFS = Symbol("makeFs");
    var FILE = Symbol("file");
    var DIRECTORY = Symbol("directory");
    var LINK = Symbol("link");
    var SYMLINK = Symbol("symlink");
    var HARDLINK = Symbol("hardlink");
    var UNSUPPORTED = Symbol("unsupported");
    var CHECKPATH = Symbol("checkPath");
    var MKDIR = Symbol("mkdir");
    var ONERROR = Symbol("onError");
    var PENDING = Symbol("pending");
    var PEND = Symbol("pend");
    var UNPEND = Symbol("unpend");
    var ENDED = Symbol("ended");
    var MAYBECLOSE = Symbol("maybeClose");
    var SKIP = Symbol("skip");
    var DOCHOWN = Symbol("doChown");
    var UID = Symbol("uid");
    var GID = Symbol("gid");
    var CHECKED_CWD = Symbol("checkedCwd");
    var crypto2 = require("crypto");
    var getFlag = require_get_write_flag();
    var platform2 = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;
    var isWindows3 = platform2 === "win32";
    var unlinkFile = (path42, cb) => {
      if (!isWindows3)
        return fs29.unlink(path42, cb);
      const name2 = path42 + ".DELETE." + crypto2.randomBytes(16).toString("hex");
      fs29.rename(path42, name2, (er) => {
        if (er)
          return cb(er);
        fs29.unlink(name2, cb);
      });
    };
    var unlinkFileSync = (path42) => {
      if (!isWindows3)
        return fs29.unlinkSync(path42);
      const name2 = path42 + ".DELETE." + crypto2.randomBytes(16).toString("hex");
      fs29.renameSync(path42, name2);
      fs29.unlinkSync(name2);
    };
    var uint32 = (a, b, c) => a === a >>> 0 ? a : b === b >>> 0 ? b : c;
    var cacheKeyNormalize = (path42) => normalize(stripSlash(normPath(path42))).toLowerCase();
    var pruneCache = (cache, abs) => {
      abs = cacheKeyNormalize(abs);
      for (const path42 of cache.keys()) {
        const pnorm = cacheKeyNormalize(path42);
        if (pnorm === abs || pnorm.indexOf(abs + "/") === 0)
          cache.delete(path42);
      }
    };
    var dropCache = (cache) => {
      for (const key of cache.keys())
        cache.delete(key);
    };
    var Unpack = class extends Parser2 {
      constructor(opt) {
        if (!opt)
          opt = {};
        opt.ondone = (_) => {
          this[ENDED] = true;
          this[MAYBECLOSE]();
        };
        super(opt);
        this[CHECKED_CWD] = false;
        this.reservations = pathReservations();
        this.transform = typeof opt.transform === "function" ? opt.transform : null;
        this.writable = true;
        this.readable = false;
        this[PENDING] = 0;
        this[ENDED] = false;
        this.dirCache = opt.dirCache || /* @__PURE__ */ new Map();
        if (typeof opt.uid === "number" || typeof opt.gid === "number") {
          if (typeof opt.uid !== "number" || typeof opt.gid !== "number")
            throw new TypeError("cannot set owner without number uid and gid");
          if (opt.preserveOwner) {
            throw new TypeError("cannot preserve owner in archive and also set owner explicitly");
          }
          this.uid = opt.uid;
          this.gid = opt.gid;
          this.setOwner = true;
        } else {
          this.uid = null;
          this.gid = null;
          this.setOwner = false;
        }
        if (opt.preserveOwner === void 0 && typeof opt.uid !== "number")
          this.preserveOwner = process.getuid && process.getuid() === 0;
        else
          this.preserveOwner = !!opt.preserveOwner;
        this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ? process.getuid() : null;
        this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ? process.getgid() : null;
        this.forceChown = opt.forceChown === true;
        this.win32 = !!opt.win32 || isWindows3;
        this.newer = !!opt.newer;
        this.keep = !!opt.keep;
        this.noMtime = !!opt.noMtime;
        this.preservePaths = !!opt.preservePaths;
        this.unlink = !!opt.unlink;
        this.cwd = normPath(path41.resolve(opt.cwd || process.cwd()));
        this.strip = +opt.strip || 0;
        this.processUmask = opt.noChmod ? 0 : process.umask();
        this.umask = typeof opt.umask === "number" ? opt.umask : this.processUmask;
        this.dmode = opt.dmode || 511 & ~this.umask;
        this.fmode = opt.fmode || 438 & ~this.umask;
        this.on("entry", (entry) => this[ONENTRY](entry));
      }
      warn(code, msg, data = {}) {
        if (code === "TAR_BAD_ARCHIVE" || code === "TAR_ABORT")
          data.recoverable = false;
        return super.warn(code, msg, data);
      }
      [MAYBECLOSE]() {
        if (this[ENDED] && this[PENDING] === 0) {
          this.emit("prefinish");
          this.emit("finish");
          this.emit("end");
          this.emit("close");
        }
      }
      [CHECKPATH](entry) {
        if (this.strip) {
          const parts = normPath(entry.path).split("/");
          if (parts.length < this.strip)
            return false;
          entry.path = parts.slice(this.strip).join("/");
          if (entry.type === "Link") {
            const linkparts = normPath(entry.linkpath).split("/");
            if (linkparts.length >= this.strip)
              entry.linkpath = linkparts.slice(this.strip).join("/");
            else
              return false;
          }
        }
        if (!this.preservePaths) {
          const p = normPath(entry.path);
          const parts = p.split("/");
          if (parts.includes("..") || isWindows3 && /^[a-z]:\.\.$/i.test(parts[0])) {
            this.warn("TAR_ENTRY_ERROR", `path contains '..'`, {
              entry,
              path: p
            });
            return false;
          }
          const [root, stripped] = stripAbsolutePath(p);
          if (root) {
            entry.path = stripped;
            this.warn("TAR_ENTRY_INFO", `stripping ${root} from absolute path`, {
              entry,
              path: p
            });
          }
        }
        if (path41.isAbsolute(entry.path))
          entry.absolute = normPath(path41.resolve(entry.path));
        else
          entry.absolute = normPath(path41.resolve(this.cwd, entry.path));
        if (!this.preservePaths && entry.absolute.indexOf(this.cwd + "/") !== 0 && entry.absolute !== this.cwd) {
          this.warn("TAR_ENTRY_ERROR", "path escaped extraction target", {
            entry,
            path: normPath(entry.path),
            resolvedPath: entry.absolute,
            cwd: this.cwd
          });
          return false;
        }
        if (entry.absolute === this.cwd && entry.type !== "Directory" && entry.type !== "GNUDumpDir")
          return false;
        if (this.win32) {
          const { root: aRoot } = path41.win32.parse(entry.absolute);
          entry.absolute = aRoot + wc.encode(entry.absolute.substr(aRoot.length));
          const { root: pRoot } = path41.win32.parse(entry.path);
          entry.path = pRoot + wc.encode(entry.path.substr(pRoot.length));
        }
        return true;
      }
      [ONENTRY](entry) {
        if (!this[CHECKPATH](entry))
          return entry.resume();
        assert.equal(typeof entry.absolute, "string");
        switch (entry.type) {
          case "Directory":
          case "GNUDumpDir":
            if (entry.mode)
              entry.mode = entry.mode | 448;
          case "File":
          case "OldFile":
          case "ContiguousFile":
          case "Link":
          case "SymbolicLink":
            return this[CHECKFS](entry);
          case "CharacterDevice":
          case "BlockDevice":
          case "FIFO":
          default:
            return this[UNSUPPORTED](entry);
        }
      }
      [ONERROR](er, entry) {
        if (er.name === "CwdError")
          this.emit("error", er);
        else {
          this.warn("TAR_ENTRY_ERROR", er, { entry });
          this[UNPEND]();
          entry.resume();
        }
      }
      [MKDIR](dir, mode, cb) {
        mkdir(normPath(dir), {
          uid: this.uid,
          gid: this.gid,
          processUid: this.processUid,
          processGid: this.processGid,
          umask: this.processUmask,
          preserve: this.preservePaths,
          unlink: this.unlink,
          cache: this.dirCache,
          cwd: this.cwd,
          mode,
          noChmod: this.noChmod
        }, cb);
      }
      [DOCHOWN](entry) {
        return this.forceChown || this.preserveOwner && (typeof entry.uid === "number" && entry.uid !== this.processUid || typeof entry.gid === "number" && entry.gid !== this.processGid) || (typeof this.uid === "number" && this.uid !== this.processUid || typeof this.gid === "number" && this.gid !== this.processGid);
      }
      [UID](entry) {
        return uint32(this.uid, entry.uid, this.processUid);
      }
      [GID](entry) {
        return uint32(this.gid, entry.gid, this.processGid);
      }
      [FILE](entry, fullyDone) {
        const mode = entry.mode & 4095 || this.fmode;
        const stream = new fsm.WriteStream(entry.absolute, {
          flags: getFlag(entry.size),
          mode,
          autoClose: false
        });
        stream.on("error", (er) => {
          if (stream.fd)
            fs29.close(stream.fd, () => {
            });
          stream.write = () => true;
          this[ONERROR](er, entry);
          fullyDone();
        });
        let actions = 1;
        const done = (er) => {
          if (er) {
            if (stream.fd)
              fs29.close(stream.fd, () => {
              });
            this[ONERROR](er, entry);
            fullyDone();
            return;
          }
          if (--actions === 0) {
            fs29.close(stream.fd, (er2) => {
              if (er2)
                this[ONERROR](er2, entry);
              else
                this[UNPEND]();
              fullyDone();
            });
          }
        };
        stream.on("finish", (_) => {
          const abs = entry.absolute;
          const fd = stream.fd;
          if (entry.mtime && !this.noMtime) {
            actions++;
            const atime = entry.atime || new Date();
            const mtime = entry.mtime;
            fs29.futimes(fd, atime, mtime, (er) => er ? fs29.utimes(abs, atime, mtime, (er2) => done(er2 && er)) : done());
          }
          if (this[DOCHOWN](entry)) {
            actions++;
            const uid = this[UID](entry);
            const gid = this[GID](entry);
            fs29.fchown(fd, uid, gid, (er) => er ? fs29.chown(abs, uid, gid, (er2) => done(er2 && er)) : done());
          }
          done();
        });
        const tx = this.transform ? this.transform(entry) || entry : entry;
        if (tx !== entry) {
          tx.on("error", (er) => {
            this[ONERROR](er, entry);
            fullyDone();
          });
          entry.pipe(tx);
        }
        tx.pipe(stream);
      }
      [DIRECTORY](entry, fullyDone) {
        const mode = entry.mode & 4095 || this.dmode;
        this[MKDIR](entry.absolute, mode, (er) => {
          if (er) {
            this[ONERROR](er, entry);
            fullyDone();
            return;
          }
          let actions = 1;
          const done = (_) => {
            if (--actions === 0) {
              fullyDone();
              this[UNPEND]();
              entry.resume();
            }
          };
          if (entry.mtime && !this.noMtime) {
            actions++;
            fs29.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done);
          }
          if (this[DOCHOWN](entry)) {
            actions++;
            fs29.chown(entry.absolute, this[UID](entry), this[GID](entry), done);
          }
          done();
        });
      }
      [UNSUPPORTED](entry) {
        entry.unsupported = true;
        this.warn("TAR_ENTRY_UNSUPPORTED", `unsupported entry type: ${entry.type}`, { entry });
        entry.resume();
      }
      [SYMLINK](entry, done) {
        this[LINK](entry, entry.linkpath, "symlink", done);
      }
      [HARDLINK](entry, done) {
        const linkpath = normPath(path41.resolve(this.cwd, entry.linkpath));
        this[LINK](entry, linkpath, "link", done);
      }
      [PEND]() {
        this[PENDING]++;
      }
      [UNPEND]() {
        this[PENDING]--;
        this[MAYBECLOSE]();
      }
      [SKIP](entry) {
        this[UNPEND]();
        entry.resume();
      }
      [ISREUSABLE](entry, st) {
        return entry.type === "File" && !this.unlink && st.isFile() && st.nlink <= 1 && !isWindows3;
      }
      [CHECKFS](entry) {
        this[PEND]();
        const paths = [entry.path];
        if (entry.linkpath)
          paths.push(entry.linkpath);
        this.reservations.reserve(paths, (done) => this[CHECKFS2](entry, done));
      }
      [PRUNECACHE](entry) {
        if (entry.type === "SymbolicLink")
          dropCache(this.dirCache);
        else if (entry.type !== "Directory")
          pruneCache(this.dirCache, entry.absolute);
      }
      [CHECKFS2](entry, fullyDone) {
        this[PRUNECACHE](entry);
        const done = (er) => {
          this[PRUNECACHE](entry);
          fullyDone(er);
        };
        const checkCwd = () => {
          this[MKDIR](this.cwd, this.dmode, (er) => {
            if (er) {
              this[ONERROR](er, entry);
              done();
              return;
            }
            this[CHECKED_CWD] = true;
            start();
          });
        };
        const start = () => {
          if (entry.absolute !== this.cwd) {
            const parent = normPath(path41.dirname(entry.absolute));
            if (parent !== this.cwd) {
              return this[MKDIR](parent, this.dmode, (er) => {
                if (er) {
                  this[ONERROR](er, entry);
                  done();
                  return;
                }
                afterMakeParent();
              });
            }
          }
          afterMakeParent();
        };
        const afterMakeParent = () => {
          fs29.lstat(entry.absolute, (lstatEr, st) => {
            if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {
              this[SKIP](entry);
              done();
              return;
            }
            if (lstatEr || this[ISREUSABLE](entry, st))
              return this[MAKEFS](null, entry, done);
            if (st.isDirectory()) {
              if (entry.type === "Directory") {
                const needChmod = !this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode;
                const afterChmod = (er) => this[MAKEFS](er, entry, done);
                if (!needChmod)
                  return afterChmod();
                return fs29.chmod(entry.absolute, entry.mode, afterChmod);
              }
              if (entry.absolute !== this.cwd) {
                return fs29.rmdir(entry.absolute, (er) => this[MAKEFS](er, entry, done));
              }
            }
            if (entry.absolute === this.cwd)
              return this[MAKEFS](null, entry, done);
            unlinkFile(entry.absolute, (er) => this[MAKEFS](er, entry, done));
          });
        };
        if (this[CHECKED_CWD])
          start();
        else
          checkCwd();
      }
      [MAKEFS](er, entry, done) {
        if (er) {
          this[ONERROR](er, entry);
          done();
          return;
        }
        switch (entry.type) {
          case "File":
          case "OldFile":
          case "ContiguousFile":
            return this[FILE](entry, done);
          case "Link":
            return this[HARDLINK](entry, done);
          case "SymbolicLink":
            return this[SYMLINK](entry, done);
          case "Directory":
          case "GNUDumpDir":
            return this[DIRECTORY](entry, done);
        }
      }
      [LINK](entry, linkpath, link, done) {
        fs29[link](linkpath, entry.absolute, (er) => {
          if (er)
            this[ONERROR](er, entry);
          else {
            this[UNPEND]();
            entry.resume();
          }
          done();
        });
      }
    };
    var callSync = (fn) => {
      try {
        return [null, fn()];
      } catch (er) {
        return [er, null];
      }
    };
    var UnpackSync = class extends Unpack {
      [MAKEFS](er, entry) {
        return super[MAKEFS](er, entry, () => {
        });
      }
      [CHECKFS](entry) {
        this[PRUNECACHE](entry);
        if (!this[CHECKED_CWD]) {
          const er2 = this[MKDIR](this.cwd, this.dmode);
          if (er2)
            return this[ONERROR](er2, entry);
          this[CHECKED_CWD] = true;
        }
        if (entry.absolute !== this.cwd) {
          const parent = normPath(path41.dirname(entry.absolute));
          if (parent !== this.cwd) {
            const mkParent = this[MKDIR](parent, this.dmode);
            if (mkParent)
              return this[ONERROR](mkParent, entry);
          }
        }
        const [lstatEr, st] = callSync(() => fs29.lstatSync(entry.absolute));
        if (st && (this.keep || this.newer && st.mtime > entry.mtime))
          return this[SKIP](entry);
        if (lstatEr || this[ISREUSABLE](entry, st))
          return this[MAKEFS](null, entry);
        if (st.isDirectory()) {
          if (entry.type === "Directory") {
            const needChmod = !this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode;
            const [er3] = needChmod ? callSync(() => {
              fs29.chmodSync(entry.absolute, entry.mode);
            }) : [];
            return this[MAKEFS](er3, entry);
          }
          const [er2] = callSync(() => fs29.rmdirSync(entry.absolute));
          this[MAKEFS](er2, entry);
        }
        const [er] = entry.absolute === this.cwd ? [] : callSync(() => unlinkFileSync(entry.absolute));
        this[MAKEFS](er, entry);
      }
      [FILE](entry, done) {
        const mode = entry.mode & 4095 || this.fmode;
        const oner = (er) => {
          let closeError;
          try {
            fs29.closeSync(fd);
          } catch (e) {
            closeError = e;
          }
          if (er || closeError)
            this[ONERROR](er || closeError, entry);
          done();
        };
        let fd;
        try {
          fd = fs29.openSync(entry.absolute, getFlag(entry.size), mode);
        } catch (er) {
          return oner(er);
        }
        const tx = this.transform ? this.transform(entry) || entry : entry;
        if (tx !== entry) {
          tx.on("error", (er) => this[ONERROR](er, entry));
          entry.pipe(tx);
        }
        tx.on("data", (chunk) => {
          try {
            fs29.writeSync(fd, chunk, 0, chunk.length);
          } catch (er) {
            oner(er);
          }
        });
        tx.on("end", (_) => {
          let er = null;
          if (entry.mtime && !this.noMtime) {
            const atime = entry.atime || new Date();
            const mtime = entry.mtime;
            try {
              fs29.futimesSync(fd, atime, mtime);
            } catch (futimeser) {
              try {
                fs29.utimesSync(entry.absolute, atime, mtime);
              } catch (utimeser) {
                er = futimeser;
              }
            }
          }
          if (this[DOCHOWN](entry)) {
            const uid = this[UID](entry);
            const gid = this[GID](entry);
            try {
              fs29.fchownSync(fd, uid, gid);
            } catch (fchowner) {
              try {
                fs29.chownSync(entry.absolute, uid, gid);
              } catch (chowner) {
                er = er || fchowner;
              }
            }
          }
          oner(er);
        });
      }
      [DIRECTORY](entry, done) {
        const mode = entry.mode & 4095 || this.dmode;
        const er = this[MKDIR](entry.absolute, mode);
        if (er) {
          this[ONERROR](er, entry);
          done();
          return;
        }
        if (entry.mtime && !this.noMtime) {
          try {
            fs29.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime);
          } catch (er2) {
          }
        }
        if (this[DOCHOWN](entry)) {
          try {
            fs29.chownSync(entry.absolute, this[UID](entry), this[GID](entry));
          } catch (er2) {
          }
        }
        done();
        entry.resume();
      }
      [MKDIR](dir, mode) {
        try {
          return mkdir.sync(normPath(dir), {
            uid: this.uid,
            gid: this.gid,
            processUid: this.processUid,
            processGid: this.processGid,
            umask: this.processUmask,
            preserve: this.preservePaths,
            unlink: this.unlink,
            cache: this.dirCache,
            cwd: this.cwd,
            mode
          });
        } catch (er) {
          return er;
        }
      }
      [LINK](entry, linkpath, link, done) {
        try {
          fs29[link + "Sync"](linkpath, entry.absolute);
          done();
          entry.resume();
        } catch (er) {
          return this[ONERROR](er, entry);
        }
      }
    };
    Unpack.Sync = UnpackSync;
    module2.exports = Unpack;
  }
});

// node_modules/tar/lib/extract.js
var require_extract = __commonJS({
  "node_modules/tar/lib/extract.js"(exports, module2) {
    "use strict";
    var hlo = require_high_level_opt();
    var Unpack = require_unpack();
    var fs29 = require("fs");
    var fsm = require_fs_minipass();
    var path41 = require("path");
    var stripSlash = require_strip_trailing_slashes();
    module2.exports = (opt_, files, cb) => {
      if (typeof opt_ === "function")
        cb = opt_, files = null, opt_ = {};
      else if (Array.isArray(opt_))
        files = opt_, opt_ = {};
      if (typeof files === "function")
        cb = files, files = null;
      if (!files)
        files = [];
      else
        files = Array.from(files);
      const opt = hlo(opt_);
      if (opt.sync && typeof cb === "function")
        throw new TypeError("callback not supported for sync tar functions");
      if (!opt.file && typeof cb === "function")
        throw new TypeError("callback only supported with file option");
      if (files.length)
        filesFilter(opt, files);
      return opt.file && opt.sync ? extractFileSync(opt) : opt.file ? extractFile(opt, cb) : opt.sync ? extractSync(opt) : extract(opt);
    };
    var filesFilter = (opt, files) => {
      const map = new Map(files.map((f) => [stripSlash(f), true]));
      const filter2 = opt.filter;
      const mapHas = (file, r) => {
        const root = r || path41.parse(file).root || ".";
        const ret = file === root ? false : map.has(file) ? map.get(file) : mapHas(path41.dirname(file), root);
        map.set(file, ret);
        return ret;
      };
      opt.filter = filter2 ? (file, entry) => filter2(file, entry) && mapHas(stripSlash(file)) : (file) => mapHas(stripSlash(file));
    };
    var extractFileSync = (opt) => {
      const u = new Unpack.Sync(opt);
      const file = opt.file;
      const stat = fs29.statSync(file);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const stream = new fsm.ReadStreamSync(file, {
        readSize,
        size: stat.size
      });
      stream.pipe(u);
    };
    var extractFile = (opt, cb) => {
      const u = new Unpack(opt);
      const readSize = opt.maxReadSize || 16 * 1024 * 1024;
      const file = opt.file;
      const p = new Promise((resolve3, reject) => {
        u.on("error", reject);
        u.on("close", resolve3);
        fs29.stat(file, (er, stat) => {
          if (er)
            reject(er);
          else {
            const stream = new fsm.ReadStream(file, {
              readSize,
              size: stat.size
            });
            stream.on("error", reject);
            stream.pipe(u);
          }
        });
      });
      return cb ? p.then(cb, cb) : p;
    };
    var extractSync = (opt) => new Unpack.Sync(opt);
    var extract = (opt) => new Unpack(opt);
  }
});

// node_modules/tar/index.js
var require_tar = __commonJS({
  "node_modules/tar/index.js"(exports) {
    "use strict";
    exports.c = exports.create = require_create();
    exports.r = exports.replace = require_replace();
    exports.t = exports.list = require_list();
    exports.u = exports.update = require_update();
    exports.x = exports.extract = require_extract();
    exports.Pack = require_pack();
    exports.Unpack = require_unpack();
    exports.Parse = require_parse2();
    exports.ReadEntry = require_read_entry();
    exports.WriteEntry = require_write_entry();
    exports.Header = require_header();
    exports.Pax = require_pax();
    exports.types = require_types2();
  }
});

// node_modules/traverse/index.js
var require_traverse = __commonJS({
  "node_modules/traverse/index.js"(exports, module2) {
    module2.exports = Traverse;
    function Traverse(obj) {
      if (!(this instanceof Traverse))
        return new Traverse(obj);
      this.value = obj;
    }
    Traverse.prototype.get = function(ps) {
      var node = this.value;
      for (var i = 0; i < ps.length; i++) {
        var key = ps[i];
        if (!Object.hasOwnProperty.call(node, key)) {
          node = void 0;
          break;
        }
        node = node[key];
      }
      return node;
    };
    Traverse.prototype.set = function(ps, value) {
      var node = this.value;
      for (var i = 0; i < ps.length - 1; i++) {
        var key = ps[i];
        if (!Object.hasOwnProperty.call(node, key))
          node[key] = {};
        node = node[key];
      }
      node[ps[i]] = value;
      return value;
    };
    Traverse.prototype.map = function(cb) {
      return walk2(this.value, cb, true);
    };
    Traverse.prototype.forEach = function(cb) {
      this.value = walk2(this.value, cb, false);
      return this.value;
    };
    Traverse.prototype.reduce = function(cb, init) {
      var skip = arguments.length === 1;
      var acc = skip ? this.value : init;
      this.forEach(function(x) {
        if (!this.isRoot || !skip) {
          acc = cb.call(this, acc, x);
        }
      });
      return acc;
    };
    Traverse.prototype.deepEqual = function(obj) {
      if (arguments.length !== 1) {
        throw new Error("deepEqual requires exactly one object to compare against");
      }
      var equal = true;
      var node = obj;
      this.forEach(function(y) {
        var notEqual = function() {
          equal = false;
          return void 0;
        }.bind(this);
        if (!this.isRoot) {
          if (typeof node !== "object")
            return notEqual();
          node = node[this.key];
        }
        var x = node;
        this.post(function() {
          node = x;
        });
        var toS = function(o) {
          return Object.prototype.toString.call(o);
        };
        if (this.circular) {
          if (Traverse(obj).get(this.circular.path) !== x)
            notEqual();
        } else if (typeof x !== typeof y) {
          notEqual();
        } else if (x === null || y === null || x === void 0 || y === void 0) {
          if (x !== y)
            notEqual();
        } else if (x.__proto__ !== y.__proto__) {
          notEqual();
        } else if (x === y) {
        } else if (typeof x === "function") {
          if (x instanceof RegExp) {
            if (x.toString() != y.toString())
              notEqual();
          } else if (x !== y)
            notEqual();
        } else if (typeof x === "object") {
          if (toS(y) === "[object Arguments]" || toS(x) === "[object Arguments]") {
            if (toS(x) !== toS(y)) {
              notEqual();
            }
          } else if (x instanceof Date || y instanceof Date) {
            if (!(x instanceof Date) || !(y instanceof Date) || x.getTime() !== y.getTime()) {
              notEqual();
            }
          } else {
            var kx = Object.keys(x);
            var ky = Object.keys(y);
            if (kx.length !== ky.length)
              return notEqual();
            for (var i = 0; i < kx.length; i++) {
              var k = kx[i];
              if (!Object.hasOwnProperty.call(y, k)) {
                notEqual();
              }
            }
          }
        }
      });
      return equal;
    };
    Traverse.prototype.paths = function() {
      var acc = [];
      this.forEach(function(x) {
        acc.push(this.path);
      });
      return acc;
    };
    Traverse.prototype.nodes = function() {
      var acc = [];
      this.forEach(function(x) {
        acc.push(this.node);
      });
      return acc;
    };
    Traverse.prototype.clone = function() {
      var parents = [], nodes = [];
      return function clone(src) {
        for (var i = 0; i < parents.length; i++) {
          if (parents[i] === src) {
            return nodes[i];
          }
        }
        if (typeof src === "object" && src !== null) {
          var dst = copy(src);
          parents.push(src);
          nodes.push(dst);
          Object.keys(src).forEach(function(key) {
            dst[key] = clone(src[key]);
          });
          parents.pop();
          nodes.pop();
          return dst;
        } else {
          return src;
        }
      }(this.value);
    };
    function walk2(root, cb, immutable) {
      var path41 = [];
      var parents = [];
      var alive = true;
      return function walker(node_) {
        var node = immutable ? copy(node_) : node_;
        var modifiers = {};
        var state = {
          node,
          node_,
          path: [].concat(path41),
          parent: parents.slice(-1)[0],
          key: path41.slice(-1)[0],
          isRoot: path41.length === 0,
          level: path41.length,
          circular: null,
          update: function(x) {
            if (!state.isRoot) {
              state.parent.node[state.key] = x;
            }
            state.node = x;
          },
          "delete": function() {
            delete state.parent.node[state.key];
          },
          remove: function() {
            if (Array.isArray(state.parent.node)) {
              state.parent.node.splice(state.key, 1);
            } else {
              delete state.parent.node[state.key];
            }
          },
          before: function(f) {
            modifiers.before = f;
          },
          after: function(f) {
            modifiers.after = f;
          },
          pre: function(f) {
            modifiers.pre = f;
          },
          post: function(f) {
            modifiers.post = f;
          },
          stop: function() {
            alive = false;
          }
        };
        if (!alive)
          return state;
        if (typeof node === "object" && node !== null) {
          state.isLeaf = Object.keys(node).length == 0;
          for (var i = 0; i < parents.length; i++) {
            if (parents[i].node_ === node_) {
              state.circular = parents[i];
              break;
            }
          }
        } else {
          state.isLeaf = true;
        }
        state.notLeaf = !state.isLeaf;
        state.notRoot = !state.isRoot;
        var ret = cb.call(state, state.node);
        if (ret !== void 0 && state.update)
          state.update(ret);
        if (modifiers.before)
          modifiers.before.call(state, state.node);
        if (typeof state.node == "object" && state.node !== null && !state.circular) {
          parents.push(state);
          var keys = Object.keys(state.node);
          keys.forEach(function(key, i2) {
            path41.push(key);
            if (modifiers.pre)
              modifiers.pre.call(state, state.node[key], key);
            var child = walker(state.node[key]);
            if (immutable && Object.hasOwnProperty.call(state.node, key)) {
              state.node[key] = child.node;
            }
            child.isLast = i2 == keys.length - 1;
            child.isFirst = i2 == 0;
            if (modifiers.post)
              modifiers.post.call(state, child);
            path41.pop();
          });
          parents.pop();
        }
        if (modifiers.after)
          modifiers.after.call(state, state.node);
        return state;
      }(root).node;
    }
    Object.keys(Traverse.prototype).forEach(function(key) {
      Traverse[key] = function(obj) {
        var args = [].slice.call(arguments, 1);
        var t = Traverse(obj);
        return t[key].apply(t, args);
      };
    });
    function copy(src) {
      if (typeof src === "object" && src !== null) {
        var dst;
        if (Array.isArray(src)) {
          dst = [];
        } else if (src instanceof Date) {
          dst = new Date(src);
        } else if (src instanceof Boolean) {
          dst = new Boolean(src);
        } else if (src instanceof Number) {
          dst = new Number(src);
        } else if (src instanceof String) {
          dst = new String(src);
        } else {
          dst = Object.create(Object.getPrototypeOf(src));
        }
        Object.keys(src).forEach(function(key) {
          dst[key] = src[key];
        });
        return dst;
      } else
        return src;
    }
  }
});

// node_modules/chainsaw/index.js
var require_chainsaw = __commonJS({
  "node_modules/chainsaw/index.js"(exports, module2) {
    var Traverse = require_traverse();
    var EventEmitter8 = require("events").EventEmitter;
    module2.exports = Chainsaw;
    function Chainsaw(builder) {
      var saw = Chainsaw.saw(builder, {});
      var r = builder.call(saw.handlers, saw);
      if (r !== void 0)
        saw.handlers = r;
      saw.record();
      return saw.chain();
    }
    Chainsaw.light = function ChainsawLight(builder) {
      var saw = Chainsaw.saw(builder, {});
      var r = builder.call(saw.handlers, saw);
      if (r !== void 0)
        saw.handlers = r;
      return saw.chain();
    };
    Chainsaw.saw = function(builder, handlers) {
      var saw = new EventEmitter8();
      saw.handlers = handlers;
      saw.actions = [];
      saw.chain = function() {
        var ch = Traverse(saw.handlers).map(function(node) {
          if (this.isRoot)
            return node;
          var ps = this.path;
          if (typeof node === "function") {
            this.update(function() {
              saw.actions.push({
                path: ps,
                args: [].slice.call(arguments)
              });
              return ch;
            });
          }
        });
        process.nextTick(function() {
          saw.emit("begin");
          saw.next();
        });
        return ch;
      };
      saw.pop = function() {
        return saw.actions.shift();
      };
      saw.next = function() {
        var action = saw.pop();
        if (!action) {
          saw.emit("end");
        } else if (!action.trap) {
          var node = saw.handlers;
          action.path.forEach(function(key) {
            node = node[key];
          });
          node.apply(saw.handlers, action.args);
        }
      };
      saw.nest = function(cb) {
        var args = [].slice.call(arguments, 1);
        var autonext = true;
        if (typeof cb === "boolean") {
          var autonext = cb;
          cb = args.shift();
        }
        var s = Chainsaw.saw(builder, {});
        var r = builder.call(s.handlers, s);
        if (r !== void 0)
          s.handlers = r;
        if (typeof saw.step !== "undefined") {
          s.record();
        }
        cb.apply(s.chain(), args);
        if (autonext !== false)
          s.on("end", saw.next);
      };
      saw.record = function() {
        upgradeChainsaw(saw);
      };
      ["trap", "down", "jump"].forEach(function(method) {
        saw[method] = function() {
          throw new Error("To use the trap, down and jump features, please call record() first to start recording actions.");
        };
      });
      return saw;
    };
    function upgradeChainsaw(saw) {
      saw.step = 0;
      saw.pop = function() {
        return saw.actions[saw.step++];
      };
      saw.trap = function(name2, cb) {
        var ps = Array.isArray(name2) ? name2 : [name2];
        saw.actions.push({
          path: ps,
          step: saw.step,
          cb,
          trap: true
        });
      };
      saw.down = function(name2) {
        var ps = (Array.isArray(name2) ? name2 : [name2]).join("/");
        var i = saw.actions.slice(saw.step).map(function(x) {
          if (x.trap && x.step <= saw.step)
            return false;
          return x.path.join("/") == ps;
        }).indexOf(true);
        if (i >= 0)
          saw.step += i;
        else
          saw.step = saw.actions.length;
        var act = saw.actions[saw.step - 1];
        if (act && act.trap) {
          saw.step = act.step;
          act.cb();
        } else
          saw.next();
      };
      saw.jump = function(step) {
        saw.step = step;
        saw.next();
      };
    }
  }
});

// node_modules/buffers/index.js
var require_buffers = __commonJS({
  "node_modules/buffers/index.js"(exports, module2) {
    module2.exports = Buffers;
    function Buffers(bufs) {
      if (!(this instanceof Buffers))
        return new Buffers(bufs);
      this.buffers = bufs || [];
      this.length = this.buffers.reduce(function(size, buf) {
        return size + buf.length;
      }, 0);
    }
    Buffers.prototype.push = function() {
      for (var i = 0; i < arguments.length; i++) {
        if (!Buffer.isBuffer(arguments[i])) {
          throw new TypeError("Tried to push a non-buffer");
        }
      }
      for (var i = 0; i < arguments.length; i++) {
        var buf = arguments[i];
        this.buffers.push(buf);
        this.length += buf.length;
      }
      return this.length;
    };
    Buffers.prototype.unshift = function() {
      for (var i = 0; i < arguments.length; i++) {
        if (!Buffer.isBuffer(arguments[i])) {
          throw new TypeError("Tried to unshift a non-buffer");
        }
      }
      for (var i = 0; i < arguments.length; i++) {
        var buf = arguments[i];
        this.buffers.unshift(buf);
        this.length += buf.length;
      }
      return this.length;
    };
    Buffers.prototype.copy = function(dst, dStart, start, end) {
      return this.slice(start, end).copy(dst, dStart, 0, end - start);
    };
    Buffers.prototype.splice = function(i, howMany) {
      var buffers = this.buffers;
      var index = i >= 0 ? i : this.length - i;
      var reps = [].slice.call(arguments, 2);
      if (howMany === void 0) {
        howMany = this.length - index;
      } else if (howMany > this.length - index) {
        howMany = this.length - index;
      }
      for (var i = 0; i < reps.length; i++) {
        this.length += reps[i].length;
      }
      var removed = new Buffers();
      var bytes2 = 0;
      var startBytes = 0;
      for (var ii = 0; ii < buffers.length && startBytes + buffers[ii].length < index; ii++) {
        startBytes += buffers[ii].length;
      }
      if (index - startBytes > 0) {
        var start = index - startBytes;
        if (start + howMany < buffers[ii].length) {
          removed.push(buffers[ii].slice(start, start + howMany));
          var orig = buffers[ii];
          var buf0 = new Buffer(start);
          for (var i = 0; i < start; i++) {
            buf0[i] = orig[i];
          }
          var buf1 = new Buffer(orig.length - start - howMany);
          for (var i = start + howMany; i < orig.length; i++) {
            buf1[i - howMany - start] = orig[i];
          }
          if (reps.length > 0) {
            var reps_ = reps.slice();
            reps_.unshift(buf0);
            reps_.push(buf1);
            buffers.splice.apply(buffers, [ii, 1].concat(reps_));
            ii += reps_.length;
            reps = [];
          } else {
            buffers.splice(ii, 1, buf0, buf1);
            ii += 2;
          }
        } else {
          removed.push(buffers[ii].slice(start));
          buffers[ii] = buffers[ii].slice(0, start);
          ii++;
        }
      }
      if (reps.length > 0) {
        buffers.splice.apply(buffers, [ii, 0].concat(reps));
        ii += reps.length;
      }
      while (removed.length < howMany) {
        var buf = buffers[ii];
        var len = buf.length;
        var take = Math.min(len, howMany - removed.length);
        if (take === len) {
          removed.push(buf);
          buffers.splice(ii, 1);
        } else {
          removed.push(buf.slice(0, take));
          buffers[ii] = buffers[ii].slice(take);
        }
      }
      this.length -= removed.length;
      return removed;
    };
    Buffers.prototype.slice = function(i, j) {
      var buffers = this.buffers;
      if (j === void 0)
        j = this.length;
      if (i === void 0)
        i = 0;
      if (j > this.length)
        j = this.length;
      var startBytes = 0;
      for (var si = 0; si < buffers.length && startBytes + buffers[si].length <= i; si++) {
        startBytes += buffers[si].length;
      }
      var target = new Buffer(j - i);
      var ti = 0;
      for (var ii = si; ti < j - i && ii < buffers.length; ii++) {
        var len = buffers[ii].length;
        var start = ti === 0 ? i - startBytes : 0;
        var end = ti + len >= j - i ? Math.min(start + (j - i) - ti, len) : len;
        buffers[ii].copy(target, ti, start, end);
        ti += end - start;
      }
      return target;
    };
    Buffers.prototype.pos = function(i) {
      if (i < 0 || i >= this.length)
        throw new Error("oob");
      var l = i, bi = 0, bu = null;
      for (; ; ) {
        bu = this.buffers[bi];
        if (l < bu.length) {
          return { buf: bi, offset: l };
        } else {
          l -= bu.length;
        }
        bi++;
      }
    };
    Buffers.prototype.get = function get(i) {
      var pos = this.pos(i);
      return this.buffers[pos.buf].get(pos.offset);
    };
    Buffers.prototype.set = function set(i, b) {
      var pos = this.pos(i);
      return this.buffers[pos.buf].set(pos.offset, b);
    };
    Buffers.prototype.indexOf = function(needle, offset) {
      if (typeof needle === "string") {
        needle = new Buffer(needle);
      } else if (needle instanceof Buffer) {
      } else {
        throw new Error("Invalid type for a search string");
      }
      if (!needle.length) {
        return 0;
      }
      if (!this.length) {
        return -1;
      }
      var i = 0, j = 0, match = 0, mstart, pos = 0;
      if (offset) {
        var p = this.pos(offset);
        i = p.buf;
        j = p.offset;
        pos = offset;
      }
      for (; ; ) {
        while (j >= this.buffers[i].length) {
          j = 0;
          i++;
          if (i >= this.buffers.length) {
            return -1;
          }
        }
        var char = this.buffers[i][j];
        if (char == needle[match]) {
          if (match == 0) {
            mstart = {
              i,
              j,
              pos
            };
          }
          match++;
          if (match == needle.length) {
            return mstart.pos;
          }
        } else if (match != 0) {
          i = mstart.i;
          j = mstart.j;
          pos = mstart.pos;
          match = 0;
        }
        j++;
        pos++;
      }
    };
    Buffers.prototype.toBuffer = function() {
      return this.slice();
    };
    Buffers.prototype.toString = function(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
  }
});

// node_modules/binary/lib/vars.js
var require_vars = __commonJS({
  "node_modules/binary/lib/vars.js"(exports, module2) {
    module2.exports = function(store) {
      function getset(name2, value) {
        var node = vars.store;
        var keys = name2.split(".");
        keys.slice(0, -1).forEach(function(k) {
          if (node[k] === void 0)
            node[k] = {};
          node = node[k];
        });
        var key = keys[keys.length - 1];
        if (arguments.length == 1) {
          return node[key];
        } else {
          return node[key] = value;
        }
      }
      var vars = {
        get: function(name2) {
          return getset(name2);
        },
        set: function(name2, value) {
          return getset(name2, value);
        },
        store: store || {}
      };
      return vars;
    };
  }
});

// node_modules/binary/index.js
var require_binary = __commonJS({
  "node_modules/binary/index.js"(exports, module2) {
    var Chainsaw = require_chainsaw();
    var EventEmitter8 = require("events").EventEmitter;
    var Buffers = require_buffers();
    var Vars = require_vars();
    var Stream = require("stream").Stream;
    exports = module2.exports = function(bufOrEm, eventName) {
      if (Buffer.isBuffer(bufOrEm)) {
        return exports.parse(bufOrEm);
      }
      var s = exports.stream();
      if (bufOrEm && bufOrEm.pipe) {
        bufOrEm.pipe(s);
      } else if (bufOrEm) {
        bufOrEm.on(eventName || "data", function(buf) {
          s.write(buf);
        });
        bufOrEm.on("end", function() {
          s.end();
        });
      }
      return s;
    };
    exports.stream = function(input) {
      if (input)
        return exports.apply(null, arguments);
      var pending = null;
      function getBytes(bytes2, cb, skip) {
        pending = {
          bytes: bytes2,
          skip,
          cb: function(buf) {
            pending = null;
            cb(buf);
          }
        };
        dispatch();
      }
      var offset = null;
      function dispatch() {
        if (!pending) {
          if (caughtEnd)
            done = true;
          return;
        }
        if (typeof pending === "function") {
          pending();
        } else {
          var bytes2 = offset + pending.bytes;
          if (buffers.length >= bytes2) {
            var buf;
            if (offset == null) {
              buf = buffers.splice(0, bytes2);
              if (!pending.skip) {
                buf = buf.slice();
              }
            } else {
              if (!pending.skip) {
                buf = buffers.slice(offset, bytes2);
              }
              offset = bytes2;
            }
            if (pending.skip) {
              pending.cb();
            } else {
              pending.cb(buf);
            }
          }
        }
      }
      function builder(saw) {
        function next() {
          if (!done)
            saw.next();
        }
        var self2 = words(function(bytes2, cb) {
          return function(name2) {
            getBytes(bytes2, function(buf) {
              vars.set(name2, cb(buf));
              next();
            });
          };
        });
        self2.tap = function(cb) {
          saw.nest(cb, vars.store);
        };
        self2.into = function(key, cb) {
          if (!vars.get(key))
            vars.set(key, {});
          var parent = vars;
          vars = Vars(parent.get(key));
          saw.nest(function() {
            cb.apply(this, arguments);
            this.tap(function() {
              vars = parent;
            });
          }, vars.store);
        };
        self2.flush = function() {
          vars.store = {};
          next();
        };
        self2.loop = function(cb) {
          var end = false;
          saw.nest(false, function loop() {
            this.vars = vars.store;
            cb.call(this, function() {
              end = true;
              next();
            }, vars.store);
            this.tap(function() {
              if (end)
                saw.next();
              else
                loop.call(this);
            }.bind(this));
          }, vars.store);
        };
        self2.buffer = function(name2, bytes2) {
          if (typeof bytes2 === "string") {
            bytes2 = vars.get(bytes2);
          }
          getBytes(bytes2, function(buf) {
            vars.set(name2, buf);
            next();
          });
        };
        self2.skip = function(bytes2) {
          if (typeof bytes2 === "string") {
            bytes2 = vars.get(bytes2);
          }
          getBytes(bytes2, function() {
            next();
          });
        };
        self2.scan = function find(name2, search) {
          if (typeof search === "string") {
            search = new Buffer(search);
          } else if (!Buffer.isBuffer(search)) {
            throw new Error("search must be a Buffer or a string");
          }
          var taken = 0;
          pending = function() {
            var pos = buffers.indexOf(search, offset + taken);
            var i = pos - offset - taken;
            if (pos !== -1) {
              pending = null;
              if (offset != null) {
                vars.set(name2, buffers.slice(offset, offset + taken + i));
                offset += taken + i + search.length;
              } else {
                vars.set(name2, buffers.slice(0, taken + i));
                buffers.splice(0, taken + i + search.length);
              }
              next();
              dispatch();
            } else {
              i = Math.max(buffers.length - search.length - offset - taken, 0);
            }
            taken += i;
          };
          dispatch();
        };
        self2.peek = function(cb) {
          offset = 0;
          saw.nest(function() {
            cb.call(this, vars.store);
            this.tap(function() {
              offset = null;
            });
          });
        };
        return self2;
      }
      ;
      var stream = Chainsaw.light(builder);
      stream.writable = true;
      var buffers = Buffers();
      stream.write = function(buf) {
        buffers.push(buf);
        dispatch();
      };
      var vars = Vars();
      var done = false, caughtEnd = false;
      stream.end = function() {
        caughtEnd = true;
      };
      stream.pipe = Stream.prototype.pipe;
      Object.getOwnPropertyNames(EventEmitter8.prototype).forEach(function(name2) {
        stream[name2] = EventEmitter8.prototype[name2];
      });
      return stream;
    };
    exports.parse = function parse4(buffer) {
      var self2 = words(function(bytes2, cb) {
        return function(name2) {
          if (offset + bytes2 <= buffer.length) {
            var buf = buffer.slice(offset, offset + bytes2);
            offset += bytes2;
            vars.set(name2, cb(buf));
          } else {
            vars.set(name2, null);
          }
          return self2;
        };
      });
      var offset = 0;
      var vars = Vars();
      self2.vars = vars.store;
      self2.tap = function(cb) {
        cb.call(self2, vars.store);
        return self2;
      };
      self2.into = function(key, cb) {
        if (!vars.get(key)) {
          vars.set(key, {});
        }
        var parent = vars;
        vars = Vars(parent.get(key));
        cb.call(self2, vars.store);
        vars = parent;
        return self2;
      };
      self2.loop = function(cb) {
        var end = false;
        var ender = function() {
          end = true;
        };
        while (end === false) {
          cb.call(self2, ender, vars.store);
        }
        return self2;
      };
      self2.buffer = function(name2, size) {
        if (typeof size === "string") {
          size = vars.get(size);
        }
        var buf = buffer.slice(offset, Math.min(buffer.length, offset + size));
        offset += size;
        vars.set(name2, buf);
        return self2;
      };
      self2.skip = function(bytes2) {
        if (typeof bytes2 === "string") {
          bytes2 = vars.get(bytes2);
        }
        offset += bytes2;
        return self2;
      };
      self2.scan = function(name2, search) {
        if (typeof search === "string") {
          search = new Buffer(search);
        } else if (!Buffer.isBuffer(search)) {
          throw new Error("search must be a Buffer or a string");
        }
        vars.set(name2, null);
        for (var i = 0; i + offset <= buffer.length - search.length + 1; i++) {
          for (var j = 0; j < search.length && buffer[offset + i + j] === search[j]; j++)
            ;
          if (j === search.length)
            break;
        }
        vars.set(name2, buffer.slice(offset, offset + i));
        offset += i + search.length;
        return self2;
      };
      self2.peek = function(cb) {
        var was = offset;
        cb.call(self2, vars.store);
        offset = was;
        return self2;
      };
      self2.flush = function() {
        vars.store = {};
        return self2;
      };
      self2.eof = function() {
        return offset >= buffer.length;
      };
      return self2;
    };
    function decodeLEu(bytes2) {
      var acc = 0;
      for (var i = 0; i < bytes2.length; i++) {
        acc += Math.pow(256, i) * bytes2[i];
      }
      return acc;
    }
    function decodeBEu(bytes2) {
      var acc = 0;
      for (var i = 0; i < bytes2.length; i++) {
        acc += Math.pow(256, bytes2.length - i - 1) * bytes2[i];
      }
      return acc;
    }
    function decodeBEs(bytes2) {
      var val = decodeBEu(bytes2);
      if ((bytes2[0] & 128) == 128) {
        val -= Math.pow(256, bytes2.length);
      }
      return val;
    }
    function decodeLEs(bytes2) {
      var val = decodeLEu(bytes2);
      if ((bytes2[bytes2.length - 1] & 128) == 128) {
        val -= Math.pow(256, bytes2.length);
      }
      return val;
    }
    function words(decode) {
      var self2 = {};
      [1, 2, 4, 8].forEach(function(bytes2) {
        var bits = bytes2 * 8;
        self2["word" + bits + "le"] = self2["word" + bits + "lu"] = decode(bytes2, decodeLEu);
        self2["word" + bits + "ls"] = decode(bytes2, decodeLEs);
        self2["word" + bits + "be"] = self2["word" + bits + "bu"] = decode(bytes2, decodeBEu);
        self2["word" + bits + "bs"] = decode(bytes2, decodeBEs);
      });
      self2.word8 = self2.word8u = self2.word8be;
      self2.word8s = self2.word8bs;
      return self2;
    }
  }
});

// node_modules/unzip-stream/lib/matcher-stream.js
var require_matcher_stream = __commonJS({
  "node_modules/unzip-stream/lib/matcher-stream.js"(exports, module2) {
    var Transform2 = require("stream").Transform;
    var util4 = require("util");
    function MatcherStream(patternDesc, matchFn) {
      if (!(this instanceof MatcherStream)) {
        return new MatcherStream();
      }
      Transform2.call(this);
      var p = typeof patternDesc === "object" ? patternDesc.pattern : patternDesc;
      this.pattern = Buffer.isBuffer(p) ? p : Buffer.from(p);
      this.requiredLength = this.pattern.length;
      if (patternDesc.requiredExtraSize)
        this.requiredLength += patternDesc.requiredExtraSize;
      this.data = new Buffer("");
      this.bytesSoFar = 0;
      this.matchFn = matchFn;
    }
    util4.inherits(MatcherStream, Transform2);
    MatcherStream.prototype.checkDataChunk = function(ignoreMatchZero) {
      var enoughData = this.data.length >= this.requiredLength;
      if (!enoughData) {
        return;
      }
      var matchIndex = this.data.indexOf(this.pattern, ignoreMatchZero ? 1 : 0);
      if (matchIndex >= 0 && matchIndex + this.requiredLength > this.data.length) {
        if (matchIndex > 0) {
          var packet = this.data.slice(0, matchIndex);
          this.push(packet);
          this.bytesSoFar += matchIndex;
          this.data = this.data.slice(matchIndex);
        }
        return;
      }
      if (matchIndex === -1) {
        var packetLen = this.data.length - this.requiredLength + 1;
        var packet = this.data.slice(0, packetLen);
        this.push(packet);
        this.bytesSoFar += packetLen;
        this.data = this.data.slice(packetLen);
        return;
      }
      if (matchIndex > 0) {
        var packet = this.data.slice(0, matchIndex);
        this.data = this.data.slice(matchIndex);
        this.push(packet);
        this.bytesSoFar += matchIndex;
      }
      var finished = this.matchFn ? this.matchFn(this.data, this.bytesSoFar) : true;
      if (finished) {
        this.data = new Buffer("");
        return;
      }
      return true;
    };
    MatcherStream.prototype._transform = function(chunk, encoding, cb) {
      this.data = Buffer.concat([this.data, chunk]);
      var firstIteration = true;
      while (this.checkDataChunk(!firstIteration)) {
        firstIteration = false;
      }
      cb();
    };
    MatcherStream.prototype._flush = function(cb) {
      if (this.data.length > 0) {
        var firstIteration = true;
        while (this.checkDataChunk(!firstIteration)) {
          firstIteration = false;
        }
      }
      if (this.data.length > 0) {
        this.push(this.data);
        this.data = null;
      }
      cb();
    };
    module2.exports = MatcherStream;
  }
});

// node_modules/unzip-stream/lib/entry.js
var require_entry = __commonJS({
  "node_modules/unzip-stream/lib/entry.js"(exports, module2) {
    "use strict";
    var stream = require("stream");
    var inherits = require("util").inherits;
    function Entry() {
      if (!(this instanceof Entry)) {
        return new Entry();
      }
      stream.PassThrough.call(this);
      this.path = null;
      this.type = null;
      this.isDirectory = false;
    }
    inherits(Entry, stream.PassThrough);
    Entry.prototype.autodrain = function() {
      return this.pipe(new stream.Transform({ transform: function(d, e, cb) {
        cb();
      } }));
    };
    module2.exports = Entry;
  }
});

// node_modules/unzip-stream/lib/unzip-stream.js
var require_unzip_stream = __commonJS({
  "node_modules/unzip-stream/lib/unzip-stream.js"(exports, module2) {
    "use strict";
    var binary = require_binary();
    var stream = require("stream");
    var util4 = require("util");
    var zlib = require("zlib");
    var MatcherStream = require_matcher_stream();
    var Entry = require_entry();
    var states = {
      STREAM_START: 0,
      START: 1,
      LOCAL_FILE_HEADER: 2,
      LOCAL_FILE_HEADER_SUFFIX: 3,
      FILE_DATA: 4,
      FILE_DATA_END: 5,
      DATA_DESCRIPTOR: 6,
      CENTRAL_DIRECTORY_FILE_HEADER: 7,
      CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX: 8,
      CDIR64_END: 9,
      CDIR64_END_DATA_SECTOR: 10,
      CDIR64_LOCATOR: 11,
      CENTRAL_DIRECTORY_END: 12,
      CENTRAL_DIRECTORY_END_COMMENT: 13,
      TRAILING_JUNK: 14,
      ERROR: 99
    };
    var FOUR_GIGS = 4294967296;
    var SIG_LOCAL_FILE_HEADER = 67324752;
    var SIG_DATA_DESCRIPTOR = 134695760;
    var SIG_CDIR_RECORD = 33639248;
    var SIG_CDIR64_RECORD_END = 101075792;
    var SIG_CDIR64_LOCATOR_END = 117853008;
    var SIG_CDIR_RECORD_END = 101010256;
    function UnzipStream(options2) {
      if (!(this instanceof UnzipStream)) {
        return new UnzipStream(options2);
      }
      stream.Transform.call(this);
      this.options = options2 || {};
      this.data = new Buffer("");
      this.state = states.STREAM_START;
      this.skippedBytes = 0;
      this.parsedEntity = null;
      this.outStreamInfo = {};
    }
    util4.inherits(UnzipStream, stream.Transform);
    UnzipStream.prototype.processDataChunk = function(chunk) {
      var requiredLength;
      switch (this.state) {
        case states.STREAM_START:
        case states.START:
          requiredLength = 4;
          break;
        case states.LOCAL_FILE_HEADER:
          requiredLength = 26;
          break;
        case states.LOCAL_FILE_HEADER_SUFFIX:
          requiredLength = this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength;
          break;
        case states.DATA_DESCRIPTOR:
          requiredLength = 12;
          break;
        case states.CENTRAL_DIRECTORY_FILE_HEADER:
          requiredLength = 42;
          break;
        case states.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX:
          requiredLength = this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength + this.parsedEntity.fileCommentLength;
          break;
        case states.CDIR64_END:
          requiredLength = 52;
          break;
        case states.CDIR64_END_DATA_SECTOR:
          requiredLength = this.parsedEntity.centralDirectoryRecordSize - 44;
          break;
        case states.CDIR64_LOCATOR:
          requiredLength = 16;
          break;
        case states.CENTRAL_DIRECTORY_END:
          requiredLength = 18;
          break;
        case states.CENTRAL_DIRECTORY_END_COMMENT:
          requiredLength = this.parsedEntity.commentLength;
          break;
        case states.FILE_DATA:
          return 0;
        case states.FILE_DATA_END:
          return 0;
        case states.TRAILING_JUNK:
          if (this.options.debug)
            console.log("found", chunk.length, "bytes of TRAILING_JUNK");
          return chunk.length;
        default:
          return chunk.length;
      }
      var chunkLength = chunk.length;
      if (chunkLength < requiredLength) {
        return 0;
      }
      switch (this.state) {
        case states.STREAM_START:
        case states.START:
          var signature = chunk.readUInt32LE(0);
          switch (signature) {
            case SIG_LOCAL_FILE_HEADER:
              this.state = states.LOCAL_FILE_HEADER;
              break;
            case SIG_CDIR_RECORD:
              this.state = states.CENTRAL_DIRECTORY_FILE_HEADER;
              break;
            case SIG_CDIR64_RECORD_END:
              this.state = states.CDIR64_END;
              break;
            case SIG_CDIR64_LOCATOR_END:
              this.state = states.CDIR64_LOCATOR;
              break;
            case SIG_CDIR_RECORD_END:
              this.state = states.CENTRAL_DIRECTORY_END;
              break;
            default:
              var isStreamStart = this.state === states.STREAM_START;
              if (!isStreamStart && (signature & 65535) !== 19280 && this.skippedBytes < 26) {
                var remaining = signature;
                var toSkip = 4;
                for (var i = 1; i < 4 && remaining !== 0; i++) {
                  remaining = remaining >>> 8;
                  if ((remaining & 255) === 80) {
                    toSkip = i;
                    break;
                  }
                }
                this.skippedBytes += toSkip;
                if (this.options.debug)
                  console.log("Skipped", this.skippedBytes, "bytes");
                return toSkip;
              }
              this.state = states.ERROR;
              var errMsg = isStreamStart ? "Not a valid zip file" : "Invalid signature in zip file";
              if (this.options.debug) {
                var sig = chunk.readUInt32LE(0);
                var asString;
                try {
                  asString = chunk.slice(0, 4).toString();
                } catch (e) {
                }
                console.log("Unexpected signature in zip file: 0x" + sig.toString(16), '"' + asString + '", skipped', this.skippedBytes, "bytes");
              }
              this.emit("error", new Error(errMsg));
              return chunk.length;
          }
          this.skippedBytes = 0;
          return requiredLength;
        case states.LOCAL_FILE_HEADER:
          this.parsedEntity = this._readFile(chunk);
          this.state = states.LOCAL_FILE_HEADER_SUFFIX;
          return requiredLength;
        case states.LOCAL_FILE_HEADER_SUFFIX:
          var entry = new Entry();
          var isUtf8 = (this.parsedEntity.flags & 2048) !== 0;
          entry.path = this._decodeString(chunk.slice(0, this.parsedEntity.fileNameLength), isUtf8);
          var extraDataBuffer = chunk.slice(this.parsedEntity.fileNameLength, this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength);
          var extra = this._readExtraFields(extraDataBuffer);
          if (extra && extra.parsed) {
            if (extra.parsed.path && !isUtf8) {
              entry.path = extra.parsed.path;
            }
            if (Number.isFinite(extra.parsed.uncompressedSize) && this.parsedEntity.uncompressedSize === FOUR_GIGS - 1) {
              this.parsedEntity.uncompressedSize = extra.parsed.uncompressedSize;
            }
            if (Number.isFinite(extra.parsed.compressedSize) && this.parsedEntity.compressedSize === FOUR_GIGS - 1) {
              this.parsedEntity.compressedSize = extra.parsed.compressedSize;
            }
          }
          this.parsedEntity.extra = extra.parsed || {};
          if (this.options.debug) {
            const debugObj = Object.assign({}, this.parsedEntity, {
              path: entry.path,
              flags: "0x" + this.parsedEntity.flags.toString(16),
              extraFields: extra && extra.debug
            });
            console.log("decoded LOCAL_FILE_HEADER:", JSON.stringify(debugObj, null, 2));
          }
          this._prepareOutStream(this.parsedEntity, entry);
          this.emit("entry", entry);
          this.state = states.FILE_DATA;
          return requiredLength;
        case states.CENTRAL_DIRECTORY_FILE_HEADER:
          this.parsedEntity = this._readCentralDirectoryEntry(chunk);
          this.state = states.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX;
          return requiredLength;
        case states.CENTRAL_DIRECTORY_FILE_HEADER_SUFFIX:
          var isUtf8 = (this.parsedEntity.flags & 2048) !== 0;
          var path41 = this._decodeString(chunk.slice(0, this.parsedEntity.fileNameLength), isUtf8);
          var extraDataBuffer = chunk.slice(this.parsedEntity.fileNameLength, this.parsedEntity.fileNameLength + this.parsedEntity.extraFieldLength);
          var extra = this._readExtraFields(extraDataBuffer);
          if (extra && extra.parsed && extra.parsed.path && !isUtf8) {
            path41 = extra.parsed.path;
          }
          this.parsedEntity.extra = extra.parsed;
          var isUnix = (this.parsedEntity.versionMadeBy & 65280) >> 8 === 3;
          var unixAttrs, isSymlink;
          if (isUnix) {
            unixAttrs = this.parsedEntity.externalFileAttributes >>> 16;
            var fileType = unixAttrs >>> 12;
            isSymlink = (fileType & 10) === 10;
          }
          if (this.options.debug) {
            const debugObj = Object.assign({}, this.parsedEntity, {
              path: path41,
              flags: "0x" + this.parsedEntity.flags.toString(16),
              unixAttrs: unixAttrs && "0" + unixAttrs.toString(8),
              isSymlink,
              extraFields: extra.debug
            });
            console.log("decoded CENTRAL_DIRECTORY_FILE_HEADER:", JSON.stringify(debugObj, null, 2));
          }
          this.state = states.START;
          return requiredLength;
        case states.CDIR64_END:
          this.parsedEntity = this._readEndOfCentralDirectory64(chunk);
          if (this.options.debug) {
            console.log("decoded CDIR64_END_RECORD:", this.parsedEntity);
          }
          this.state = states.CDIR64_END_DATA_SECTOR;
          return requiredLength;
        case states.CDIR64_END_DATA_SECTOR:
          this.state = states.START;
          return requiredLength;
        case states.CDIR64_LOCATOR:
          this.state = states.START;
          return requiredLength;
        case states.CENTRAL_DIRECTORY_END:
          this.parsedEntity = this._readEndOfCentralDirectory(chunk);
          if (this.options.debug) {
            console.log("decoded CENTRAL_DIRECTORY_END:", this.parsedEntity);
          }
          this.state = states.CENTRAL_DIRECTORY_END_COMMENT;
          return requiredLength;
        case states.CENTRAL_DIRECTORY_END_COMMENT:
          if (this.options.debug) {
            console.log("decoded CENTRAL_DIRECTORY_END_COMMENT:", chunk.slice(0, requiredLength).toString());
          }
          this.state = states.TRAILING_JUNK;
          return requiredLength;
        case states.ERROR:
          return chunk.length;
        default:
          console.log("didn't handle state #", this.state, "discarding");
          return chunk.length;
      }
    };
    UnzipStream.prototype._prepareOutStream = function(vars, entry) {
      var self2 = this;
      var isDirectory = vars.uncompressedSize === 0 && /[\/\\]$/.test(entry.path);
      entry.path = entry.path.replace(/^([/\\]*[.]+[/\\]+)*[/\\]*/, "");
      entry.type = isDirectory ? "Directory" : "File";
      entry.isDirectory = isDirectory;
      var fileSizeKnown = !(vars.flags & 8);
      if (fileSizeKnown) {
        entry.size = vars.uncompressedSize;
      }
      var isVersionSupported = vars.versionsNeededToExtract <= 45;
      this.outStreamInfo = {
        stream: null,
        limit: fileSizeKnown ? vars.compressedSize : -1,
        written: 0
      };
      if (!fileSizeKnown) {
        var pattern = new Buffer(4);
        pattern.writeUInt32LE(SIG_DATA_DESCRIPTOR, 0);
        var zip64Mode = vars.extra.zip64Mode;
        var extraSize = zip64Mode ? 20 : 12;
        var searchPattern = {
          pattern,
          requiredExtraSize: extraSize
        };
        var matcherStream = new MatcherStream(searchPattern, function(matchedChunk, sizeSoFar) {
          var vars2 = self2._readDataDescriptor(matchedChunk, zip64Mode);
          var compressedSizeMatches = vars2.compressedSize === sizeSoFar;
          if (!zip64Mode && !compressedSizeMatches && sizeSoFar >= FOUR_GIGS) {
            var overflown = sizeSoFar - FOUR_GIGS;
            while (overflown >= 0) {
              compressedSizeMatches = vars2.compressedSize === overflown;
              if (compressedSizeMatches)
                break;
              overflown -= FOUR_GIGS;
            }
          }
          if (!compressedSizeMatches) {
            return;
          }
          self2.state = states.FILE_DATA_END;
          var sliceOffset = zip64Mode ? 24 : 16;
          if (self2.data.length > 0) {
            self2.data = Buffer.concat([matchedChunk.slice(sliceOffset), self2.data]);
          } else {
            self2.data = matchedChunk.slice(sliceOffset);
          }
          return true;
        });
        this.outStreamInfo.stream = matcherStream;
      } else {
        this.outStreamInfo.stream = new stream.PassThrough();
      }
      var isEncrypted = vars.flags & 1 || vars.flags & 64;
      if (isEncrypted || !isVersionSupported) {
        var message = isEncrypted ? "Encrypted files are not supported!" : "Zip version " + Math.floor(vars.versionsNeededToExtract / 10) + "." + vars.versionsNeededToExtract % 10 + " is not supported";
        entry.skip = true;
        setImmediate(() => {
          entry.emit("error", new Error(message));
        });
        this.outStreamInfo.stream.pipe(new Entry().autodrain());
        return;
      }
      var isCompressed = vars.compressionMethod > 0;
      if (isCompressed) {
        var inflater = zlib.createInflateRaw();
        inflater.on("error", function(err) {
          self2.state = states.ERROR;
          self2.emit("error", err);
        });
        this.outStreamInfo.stream.pipe(inflater).pipe(entry);
      } else {
        this.outStreamInfo.stream.pipe(entry);
      }
      if (this._drainAllEntries) {
        entry.autodrain();
      }
    };
    UnzipStream.prototype._readFile = function(data) {
      var vars = binary.parse(data).word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").vars;
      return vars;
    };
    UnzipStream.prototype._readExtraFields = function(data) {
      var extra = {};
      var result = { parsed: extra };
      if (this.options.debug) {
        result.debug = [];
      }
      var index = 0;
      while (index < data.length) {
        var vars = binary.parse(data).skip(index).word16lu("extraId").word16lu("extraSize").vars;
        index += 4;
        var fieldType = void 0;
        switch (vars.extraId) {
          case 1:
            fieldType = "Zip64 extended information extra field";
            var z64vars = binary.parse(data.slice(index, index + vars.extraSize)).word64lu("uncompressedSize").word64lu("compressedSize").word64lu("offsetToLocalHeader").word32lu("diskStartNumber").vars;
            if (z64vars.uncompressedSize !== null) {
              extra.uncompressedSize = z64vars.uncompressedSize;
            }
            if (z64vars.compressedSize !== null) {
              extra.compressedSize = z64vars.compressedSize;
            }
            extra.zip64Mode = true;
            break;
          case 10:
            fieldType = "NTFS extra field";
            break;
          case 21589:
            fieldType = "extended timestamp";
            var timestampFields = data.readUInt8(index);
            var offset = 1;
            if (vars.extraSize >= offset + 4 && timestampFields & 1) {
              extra.mtime = new Date(data.readUInt32LE(index + offset) * 1e3);
              offset += 4;
            }
            if (vars.extraSize >= offset + 4 && timestampFields & 2) {
              extra.atime = new Date(data.readUInt32LE(index + offset) * 1e3);
              offset += 4;
            }
            if (vars.extraSize >= offset + 4 && timestampFields & 4) {
              extra.ctime = new Date(data.readUInt32LE(index + offset) * 1e3);
            }
            break;
          case 28789:
            fieldType = "Info-ZIP Unicode Path Extra Field";
            var fieldVer = data.readUInt8(index);
            if (fieldVer === 1) {
              var offset = 1;
              var nameCrc32 = data.readUInt32LE(index + offset);
              offset += 4;
              var pathBuffer = data.slice(index + offset);
              extra.path = pathBuffer.toString();
            }
            break;
          case 13:
          case 22613:
            fieldType = vars.extraId === 13 ? "PKWARE Unix" : "Info-ZIP UNIX (type 1)";
            var offset = 0;
            if (vars.extraSize >= 8) {
              var atime = new Date(data.readUInt32LE(index + offset) * 1e3);
              offset += 4;
              var mtime = new Date(data.readUInt32LE(index + offset) * 1e3);
              offset += 4;
              extra.atime = atime;
              extra.mtime = mtime;
              if (vars.extraSize >= 12) {
                var uid = data.readUInt16LE(index + offset);
                offset += 2;
                var gid = data.readUInt16LE(index + offset);
                offset += 2;
                extra.uid = uid;
                extra.gid = gid;
              }
            }
            break;
          case 30805:
            fieldType = "Info-ZIP UNIX (type 2)";
            var offset = 0;
            if (vars.extraSize >= 4) {
              var uid = data.readUInt16LE(index + offset);
              offset += 2;
              var gid = data.readUInt16LE(index + offset);
              offset += 2;
              extra.uid = uid;
              extra.gid = gid;
            }
            break;
          case 30837:
            fieldType = "Info-ZIP New Unix";
            var offset = 0;
            var extraVer = data.readUInt8(index);
            offset += 1;
            if (extraVer === 1) {
              var uidSize = data.readUInt8(index + offset);
              offset += 1;
              if (uidSize <= 6) {
                extra.uid = data.readUIntLE(index + offset, uidSize);
              }
              offset += uidSize;
              var gidSize = data.readUInt8(index + offset);
              offset += 1;
              if (gidSize <= 6) {
                extra.gid = data.readUIntLE(index + offset, gidSize);
              }
            }
            break;
          case 30062:
            fieldType = "ASi Unix";
            var offset = 0;
            if (vars.extraSize >= 14) {
              var crc = data.readUInt32LE(index + offset);
              offset += 4;
              var mode = data.readUInt16LE(index + offset);
              offset += 2;
              var sizdev = data.readUInt32LE(index + offset);
              offset += 4;
              var uid = data.readUInt16LE(index + offset);
              offset += 2;
              var gid = data.readUInt16LE(index + offset);
              offset += 2;
              extra.mode = mode;
              extra.uid = uid;
              extra.gid = gid;
              if (vars.extraSize > 14) {
                var start = index + offset;
                var end = index + vars.extraSize - 14;
                var symlinkName = this._decodeString(data.slice(start, end));
                extra.symlink = symlinkName;
              }
            }
            break;
        }
        if (this.options.debug) {
          result.debug.push({
            extraId: "0x" + vars.extraId.toString(16),
            description: fieldType,
            data: data.slice(index, index + vars.extraSize).inspect()
          });
        }
        index += vars.extraSize;
      }
      return result;
    };
    UnzipStream.prototype._readDataDescriptor = function(data, zip64Mode) {
      if (zip64Mode) {
        var vars = binary.parse(data).word32lu("dataDescriptorSignature").word32lu("crc32").word64lu("compressedSize").word64lu("uncompressedSize").vars;
        return vars;
      }
      var vars = binary.parse(data).word32lu("dataDescriptorSignature").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").vars;
      return vars;
    };
    UnzipStream.prototype._readCentralDirectoryEntry = function(data) {
      var vars = binary.parse(data).word16lu("versionMadeBy").word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").word16lu("fileCommentLength").word16lu("diskNumber").word16lu("internalFileAttributes").word32lu("externalFileAttributes").word32lu("offsetToLocalFileHeader").vars;
      return vars;
    };
    UnzipStream.prototype._readEndOfCentralDirectory64 = function(data) {
      var vars = binary.parse(data).word64lu("centralDirectoryRecordSize").word16lu("versionMadeBy").word16lu("versionsNeededToExtract").word32lu("diskNumber").word32lu("diskNumberWithCentralDirectoryStart").word64lu("centralDirectoryEntries").word64lu("totalCentralDirectoryEntries").word64lu("sizeOfCentralDirectory").word64lu("offsetToStartOfCentralDirectory").vars;
      return vars;
    };
    UnzipStream.prototype._readEndOfCentralDirectory = function(data) {
      var vars = binary.parse(data).word16lu("diskNumber").word16lu("diskStart").word16lu("centralDirectoryEntries").word16lu("totalCentralDirectoryEntries").word32lu("sizeOfCentralDirectory").word32lu("offsetToStartOfCentralDirectory").word16lu("commentLength").vars;
      return vars;
    };
    var cp437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0 ";
    UnzipStream.prototype._decodeString = function(buffer, isUtf8) {
      if (isUtf8) {
        return buffer.toString("utf8");
      }
      if (this.options.decodeString) {
        return this.options.decodeString(buffer);
      }
      let result = "";
      for (var i = 0; i < buffer.length; i++) {
        result += cp437[buffer[i]];
      }
      return result;
    };
    UnzipStream.prototype._parseOrOutput = function(encoding, cb) {
      var consume;
      while ((consume = this.processDataChunk(this.data)) > 0) {
        this.data = this.data.slice(consume);
        if (this.data.length === 0)
          break;
      }
      if (this.state === states.FILE_DATA) {
        if (this.outStreamInfo.limit >= 0) {
          var remaining = this.outStreamInfo.limit - this.outStreamInfo.written;
          var packet;
          if (remaining < this.data.length) {
            packet = this.data.slice(0, remaining);
            this.data = this.data.slice(remaining);
          } else {
            packet = this.data;
            this.data = new Buffer("");
          }
          this.outStreamInfo.written += packet.length;
          if (this.outStreamInfo.limit === this.outStreamInfo.written) {
            this.state = states.START;
            this.outStreamInfo.stream.end(packet, encoding, cb);
          } else {
            this.outStreamInfo.stream.write(packet, encoding, cb);
          }
        } else {
          var packet = this.data;
          this.data = new Buffer("");
          this.outStreamInfo.written += packet.length;
          var outputStream = this.outStreamInfo.stream;
          outputStream.write(packet, encoding, () => {
            if (this.state === states.FILE_DATA_END) {
              this.state = states.START;
              return outputStream.end(cb);
            }
            cb();
          });
        }
        return;
      }
      cb();
    };
    UnzipStream.prototype.drainAll = function() {
      this._drainAllEntries = true;
    };
    UnzipStream.prototype._transform = function(chunk, encoding, cb) {
      var self2 = this;
      if (self2.data.length > 0) {
        self2.data = Buffer.concat([self2.data, chunk]);
      } else {
        self2.data = chunk;
      }
      var startDataLength = self2.data.length;
      var done = function() {
        if (self2.data.length > 0 && self2.data.length < startDataLength) {
          startDataLength = self2.data.length;
          self2._parseOrOutput(encoding, done);
          return;
        }
        cb();
      };
      self2._parseOrOutput(encoding, done);
    };
    UnzipStream.prototype._flush = function(cb) {
      var self2 = this;
      if (self2.data.length > 0) {
        self2._parseOrOutput("buffer", function() {
          if (self2.data.length > 0)
            return setImmediate(function() {
              self2._flush(cb);
            });
          cb();
        });
        return;
      }
      if (self2.state === states.FILE_DATA) {
        return cb(new Error("Stream finished in an invalid state, uncompression failed"));
      }
      setImmediate(cb);
    };
    module2.exports = UnzipStream;
  }
});

// node_modules/unzip-stream/lib/parser-stream.js
var require_parser_stream = __commonJS({
  "node_modules/unzip-stream/lib/parser-stream.js"(exports, module2) {
    var Transform2 = require("stream").Transform;
    var util4 = require("util");
    var UnzipStream = require_unzip_stream();
    function ParserStream(opts) {
      if (!(this instanceof ParserStream)) {
        return new ParserStream(opts);
      }
      var transformOpts = opts || {};
      Transform2.call(this, { readableObjectMode: true });
      this.opts = opts || {};
      this.unzipStream = new UnzipStream(this.opts);
      var self2 = this;
      this.unzipStream.on("entry", function(entry) {
        self2.push(entry);
      });
      this.unzipStream.on("error", function(error) {
        self2.emit("error", error);
      });
    }
    util4.inherits(ParserStream, Transform2);
    ParserStream.prototype._transform = function(chunk, encoding, cb) {
      this.unzipStream.write(chunk, encoding, cb);
    };
    ParserStream.prototype._flush = function(cb) {
      var self2 = this;
      this.unzipStream.end(function() {
        process.nextTick(function() {
          self2.emit("close");
        });
        cb();
      });
    };
    ParserStream.prototype.on = function(eventName, fn) {
      if (eventName === "entry") {
        return Transform2.prototype.on.call(this, "data", fn);
      }
      return Transform2.prototype.on.call(this, eventName, fn);
    };
    ParserStream.prototype.drainAll = function() {
      this.unzipStream.drainAll();
      return this.pipe(new Transform2({ objectMode: true, transform: function(d, e, cb) {
        cb();
      } }));
    };
    module2.exports = ParserStream;
  }
});

// node_modules/mkdirp/index.js
var require_mkdirp2 = __commonJS({
  "node_modules/mkdirp/index.js"(exports, module2) {
    var path41 = require("path");
    var fs29 = require("fs");
    var _0777 = parseInt("0777", 8);
    module2.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
    function mkdirP(p, opts, f, made) {
      if (typeof opts === "function") {
        f = opts;
        opts = {};
      } else if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      var mode = opts.mode;
      var xfs = opts.fs || fs29;
      if (mode === void 0) {
        mode = _0777;
      }
      if (!made)
        made = null;
      var cb = f || function() {
      };
      p = path41.resolve(p);
      xfs.mkdir(p, mode, function(er) {
        if (!er) {
          made = made || p;
          return cb(null, made);
        }
        switch (er.code) {
          case "ENOENT":
            if (path41.dirname(p) === p)
              return cb(er);
            mkdirP(path41.dirname(p), opts, function(er2, made2) {
              if (er2)
                cb(er2, made2);
              else
                mkdirP(p, opts, cb, made2);
            });
            break;
          default:
            xfs.stat(p, function(er2, stat) {
              if (er2 || !stat.isDirectory())
                cb(er, made);
              else
                cb(null, made);
            });
            break;
        }
      });
    }
    mkdirP.sync = function sync(p, opts, made) {
      if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      var mode = opts.mode;
      var xfs = opts.fs || fs29;
      if (mode === void 0) {
        mode = _0777;
      }
      if (!made)
        made = null;
      p = path41.resolve(p);
      try {
        xfs.mkdirSync(p, mode);
        made = made || p;
      } catch (err0) {
        switch (err0.code) {
          case "ENOENT":
            made = sync(path41.dirname(p), opts, made);
            sync(p, opts, made);
            break;
          default:
            var stat;
            try {
              stat = xfs.statSync(p);
            } catch (err1) {
              throw err0;
            }
            if (!stat.isDirectory())
              throw err0;
            break;
        }
      }
      return made;
    };
  }
});

// node_modules/unzip-stream/lib/extract.js
var require_extract2 = __commonJS({
  "node_modules/unzip-stream/lib/extract.js"(exports, module2) {
    var fs29 = require("fs");
    var path41 = require("path");
    var util4 = require("util");
    var mkdirp = require_mkdirp2();
    var Transform2 = require("stream").Transform;
    var UnzipStream = require_unzip_stream();
    function Extract(opts) {
      if (!(this instanceof Extract))
        return new Extract(opts);
      Transform2.call(this);
      this.opts = opts || {};
      this.unzipStream = new UnzipStream(this.opts);
      this.unfinishedEntries = 0;
      this.afterFlushWait = false;
      this.createdDirectories = {};
      var self2 = this;
      this.unzipStream.on("entry", this._processEntry.bind(this));
      this.unzipStream.on("error", function(error) {
        self2.emit("error", error);
      });
    }
    util4.inherits(Extract, Transform2);
    Extract.prototype._transform = function(chunk, encoding, cb) {
      this.unzipStream.write(chunk, encoding, cb);
    };
    Extract.prototype._flush = function(cb) {
      var self2 = this;
      var allDone = function() {
        process.nextTick(function() {
          self2.emit("close");
        });
        cb();
      };
      this.unzipStream.end(function() {
        if (self2.unfinishedEntries > 0) {
          self2.afterFlushWait = true;
          return self2.on("await-finished", allDone);
        }
        allDone();
      });
    };
    Extract.prototype._processEntry = function(entry) {
      var self2 = this;
      var destPath = path41.join(this.opts.path, entry.path);
      var directory = entry.isDirectory ? destPath : path41.dirname(destPath);
      this.unfinishedEntries++;
      var writeFileFn = function() {
        var pipedStream = fs29.createWriteStream(destPath);
        pipedStream.on("close", function() {
          self2.unfinishedEntries--;
          self2._notifyAwaiter();
        });
        pipedStream.on("error", function(error) {
          self2.emit("error", error);
        });
        entry.pipe(pipedStream);
      };
      if (this.createdDirectories[directory] || directory === ".") {
        return writeFileFn();
      }
      mkdirp(directory, function(err) {
        if (err)
          return self2.emit("error", err);
        self2.createdDirectories[directory] = true;
        if (entry.isDirectory) {
          self2.unfinishedEntries--;
          self2._notifyAwaiter();
          return;
        }
        writeFileFn();
      });
    };
    Extract.prototype._notifyAwaiter = function() {
      if (this.afterFlushWait && this.unfinishedEntries === 0) {
        this.emit("await-finished");
        this.afterFlushWait = false;
      }
    };
    module2.exports = Extract;
  }
});

// node_modules/unzip-stream/unzip.js
var require_unzip = __commonJS({
  "node_modules/unzip-stream/unzip.js"(exports) {
    "use strict";
    exports.Parse = require_parser_stream();
    exports.Extract = require_extract2();
  }
});

// node_modules/@tootallnate/once/dist/index.js
var require_dist = __commonJS({
  "node_modules/@tootallnate/once/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function once(emitter, name2, { signal } = {}) {
      return new Promise((resolve3, reject) => {
        function cleanup() {
          signal === null || signal === void 0 ? void 0 : signal.removeEventListener("abort", cleanup);
          emitter.removeListener(name2, onEvent);
          emitter.removeListener("error", onError);
        }
        function onEvent(...args) {
          cleanup();
          resolve3(args);
        }
        function onError(err) {
          cleanup();
          reject(err);
        }
        signal === null || signal === void 0 ? void 0 : signal.addEventListener("abort", cleanup);
        emitter.on(name2, onEvent);
        emitter.on("error", onError);
      });
    }
    exports.default = once;
  }
});

// node_modules/agent-base/dist/src/promisify.js
var require_promisify = __commonJS({
  "node_modules/agent-base/dist/src/promisify.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function promisify3(fn) {
      return function(req, opts) {
        return new Promise((resolve3, reject) => {
          fn.call(this, req, opts, (err, rtn) => {
            if (err) {
              reject(err);
            } else {
              resolve3(rtn);
            }
          });
        });
      };
    }
    exports.default = promisify3;
  }
});

// node_modules/agent-base/dist/src/index.js
var require_src2 = __commonJS({
  "node_modules/agent-base/dist/src/index.js"(exports, module2) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var events_1 = require("events");
    var debug_1 = __importDefault(require_src());
    var promisify_1 = __importDefault(require_promisify());
    var debug = debug_1.default("agent-base");
    function isAgent(v) {
      return Boolean(v) && typeof v.addRequest === "function";
    }
    function isSecureEndpoint() {
      const { stack } = new Error();
      if (typeof stack !== "string")
        return false;
      return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
    }
    function createAgent(callback, opts) {
      return new createAgent.Agent(callback, opts);
    }
    (function(createAgent2) {
      class Agent extends events_1.EventEmitter {
        constructor(callback, _opts) {
          super();
          let opts = _opts;
          if (typeof callback === "function") {
            this.callback = callback;
          } else if (callback) {
            opts = callback;
          }
          this.timeout = null;
          if (opts && typeof opts.timeout === "number") {
            this.timeout = opts.timeout;
          }
          this.maxFreeSockets = 1;
          this.maxSockets = 1;
          this.maxTotalSockets = Infinity;
          this.sockets = {};
          this.freeSockets = {};
          this.requests = {};
          this.options = {};
        }
        get defaultPort() {
          if (typeof this.explicitDefaultPort === "number") {
            return this.explicitDefaultPort;
          }
          return isSecureEndpoint() ? 443 : 80;
        }
        set defaultPort(v) {
          this.explicitDefaultPort = v;
        }
        get protocol() {
          if (typeof this.explicitProtocol === "string") {
            return this.explicitProtocol;
          }
          return isSecureEndpoint() ? "https:" : "http:";
        }
        set protocol(v) {
          this.explicitProtocol = v;
        }
        callback(req, opts, fn) {
          throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
        }
        addRequest(req, _opts) {
          const opts = Object.assign({}, _opts);
          if (typeof opts.secureEndpoint !== "boolean") {
            opts.secureEndpoint = isSecureEndpoint();
          }
          if (opts.host == null) {
            opts.host = "localhost";
          }
          if (opts.port == null) {
            opts.port = opts.secureEndpoint ? 443 : 80;
          }
          if (opts.protocol == null) {
            opts.protocol = opts.secureEndpoint ? "https:" : "http:";
          }
          if (opts.host && opts.path) {
            delete opts.path;
          }
          delete opts.agent;
          delete opts.hostname;
          delete opts._defaultAgent;
          delete opts.defaultPort;
          delete opts.createConnection;
          req._last = true;
          req.shouldKeepAlive = false;
          let timedOut = false;
          let timeoutId = null;
          const timeoutMs = opts.timeout || this.timeout;
          const onerror = (err) => {
            if (req._hadError)
              return;
            req.emit("error", err);
            req._hadError = true;
          };
          const ontimeout = () => {
            timeoutId = null;
            timedOut = true;
            const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
            err.code = "ETIMEOUT";
            onerror(err);
          };
          const callbackError = (err) => {
            if (timedOut)
              return;
            if (timeoutId !== null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            onerror(err);
          };
          const onsocket = (socket) => {
            if (timedOut)
              return;
            if (timeoutId != null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            if (isAgent(socket)) {
              debug("Callback returned another Agent instance %o", socket.constructor.name);
              socket.addRequest(req, opts);
              return;
            }
            if (socket) {
              socket.once("free", () => {
                this.freeSocket(socket, opts);
              });
              req.onSocket(socket);
              return;
            }
            const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
            onerror(err);
          };
          if (typeof this.callback !== "function") {
            onerror(new Error("`callback` is not defined"));
            return;
          }
          if (!this.promisifiedCallback) {
            if (this.callback.length >= 3) {
              debug("Converting legacy callback function to promise");
              this.promisifiedCallback = promisify_1.default(this.callback);
            } else {
              this.promisifiedCallback = this.callback;
            }
          }
          if (typeof timeoutMs === "number" && timeoutMs > 0) {
            timeoutId = setTimeout(ontimeout, timeoutMs);
          }
          if ("port" in opts && typeof opts.port !== "number") {
            opts.port = Number(opts.port);
          }
          try {
            debug("Resolving socket for %o request: %o", opts.protocol, `${req.method} ${req.path}`);
            Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
          } catch (err) {
            Promise.reject(err).catch(callbackError);
          }
        }
        freeSocket(socket, opts) {
          debug("Freeing socket %o %o", socket.constructor.name, opts);
          socket.destroy();
        }
        destroy() {
          debug("Destroying agent %o", this.constructor.name);
        }
      }
      createAgent2.Agent = Agent;
      createAgent2.prototype = createAgent2.Agent.prototype;
    })(createAgent || (createAgent = {}));
    module2.exports = createAgent;
  }
});

// node_modules/http-proxy-agent/dist/agent.js
var require_agent = __commonJS({
  "node_modules/http-proxy-agent/dist/agent.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve3) {
          resolve3(value);
        });
      }
      return new (P || (P = Promise))(function(resolve3, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve3(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var net_1 = __importDefault(require("net"));
    var tls_1 = __importDefault(require("tls"));
    var url_1 = __importDefault(require("url"));
    var debug_1 = __importDefault(require_src());
    var once_1 = __importDefault(require_dist());
    var agent_base_1 = require_src2();
    var debug = (0, debug_1.default)("http-proxy-agent");
    function isHTTPS(protocol2) {
      return typeof protocol2 === "string" ? /^https:?$/i.test(protocol2) : false;
    }
    var HttpProxyAgent2 = class extends agent_base_1.Agent {
      constructor(_opts) {
        let opts;
        if (typeof _opts === "string") {
          opts = url_1.default.parse(_opts);
        } else {
          opts = _opts;
        }
        if (!opts) {
          throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
        }
        debug("Creating new HttpProxyAgent instance: %o", opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === "string") {
          proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
          proxy.port = this.secureProxy ? 443 : 80;
        }
        if (proxy.host && proxy.path) {
          delete proxy.path;
          delete proxy.pathname;
        }
        this.proxy = proxy;
      }
      callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const { proxy, secureProxy } = this;
          const parsed = url_1.default.parse(req.path);
          if (!parsed.protocol) {
            parsed.protocol = "http:";
          }
          if (!parsed.hostname) {
            parsed.hostname = opts.hostname || opts.host || null;
          }
          if (parsed.port == null && typeof opts.port) {
            parsed.port = String(opts.port);
          }
          if (parsed.port === "80") {
            parsed.port = "";
          }
          req.path = url_1.default.format(parsed);
          if (proxy.auth) {
            req.setHeader("Proxy-Authorization", `Basic ${Buffer.from(proxy.auth).toString("base64")}`);
          }
          let socket;
          if (secureProxy) {
            debug("Creating `tls.Socket`: %o", proxy);
            socket = tls_1.default.connect(proxy);
          } else {
            debug("Creating `net.Socket`: %o", proxy);
            socket = net_1.default.connect(proxy);
          }
          if (req._header) {
            let first;
            let endOfHeaders;
            debug("Regenerating stored HTTP header string for request");
            req._header = null;
            req._implicitHeader();
            if (req.output && req.output.length > 0) {
              debug("Patching connection write() output buffer with updated header");
              first = req.output[0];
              endOfHeaders = first.indexOf("\r\n\r\n") + 4;
              req.output[0] = req._header + first.substring(endOfHeaders);
              debug("Output buffer: %o", req.output);
            } else if (req.outputData && req.outputData.length > 0) {
              debug("Patching connection write() output buffer with updated header");
              first = req.outputData[0].data;
              endOfHeaders = first.indexOf("\r\n\r\n") + 4;
              req.outputData[0].data = req._header + first.substring(endOfHeaders);
              debug("Output buffer: %o", req.outputData[0].data);
            }
          }
          yield (0, once_1.default)(socket, "connect");
          return socket;
        });
      }
    };
    exports.default = HttpProxyAgent2;
  }
});

// node_modules/http-proxy-agent/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/http-proxy-agent/dist/index.js"(exports, module2) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var agent_1 = __importDefault(require_agent());
    function createHttpProxyAgent2(opts) {
      return new agent_1.default(opts);
    }
    (function(createHttpProxyAgent3) {
      createHttpProxyAgent3.HttpProxyAgent = agent_1.default;
      createHttpProxyAgent3.prototype = agent_1.default.prototype;
    })(createHttpProxyAgent2 || (createHttpProxyAgent2 = {}));
    module2.exports = createHttpProxyAgent2;
  }
});

// node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS({
  "node_modules/https-proxy-agent/dist/parse-proxy-response.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var debug_1 = __importDefault(require_src());
    var debug = debug_1.default("https-proxy-agent:parse-proxy-response");
    function parseProxyResponse(socket) {
      return new Promise((resolve3, reject) => {
        let buffersLength = 0;
        const buffers = [];
        function read() {
          const b = socket.read();
          if (b)
            ondata(b);
          else
            socket.once("readable", read);
        }
        function cleanup() {
          socket.removeListener("end", onend);
          socket.removeListener("error", onerror);
          socket.removeListener("close", onclose);
          socket.removeListener("readable", read);
        }
        function onclose(err) {
          debug("onclose had error %o", err);
        }
        function onend() {
          debug("onend");
        }
        function onerror(err) {
          cleanup();
          debug("onerror %o", err);
          reject(err);
        }
        function ondata(b) {
          buffers.push(b);
          buffersLength += b.length;
          const buffered = Buffer.concat(buffers, buffersLength);
          const endOfHeaders = buffered.indexOf("\r\n\r\n");
          if (endOfHeaders === -1) {
            debug("have not received end of HTTP headers yet...");
            read();
            return;
          }
          const firstLine = buffered.toString("ascii", 0, buffered.indexOf("\r\n"));
          const statusCode = +firstLine.split(" ")[1];
          debug("got proxy server response: %o", firstLine);
          resolve3({
            statusCode,
            buffered
          });
        }
        socket.on("error", onerror);
        socket.on("close", onclose);
        socket.on("end", onend);
        read();
      });
    }
    exports.default = parseProxyResponse;
  }
});

// node_modules/https-proxy-agent/dist/agent.js
var require_agent2 = __commonJS({
  "node_modules/https-proxy-agent/dist/agent.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve3) {
          resolve3(value);
        });
      }
      return new (P || (P = Promise))(function(resolve3, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve3(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var net_1 = __importDefault(require("net"));
    var tls_1 = __importDefault(require("tls"));
    var url_1 = __importDefault(require("url"));
    var assert_1 = __importDefault(require("assert"));
    var debug_1 = __importDefault(require_src());
    var agent_base_1 = require_src2();
    var parse_proxy_response_1 = __importDefault(require_parse_proxy_response());
    var debug = debug_1.default("https-proxy-agent:agent");
    var HttpsProxyAgent2 = class extends agent_base_1.Agent {
      constructor(_opts) {
        let opts;
        if (typeof _opts === "string") {
          opts = url_1.default.parse(_opts);
        } else {
          opts = _opts;
        }
        if (!opts) {
          throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
        }
        debug("creating new HttpsProxyAgent instance: %o", opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === "string") {
          proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
          proxy.port = this.secureProxy ? 443 : 80;
        }
        if (this.secureProxy && !("ALPNProtocols" in proxy)) {
          proxy.ALPNProtocols = ["http 1.1"];
        }
        if (proxy.host && proxy.path) {
          delete proxy.path;
          delete proxy.pathname;
        }
        this.proxy = proxy;
      }
      callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const { proxy, secureProxy } = this;
          let socket;
          if (secureProxy) {
            debug("Creating `tls.Socket`: %o", proxy);
            socket = tls_1.default.connect(proxy);
          } else {
            debug("Creating `net.Socket`: %o", proxy);
            socket = net_1.default.connect(proxy);
          }
          const headers = Object.assign({}, proxy.headers);
          const hostname = `${opts.host}:${opts.port}`;
          let payload = `CONNECT ${hostname} HTTP/1.1\r
`;
          if (proxy.auth) {
            headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`;
          }
          let { host, port, secureEndpoint } = opts;
          if (!isDefaultPort(port, secureEndpoint)) {
            host += `:${port}`;
          }
          headers.Host = host;
          headers.Connection = "close";
          for (const name2 of Object.keys(headers)) {
            payload += `${name2}: ${headers[name2]}\r
`;
          }
          const proxyResponsePromise = parse_proxy_response_1.default(socket);
          socket.write(`${payload}\r
`);
          const { statusCode, buffered } = yield proxyResponsePromise;
          if (statusCode === 200) {
            req.once("socket", resume);
            if (opts.secureEndpoint) {
              const servername = opts.servername || opts.host;
              if (!servername) {
                throw new Error('Could not determine "servername"');
              }
              debug("Upgrading socket connection to TLS");
              return tls_1.default.connect(Object.assign(Object.assign({}, omit2(opts, "host", "hostname", "path", "port")), {
                socket,
                servername
              }));
            }
            return socket;
          }
          socket.destroy();
          const fakeSocket = new net_1.default.Socket();
          fakeSocket.readable = true;
          req.once("socket", (s) => {
            debug("replaying proxy buffer for failed request");
            assert_1.default(s.listenerCount("data") > 0);
            s.push(buffered);
            s.push(null);
          });
          return fakeSocket;
        });
      }
    };
    exports.default = HttpsProxyAgent2;
    function resume(socket) {
      socket.resume();
    }
    function isDefaultPort(port, secure) {
      return Boolean(!secure && port === 80 || secure && port === 443);
    }
    function isHTTPS(protocol2) {
      return typeof protocol2 === "string" ? /^https:?$/i.test(protocol2) : false;
    }
    function omit2(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// node_modules/https-proxy-agent/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/https-proxy-agent/dist/index.js"(exports, module2) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var agent_1 = __importDefault(require_agent2());
    function createHttpsProxyAgent2(opts) {
      return new agent_1.default(opts);
    }
    (function(createHttpsProxyAgent3) {
      createHttpsProxyAgent3.HttpsProxyAgent = agent_1.default;
      createHttpsProxyAgent3.prototype = agent_1.default.prototype;
    })(createHttpsProxyAgent2 || (createHttpsProxyAgent2 = {}));
    module2.exports = createHttpsProxyAgent2;
  }
});

// node_modules/mimic-response/index.js
var require_mimic_response = __commonJS({
  "node_modules/mimic-response/index.js"(exports, module2) {
    "use strict";
    var knownProperties = [
      "aborted",
      "complete",
      "headers",
      "httpVersion",
      "httpVersionMinor",
      "httpVersionMajor",
      "method",
      "rawHeaders",
      "rawTrailers",
      "setTimeout",
      "socket",
      "statusCode",
      "statusMessage",
      "trailers",
      "url"
    ];
    module2.exports = (fromStream, toStream) => {
      if (toStream._readableState.autoDestroy) {
        throw new Error("The second stream must have the `autoDestroy` option set to `false`");
      }
      const fromProperties = new Set(Object.keys(fromStream).concat(knownProperties));
      const properties = {};
      for (const property of fromProperties) {
        if (property in toStream) {
          continue;
        }
        properties[property] = {
          get() {
            const value = fromStream[property];
            const isFunction = typeof value === "function";
            return isFunction ? value.bind(fromStream) : value;
          },
          set(value) {
            fromStream[property] = value;
          },
          enumerable: true,
          configurable: false
        };
      }
      Object.defineProperties(toStream, properties);
      fromStream.once("aborted", () => {
        toStream.destroy();
        toStream.emit("aborted");
      });
      fromStream.once("close", () => {
        if (fromStream.complete) {
          if (toStream.readable) {
            toStream.once("end", () => {
              toStream.emit("close");
            });
          } else {
            toStream.emit("close");
          }
        } else {
          toStream.emit("close");
        }
      });
      return toStream;
    };
  }
});

// node_modules/decompress-response/index.js
var require_decompress_response = __commonJS({
  "node_modules/decompress-response/index.js"(exports, module2) {
    "use strict";
    var { Transform: Transform2, PassThrough } = require("stream");
    var zlib = require("zlib");
    var mimicResponse = require_mimic_response();
    module2.exports = (response) => {
      const contentEncoding = (response.headers["content-encoding"] || "").toLowerCase();
      if (!["gzip", "deflate", "br"].includes(contentEncoding)) {
        return response;
      }
      const isBrotli = contentEncoding === "br";
      if (isBrotli && typeof zlib.createBrotliDecompress !== "function") {
        response.destroy(new Error("Brotli is not supported on Node.js < 12"));
        return response;
      }
      let isEmpty = true;
      const checker = new Transform2({
        transform(data, _encoding, callback) {
          isEmpty = false;
          callback(null, data);
        },
        flush(callback) {
          callback();
        }
      });
      const finalStream = new PassThrough({
        autoDestroy: false,
        destroy(error, callback) {
          response.destroy();
          callback(error);
        }
      });
      const decompressStream = isBrotli ? zlib.createBrotliDecompress() : zlib.createUnzip();
      decompressStream.once("error", (error) => {
        if (isEmpty && !response.readable) {
          finalStream.end();
          return;
        }
        finalStream.destroy(error);
      });
      mimicResponse(response, finalStream);
      response.pipe(checker).pipe(decompressStream).pipe(finalStream);
      return finalStream;
    };
  }
});

// src/model/fetch.ts
function getSystemProxyURI(endpoint) {
  let env;
  if (endpoint.protocol === "http:") {
    env = process.env.HTTP_PROXY || process.env.http_proxy || null;
  } else if (endpoint.protocol === "https:") {
    env = process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy || null;
  }
  let noProxy = process.env.NO_PROXY || process.env.no_proxy;
  if (noProxy === "*") {
    env = null;
  } else if (noProxy) {
    const hostname = endpoint.hostname.replace(/^\.*/, ".").toLowerCase();
    const port = endpoint.port || endpoint.protocol.startsWith("https") ? "443" : "80";
    const noProxyList = noProxy.split(",");
    for (let i = 0, len = noProxyList.length; i < len; i++) {
      let noProxyItem = noProxyList[i].trim().toLowerCase();
      if (noProxyItem.includes(":")) {
        let noProxyItemParts = noProxyItem.split(":", 2);
        let noProxyHost = noProxyItemParts[0].replace(/^\.*/, ".");
        let noProxyPort = noProxyItemParts[1];
        if (port === noProxyPort && hostname.endsWith(noProxyHost)) {
          env = null;
          break;
        }
      } else {
        noProxyItem = noProxyItem.replace(/^\.*/, ".");
        if (hostname.endsWith(noProxyItem)) {
          env = null;
          break;
        }
      }
    }
  }
  return env;
}
function getAgent(endpoint, options2) {
  let proxy = options2.proxyUrl || getSystemProxyURI(endpoint);
  if (proxy) {
    const proxyEndpoint = (0, import_url.parse)(proxy);
    if (!/^https?:$/.test(proxyEndpoint.protocol)) {
      return null;
    }
    let opts = {
      host: proxyEndpoint.hostname,
      port: proxyEndpoint.port ? Number(proxyEndpoint.port) : proxyEndpoint.protocol === "https" ? "443" : "80",
      auth: proxyEndpoint.auth,
      rejectUnauthorized: typeof options2.strictSSL === "boolean" ? options2.strictSSL : true
    };
    logger49.info(`Using proxy ${proxy} from ${options2.proxyUrl ? "configuration" : "system environment"} for ${endpoint.hostname}:`);
    return endpoint.protocol === "http:" ? (0, import_http_proxy_agent.default)(opts) : (0, import_https_proxy_agent.default)(opts);
  }
  return null;
}
function resolveRequestOptions(url, options2 = {}) {
  let config = workspace_default.getConfiguration("http");
  let { data } = options2;
  let dataType = getDataType(data);
  let proxyOptions = {
    proxyUrl: config.get("proxy", ""),
    strictSSL: config.get("proxyStrictSSL", true),
    proxyAuthorization: config.get("proxyAuthorization", null),
    proxyCA: config.get("proxyCA", null)
  };
  if (options2.query && !url.includes("?")) {
    url = `${url}?${(0, import_querystring.stringify)(options2.query)}`;
  }
  let headers = Object.assign(options2.headers || {}, { "Proxy-Authorization": proxyOptions.proxyAuthorization });
  let endpoint = (0, import_url.parse)(url);
  let agent = getAgent(endpoint, proxyOptions);
  let opts = {
    method: options2.method || "GET",
    hostname: endpoint.hostname,
    port: endpoint.port ? parseInt(endpoint.port, 10) : endpoint.protocol === "https:" ? 443 : 80,
    path: endpoint.path,
    agent,
    rejectUnauthorized: proxyOptions.strictSSL,
    maxRedirects: 3,
    headers: Object.assign({
      "User-Agent": "Mozilla/5.0 (X11; Linux x86_64)",
      "Accept-Encoding": "gzip, deflate"
    }, headers)
  };
  if (proxyOptions.proxyCA) {
    opts.ca = import_fs17.default.readFileSync(proxyOptions.proxyCA);
  }
  if (dataType == "object") {
    opts.headers["Content-Type"] = "application/json";
  } else if (dataType == "string") {
    opts.headers["Content-Type"] = "text/plain";
  }
  if (options2.user && options2.password) {
    opts.auth = options2.user + ":" + options2.password;
  }
  if (options2.timeout) {
    opts.timeout = options2.timeout;
  }
  if (options2.buffer)
    opts.buffer = true;
  return opts;
}
function request(url, data, opts, token) {
  let mod = url.startsWith("https:") ? import_follow_redirects.https : import_follow_redirects.http;
  return new Promise((resolve3, reject) => {
    if (token) {
      let disposable = token.onCancellationRequested(() => {
        disposable.dispose();
        req.destroy(new Error("request aborted"));
      });
    }
    let timer;
    const req = mod.request(opts, (res) => {
      let readable = res;
      if (res.statusCode >= 200 && res.statusCode < 300 || res.statusCode === 1223) {
        let headers = res.headers || {};
        let chunks = [];
        let contentType = headers["content-type"] || "";
        readable = (0, import_decompress_response.default)(res);
        readable.on("data", (chunk) => {
          chunks.push(chunk);
        });
        readable.on("end", () => {
          if (timer)
            clearTimeout(timer);
          let buf = Buffer.concat(chunks);
          if (!opts.buffer && (contentType.startsWith("application/json") || contentType.startsWith("text/"))) {
            let ms = contentType.match(/charset=(\S+)/);
            let encoding = ms ? ms[1] : "utf8";
            let rawData = buf.toString(encoding);
            if (!contentType.includes("application/json")) {
              resolve3(rawData);
            } else {
              try {
                const parsedData = JSON.parse(rawData);
                resolve3(parsedData);
              } catch (e) {
                reject(new Error(`Parse response error: ${e}`));
              }
            }
          } else {
            resolve3(buf);
          }
        });
        readable.on("error", (err) => {
          reject(new Error(`Unable to connect ${url}: ${err.message}`));
        });
      } else {
        reject(new Error(`Bad response from ${url}: ${res.statusCode}`));
      }
    });
    req.on("error", (e) => {
      if (opts.agent && e.code == "ECONNRESET") {
        timer = setTimeout(() => {
          reject(e);
        }, 500);
      } else {
        reject(e);
      }
    });
    req.on("timeout", () => {
      req.destroy(new Error(`Request timeout after ${opts.timeout}ms`));
    });
    if (data) {
      if (typeof data === "string" || Buffer.isBuffer(data)) {
        req.write(data);
      } else {
        req.write(JSON.stringify(data));
      }
    }
    if (opts.timeout) {
      req.setTimeout(opts.timeout);
    }
    req.end();
  });
}
function getDataType(data) {
  if (data === null)
    return "null";
  if (data === void 0)
    return "undefined";
  if (typeof data == "string")
    return "string";
  if (Buffer.isBuffer(data))
    return "buffer";
  if (Array.isArray(data) || objectLiteral(data))
    return "object";
  return "unknown";
}
function fetch(url, options2 = {}, token) {
  let opts = resolveRequestOptions(url, options2);
  return request(url, options2.data, opts, token).catch((err) => {
    logger49.error(`Fetch error for ${url}:`, opts, err);
    if (opts.agent && opts.agent.proxy) {
      let { proxy } = opts.agent;
      throw new Error(`Request failed using proxy ${proxy.host}: ${err.message}`);
    } else {
      throw err;
    }
  });
}
var import_follow_redirects, import_url, import_fs17, import_querystring, import_http_proxy_agent, import_https_proxy_agent, import_decompress_response, logger49;
var init_fetch = __esm({
  "src/model/fetch.ts"() {
    "use strict";
    import_follow_redirects = __toESM(require_follow_redirects());
    import_url = require("url");
    import_fs17 = __toESM(require("fs"));
    init_is();
    init_workspace();
    import_querystring = require("querystring");
    import_http_proxy_agent = __toESM(require_dist2());
    import_https_proxy_agent = __toESM(require_dist3());
    import_decompress_response = __toESM(require_decompress_response());
    logger49 = require_logger2()("model-fetch");
  }
});

// src/model/download.ts
function download(url, options2, token) {
  let { dest, onProgress, extract } = options2;
  if (!dest || !import_path18.default.isAbsolute(dest)) {
    throw new Error(`Expect absolute file path for dest option.`);
  }
  let stat;
  try {
    stat = import_fs_extra7.default.statSync(dest);
  } catch (_e) {
    import_fs_extra7.default.mkdirpSync(dest);
  }
  if (stat && !stat.isDirectory()) {
    throw new Error(`${dest} exists, but not directory!`);
  }
  let mod = url.startsWith("https") ? import_follow_redirects2.https : import_follow_redirects2.http;
  let opts = resolveRequestOptions(url, options2);
  let extname = import_path18.default.extname(url);
  return new Promise((resolve3, reject) => {
    if (token) {
      let disposable = token.onCancellationRequested(() => {
        disposable.dispose();
        req.destroy(new Error("request aborted"));
      });
    }
    let timer;
    const req = mod.request(opts, (res) => {
      var _a;
      if (res.statusCode >= 200 && res.statusCode < 300 || res.statusCode === 1223) {
        let headers = res.headers || {};
        let dispositionHeader = headers["content-disposition"];
        if (!extname && dispositionHeader) {
          let disposition = import_content_disposition.default.parse(dispositionHeader);
          if ((_a = disposition.parameters) == null ? void 0 : _a.filename) {
            extname = import_path18.default.extname(disposition.parameters.filename);
          }
        }
        if (extract === true) {
          if (extname === ".zip" || headers["content-type"] == "application/zip") {
            extract = "unzip";
          } else if (extname == ".tgz") {
            extract = "untar";
          } else {
            reject(new Error(`Unable to extract for ${url}`));
            return;
          }
        }
        let total = Number(headers["content-length"]);
        let cur = 0;
        if (!isNaN(total)) {
          res.on("data", (chunk) => {
            cur += chunk.length;
            let percent = (cur / total * 100).toFixed(1);
            if (onProgress) {
              onProgress(percent);
            } else {
              logger50.info(`Download ${url} progress ${percent}%`);
            }
          });
        }
        res.on("error", (err) => {
          reject(new Error(`Unable to connect ${url}: ${err.message}`));
        });
        res.on("data", () => {
          if (timer) {
            clearTimeout(timer);
            timer = void 0;
          }
        });
        res.on("end", () => {
          logger50.info("Download completed:", url);
        });
        let stream;
        if (extract === "untar") {
          stream = res.pipe(import_tar.default.x({ strip: options2.strip ?? 1, C: dest }));
        } else if (extract === "unzip") {
          stream = res.pipe(import_unzip_stream.default.Extract({ path: dest }));
        } else {
          dest = import_path18.default.join(dest, `${v1_default()}${extname}`);
          stream = res.pipe(import_fs_extra7.default.createWriteStream(dest));
        }
        stream.on("finish", () => {
          logger50.info(`Downloaded ${url} => ${dest}`);
          setTimeout(() => {
            resolve3(dest);
          }, 100);
        });
        stream.on("error", reject);
      } else {
        reject(new Error(`Invalid response from ${url}: ${res.statusCode}`));
      }
    });
    req.on("error", (e) => {
      if (opts.agent && e.code == "ECONNRESET") {
        timer = setTimeout(() => {
          reject(e);
        }, 500);
      } else {
        reject(e);
      }
    });
    req.on("timeout", () => {
      req.destroy(new Error(`request timeout after ${options2.timeout}ms`));
    });
    if (options2.timeout) {
      req.setTimeout(options2.timeout);
    }
    req.end();
  });
}
var import_content_disposition, import_follow_redirects2, import_fs_extra7, import_path18, import_tar, import_unzip_stream, logger50;
var init_download = __esm({
  "src/model/download.ts"() {
    "use strict";
    import_content_disposition = __toESM(require_content_disposition());
    import_follow_redirects2 = __toESM(require_follow_redirects());
    import_fs_extra7 = __toESM(require_lib4());
    import_path18 = __toESM(require("path"));
    import_tar = __toESM(require_tar());
    import_unzip_stream = __toESM(require_unzip());
    init_esm_node();
    init_fetch();
    logger50 = require_logger2()("model-download");
  }
});

// src/model/installer.ts
function registryUrl(scope = "coc.nvim") {
  let res = "https://registry.npmjs.org/";
  let filepath = import_path19.default.join(HOME_DIR, ".npmrc");
  if (import_fs_extra8.default.existsSync(filepath)) {
    try {
      let content = import_fs_extra8.default.readFileSync(filepath, "utf8");
      let obj = {};
      for (let line of content.split(/\r?\n/)) {
        if (line.indexOf("=") > -1) {
          let [_, key, val] = line.match(/^(.*?)=(.*)$/);
          obj[key] = val;
        }
      }
      if (obj[`${scope}:registry`]) {
        res = obj[`${scope}:registry`];
      } else if (obj["registry"]) {
        res = obj["registry"];
      }
    } catch (e) {
      logger51.error("Error on read .npmrc:", e);
    }
  }
  return res.endsWith("/") ? res : res + "/";
}
function isNpmCommand(exePath) {
  let name2 = import_path19.default.basename(exePath);
  return name2 === "npm" || name2 === "npm.CMD";
}
function isYarn(exePath) {
  let name2 = import_path19.default.basename(exePath);
  return ["yarn", "yarn.CMD", "yarnpkg", "yarnpkg.CMD"].includes(name2);
}
function getInstallArguments(exePath, url) {
  let args = ["install", "--ignore-scripts", "--no-lockfile", "--production"];
  if (url.startsWith("https://github.com")) {
    args = ["install"];
  }
  if (isNpmCommand(exePath)) {
    args.push("--legacy-peer-deps");
    args.push("--no-global");
  }
  if (isYarn(exePath)) {
    args.push("--ignore-engines");
  }
  return args;
}
function getDependencies(content) {
  let dependencies;
  try {
    let obj = JSON.parse(content);
    dependencies = obj.dependencies || {};
  } catch (e) {
    dependencies = {};
  }
  return omit(dependencies, ["coc.nvim", "esbuild", "webpack", "@types/node"]);
}
function isSymbolicLink(folder) {
  if (import_fs_extra8.default.existsSync(folder)) {
    let stat = import_fs_extra8.default.lstatSync(folder);
    if (stat.isSymbolicLink()) {
      return true;
    }
  }
  return false;
}
function createInstallerFactory(npm, root) {
  return (def) => new Installer(root, npm, def);
}
var import_child_process3, import_events24, import_fs_extra8, import_os10, import_path19, import_readline2, import_semver2, logger51, HOME_DIR, Installer;
var init_installer = __esm({
  "src/model/installer.ts"() {
    "use strict";
    import_child_process3 = require("child_process");
    import_events24 = require("events");
    import_fs_extra8 = __toESM(require_lib4());
    init_main2();
    import_os10 = __toESM(require("os"));
    import_path19 = __toESM(require("path"));
    import_readline2 = __toESM(require("readline"));
    import_semver2 = __toESM(require_semver2());
    init_fs();
    init_lodash();
    init_workspace();
    init_download();
    init_fetch();
    logger51 = require_logger2()("model-installer");
    HOME_DIR = global.__TEST__ ? import_os10.default.tmpdir() : import_os10.default.homedir();
    Installer = class extends import_events24.EventEmitter {
      constructor(root, npm, def) {
        super();
        this.root = root;
        this.npm = npm;
        this.def = def;
        if (!import_fs_extra8.default.existsSync(root))
          import_fs_extra8.default.mkdirpSync(root);
        if (/^https?:/.test(def)) {
          this.url = def;
        } else {
          let ms = def.match(/(.+)@([^/]+)$/);
          if (ms) {
            this.name = ms[1];
            this.version = ms[2];
          } else {
            this.name = def;
          }
        }
      }
      get info() {
        return { name: this.name, version: this.version };
      }
      async install() {
        this.log(`Using npm from: ${this.npm}`);
        let info = await this.getInfo();
        logger51.info(`Fetched info of ${this.def}`, info);
        let { name: name2 } = info;
        let required = info["engines.coc"] ? info["engines.coc"].replace(/^\^/, ">=") : "";
        if (required && !import_semver2.default.satisfies(workspace_default.version, required)) {
          throw new Error(`${name2} ${info.version} requires coc.nvim >= ${required}, please update coc.nvim.`);
        }
        await this.doInstall(info);
        return name2;
      }
      async update(url) {
        this.url = url;
        let folder = import_path19.default.join(this.root, this.name);
        if (isSymbolicLink(folder)) {
          this.log(`Skipped update for symbol link`);
          return;
        }
        let version2;
        if (import_fs_extra8.default.existsSync(import_path19.default.join(folder, "package.json"))) {
          let content = await import_fs_extra8.default.readFile(import_path19.default.join(folder, "package.json"), "utf8");
          version2 = JSON.parse(content).version;
        }
        this.log(`Using npm from: ${this.npm}`);
        let info = await this.getInfo();
        if (version2 && info.version && import_semver2.default.gte(version2, info.version)) {
          this.log(`Current version ${version2} is up to date.`);
          return;
        }
        let required = info["engines.coc"] ? info["engines.coc"].replace(/^\^/, ">=") : "";
        if (required && !import_semver2.default.satisfies(workspace_default.version, required)) {
          throw new Error(`${info.version} requires coc.nvim ${required}, please update coc.nvim.`);
        }
        await this.doInstall(info);
        let jsonFile = import_path19.default.join(this.root, info.name, "package.json");
        this.log(`Updated to v${info.version}`);
        return import_path19.default.dirname(jsonFile);
      }
      async doInstall(info) {
        let folder = import_path19.default.join(this.root, info.name);
        if (isSymbolicLink(folder))
          return false;
        let tmpFolder = await import_fs_extra8.default.mkdtemp(import_path19.default.join(import_os10.default.tmpdir(), `${info.name.replace("/", "-")}-`));
        let url = info["dist.tarball"];
        this.log(`Downloading from ${url}`);
        await download(url, { dest: tmpFolder, onProgress: (p) => this.log(`Download progress ${p}%`, true), extract: "untar" });
        this.log(`Extension download at ${tmpFolder}`);
        let content = await import_fs_extra8.default.readFile(import_path19.default.join(tmpFolder, "package.json"), "utf8");
        let dependencies = getDependencies(content);
        if (Object.keys(dependencies).length) {
          let p = new Promise((resolve3, reject) => {
            let args = getInstallArguments(this.npm, url);
            this.log(`Installing dependencies by: ${this.npm} ${args.join(" ")}.`);
            const child = (0, import_child_process3.spawn)(this.npm, args, {
              cwd: tmpFolder
            });
            const rl = import_readline2.default.createInterface({
              input: child.stdout
            });
            rl.on("line", (line) => {
              this.log(`[npm] ${line}`, true);
            });
            child.stderr.setEncoding("utf8");
            child.stdout.setEncoding("utf8");
            child.on("error", reject);
            let err = "";
            child.stderr.on("data", (data) => {
              err += data;
            });
            child.on("exit", (code) => {
              if (code) {
                if (err)
                  this.log(err);
                reject(new Error(`${this.npm} install exited with ${code}`));
                return;
              }
              resolve3();
            });
          });
          await p;
        }
        let jsonFile = import_path19.default.resolve(this.root, global.__TEST__ ? "" : "..", "package.json");
        let errors = [];
        if (!import_fs_extra8.default.existsSync(jsonFile))
          import_fs_extra8.default.writeFileSync(jsonFile, "{}");
        let obj = parse2(import_fs_extra8.default.readFileSync(jsonFile, "utf8"), errors, { allowTrailingComma: true });
        if (errors && errors.length > 0) {
          throw new Error(`Error on load ${jsonFile}`);
        }
        obj.dependencies = obj.dependencies || {};
        if (this.url) {
          obj.dependencies[info.name] = this.url;
        } else {
          obj.dependencies[info.name] = ">=" + info.version;
        }
        const sortedObj = { dependencies: {} };
        Object.keys(obj.dependencies).sort().forEach((k) => {
          sortedObj.dependencies[k] = obj.dependencies[k];
        });
        let stat = await statAsync(folder);
        if (stat) {
          if (stat.isDirectory()) {
            import_fs_extra8.default.removeSync(folder);
          } else {
            import_fs_extra8.default.unlinkSync(folder);
          }
        }
        await import_fs_extra8.default.move(tmpFolder, folder, { overwrite: true });
        await import_fs_extra8.default.writeFile(jsonFile, JSON.stringify(sortedObj, null, 2), { encoding: "utf8" });
        if (import_fs_extra8.default.existsSync(tmpFolder))
          import_fs_extra8.default.rmdirSync(tmpFolder);
        this.log(`Update package.json at ${jsonFile}`);
        this.log(`Installed extension ${this.name}@${info.version} at ${folder}`);
        return true;
      }
      async getInfo() {
        if (this.url)
          return await this.getInfoFromUri();
        let registry = registryUrl();
        this.log(`Get info from ${registry}`);
        let buffer = await fetch(registry + this.name, { timeout: 1e4, buffer: true });
        let res = JSON.parse(buffer.toString());
        if (!this.version)
          this.version = res["dist-tags"]["latest"];
        let obj = res["versions"][this.version];
        if (!obj)
          throw new Error(`${this.def} doesn't exists in ${registry}.`);
        let requiredVersion = obj["engines"] && obj["engines"]["coc"];
        if (!requiredVersion) {
          throw new Error(`${this.def} is not valid coc extension, "engines" field with coc property required.`);
        }
        return {
          "dist.tarball": obj["dist"]["tarball"],
          "engines.coc": requiredVersion,
          version: obj["version"],
          name: res.name
        };
      }
      async getInfoFromUri() {
        let { url } = this;
        if (!url.startsWith("https://github.com")) {
          throw new Error(`"${url}" is not supported, coc.nvim support github.com only`);
        }
        url = url.replace(/\/$/, "");
        let branch = "master";
        if (url.includes("@")) {
          let idx = url.indexOf("@");
          branch = url.substr(idx + 1);
          url = url.substring(0, idx);
        }
        let fileUrl = url.replace("github.com", "raw.githubusercontent.com") + `/${branch}/package.json`;
        this.log(`Get info from ${fileUrl}`);
        let content = await fetch(fileUrl, { timeout: 1e4 });
        let obj = typeof content == "string" ? JSON.parse(content) : content;
        this.name = obj.name;
        return {
          "dist.tarball": `${url}/archive/${branch}.tar.gz`,
          "engines.coc": obj["engines"] ? obj["engines"]["coc"] : null,
          name: obj.name,
          version: obj.version
        };
      }
      log(msg, isProgress = false) {
        logger51.info(msg);
        this.emit("message", msg, isProgress);
      }
    };
  }
});

// src/model/memos.ts
var import_fs19, logger52, Memos;
var init_memos = __esm({
  "src/model/memos.ts"() {
    "use strict";
    import_fs19 = __toESM(require("fs"));
    init_object();
    logger52 = require_logger2()("model-memos");
    Memos = class {
      constructor(filepath) {
        this.filepath = filepath;
        if (!import_fs19.default.existsSync(filepath)) {
          import_fs19.default.writeFileSync(filepath, "{}", "utf8");
        }
      }
      fetchContent(id, key) {
        try {
          let content = import_fs19.default.readFileSync(this.filepath, "utf8");
          let res = JSON.parse(content);
          let obj = res[id];
          if (!obj)
            return void 0;
          return obj[key];
        } catch (e) {
          return void 0;
        }
      }
      async update(id, key, value) {
        let { filepath } = this;
        try {
          let content = import_fs19.default.readFileSync(filepath, "utf8");
          let current = content ? JSON.parse(content) : {};
          current[id] = current[id] || {};
          if (value !== void 0) {
            current[id][key] = deepClone(value);
          } else {
            delete current[id][key];
          }
          content = JSON.stringify(current, null, 2);
          import_fs19.default.writeFileSync(filepath, content, "utf8");
        } catch (e) {
          logger52.error(`Error on update memos:`, e);
        }
      }
      createMemento(id) {
        return {
          get: (key, defaultValue) => {
            let res = this.fetchContent(id, key);
            return res === void 0 ? defaultValue : res;
          },
          update: async (key, value) => {
            await this.update(id, key, value);
          }
        };
      }
    };
  }
});

// src/model/relativePattern.ts
var RelativePattern;
var init_relativePattern = __esm({
  "src/model/relativePattern.ts"() {
    "use strict";
    init_esm();
    init_errors();
    RelativePattern = class {
      constructor(base, pattern) {
        if (typeof base !== "string") {
          if (!base || !URI2.isUri(base) && typeof base.uri !== "string") {
            throw illegalArgument("base");
          }
        }
        if (typeof pattern !== "string") {
          throw illegalArgument("pattern");
        }
        if (typeof base === "string") {
          this.baseUri = URI2.file(base);
        } else if (URI2.isUri(base)) {
          this.baseUri = base;
        } else {
          this.baseUri = URI2.parse(base.uri);
        }
        this.pattern = pattern;
      }
      toJSON() {
        return {
          pattern: this.pattern,
          baseUri: this.baseUri.toJSON()
        };
      }
    };
  }
});

// node_modules/vscode-languageserver-protocol/node.js
var require_node3 = __commonJS({
  "node_modules/vscode-languageserver-protocol/node.js"(exports, module2) {
    "use strict";
    module2.exports = require_main2();
  }
});

// src/util/processes.ts
function terminate(process2, cwd) {
  if (process2.killed)
    return;
  if (isWindows2) {
    try {
      let options2 = {
        stdio: ["pipe", "pipe", "ignore"]
      };
      if (cwd) {
        options2.cwd = cwd;
      }
      cp.execFileSync("taskkill", ["/T", "/F", "/PID", process2.pid.toString()], options2);
      return true;
    } catch (err) {
      return false;
    }
  } else if (isLinux2 || isMacintosh2) {
    try {
      let filepath = (0, import_path20.join)(pluginRoot2, "bin/terminateProcess.sh");
      let result = cp.spawnSync(filepath, [process2.pid.toString()]);
      return result.error ? false : true;
    } catch (err) {
      return false;
    }
  } else {
    process2.kill("SIGKILL");
    return true;
  }
}
var cp, import_path20, isWindows2, isMacintosh2, isLinux2, pluginRoot2;
var init_processes = __esm({
  "src/util/processes.ts"() {
    "use strict";
    cp = __toESM(require("child_process"));
    import_path20 = require("path");
    isWindows2 = process.platform === "win32";
    isMacintosh2 = process.platform === "darwin";
    isLinux2 = process.platform === "linux";
    pluginRoot2 = false ? resolve2(__dirname, "../..") : (0, import_path20.dirname)(__dirname);
  }
});

// src/language-client/utils/uuid.ts
function generateUuid() {
  return v4_default();
}
var init_uuid = __esm({
  "src/language-client/utils/uuid.ts"() {
    "use strict";
    init_esm_node();
  }
});

// src/language-client/features.ts
function ensure(target, key) {
  if (target[key] === void 0) {
    target[key] = {};
  }
  return target[key];
}
var import_vscode_languageserver_protocol38, LSPCancellationError, BaseFeature, StaticFeature, DynamicFeature, DynamicDocumentFeature, TextDocumentEventFeature, TextDocumentLanguageFeature;
var init_features = __esm({
  "src/language-client/features.ts"() {
    "use strict";
    import_vscode_languageserver_protocol38 = __toESM(require_main2());
    init_is();
    init_workspace();
    init_uuid();
    init_errors();
    LSPCancellationError = class extends CancellationError {
      constructor(data) {
        super();
        this.data = data;
      }
    };
    BaseFeature = class {
      constructor(client) {
        this._client = client;
      }
      sendRequest(type, params, token, defaultValue) {
        return this._client.sendRequest(type, params, token).then((res) => {
          return token.isCancellationRequested || res == null ? defaultValue ?? null : res;
        }, (error) => {
          return this._client.handleFailedRequest(type, token, error, defaultValue ?? null);
        });
      }
    };
    ((StaticFeature4) => {
      function is(value) {
        return value !== void 0 && value !== null && func(value.fillClientCapabilities) && func(value.initialize) && func(value.dispose) && (value.fillInitializeParams === void 0 || func(value.fillInitializeParams)) && value.registrationType === void 0;
      }
      StaticFeature4.is = is;
    })(StaticFeature || (StaticFeature = {}));
    ((DynamicFeature8) => {
      function is(value) {
        const candidate = value;
        return candidate !== void 0 && candidate !== null && func(candidate.fillClientCapabilities) && func(candidate.initialize) && func(candidate.dispose) && (candidate.fillInitializeParams === void 0 || func(candidate.fillInitializeParams)) && func(candidate.register) && func(candidate.unregister) && candidate.registrationType !== void 0;
      }
      DynamicFeature8.is = is;
    })(DynamicFeature || (DynamicFeature = {}));
    DynamicDocumentFeature = class extends BaseFeature {
      constructor(client) {
        super(client);
      }
      getState() {
        const selectors = this.getDocumentSelectors();
        let count = 0;
        for (const selector of selectors) {
          count++;
          for (const document2 of workspace_default.textDocuments) {
            if (workspace_default.match(selector, document2) > 0) {
              return { kind: "document", id: this.registrationType.method, registrations: true, matches: true };
            }
          }
        }
        const registrations = count > 0;
        return { kind: "document", id: this.registrationType.method, registrations, matches: false };
      }
    };
    TextDocumentEventFeature = class extends DynamicDocumentFeature {
      static textDocumentFilter(selectors, textDocument) {
        for (const selector of selectors) {
          if (workspace_default.match(selector, textDocument) > 0) {
            return true;
          }
        }
        return false;
      }
      constructor(client, event, type, middleware, createParams, selectorFilter) {
        super(client);
        this._event = event;
        this._type = type;
        this._middleware = middleware;
        this._createParams = createParams;
        this._selectorFilter = selectorFilter;
        this._selectors = /* @__PURE__ */ new Map();
        this._onNotificationSent = new import_vscode_languageserver_protocol38.Emitter();
      }
      getDocumentSelectors() {
        return this._selectors.values();
      }
      register(data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        if (!this._listener) {
          this._listener = this._event((data2) => {
            this.callback(data2).catch((error) => {
              this._client.error(`Sending document notification ${this._type.method} failed.`, error);
            });
          });
        }
        this._selectors.set(data.id, data.registerOptions.documentSelector);
      }
      async callback(data) {
        if (!this.matches(data))
          return;
        const doSend = async (data2) => {
          const params = this._createParams(data2);
          await this._client.sendNotification(this._type, params).catch();
          this.notificationSent(data2, this._type, params);
        };
        const middleware = this._client.middleware[this._middleware];
        return Promise.resolve(middleware ? middleware(data, (data2) => doSend(data2)) : doSend(data));
      }
      matches(data) {
        return !this._selectorFilter || this._selectorFilter(this._selectors.values(), data);
      }
      get onNotificationSent() {
        return this._onNotificationSent.event;
      }
      notificationSent(data, type, params) {
        this._onNotificationSent.fire({ original: data, type, params });
      }
      unregister(id) {
        this._selectors.delete(id);
      }
      dispose() {
        this._selectors.clear();
        this._onNotificationSent.dispose();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      getProvider(document2) {
        for (const selector of this.getDocumentSelectors()) {
          if (workspace_default.match(selector, document2) > 0) {
            return {
              send: (data) => {
                return this.callback(data);
              }
            };
          }
        }
        return void 0;
      }
    };
    TextDocumentLanguageFeature = class extends DynamicDocumentFeature {
      constructor(client, registrationType) {
        super(client);
        this._registrationType = registrationType;
        this._registrations = /* @__PURE__ */ new Map();
      }
      *getDocumentSelectors() {
        for (const registration of this._registrations.values()) {
          const selector = registration.data.registerOptions.documentSelector;
          if (selector === null) {
            continue;
          }
          yield selector;
        }
      }
      get registrationType() {
        return this._registrationType;
      }
      get registrationLength() {
        return this._registrations.size;
      }
      register(data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        let registration = this.registerLanguageProvider(data.registerOptions, data.id);
        this._registrations.set(data.id, { disposable: registration[0], data, provider: registration[1] });
      }
      unregister(id) {
        let registration = this._registrations.get(id);
        if (registration !== void 0) {
          registration.disposable.dispose();
        }
      }
      dispose() {
        this._registrations.forEach((value) => {
          value.disposable.dispose();
        });
        this._registrations.clear();
      }
      getRegistration(documentSelector, capability) {
        if (!capability)
          return [void 0, void 0];
        if (boolean(capability) && capability === true) {
          return [generateUuid(), { documentSelector }];
        }
        if (import_vscode_languageserver_protocol38.TextDocumentRegistrationOptions.is(capability)) {
          const id = import_vscode_languageserver_protocol38.StaticRegistrationOptions.hasId(capability) ? capability.id : generateUuid();
          const selector = capability.documentSelector ?? documentSelector;
          return [id, Object.assign({}, capability, { documentSelector: selector })];
        }
        if (import_vscode_languageserver_protocol38.WorkDoneProgressOptions.is(capability)) {
          const id = import_vscode_languageserver_protocol38.StaticRegistrationOptions.hasId(capability) ? capability.id : generateUuid();
          return [id, Object.assign({}, capability, { documentSelector })];
        }
        return [void 0, void 0];
      }
      getRegistrationOptions(documentSelector, capability) {
        if (!documentSelector || !capability) {
          return void 0;
        }
        return boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector });
      }
      getProvider(textDocument) {
        for (const registration of this._registrations.values()) {
          let selector = registration.data.registerOptions.documentSelector;
          if (selector !== null && workspace_default.match(selector, textDocument) > 0) {
            return registration.provider;
          }
        }
        return void 0;
      }
      getAllProviders() {
        const result = [];
        for (const item of this._registrations.values()) {
          result.push(item.provider);
        }
        return result;
      }
    };
  }
});

// src/language-client/utils/converter.ts
function convertToTextDocumentItem(document2) {
  return {
    uri: document2.uri,
    languageId: document2.languageId,
    version: document2.version,
    text: document2.getText()
  };
}
function asOpenTextDocumentParams(textDocument) {
  return {
    textDocument: convertToTextDocumentItem(textDocument)
  };
}
function asRelativePattern(rp) {
  let { baseUri, pattern } = rp;
  if (typeof baseUri === "string") {
    return new RelativePattern(URI2.parse(baseUri), pattern);
  }
  return new RelativePattern(baseUri, pattern);
}
function asCloseTextDocumentParams(document2) {
  return {
    textDocument: {
      uri: document2.uri
    }
  };
}
function asFullChangeTextDocumentParams(document2) {
  let result = {
    textDocument: {
      uri: document2.uri,
      version: document2.version
    },
    contentChanges: [{ text: document2.getText() }]
  };
  return result;
}
function asChangeTextDocumentParams(event) {
  let { textDocument, contentChanges } = event;
  let result = {
    textDocument: {
      uri: textDocument.uri,
      version: textDocument.version
    },
    contentChanges: contentChanges.slice()
  };
  return result;
}
function asWillSaveTextDocumentParams(event) {
  return {
    textDocument: asVersionedTextDocumentIdentifier(event.document),
    reason: event.reason
  };
}
function asVersionedTextDocumentIdentifier(textDocument) {
  return {
    uri: textDocument.uri,
    version: textDocument.version
  };
}
function asSaveTextDocumentParams(document2, includeText) {
  let result = {
    textDocument: asVersionedTextDocumentIdentifier(document2)
  };
  if (includeText) {
    result.text = document2.getText();
  }
  return result;
}
function asUri(resource) {
  return resource.toString();
}
function asCompletionParams(textDocument, position, context) {
  return {
    textDocument: {
      uri: textDocument.uri
    },
    position,
    context: omit(context, ["option"])
  };
}
function asTextDocumentPositionParams(textDocument, position) {
  return {
    textDocument: {
      uri: textDocument.uri
    },
    position
  };
}
function asSignatureHelpParams(textDocument, position, context) {
  return {
    textDocument: asTextDocumentIdentifier(textDocument),
    position,
    context
  };
}
function asTextDocumentIdentifier(textDocument) {
  return {
    uri: textDocument.uri
  };
}
function asReferenceParams(textDocument, position, options2) {
  return {
    textDocument: {
      uri: textDocument.uri
    },
    position,
    context: { includeDeclaration: options2.includeDeclaration }
  };
}
function asDocumentSymbolParams(textDocument) {
  return {
    textDocument: {
      uri: textDocument.uri
    }
  };
}
function asCodeLensParams(textDocument) {
  return {
    textDocument: {
      uri: textDocument.uri
    }
  };
}
var init_converter = __esm({
  "src/language-client/utils/converter.ts"() {
    "use strict";
    init_esm();
    init_lodash();
    init_relativePattern();
  }
});

// src/language-client/callHierarchy.ts
var import_vscode_languageserver_protocol39, CallHierarchyFeature;
var init_callHierarchy = __esm({
  "src/language-client/callHierarchy.ts"() {
    "use strict";
    import_vscode_languageserver_protocol39 = __toESM(require_main2());
    init_languages();
    init_features();
    init_converter();
    CallHierarchyFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol39.CallHierarchyPrepareRequest.type);
      }
      fillClientCapabilities(cap) {
        const capabilities = cap;
        const capability = ensure(ensure(capabilities, "textDocument"), "callHierarchy");
        capability.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const [id, options2] = this.getRegistration(documentSelector, capabilities.callHierarchyProvider);
        if (!id || !options2) {
          return;
        }
        this.register({ id, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const provider = {
          prepareCallHierarchy: (document2, position, token) => {
            const client = this._client;
            const prepareCallHierarchy = (document3, position2, token2) => {
              const params = asTextDocumentPositionParams(document3, position2);
              return this.sendRequest(import_vscode_languageserver_protocol39.CallHierarchyPrepareRequest.type, params, token2);
            };
            const middleware = client.middleware;
            return middleware.prepareCallHierarchy ? middleware.prepareCallHierarchy(document2, position, token, prepareCallHierarchy) : prepareCallHierarchy(document2, position, token);
          },
          provideCallHierarchyIncomingCalls: (item, token) => {
            const client = this._client;
            const provideCallHierarchyIncomingCalls = (item2, token2) => {
              return this.sendRequest(import_vscode_languageserver_protocol39.CallHierarchyIncomingCallsRequest.type, { item: item2 }, token2);
            };
            const middleware = client.middleware;
            return middleware.provideCallHierarchyIncomingCalls ? middleware.provideCallHierarchyIncomingCalls(item, token, provideCallHierarchyIncomingCalls) : provideCallHierarchyIncomingCalls(item, token);
          },
          provideCallHierarchyOutgoingCalls: (item, token) => {
            const client = this._client;
            const provideCallHierarchyOutgoingCalls = (item2, token2) => {
              return this.sendRequest(import_vscode_languageserver_protocol39.CallHierarchyOutgoingCallsRequest.type, { item: item2 }, token2);
            };
            const middleware = client.middleware;
            return middleware.provideCallHierarchyOutgoingCalls ? middleware.provideCallHierarchyOutgoingCalls(item, token, provideCallHierarchyOutgoingCalls) : provideCallHierarchyOutgoingCalls(item, token);
          }
        };
        return [languages_default.registerCallHierarchyProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/codeAction.ts
var import_vscode_languageserver_protocol40, CodeActionFeature;
var init_codeAction = __esm({
  "src/language-client/codeAction.ts"() {
    "use strict";
    import_vscode_languageserver_protocol40 = __toESM(require_main2());
    init_commands2();
    init_languages();
    init_features();
    init_uuid();
    CodeActionFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol40.CodeActionRequest.type);
        this.disposables = [];
      }
      fillClientCapabilities(capabilities) {
        const cap = ensure(ensure(capabilities, "textDocument"), "codeAction");
        cap.dynamicRegistration = true;
        cap.isPreferredSupport = true;
        cap.disabledSupport = true;
        cap.dataSupport = true;
        cap.honorsChangeAnnotations = false;
        cap.resolveSupport = {
          properties: ["edit"]
        };
        cap.codeActionLiteralSupport = {
          codeActionKind: {
            valueSet: [
              import_vscode_languageserver_protocol40.CodeActionKind.Empty,
              import_vscode_languageserver_protocol40.CodeActionKind.QuickFix,
              import_vscode_languageserver_protocol40.CodeActionKind.Refactor,
              import_vscode_languageserver_protocol40.CodeActionKind.RefactorExtract,
              import_vscode_languageserver_protocol40.CodeActionKind.RefactorInline,
              import_vscode_languageserver_protocol40.CodeActionKind.RefactorRewrite,
              import_vscode_languageserver_protocol40.CodeActionKind.Source,
              import_vscode_languageserver_protocol40.CodeActionKind.SourceOrganizeImports
            ]
          }
        };
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.codeActionProvider);
        if (!options2) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const registCommand = (id) => {
          const client = this._client;
          const executeCommand = (command, args) => {
            const params = {
              command,
              arguments: args
            };
            return client.sendRequest(import_vscode_languageserver_protocol40.ExecuteCommandRequest.type, params);
          };
          const middleware = client.middleware;
          this.disposables.push(commands_default.registerCommand(id, (...args) => {
            return middleware.executeCommand ? middleware.executeCommand(id, args, executeCommand) : executeCommand(id, args);
          }, null, true));
        };
        const provider = {
          provideCodeActions: (document2, range2, context, token) => {
            const client = this._client;
            const _provideCodeActions = (document3, range3, context2, token2) => {
              const params = {
                textDocument: {
                  uri: document3.uri
                },
                range: range3,
                context: context2
              };
              return this.sendRequest(import_vscode_languageserver_protocol40.CodeActionRequest.type, params, token2).then((values) => {
                if (!values)
                  return void 0;
                values.forEach((val) => {
                  var _a;
                  let cmd = import_vscode_languageserver_protocol40.Command.is(val) ? val.command : (_a = val.command) == null ? void 0 : _a.command;
                  if (cmd && !commands_default.has(cmd))
                    registCommand(cmd);
                });
                return values;
              });
            };
            const middleware = client.middleware;
            return middleware.provideCodeActions ? middleware.provideCodeActions(document2, range2, context, token, _provideCodeActions) : _provideCodeActions(document2, range2, context, token);
          },
          resolveCodeAction: options2.resolveProvider ? (item, token) => {
            const middleware = this._client.middleware;
            const resolveCodeAction = (item2, token2) => {
              return this.sendRequest(import_vscode_languageserver_protocol40.CodeActionResolveRequest.type, item2, token2, item2);
            };
            return middleware.resolveCodeAction ? middleware.resolveCodeAction(item, token, resolveCodeAction) : resolveCodeAction(item, token);
          } : void 0
        };
        return [languages_default.registerCodeActionProvider(options2.documentSelector, provider, this._client.id, options2.codeActionKinds), provider];
      }
      dispose() {
        this.disposables.forEach((o) => {
          o.dispose();
        });
        this.disposables = [];
        super.dispose();
      }
    };
  }
});

// src/language-client/codeLens.ts
var import_vscode_languageserver_protocol41, CodeLensFeature;
var init_codeLens = __esm({
  "src/language-client/codeLens.ts"() {
    "use strict";
    import_vscode_languageserver_protocol41 = __toESM(require_main2());
    init_uuid();
    init_features();
    init_converter();
    init_languages();
    CodeLensFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol41.CodeLensRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "codeLens").dynamicRegistration = true;
        ensure(ensure(capabilities, "workspace"), "codeLens").refreshSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(import_vscode_languageserver_protocol41.CodeLensRefreshRequest.type, async () => {
          for (const provider of this.getAllProviders()) {
            provider.onDidChangeCodeLensEmitter.fire();
          }
        });
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.codeLensProvider);
        if (!options2)
          return;
        this.register({ id: generateUuid(), registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const emitter = new import_vscode_languageserver_protocol41.Emitter();
        const provider = {
          onDidChangeCodeLenses: emitter.event,
          provideCodeLenses: (document2, token) => {
            const client = this._client;
            const provideCodeLenses = (document3, token2) => {
              return this.sendRequest(import_vscode_languageserver_protocol41.CodeLensRequest.type, asCodeLensParams(document3), token2);
            };
            const middleware = client.middleware;
            return middleware.provideCodeLenses ? middleware.provideCodeLenses(document2, token, provideCodeLenses) : provideCodeLenses(document2, token);
          },
          resolveCodeLens: options2.resolveProvider ? (codeLens, token) => {
            const client = this._client;
            const resolveCodeLens = (codeLens2, token2) => {
              return this.sendRequest(import_vscode_languageserver_protocol41.CodeLensResolveRequest.type, codeLens2, token2, codeLens2);
            };
            const middleware = client.middleware;
            return middleware.resolveCodeLens ? middleware.resolveCodeLens(codeLens, token, resolveCodeLens) : resolveCodeLens(codeLens, token);
          } : void 0
        };
        return [languages_default.registerCodeLensProvider(options2.documentSelector, provider), { provider, onDidChangeCodeLensEmitter: emitter }];
      }
    };
  }
});

// src/language-client/colorProvider.ts
var import_vscode_languageserver_protocol42, ColorProviderFeature;
var init_colorProvider = __esm({
  "src/language-client/colorProvider.ts"() {
    "use strict";
    import_vscode_languageserver_protocol42 = __toESM(require_main2());
    init_languages();
    init_features();
    ColorProviderFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol42.DocumentColorRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "colorProvider").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let [id, options2] = this.getRegistration(documentSelector, capabilities.colorProvider);
        if (!id || !options2) {
          return;
        }
        this.register({ id, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideColorPresentations: (color, context, token) => {
            const client = this._client;
            const provideColorPresentations = (color2, context2, token2) => {
              const requestParams = {
                color: color2,
                textDocument: { uri: context2.document.uri },
                range: context2.range
              };
              return this.sendRequest(import_vscode_languageserver_protocol42.ColorPresentationRequest.type, requestParams, token2);
            };
            const middleware = client.middleware;
            return middleware.provideColorPresentations ? middleware.provideColorPresentations(color, context, token, provideColorPresentations) : provideColorPresentations(color, context, token);
          },
          provideDocumentColors: (document2, token) => {
            const client = this._client;
            const provideDocumentColors = (document3, token2) => {
              const requestParams = {
                textDocument: { uri: document3.uri }
              };
              return this.sendRequest(import_vscode_languageserver_protocol42.DocumentColorRequest.type, requestParams, token2);
            };
            const middleware = client.middleware;
            return middleware.provideDocumentColors ? middleware.provideDocumentColors(document2, token, provideDocumentColors) : provideDocumentColors(document2, token);
          }
        };
        return [languages_default.registerDocumentColorProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/completion.ts
var import_vscode_languageserver_protocol43, SupportedCompletionItemKinds, CompletionItemFeature;
var init_completion = __esm({
  "src/language-client/completion.ts"() {
    "use strict";
    import_vscode_languageserver_protocol43 = __toESM(require_main2());
    init_languages();
    init_features();
    init_converter();
    init_uuid();
    SupportedCompletionItemKinds = [
      import_vscode_languageserver_protocol43.CompletionItemKind.Text,
      import_vscode_languageserver_protocol43.CompletionItemKind.Method,
      import_vscode_languageserver_protocol43.CompletionItemKind.Function,
      import_vscode_languageserver_protocol43.CompletionItemKind.Constructor,
      import_vscode_languageserver_protocol43.CompletionItemKind.Field,
      import_vscode_languageserver_protocol43.CompletionItemKind.Variable,
      import_vscode_languageserver_protocol43.CompletionItemKind.Class,
      import_vscode_languageserver_protocol43.CompletionItemKind.Interface,
      import_vscode_languageserver_protocol43.CompletionItemKind.Module,
      import_vscode_languageserver_protocol43.CompletionItemKind.Property,
      import_vscode_languageserver_protocol43.CompletionItemKind.Unit,
      import_vscode_languageserver_protocol43.CompletionItemKind.Value,
      import_vscode_languageserver_protocol43.CompletionItemKind.Enum,
      import_vscode_languageserver_protocol43.CompletionItemKind.Keyword,
      import_vscode_languageserver_protocol43.CompletionItemKind.Snippet,
      import_vscode_languageserver_protocol43.CompletionItemKind.Color,
      import_vscode_languageserver_protocol43.CompletionItemKind.File,
      import_vscode_languageserver_protocol43.CompletionItemKind.Reference,
      import_vscode_languageserver_protocol43.CompletionItemKind.Folder,
      import_vscode_languageserver_protocol43.CompletionItemKind.EnumMember,
      import_vscode_languageserver_protocol43.CompletionItemKind.Constant,
      import_vscode_languageserver_protocol43.CompletionItemKind.Struct,
      import_vscode_languageserver_protocol43.CompletionItemKind.Event,
      import_vscode_languageserver_protocol43.CompletionItemKind.Operator,
      import_vscode_languageserver_protocol43.CompletionItemKind.TypeParameter
    ];
    CompletionItemFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol43.CompletionRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let snippetSupport = this._client.clientOptions.disableSnippetCompletion !== true;
        let completion = ensure(ensure(capabilities, "textDocument"), "completion");
        completion.dynamicRegistration = true;
        completion.contextSupport = true;
        completion.completionItem = {
          snippetSupport,
          commitCharactersSupport: true,
          documentationFormat: this._client.supportedMarkupKind,
          deprecatedSupport: true,
          preselectSupport: true,
          insertReplaceSupport: true,
          tagSupport: { valueSet: [import_vscode_languageserver_protocol43.CompletionItemTag.Deprecated] },
          resolveSupport: { properties: ["documentation", "detail", "additionalTextEdits"] },
          labelDetailsSupport: true,
          insertTextModeSupport: { valueSet: [import_vscode_languageserver_protocol43.InsertTextMode.asIs, import_vscode_languageserver_protocol43.InsertTextMode.adjustIndentation] }
        };
        completion.completionItemKind = { valueSet: SupportedCompletionItemKinds };
        completion.insertTextMode = import_vscode_languageserver_protocol43.InsertTextMode.adjustIndentation;
        completion.completionList = {
          itemDefaults: [
            "commitCharacters",
            "editRange",
            "insertTextFormat",
            "insertTextMode"
          ]
        };
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.completionProvider);
        if (!options2)
          return;
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2, id) {
        let triggerCharacters = options2.triggerCharacters || [];
        let allCommitCharacters = options2.allCommitCharacters || [];
        const provider = {
          provideCompletionItems: (document2, position, token, context) => {
            const middleware = this._client.middleware;
            const provideCompletionItems = (document3, position2, context2, token2) => {
              return this.sendRequest(import_vscode_languageserver_protocol43.CompletionRequest.type, asCompletionParams(document3, position2, context2), token2, []);
            };
            return middleware.provideCompletionItem ? middleware.provideCompletionItem(document2, position, context, token, provideCompletionItems) : provideCompletionItems(document2, position, context, token);
          },
          resolveCompletionItem: options2.resolveProvider ? (item, token) => {
            const middleware = this._client.middleware;
            const resolveCompletionItem = (item2, token2) => {
              return this.sendRequest(import_vscode_languageserver_protocol43.CompletionResolveRequest.type, item2, token2, item2);
            };
            return middleware.resolveCompletionItem ? middleware.resolveCompletionItem(item, token, resolveCompletionItem) : resolveCompletionItem(item, token);
          } : void 0
        };
        let name2 = this._client.id + (this.registrationLength == 0 ? "" : "-" + id);
        const disposable = languages_default.registerCompletionItemProvider(name2, "LS", options2.documentSelector, provider, triggerCharacters, options2.priority, allCommitCharacters);
        return [disposable, provider];
      }
    };
  }
});

// src/language-client/configuration.ts
var import_vscode_languageserver_protocol44, logger53, PullConfigurationFeature, SyncConfigurationFeature;
var init_configuration3 = __esm({
  "src/language-client/configuration.ts"() {
    "use strict";
    import_vscode_languageserver_protocol44 = __toESM(require_main2());
    init_util2();
    init_is();
    init_workspace();
    init_features();
    init_uuid();
    logger53 = require_logger2()("languageclient-configuration");
    PullConfigurationFeature = class {
      constructor(_client) {
        this._client = _client;
      }
      get method() {
        return import_vscode_languageserver_protocol44.ConfigurationRequest.method;
      }
      fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.configuration = true;
      }
      getState() {
        return { kind: "static" };
      }
      initialize() {
        let client = this._client;
        let { configuredSection } = client;
        client.onRequest(import_vscode_languageserver_protocol44.ConfigurationRequest.type, (params, token) => {
          let configuration = (params2) => {
            let result = [];
            for (let item of params2.items) {
              let section2 = configuredSection ? configuredSection + (item.section ? `.${item.section}` : "") : item.section;
              result.push(this.getConfiguration(item.scopeUri, section2));
            }
            return result;
          };
          let middleware = client.middleware.workspace;
          return (middleware == null ? void 0 : middleware.configuration) ? middleware.configuration(params, token, configuration) : configuration(params, token);
        });
      }
      getConfiguration(resource, section2) {
        let result = null;
        if (section2) {
          let index = section2.lastIndexOf(".");
          if (index === -1) {
            result = toJSONObject(workspace_default.getConfiguration(void 0, resource).get(section2));
          } else {
            let config = workspace_default.getConfiguration(section2.substr(0, index), resource);
            if (config)
              result = toJSONObject(config.get(section2.substr(index + 1)));
          }
        } else {
          let config = workspace_default.getConfiguration(section2, resource);
          result = {};
          for (let key of Object.keys(config)) {
            if (config.has(key)) {
              result[key] = toJSONObject(config.get(key));
            }
          }
        }
        return result ?? null;
      }
      dispose() {
      }
    };
    SyncConfigurationFeature = class {
      constructor(_client) {
        this._client = _client;
        this._listeners = /* @__PURE__ */ new Map();
      }
      getState() {
        return { kind: "workspace", id: this.registrationType.method, registrations: this._listeners.size > 0 };
      }
      get registrationType() {
        return import_vscode_languageserver_protocol44.DidChangeConfigurationNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "workspace"), "didChangeConfiguration").dynamicRegistration = true;
      }
      initialize() {
        var _a;
        let section2 = (_a = this._client.clientOptions.synchronize) == null ? void 0 : _a.configurationSection;
        if (section2 !== void 0) {
          this.register({
            id: generateUuid(),
            registerOptions: {
              section: section2
            }
          });
        }
      }
      register(data) {
        let { section: section2 } = data.registerOptions;
        let disposable = workspace_default.onDidChangeConfiguration((event) => {
          this.onDidChangeConfiguration(section2, event);
        });
        this._listeners.set(data.id, disposable);
        if (section2 != void 0) {
          this.onDidChangeConfiguration(section2, void 0);
        }
      }
      unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable) {
          this._listeners.delete(id);
          disposable.dispose();
        }
      }
      dispose() {
        for (let disposable of this._listeners.values()) {
          disposable.dispose();
        }
        this._listeners.clear();
      }
      onDidChangeConfiguration(configurationSection, event) {
        var _a;
        let { configuredSection } = this._client;
        let sections;
        if (string(configurationSection)) {
          sections = [configurationSection];
        } else {
          sections = configurationSection;
        }
        if (sections != null && event != null) {
          let affected = sections.some((section2) => event.affectsConfiguration(section2));
          if (!affected)
            return;
        }
        let didChangeConfiguration = (sections2) => {
          if (sections2 == null) {
            return this._client.sendNotification(import_vscode_languageserver_protocol44.DidChangeConfigurationNotification.type, { settings: null });
          }
          let settings = configuredSection ? SyncConfigurationFeature.getConfiguredSettings(configuredSection) : this.extractSettingsInformation(sections2);
          return this._client.sendNotification(import_vscode_languageserver_protocol44.DidChangeConfigurationNotification.type, { settings });
        };
        let middleware = (_a = this._client.middleware.workspace) == null ? void 0 : _a.didChangeConfiguration;
        middleware ? middleware(sections, didChangeConfiguration) : didChangeConfiguration(sections).catch((error) => {
          this._client.error(`Sending notification ${import_vscode_languageserver_protocol44.DidChangeConfigurationNotification.type.method} failed`, error);
        });
      }
      static getConfiguredSettings(key) {
        let len = ".settings".length;
        let config = workspace_default.getConfiguration(key.slice(0, -len));
        return mergeConfigProperties(config.get("settings", {}));
      }
      extractSettingsInformation(keys) {
        function ensurePath(config, path41) {
          let current = config;
          for (let i = 0; i < path41.length - 1; i++) {
            let obj = current[path41[i]];
            if (!obj) {
              obj = /* @__PURE__ */ Object.create(null);
              current[path41[i]] = obj;
            }
            current = obj;
          }
          return current;
        }
        let result = /* @__PURE__ */ Object.create(null);
        for (let i = 0; i < keys.length; i++) {
          let key = keys[i];
          let index = key.indexOf(".");
          let config = null;
          if (index >= 0) {
            config = workspace_default.getConfiguration(key.substr(0, index)).get(key.substr(index + 1));
          } else {
            config = workspace_default.getConfiguration(key);
          }
          if (config) {
            let path41 = keys[i].split(".");
            ensurePath(result, path41)[path41[path41.length - 1]] = config;
          }
        }
        return result;
      }
    };
  }
});

// src/language-client/declaration.ts
var import_vscode_languageserver_protocol45, DeclarationFeature;
var init_declaration = __esm({
  "src/language-client/declaration.ts"() {
    "use strict";
    import_vscode_languageserver_protocol45 = __toESM(require_main2());
    init_languages();
    init_features();
    init_converter();
    DeclarationFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol45.DeclarationRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let declarationSupport = ensure(ensure(capabilities, "textDocument"), "declaration");
        declarationSupport.dynamicRegistration = true;
        declarationSupport.linkSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const [id, options2] = this.getRegistration(documentSelector, capabilities.declarationProvider);
        if (!id || !options2) {
          return;
        }
        this.register({ id, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideDeclaration: (document2, position, token) => {
            const client = this._client;
            const provideDeclaration = (document3, position2, token2) => this.sendRequest(import_vscode_languageserver_protocol45.DeclarationRequest.type, asTextDocumentPositionParams(document3, position2), token2);
            const middleware = client.middleware;
            return middleware.provideDeclaration ? middleware.provideDeclaration(document2, position, token, provideDeclaration) : provideDeclaration(document2, position, token);
          }
        };
        return [languages_default.registerDeclarationProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/definition.ts
var import_vscode_languageserver_protocol46, DefinitionFeature;
var init_definition = __esm({
  "src/language-client/definition.ts"() {
    "use strict";
    import_vscode_languageserver_protocol46 = __toESM(require_main2());
    init_languages();
    init_features();
    init_converter();
    init_uuid();
    DefinitionFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol46.DefinitionRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let definitionSupport = ensure(ensure(capabilities, "textDocument"), "definition");
        definitionSupport.dynamicRegistration = true;
        definitionSupport.linkSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.definitionProvider);
        if (!options2) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideDefinition: (document2, position, token) => {
            const client = this._client;
            const provideDefinition = (document3, position2, token2) => {
              return this.sendRequest(import_vscode_languageserver_protocol46.DefinitionRequest.type, asTextDocumentPositionParams(document3, position2), token2);
            };
            const middleware = client.middleware;
            return middleware.provideDefinition ? middleware.provideDefinition(document2, position, token, provideDefinition) : provideDefinition(document2, position, token);
          }
        };
        return [languages_default.registerDefinitionProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/diagnostic.ts
var import_minimatch6, import_vscode_languageserver_protocol47, DocumentPullStateTracker, DiagnosticRequestor, BackgroundScheduler, DiagnosticFeatureProviderImpl, DiagnosticFeature;
var init_diagnostic = __esm({
  "src/language-client/diagnostic.ts"() {
    "use strict";
    import_minimatch6 = __toESM(require_minimatch());
    init_esm_node();
    import_vscode_languageserver_protocol47 = __toESM(require_main2());
    init_esm();
    init_languages();
    init_errors();
    init_window();
    init_workspace();
    init_features();
    DocumentPullStateTracker = class {
      constructor() {
        this.documentPullStates = /* @__PURE__ */ new Map();
        this.workspacePullStates = /* @__PURE__ */ new Map();
      }
      track(kind, document2, arg1) {
        const states = kind === 1 /* document */ ? this.documentPullStates : this.workspacePullStates;
        const [key, uri, version2] = document2 instanceof URI2 ? [document2.toString(), document2, arg1] : [document2.uri.toString(), URI2.parse(document2.uri), document2.version];
        let state = states.get(key);
        if (state === void 0) {
          state = { document: uri, pulledVersion: version2, resultId: void 0 };
          states.set(key, state);
        }
        return state;
      }
      update(kind, document2, arg1, arg2) {
        const states = kind === 1 /* document */ ? this.documentPullStates : this.workspacePullStates;
        const [key, uri, version2, resultId] = document2 instanceof URI2 ? [document2.toString(), document2, arg1, arg2] : [document2.uri, URI2.parse(document2.uri), document2.version, arg1];
        let state = states.get(key);
        if (state === void 0) {
          state = { document: uri, pulledVersion: version2, resultId };
          states.set(key, state);
        } else {
          state.pulledVersion = version2;
          state.resultId = resultId;
        }
      }
      unTrack(kind, document2) {
        const key = document2 instanceof URI2 ? document2.toString() : document2.uri;
        const states = kind === 1 /* document */ ? this.documentPullStates : this.workspacePullStates;
        states.delete(key);
      }
      tracks(kind, document2) {
        const key = document2 instanceof URI2 ? document2.toString() : document2.uri;
        const states = kind === 1 /* document */ ? this.documentPullStates : this.workspacePullStates;
        return states.has(key);
      }
      trackingDocuments() {
        return Array.from(this.documentPullStates.keys());
      }
      getResultId(kind, document2) {
        var _a;
        const key = document2 instanceof URI2 ? document2.toString() : document2.uri;
        const states = kind === 1 /* document */ ? this.documentPullStates : this.workspacePullStates;
        return (_a = states.get(key)) == null ? void 0 : _a.resultId;
      }
      getAllResultIds() {
        const result = [];
        for (let [uri, value] of this.workspacePullStates) {
          if (this.documentPullStates.has(uri)) {
            value = this.documentPullStates.get(uri);
          }
          if (value.resultId !== void 0) {
            result.push({ uri, value: value.resultId });
          }
        }
        return result;
      }
    };
    DiagnosticRequestor = class extends BaseFeature {
      constructor(client, options2) {
        super(client);
        var _a;
        this.client = client;
        this.options = options2;
        this.enableWorkspace = options2.workspaceDiagnostics && ((_a = this.client.clientOptions.diagnosticPullOptions) == null ? void 0 : _a.workspace) !== false;
        this.isDisposed = false;
        this.onDidChangeDiagnosticsEmitter = new import_vscode_languageserver_protocol47.Emitter();
        this.provider = this.createProvider();
        this.diagnostics = languages_default.createDiagnosticCollection(options2.identifier ? options2.identifier : client.id);
        this.openRequests = /* @__PURE__ */ new Map();
        this.documentStates = new DocumentPullStateTracker();
        this.workspaceErrorCounter = 0;
      }
      knows(kind, textDocument) {
        return this.documentStates.tracks(kind, textDocument);
      }
      trackingDocuments() {
        return this.documentStates.trackingDocuments();
      }
      forget(kind, document2) {
        this.documentStates.unTrack(kind, document2);
      }
      pull(document2, cb) {
        this.pullAsync(document2).then(() => {
          if (cb) {
            cb();
          }
        }, (error) => {
          this.client.error(`Document pull failed for text document ${document2.uri}`, error);
        });
      }
      async pullAsync(document2) {
        if (this.isDisposed)
          return;
        const uri = document2.uri;
        const version2 = document2.version;
        const currentRequestState = this.openRequests.get(uri);
        const documentState = this.documentStates.track(1 /* document */, document2);
        if (currentRequestState === void 0) {
          const tokenSource = new import_vscode_languageserver_protocol47.CancellationTokenSource();
          this.openRequests.set(uri, { state: "open" /* active */, document: document2, version: version2, tokenSource });
          let report;
          let afterState;
          try {
            report = await this.provider.provideDiagnostics(document2, documentState.resultId, tokenSource.token) ?? { kind: import_vscode_languageserver_protocol47.DocumentDiagnosticReportKind.Full, items: [] };
          } catch (error) {
            if (error instanceof LSPCancellationError && error.data && import_vscode_languageserver_protocol47.DiagnosticServerCancellationData.is(error.data) && error.data.retriggerRequest === false) {
              afterState = { state: "drop" /* outDated */, document: document2 };
            }
            if (afterState === void 0 && error instanceof CancellationError) {
              afterState = { state: "reschedule" /* reschedule */, document: document2 };
            } else {
              throw error;
            }
          }
          afterState = afterState ?? this.openRequests.get(uri);
          if (afterState === void 0) {
            this.client.error(`Lost request state in diagnostic pull model. Clearing diagnostics for ${uri}`);
            this.diagnostics.delete(uri);
            return;
          }
          this.openRequests.delete(uri);
          const visible = window_default.visibleTextEditors.some((editor) => editor.document.uri === uri);
          if (!visible) {
            this.documentStates.unTrack(1 /* document */, document2);
            return;
          }
          if (afterState.state === "drop" /* outDated */)
            return;
          if (report !== void 0) {
            if (report.kind === import_vscode_languageserver_protocol47.DocumentDiagnosticReportKind.Full) {
              this.diagnostics.set(uri, report.items);
            }
            documentState.pulledVersion = version2;
            documentState.resultId = report.resultId;
          }
          if (afterState.state === "reschedule" /* reschedule */) {
            this.pull(document2);
          }
        } else {
          if (currentRequestState.state === "open" /* active */) {
            currentRequestState.tokenSource.cancel();
            this.openRequests.set(uri, { state: "reschedule" /* reschedule */, document: currentRequestState.document });
          } else if (currentRequestState.state === "drop" /* outDated */) {
            this.openRequests.set(uri, { state: "reschedule" /* reschedule */, document: currentRequestState.document });
          }
        }
      }
      forgetDocument(document2) {
        const uri = document2.uri;
        const request2 = this.openRequests.get(uri);
        if (this.enableWorkspace) {
          if (request2 !== void 0) {
            this.openRequests.set(uri, { state: "reschedule" /* reschedule */, document: document2 });
          } else {
            this.pull(document2, () => {
              this.forget(1 /* document */, document2);
            });
          }
        } else {
          if (request2 !== void 0) {
            if (request2.state === "open" /* active */) {
              request2.tokenSource.cancel();
            }
            this.openRequests.delete(uri);
          }
          this.diagnostics.delete(uri.toString());
          this.forget(1 /* document */, document2);
        }
      }
      pullWorkspace() {
        if (!this.enableWorkspace)
          return;
        this.pullWorkspaceAsync().then(() => {
          this.workspaceTimeout = (0, import_vscode_languageserver_protocol47.RAL)().timer.setTimeout(() => {
            this.pullWorkspace();
          }, global.__TEST__ ? 10 : 3e3);
        }, (error) => {
          if (!(error instanceof LSPCancellationError) && !import_vscode_languageserver_protocol47.DiagnosticServerCancellationData.is(error.data)) {
            this.client.error(`Workspace diagnostic pull failed.`, error);
            this.workspaceErrorCounter++;
          }
          if (this.workspaceErrorCounter <= 5) {
            this.workspaceTimeout = (0, import_vscode_languageserver_protocol47.RAL)().timer.setTimeout(() => {
              this.pullWorkspace();
            }, global.__TEST__ ? 10 : 3e3);
          }
        });
      }
      async pullWorkspaceAsync() {
        if (!this.provider.provideWorkspaceDiagnostics) {
          return;
        }
        if (this.workspaceCancellation !== void 0) {
          this.workspaceCancellation.cancel();
          this.workspaceCancellation = void 0;
        }
        this.workspaceCancellation = new import_vscode_languageserver_protocol47.CancellationTokenSource();
        const previousResultIds = this.documentStates.getAllResultIds();
        await this.provider.provideWorkspaceDiagnostics(previousResultIds, this.workspaceCancellation.token, (chunk) => {
          if (!chunk || this.isDisposed) {
            return;
          }
          for (const item of chunk.items) {
            if (item.kind === import_vscode_languageserver_protocol47.DocumentDiagnosticReportKind.Full) {
              if (!this.documentStates.tracks(1 /* document */, URI2.parse(item.uri))) {
                this.diagnostics.set(item.uri.toString(), item.items);
              }
            }
            this.documentStates.update(2 /* workspace */, URI2.parse(item.uri), item.version ?? void 0, item.resultId);
          }
        });
      }
      createProvider() {
        const provider = {
          onDidChangeDiagnostics: this.onDidChangeDiagnosticsEmitter.event,
          provideDiagnostics: (document2, previousResultId, token) => {
            const middleware = this.client.middleware;
            const provideDiagnostics = (document3, previousResultId2, token2) => {
              const uri = document3 instanceof URI2 ? document3.toString() : document3.uri;
              const params = {
                identifier: this.options.identifier,
                textDocument: { uri },
                previousResultId: previousResultId2
              };
              return this.sendRequest(import_vscode_languageserver_protocol47.DocumentDiagnosticRequest.type, params, token2, { kind: import_vscode_languageserver_protocol47.DocumentDiagnosticReportKind.Full, items: [] }).then(async (result) => {
                if (result === void 0 || result === null || this.isDisposed) {
                  return { kind: import_vscode_languageserver_protocol47.DocumentDiagnosticReportKind.Full, items: [] };
                }
                if (middleware.handleDiagnostics && result.kind == import_vscode_languageserver_protocol47.DocumentDiagnosticReportKind.Full) {
                  middleware.handleDiagnostics(uri, result.items, (_, diagnostics) => {
                    result.items = diagnostics;
                  });
                }
                return result;
              });
            };
            return middleware.provideDiagnostics ? middleware.provideDiagnostics(document2, previousResultId, token, provideDiagnostics) : provideDiagnostics(document2, previousResultId, token);
          }
        };
        if (this.options.workspaceDiagnostics) {
          provider.provideWorkspaceDiagnostics = (resultIds, token, resultReporter) => {
            const provideWorkspaceDiagnostics = (resultIds2, token2) => {
              const partialResultToken = v4_default();
              const disposable = this.client.onProgress(import_vscode_languageserver_protocol47.WorkspaceDiagnosticRequest.partialResult, partialResultToken, (partialResult) => {
                if (partialResult == void 0) {
                  resultReporter(null);
                  return;
                }
                resultReporter(partialResult);
              });
              const params = {
                identifier: this.options.identifier,
                previousResultIds: resultIds2,
                partialResultToken
              };
              return this.sendRequest(import_vscode_languageserver_protocol47.WorkspaceDiagnosticRequest.type, params, token2, { items: [] }).then(async (result) => {
                resultReporter(result);
                return { items: [] };
              }).finally(() => {
                disposable.dispose();
              });
            };
            const middleware = this.client.middleware;
            return middleware.provideWorkspaceDiagnostics ? middleware.provideWorkspaceDiagnostics(resultIds, token, resultReporter, provideWorkspaceDiagnostics) : provideWorkspaceDiagnostics(resultIds, token, resultReporter);
          };
        }
        return provider;
      }
      dispose() {
        var _a, _b;
        this.isDisposed = true;
        (_a = this.workspaceCancellation) == null ? void 0 : _a.cancel();
        (_b = this.workspaceTimeout) == null ? void 0 : _b.dispose();
        for (const request2 of this.openRequests.values()) {
          if (request2.state === "open" /* active */) {
            request2.tokenSource.cancel();
          }
        }
        this.openRequests.clear();
      }
    };
    BackgroundScheduler = class {
      constructor(diagnosticRequestor) {
        this.diagnosticRequestor = diagnosticRequestor;
        this.documents = new import_vscode_languageserver_protocol47.LinkedMap();
      }
      add(document2) {
        const key = document2.uri;
        if (this.documents.has(key))
          return;
        this.documents.set(key, document2, import_vscode_languageserver_protocol47.Touch.Last);
        this.trigger();
      }
      remove(document2) {
        var _a;
        const key = document2.uri;
        if (this.documents.has(key)) {
          this.documents.delete(key);
          this.diagnosticRequestor.pull(document2);
        }
        if (this.documents.size === 0) {
          this.stop();
        } else if (document2.uri === ((_a = this.endDocument) == null ? void 0 : _a.uri)) {
          this.endDocument = this.documents.last;
        }
      }
      trigger() {
        if (this.intervalHandle !== void 0) {
          this.endDocument = this.documents.last;
          return;
        }
        this.endDocument = this.documents.last;
        this.intervalHandle = (0, import_vscode_languageserver_protocol47.RAL)().timer.setInterval(() => {
          const document2 = this.documents.first;
          if (document2 !== void 0) {
            const key = document2.uri;
            this.diagnosticRequestor.pull(document2);
            this.documents.set(key, document2, import_vscode_languageserver_protocol47.Touch.Last);
            if (document2 === this.endDocument) {
              this.stop();
            }
          }
        }, global.__TEST__ ? 10 : 200);
      }
      dispose() {
        this.stop();
        this.documents.clear();
      }
      stop() {
        var _a;
        (_a = this.intervalHandle) == null ? void 0 : _a.dispose();
        this.intervalHandle = void 0;
        this.endDocument = void 0;
      }
    };
    DiagnosticFeatureProviderImpl = class {
      constructor(client, options2) {
        var _a;
        const diagnosticPullOptions = client.clientOptions.diagnosticPullOptions;
        const documentSelector = options2.documentSelector;
        const disposables = [];
        const ignored = diagnosticPullOptions.ignored ?? [];
        const matches = (document2) => {
          if (workspace_default.match(documentSelector, document2) <= 0)
            return false;
          const visible = window_default.visibleTextEditors.some((editor) => editor.document.uri === document2.uri);
          if (!visible)
            return false;
          if (ignored.length > 0 && ignored.some((p) => (0, import_minimatch6.default)(URI2.parse(document2.uri).fsPath, p, { dot: true })))
            return false;
          return true;
        };
        this.diagnosticRequestor = new DiagnosticRequestor(client, options2);
        this.backgroundScheduler = new BackgroundScheduler(this.diagnosticRequestor);
        const addToBackgroundIfNeeded = (document2) => {
          var _a2;
          if (!matches(document2) || !options2.interFileDependencies || ((_a2 = this.activeTextDocument) == null ? void 0 : _a2.uri) === document2.uri)
            return;
          this.backgroundScheduler.add(document2);
        };
        this.activeTextDocument = (_a = window_default.activeTextEditor) == null ? void 0 : _a.document.textDocument;
        window_default.onDidChangeActiveTextEditor((editor) => {
          const oldActive = this.activeTextDocument;
          let textDocument = this.activeTextDocument = editor == null ? void 0 : editor.document.textDocument;
          if (oldActive !== void 0) {
            addToBackgroundIfNeeded(oldActive);
          }
          if (textDocument != null)
            this.backgroundScheduler.remove(textDocument);
        }, null, disposables);
        const openFeature = client.getFeature(import_vscode_languageserver_protocol47.DidOpenTextDocumentNotification.method);
        disposables.push(openFeature.onNotificationSent((event) => {
          const textDocument = event.original;
          if (matches(textDocument)) {
            this.diagnosticRequestor.pull(textDocument, () => {
              addToBackgroundIfNeeded(textDocument);
            });
          }
        }));
        const shouldPull = (textDocument, mode) => {
          if (diagnosticPullOptions.filter && diagnosticPullOptions.filter(textDocument, mode))
            return false;
          if (!this.diagnosticRequestor.knows(1 /* document */, textDocument))
            return false;
          return true;
        };
        if (diagnosticPullOptions.onChange === true) {
          const changeFeature = client.getFeature(import_vscode_languageserver_protocol47.DidChangeTextDocumentNotification.method);
          disposables.push(changeFeature.onNotificationSent(async (event) => {
            const textDocument = workspace_default.getDocument(event.original.bufnr).textDocument;
            if (event.original.contentChanges.length == 0)
              return;
            if (shouldPull(textDocument, "onType" /* onType */)) {
              this.diagnosticRequestor.pull(textDocument, () => {
                this.backgroundScheduler.trigger();
              });
            }
          }));
        }
        if (diagnosticPullOptions.onSave === true) {
          const saveFeature = client.getFeature(import_vscode_languageserver_protocol47.DidSaveTextDocumentNotification.method);
          disposables.push(saveFeature.onNotificationSent((event) => {
            const textDocument = event.original;
            if (shouldPull(textDocument, "onSave" /* onSave */)) {
              this.diagnosticRequestor.pull(event.original, () => {
                this.backgroundScheduler.trigger();
              });
            }
          }));
        }
        const closeFeature = client.getFeature(import_vscode_languageserver_protocol47.DidCloseTextDocumentNotification.method);
        disposables.push(closeFeature.onNotificationSent((event) => {
          this.cleanUpDocument(event.original);
        }));
        this.diagnosticRequestor.onDidChangeDiagnosticsEmitter.event(() => {
          for (const textDocument of workspace_default.textDocuments) {
            if (matches(textDocument)) {
              this.diagnosticRequestor.pull(textDocument);
            }
          }
        });
        window_default.onDidChangeVisibleTextEditors((editors) => {
          const handled = /* @__PURE__ */ new Set();
          const tracking = this.diagnosticRequestor.trackingDocuments();
          editors.forEach((editor) => {
            let { uri, textDocument } = editor.document;
            if (handled.has(uri))
              return;
            handled.add(uri);
            if (matches(textDocument) && !tracking.includes(uri)) {
              this.diagnosticRequestor.pull(textDocument, () => {
                addToBackgroundIfNeeded(textDocument);
              });
            }
          });
          tracking.forEach((uri) => {
            if (handled.has(uri))
              return;
            let doc = workspace_default.getDocument(uri);
            if (doc && doc.attached)
              this.cleanUpDocument(doc.textDocument);
          });
        }, null, disposables);
        if (options2.workspaceDiagnostics === true && options2.identifier !== "da348dc5-c30a-4515-9d98-31ff3be38d14") {
          this.diagnosticRequestor.pullWorkspace();
        }
        this.disposable = import_vscode_languageserver_protocol47.Disposable.create(() => [...disposables, this.backgroundScheduler, this.diagnosticRequestor].forEach((d) => d.dispose()));
      }
      get onDidChangeDiagnosticsEmitter() {
        return this.diagnosticRequestor.onDidChangeDiagnosticsEmitter;
      }
      get diagnostics() {
        return this.diagnosticRequestor.provider;
      }
      knows(kind, textDocument) {
        return this.diagnosticRequestor.knows(kind, textDocument);
      }
      cleanUpDocument(document2) {
        if (this.diagnosticRequestor.knows(1 /* document */, document2)) {
          this.diagnosticRequestor.forgetDocument(document2);
          this.backgroundScheduler.remove(document2);
        }
      }
    };
    DiagnosticFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol47.DocumentDiagnosticRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let capability = ensure(ensure(capabilities, "textDocument"), "diagnostic");
        capability.dynamicRegistration = true;
        capability.relatedDocumentSupport = true;
        ensure(ensure(capabilities, "workspace"), "diagnostics").refreshSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const client = this._client;
        let [id, options2] = this.getRegistration(documentSelector, capabilities.diagnosticProvider);
        if (!id || !options2)
          return;
        client.onRequest(import_vscode_languageserver_protocol47.DiagnosticRefreshRequest.type, async () => {
          for (const provider of this.getAllProviders()) {
            provider.onDidChangeDiagnosticsEmitter.fire();
          }
        });
        this.register({ id, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const provider = new DiagnosticFeatureProviderImpl(this._client, options2);
        return [provider.disposable, provider];
      }
    };
  }
});

// src/language-client/documentHighlight.ts
var import_vscode_languageserver_protocol48, DocumentHighlightFeature;
var init_documentHighlight = __esm({
  "src/language-client/documentHighlight.ts"() {
    "use strict";
    import_vscode_languageserver_protocol48 = __toESM(require_main2());
    init_languages();
    init_features();
    init_converter();
    init_uuid();
    DocumentHighlightFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol48.DocumentHighlightRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "documentHighlight").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.documentHighlightProvider);
        if (!options2) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideDocumentHighlights: (document2, position, token) => {
            const client = this._client;
            const _provideDocumentHighlights = (document3, position2, token2) => {
              return this.sendRequest(import_vscode_languageserver_protocol48.DocumentHighlightRequest.type, asTextDocumentPositionParams(document3, position2), token2);
            };
            const middleware = client.middleware;
            return middleware.provideDocumentHighlights ? middleware.provideDocumentHighlights(document2, position, token, _provideDocumentHighlights) : _provideDocumentHighlights(document2, position, token);
          }
        };
        return [languages_default.registerDocumentHighlightProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/documentLink.ts
var import_vscode_languageserver_protocol49, DocumentLinkFeature;
var init_documentLink = __esm({
  "src/language-client/documentLink.ts"() {
    "use strict";
    import_vscode_languageserver_protocol49 = __toESM(require_main2());
    init_languages();
    init_features();
    init_uuid();
    DocumentLinkFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol49.DocumentLinkRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const documentLinkCapabilities = ensure(ensure(capabilities, "textDocument"), "documentLink");
        documentLinkCapabilities.dynamicRegistration = true;
        documentLinkCapabilities.tooltipSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.documentLinkProvider);
        if (!options2) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideDocumentLinks: (document2, token) => {
            const client = this._client;
            const provideDocumentLinks = (document3, token2) => {
              return this.sendRequest(import_vscode_languageserver_protocol49.DocumentLinkRequest.type, { textDocument: { uri: document3.uri } }, token2);
            };
            const middleware = client.middleware;
            return middleware.provideDocumentLinks ? middleware.provideDocumentLinks(document2, token, provideDocumentLinks) : provideDocumentLinks(document2, token);
          },
          resolveDocumentLink: options2.resolveProvider ? (link, token) => {
            const client = this._client;
            let resolveDocumentLink = (link2, token2) => {
              return this.sendRequest(import_vscode_languageserver_protocol49.DocumentLinkResolveRequest.type, link2, token2, link2);
            };
            const middleware = client.middleware;
            return middleware.resolveDocumentLink ? middleware.resolveDocumentLink(link, token, resolveDocumentLink) : resolveDocumentLink(link, token);
          } : void 0
        };
        return [languages_default.registerDocumentLinkProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/documentSymbol.ts
var import_vscode_languageserver_protocol50, SupportedSymbolKinds, SupportedSymbolTags, DocumentSymbolFeature;
var init_documentSymbol = __esm({
  "src/language-client/documentSymbol.ts"() {
    "use strict";
    import_vscode_languageserver_protocol50 = __toESM(require_main2());
    init_languages();
    init_features();
    init_converter();
    init_uuid();
    SupportedSymbolKinds = [
      import_vscode_languageserver_protocol50.SymbolKind.File,
      import_vscode_languageserver_protocol50.SymbolKind.Module,
      import_vscode_languageserver_protocol50.SymbolKind.Namespace,
      import_vscode_languageserver_protocol50.SymbolKind.Package,
      import_vscode_languageserver_protocol50.SymbolKind.Class,
      import_vscode_languageserver_protocol50.SymbolKind.Method,
      import_vscode_languageserver_protocol50.SymbolKind.Property,
      import_vscode_languageserver_protocol50.SymbolKind.Field,
      import_vscode_languageserver_protocol50.SymbolKind.Constructor,
      import_vscode_languageserver_protocol50.SymbolKind.Enum,
      import_vscode_languageserver_protocol50.SymbolKind.Interface,
      import_vscode_languageserver_protocol50.SymbolKind.Function,
      import_vscode_languageserver_protocol50.SymbolKind.Variable,
      import_vscode_languageserver_protocol50.SymbolKind.Constant,
      import_vscode_languageserver_protocol50.SymbolKind.String,
      import_vscode_languageserver_protocol50.SymbolKind.Number,
      import_vscode_languageserver_protocol50.SymbolKind.Boolean,
      import_vscode_languageserver_protocol50.SymbolKind.Array,
      import_vscode_languageserver_protocol50.SymbolKind.Object,
      import_vscode_languageserver_protocol50.SymbolKind.Key,
      import_vscode_languageserver_protocol50.SymbolKind.Null,
      import_vscode_languageserver_protocol50.SymbolKind.EnumMember,
      import_vscode_languageserver_protocol50.SymbolKind.Struct,
      import_vscode_languageserver_protocol50.SymbolKind.Event,
      import_vscode_languageserver_protocol50.SymbolKind.Operator,
      import_vscode_languageserver_protocol50.SymbolKind.TypeParameter
    ];
    SupportedSymbolTags = [
      import_vscode_languageserver_protocol50.SymbolTag.Deprecated
    ];
    DocumentSymbolFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol50.DocumentSymbolRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let symbolCapabilities = ensure(ensure(capabilities, "textDocument"), "documentSymbol");
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
          valueSet: SupportedSymbolKinds
        };
        symbolCapabilities.hierarchicalDocumentSymbolSupport = true;
        symbolCapabilities.tagSupport = {
          valueSet: SupportedSymbolTags
        };
        symbolCapabilities.labelSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.documentSymbolProvider);
        if (!options2) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          meta: options2.label ? { label: options2.label } : void 0,
          provideDocumentSymbols: (document2, token) => {
            const client = this._client;
            const _provideDocumentSymbols = (document3, token2) => {
              return this.sendRequest(import_vscode_languageserver_protocol50.DocumentSymbolRequest.type, asDocumentSymbolParams(document3), token2);
            };
            const middleware = client.middleware;
            return middleware.provideDocumentSymbols ? middleware.provideDocumentSymbols(document2, token, _provideDocumentSymbols) : _provideDocumentSymbols(document2, token);
          }
        };
        return [languages_default.registerDocumentSymbolProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/executeCommand.ts
var import_vscode_languageserver_protocol51, ExecuteCommandFeature;
var init_executeCommand = __esm({
  "src/language-client/executeCommand.ts"() {
    "use strict";
    import_vscode_languageserver_protocol51 = __toESM(require_main2());
    init_features();
    init_commands2();
    init_uuid();
    ExecuteCommandFeature = class extends BaseFeature {
      constructor(client) {
        super(client);
        this._commands = /* @__PURE__ */ new Map();
      }
      getState() {
        return { kind: "workspace", id: this.registrationType.method, registrations: this._commands.size > 0 };
      }
      get registrationType() {
        return import_vscode_languageserver_protocol51.ExecuteCommandRequest.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "workspace"), "executeCommand").dynamicRegistration = true;
      }
      initialize(capabilities) {
        if (!capabilities.executeCommandProvider) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: Object.assign({}, capabilities.executeCommandProvider)
        });
      }
      register(data) {
        const client = this._client;
        const middleware = client.middleware;
        const executeCommand = (command, args) => {
          const params = {
            command,
            arguments: args
          };
          return this.sendRequest(import_vscode_languageserver_protocol51.ExecuteCommandRequest.type, params, import_vscode_languageserver_protocol51.CancellationToken.None);
        };
        if (data.registerOptions.commands) {
          let disposables = [];
          for (const command of data.registerOptions.commands) {
            disposables.push(commands_default.registerCommand(command, (...args) => {
              return middleware.executeCommand ? middleware.executeCommand(command, args, executeCommand) : executeCommand(command, args);
            }, null, true));
          }
          this._commands.set(data.id, disposables);
        }
      }
      unregister(id) {
        let disposables = this._commands.get(id);
        if (disposables) {
          disposables.forEach((disposable) => disposable.dispose());
        }
      }
      dispose() {
        this._commands.forEach((value) => {
          value.forEach((disposable) => disposable.dispose());
        });
        this._commands.clear();
      }
    };
  }
});

// src/language-client/fileOperations.ts
function access(target, key) {
  return target[key];
}
function assign(target, key, value) {
  target[key] = value;
}
function asCreateDeleteFilesParams(e) {
  return {
    files: e.files.map((f) => ({ uri: f.toString() }))
  };
}
function asRenameFilesParams(e) {
  return {
    files: e.files.map((f) => ({ oldUri: f.oldUri.toString(), newUri: f.newUri.toString() }))
  };
}
var minimatch7, import_vscode_languageserver_protocol52, logger54, FileOperationFeature, NotificationFileOperationFeature, DidCreateFilesFeature, DidRenameFilesFeature, DidDeleteFilesFeature, RequestFileOperationFeature, WillCreateFilesFeature, WillRenameFilesFeature, WillDeleteFilesFeature;
var init_fileOperations = __esm({
  "src/language-client/fileOperations.ts"() {
    "use strict";
    minimatch7 = __toESM(require_minimatch());
    import_vscode_languageserver_protocol52 = __toESM(require_main2());
    init_types();
    init_fs();
    init_workspace();
    init_features();
    init_uuid();
    logger54 = require_logger2()("language-client-fileOperations");
    FileOperationFeature = class extends BaseFeature {
      constructor(client, event, registrationType, clientCapability, serverCapability) {
        super(client);
        this._filters = /* @__PURE__ */ new Map();
        this._event = event;
        this._registrationType = registrationType;
        this._clientCapability = clientCapability;
        this._serverCapability = serverCapability;
      }
      getState() {
        return { kind: "workspace", id: this._registrationType.method, registrations: this._filters.size > 0 };
      }
      get registrationType() {
        return this._registrationType;
      }
      fillClientCapabilities(capabilities) {
        const value = ensure(ensure(capabilities, "workspace"), "fileOperations");
        assign(value, "dynamicRegistration", true);
        assign(value, this._clientCapability, true);
      }
      initialize(capabilities) {
        var _a;
        const options2 = (_a = capabilities.workspace) == null ? void 0 : _a.fileOperations;
        const capability = options2 !== void 0 ? access(options2, this._serverCapability) : void 0;
        if ((capability == null ? void 0 : capability.filters) !== void 0) {
          try {
            this.register({
              id: generateUuid(),
              registerOptions: { filters: capability.filters }
            });
          } catch (e) {
            this._client.warn(`Ignoring invalid glob pattern for ${this._serverCapability} registration: ${e}`);
          }
        }
      }
      register(data) {
        if (!this._listener) {
          this._listener = this._event(this.send, this);
        }
        const minimatchFilter = data.registerOptions.filters.map((filter2) => {
          const matcher = new minimatch7.Minimatch(filter2.pattern.glob, FileOperationFeature.asMinimatchOptions(filter2.pattern.options));
          if (!matcher.makeRe()) {
            throw new Error(`Invalid pattern ${filter2.pattern.glob}!`);
          }
          return { scheme: filter2.scheme, matcher, kind: filter2.pattern.matches };
        });
        this._filters.set(data.id, minimatchFilter);
      }
      unregister(id) {
        this._filters.delete(id);
      }
      dispose() {
        this._filters.clear();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      async filter(event, prop) {
        const fileMatches = await Promise.all(event.files.map(async (item) => {
          const uri = prop(item);
          const path41 = uri.fsPath.replace(/\\/g, "/");
          for (const filters of this._filters.values()) {
            for (const filter2 of filters) {
              if (filter2.scheme !== void 0 && filter2.scheme !== uri.scheme) {
                continue;
              }
              if (filter2.matcher.match(path41)) {
                if (filter2.kind === void 0) {
                  return true;
                }
                const fileType = await getFileType(uri.fsPath);
                if (fileType === void 0) {
                  this._client.error(`Failed to determine file type for ${uri.toString()}.`);
                  return true;
                }
                if (fileType === 1 /* File */ && filter2.kind === import_vscode_languageserver_protocol52.FileOperationPatternKind.file || fileType === 2 /* Directory */ && filter2.kind === import_vscode_languageserver_protocol52.FileOperationPatternKind.folder) {
                  return true;
                }
              } else if (filter2.kind === import_vscode_languageserver_protocol52.FileOperationPatternKind.folder) {
                const fileType = await getFileType(uri.fsPath);
                if (fileType === 2 /* Directory */ && filter2.matcher.match(`${path41}/`)) {
                  return true;
                }
              }
            }
          }
          return false;
        }));
        const files = event.files.filter((_, index) => fileMatches[index]);
        return __spreadProps(__spreadValues({}, event), { files });
      }
      static asMinimatchOptions(options2) {
        if (options2 === void 0) {
          return void 0;
        }
        if (options2.ignoreCase === true) {
          return { nocase: true };
        }
        return void 0;
      }
    };
    NotificationFileOperationFeature = class extends FileOperationFeature {
      constructor(client, event, notificationType, clientCapability, serverCapability, accessUri, createParams) {
        super(client, event, notificationType, clientCapability, serverCapability);
        this._notificationType = notificationType;
        this._accessUri = accessUri;
        this._createParams = createParams;
      }
      async send(originalEvent) {
        const filteredEvent = await this.filter(originalEvent, this._accessUri);
        if (filteredEvent.files.length) {
          const next = async (event) => {
            if (!this._client.isRunning())
              return;
            return this._client.sendNotification(this._notificationType, this._createParams(event));
          };
          let promise = this.doSend(filteredEvent, next);
          if (promise) {
            await promise.catch((e) => {
              this._client.error(`Sending notification ${this.registrationType.method} failed`, e);
            });
          }
        }
      }
    };
    DidCreateFilesFeature = class extends NotificationFileOperationFeature {
      constructor(client) {
        super(client, workspace_default.onDidCreateFiles, import_vscode_languageserver_protocol52.DidCreateFilesNotification.type, "didCreate", "didCreate", (i) => i, (e) => asCreateDeleteFilesParams(e));
      }
      doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return (middleware == null ? void 0 : middleware.didCreateFiles) ? middleware.didCreateFiles(event, next) : next(event);
      }
    };
    DidRenameFilesFeature = class extends NotificationFileOperationFeature {
      constructor(client) {
        super(client, workspace_default.onDidRenameFiles, import_vscode_languageserver_protocol52.DidRenameFilesNotification.type, "didRename", "didRename", (i) => i.oldUri, (e) => asRenameFilesParams(e));
      }
      doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return (middleware == null ? void 0 : middleware.didRenameFiles) ? middleware.didRenameFiles(event, next) : next(event);
      }
    };
    DidDeleteFilesFeature = class extends NotificationFileOperationFeature {
      constructor(client) {
        super(client, workspace_default.onDidDeleteFiles, import_vscode_languageserver_protocol52.DidDeleteFilesNotification.type, "didDelete", "didDelete", (i) => i, (e) => asCreateDeleteFilesParams(e));
      }
      doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return (middleware == null ? void 0 : middleware.didDeleteFiles) ? middleware.didDeleteFiles(event, next) : next(event);
      }
    };
    RequestFileOperationFeature = class extends FileOperationFeature {
      constructor(client, event, requestType, clientCapability, serverCapability, accessUri, createParams) {
        super(client, event, requestType, clientCapability, serverCapability);
        this._requestType = requestType;
        this._accessUri = accessUri;
        this._createParams = createParams;
      }
      async send(originalEvent) {
        const waitUntil = this.waitUntil(originalEvent);
        originalEvent.waitUntil(waitUntil);
      }
      async waitUntil(originalEvent) {
        const filteredEvent = await this.filter(originalEvent, this._accessUri);
        if (filteredEvent.files.length) {
          const next = (event) => {
            return this.sendRequest(this._requestType, this._createParams(event), import_vscode_languageserver_protocol52.CancellationToken.None);
          };
          return this.doSend(filteredEvent, next);
        } else {
          return void 0;
        }
      }
    };
    WillCreateFilesFeature = class extends RequestFileOperationFeature {
      constructor(client) {
        super(client, workspace_default.onWillCreateFiles, import_vscode_languageserver_protocol52.WillCreateFilesRequest.type, "willCreate", "willCreate", (i) => i, (e) => asCreateDeleteFilesParams(e));
      }
      doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return (middleware == null ? void 0 : middleware.willCreateFiles) ? middleware.willCreateFiles(event, next) : next(event);
      }
    };
    WillRenameFilesFeature = class extends RequestFileOperationFeature {
      constructor(client) {
        super(client, workspace_default.onWillRenameFiles, import_vscode_languageserver_protocol52.WillRenameFilesRequest.type, "willRename", "willRename", (i) => i.oldUri, (e) => asRenameFilesParams(e));
      }
      doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return (middleware == null ? void 0 : middleware.willRenameFiles) ? middleware.willRenameFiles(event, next) : next(event);
      }
    };
    WillDeleteFilesFeature = class extends RequestFileOperationFeature {
      constructor(client) {
        super(client, workspace_default.onWillDeleteFiles, import_vscode_languageserver_protocol52.WillDeleteFilesRequest.type, "willDelete", "willDelete", (i) => i, (e) => asCreateDeleteFilesParams(e));
      }
      doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return (middleware == null ? void 0 : middleware.willDeleteFiles) ? middleware.willDeleteFiles(event, next) : next(event);
      }
    };
  }
});

// src/language-client/fileSystemWatcher.ts
var import_debounce4, import_vscode_languageserver_protocol53, logger55, FileSystemWatcherFeature;
var init_fileSystemWatcher2 = __esm({
  "src/language-client/fileSystemWatcher.ts"() {
    "use strict";
    import_debounce4 = __toESM(require_debounce());
    import_vscode_languageserver_protocol53 = __toESM(require_main2());
    init_is();
    init_workspace();
    init_features();
    init_converter();
    init_uuid();
    logger55 = require_logger2()("language-client-fileSystemWatcher");
    FileSystemWatcherFeature = class {
      constructor(_client) {
        this._client = _client;
        this._watchers = /* @__PURE__ */ new Map();
        this._fileEventsMap = /* @__PURE__ */ new Map();
        this.debouncedFileNotify = (0, import_debounce4.default)(() => {
          void this._notifyFileEvent();
        }, global.__TEST__ ? 20 : 200);
      }
      async _notifyFileEvent() {
        let map = this._fileEventsMap;
        if (map.size == 0)
          return;
        await this._client.forceDocumentSync();
        this._client.sendNotification(import_vscode_languageserver_protocol53.DidChangeWatchedFilesNotification.type, { changes: Array.from(map.values()) }).catch((error) => {
          this._client.error(`Notify file events failed.`, error);
        });
        map.clear();
      }
      notifyFileEvent(event) {
        let self2 = this;
        function didChangeWatchedFile(event2) {
          self2._fileEventsMap.set(event2.uri, event2);
          self2.debouncedFileNotify();
        }
        const workSpaceMiddleware = this._client.middleware.workspace;
        if (workSpaceMiddleware == null ? void 0 : workSpaceMiddleware.didChangeWatchedFile) {
          void workSpaceMiddleware.didChangeWatchedFile(event, didChangeWatchedFile);
        } else {
          didChangeWatchedFile(event);
        }
      }
      getState() {
        return { kind: "workspace", id: this.registrationType.method, registrations: this._watchers.size > 0 };
      }
      get registrationType() {
        return import_vscode_languageserver_protocol53.DidChangeWatchedFilesNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "workspace"), "didChangeWatchedFiles").dynamicRegistration = true;
        ensure(ensure(capabilities, "workspace"), "didChangeWatchedFiles").relativePatternSupport = true;
      }
      initialize(_capabilities, _documentSelector) {
        var _a;
        let fileEvents = (_a = this._client.clientOptions.synchronize) == null ? void 0 : _a.fileEvents;
        if (!fileEvents)
          return;
        let watchers = Array.isArray(fileEvents) ? fileEvents : [fileEvents];
        let disposables = [];
        for (let fileSystemWatcher of watchers) {
          disposables.push(fileSystemWatcher);
          this.hookListeners(fileSystemWatcher, !fileSystemWatcher.ignoreCreateEvents, !fileSystemWatcher.ignoreChangeEvents, !fileSystemWatcher.ignoreDeleteEvents, disposables);
        }
        this._watchers.set(generateUuid(), disposables);
      }
      register(data) {
        if (!Array.isArray(data.registerOptions.watchers)) {
          return;
        }
        let disposables = [];
        for (let watcher of data.registerOptions.watchers) {
          let globPattern;
          if (string(watcher.globPattern)) {
            globPattern = watcher.globPattern;
          } else if (import_vscode_languageserver_protocol53.RelativePattern.is(watcher.globPattern)) {
            globPattern = asRelativePattern(watcher.globPattern);
          } else {
            continue;
          }
          let watchCreate = true;
          let watchChange = true;
          let watchDelete = true;
          if (watcher.kind != null) {
            watchCreate = (watcher.kind & import_vscode_languageserver_protocol53.WatchKind.Create) !== 0;
            watchChange = (watcher.kind & import_vscode_languageserver_protocol53.WatchKind.Change) !== 0;
            watchDelete = (watcher.kind & import_vscode_languageserver_protocol53.WatchKind.Delete) !== 0;
          }
          let fileSystemWatcher = workspace_default.createFileSystemWatcher(globPattern, !watchCreate, !watchChange, !watchDelete);
          this.hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, disposables);
          disposables.push(fileSystemWatcher);
        }
        this._watchers.set(data.id, disposables);
      }
      hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, listeners) {
        if (watchCreate) {
          fileSystemWatcher.onDidCreate((resource) => this.notifyFileEvent({
            uri: asUri(resource),
            type: import_vscode_languageserver_protocol53.FileChangeType.Created
          }), null, listeners);
        }
        if (watchChange) {
          fileSystemWatcher.onDidChange((resource) => this.notifyFileEvent({
            uri: asUri(resource),
            type: import_vscode_languageserver_protocol53.FileChangeType.Changed
          }), null, listeners);
        }
        if (watchDelete) {
          fileSystemWatcher.onDidDelete((resource) => this.notifyFileEvent({
            uri: asUri(resource),
            type: import_vscode_languageserver_protocol53.FileChangeType.Deleted
          }), null, listeners);
        }
      }
      unregister(id) {
        let disposables = this._watchers.get(id);
        if (disposables) {
          for (let disposable of disposables) {
            disposable.dispose();
          }
          this._watchers.delete(id);
        }
      }
      dispose() {
        this._fileEventsMap.clear();
        this.debouncedFileNotify.clear();
        this._watchers.forEach((disposables) => {
          for (let disposable of disposables) {
            disposable.dispose();
          }
        });
        this._watchers.clear();
      }
    };
  }
});

// src/language-client/foldingRange.ts
var import_vscode_languageserver_protocol54, FoldingRangeFeature;
var init_foldingRange = __esm({
  "src/language-client/foldingRange.ts"() {
    "use strict";
    import_vscode_languageserver_protocol54 = __toESM(require_main2());
    init_languages();
    init_features();
    FoldingRangeFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol54.FoldingRangeRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let capability = ensure(ensure(capabilities, "textDocument"), "foldingRange");
        capability.dynamicRegistration = true;
        capability.rangeLimit = 5e3;
        capability.lineFoldingOnly = true;
        capability.foldingRangeKind = { valueSet: [import_vscode_languageserver_protocol54.FoldingRangeKind.Comment, import_vscode_languageserver_protocol54.FoldingRangeKind.Imports, import_vscode_languageserver_protocol54.FoldingRangeKind.Region] };
        capability.foldingRange = { collapsedText: false };
      }
      initialize(capabilities, documentSelector) {
        const [id, options2] = this.getRegistration(documentSelector, capabilities.foldingRangeProvider);
        if (!id || !options2) {
          return;
        }
        this.register({ id, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideFoldingRanges: (document2, context, token) => {
            const client = this._client;
            const provideFoldingRanges = (document3, _, token2) => {
              const requestParams = {
                textDocument: { uri: document3.uri }
              };
              return this.sendRequest(import_vscode_languageserver_protocol54.FoldingRangeRequest.type, requestParams, token2);
            };
            const middleware = client.middleware;
            return middleware.provideFoldingRanges ? middleware.provideFoldingRanges(document2, context, token, provideFoldingRanges) : provideFoldingRanges(document2, context, token);
          }
        };
        return [languages_default.registerFoldingRangeProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/formatting.ts
var import_vscode_languageserver_protocol55, DocumentFormattingFeature, DocumentRangeFormattingFeature, DocumentOnTypeFormattingFeature;
var init_formatting = __esm({
  "src/language-client/formatting.ts"() {
    "use strict";
    import_vscode_languageserver_protocol55 = __toESM(require_main2());
    init_languages();
    init_features();
    init_converter();
    init_uuid();
    DocumentFormattingFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol55.DocumentFormattingRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "formatting").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.documentFormattingProvider);
        if (!options2) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideDocumentFormattingEdits: (document2, options3, token) => {
            const client = this._client;
            const provideDocumentFormattingEdits = (document3, options4, token2) => {
              const params = {
                textDocument: { uri: document3.uri },
                options: options4
              };
              return this.sendRequest(import_vscode_languageserver_protocol55.DocumentFormattingRequest.type, params, token2);
            };
            const middleware = client.middleware;
            return middleware.provideDocumentFormattingEdits ? middleware.provideDocumentFormattingEdits(document2, options3, token, provideDocumentFormattingEdits) : provideDocumentFormattingEdits(document2, options3, token);
          }
        };
        return [
          languages_default.registerDocumentFormatProvider(options2.documentSelector, provider, this._client.clientOptions.formatterPriority),
          provider
        ];
      }
    };
    DocumentRangeFormattingFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol55.DocumentRangeFormattingRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "rangeFormatting").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.documentRangeFormattingProvider);
        if (!options2) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideDocumentRangeFormattingEdits: (document2, range2, options3, token) => {
            const client = this._client;
            const provideDocumentRangeFormattingEdits = (document3, range3, options4, token2) => {
              const params = {
                textDocument: { uri: document3.uri },
                range: range3,
                options: options4
              };
              return this.sendRequest(import_vscode_languageserver_protocol55.DocumentRangeFormattingRequest.type, params, token2);
            };
            const middleware = client.middleware;
            return middleware.provideDocumentRangeFormattingEdits ? middleware.provideDocumentRangeFormattingEdits(document2, range2, options3, token, provideDocumentRangeFormattingEdits) : provideDocumentRangeFormattingEdits(document2, range2, options3, token);
          }
        };
        return [languages_default.registerDocumentRangeFormatProvider(options2.documentSelector, provider), provider];
      }
    };
    DocumentOnTypeFormattingFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol55.DocumentOnTypeFormattingRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "onTypeFormatting").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.documentOnTypeFormattingProvider);
        if (!options2) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideOnTypeFormattingEdits: (document2, position, ch, options3, token) => {
            const client = this._client;
            const provideOnTypeFormattingEdits = (document3, position2, ch2, options4, token2) => {
              const params = {
                textDocument: asVersionedTextDocumentIdentifier(document3),
                position: position2,
                ch: ch2,
                options: options4
              };
              return this.sendRequest(import_vscode_languageserver_protocol55.DocumentOnTypeFormattingRequest.type, params, token2);
            };
            const middleware = client.middleware;
            return middleware.provideOnTypeFormattingEdits ? middleware.provideOnTypeFormattingEdits(document2, position, ch, options3, token, provideOnTypeFormattingEdits) : provideOnTypeFormattingEdits(document2, position, ch, options3, token);
          }
        };
        const moreTriggerCharacter = options2.moreTriggerCharacter || [];
        const characters = [options2.firstTriggerCharacter, ...moreTriggerCharacter];
        return [languages_default.registerOnTypeFormattingEditProvider(options2.documentSelector, provider, characters), provider];
      }
    };
  }
});

// src/language-client/hover.ts
var import_vscode_languageserver_protocol56, HoverFeature;
var init_hover = __esm({
  "src/language-client/hover.ts"() {
    "use strict";
    import_vscode_languageserver_protocol56 = __toESM(require_main2());
    init_languages();
    init_features();
    init_converter();
    init_uuid();
    init_features();
    HoverFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol56.HoverRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const hoverCapability = ensure(ensure(capabilities, "textDocument"), "hover");
        hoverCapability.dynamicRegistration = true;
        hoverCapability.contentFormat = this._client.supportedMarkupKind;
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.hoverProvider);
        if (!options2) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideHover: (document2, position, token) => {
            const client = this._client;
            const provideHover = (document3, position2, token2) => {
              return this.sendRequest(import_vscode_languageserver_protocol56.HoverRequest.type, asTextDocumentPositionParams(document3, position2), token2);
            };
            const middleware = client.middleware;
            return middleware.provideHover ? middleware.provideHover(document2, position, token, provideHover) : provideHover(document2, position, token);
          }
        };
        return [languages_default.registerHoverProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/implementation.ts
var import_vscode_languageserver_protocol57, ImplementationFeature;
var init_implementation = __esm({
  "src/language-client/implementation.ts"() {
    "use strict";
    import_vscode_languageserver_protocol57 = __toESM(require_main2());
    init_languages();
    init_features();
    init_converter();
    ImplementationFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol57.ImplementationRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const implementationSupport = ensure(ensure(capabilities, "textDocument"), "implementation");
        implementationSupport.dynamicRegistration = true;
        implementationSupport.linkSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const [id, options2] = this.getRegistration(documentSelector, capabilities.implementationProvider);
        if (!id || !options2) {
          return;
        }
        this.register({ id, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideImplementation: (document2, position, token) => {
            const client = this._client;
            const provideImplementation = (document3, position2, token2) => this.sendRequest(import_vscode_languageserver_protocol57.ImplementationRequest.type, asTextDocumentPositionParams(document3, position2), token2);
            const middleware = client.middleware;
            return middleware.provideImplementation ? middleware.provideImplementation(document2, position, token, provideImplementation) : provideImplementation(document2, position, token);
          }
        };
        return [languages_default.registerImplementationProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/inlayHint.ts
var import_vscode_languageserver_protocol58, logger56, InlayHintsFeature;
var init_inlayHint = __esm({
  "src/language-client/inlayHint.ts"() {
    "use strict";
    import_vscode_languageserver_protocol58 = __toESM(require_main2());
    init_languages();
    init_features();
    init_converter();
    logger56 = require_logger2()("language-client-inlayHint");
    InlayHintsFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol58.InlayHintRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const inlayHint = ensure(ensure(capabilities, "textDocument"), "inlayHint");
        inlayHint.dynamicRegistration = true;
        inlayHint.resolveSupport = {
          properties: ["tooltip", "textEdits", "label.tooltip", "label.location", "label.command"]
        };
        ensure(ensure(capabilities, "workspace"), "inlayHint").refreshSupport = true;
      }
      initialize(capabilities, documentSelector) {
        this._client.onRequest(import_vscode_languageserver_protocol58.InlayHintRefreshRequest.type, async () => {
          for (const provider of this.getAllProviders()) {
            provider.onDidChangeInlayHints.fire();
          }
        });
        const [id, options2] = this.getRegistration(documentSelector, capabilities.inlayHintProvider);
        if (!id || !options2) {
          return;
        }
        this.register({ id, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const eventEmitter = new import_vscode_languageserver_protocol58.Emitter();
        const provider = {
          onDidChangeInlayHints: eventEmitter.event,
          provideInlayHints: (document2, range2, token) => {
            const client = this._client;
            const provideInlayHints = (document3, range3, token2) => {
              const requestParams = {
                textDocument: asTextDocumentIdentifier(document3),
                range: range3
              };
              return this.sendRequest(import_vscode_languageserver_protocol58.InlayHintRequest.type, requestParams, token2, []);
            };
            const middleware = client.middleware;
            return middleware.provideInlayHints ? middleware.provideInlayHints(document2, range2, token, provideInlayHints) : provideInlayHints(document2, range2, token);
          }
        };
        provider.resolveInlayHint = options2.resolveProvider === true ? (hint, token) => {
          const client = this._client;
          const resolveInlayHint = (item, token2) => {
            return this.sendRequest(import_vscode_languageserver_protocol58.InlayHintResolveRequest.type, item, token2);
          };
          const middleware = client.middleware;
          return middleware.resolveInlayHint ? middleware.resolveInlayHint(hint, token, resolveInlayHint) : resolveInlayHint(hint, token);
        } : void 0;
        const selector = options2.documentSelector;
        return [languages_default.registerInlayHintsProvider(selector, provider), { provider, onDidChangeInlayHints: eventEmitter }];
      }
    };
  }
});

// src/language-client/inlineValue.ts
var import_vscode_languageserver_protocol59, InlineValueFeature;
var init_inlineValue = __esm({
  "src/language-client/inlineValue.ts"() {
    "use strict";
    import_vscode_languageserver_protocol59 = __toESM(require_main2());
    init_languages();
    init_converter();
    init_features();
    InlineValueFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol59.InlineValueRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "inlineValue").dynamicRegistration = true;
        ensure(ensure(capabilities, "workspace"), "inlineValue").refreshSupport = true;
      }
      initialize(capabilities, documentSelector) {
        this._client.onRequest(import_vscode_languageserver_protocol59.InlineValueRefreshRequest.type, async () => {
          for (const provider of this.getAllProviders()) {
            provider.onDidChangeInlineValues.fire();
          }
        });
        const [id, options2] = this.getRegistration(documentSelector, capabilities.inlineValueProvider);
        if (!id || !options2) {
          return;
        }
        this.register({ id, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const eventEmitter = new import_vscode_languageserver_protocol59.Emitter();
        const provider = {
          onDidChangeInlineValues: eventEmitter.event,
          provideInlineValues: (document2, viewPort, context, token) => {
            const client = this._client;
            const provideInlineValues = (document3, range2, context2, token2) => {
              const requestParams = {
                textDocument: asTextDocumentIdentifier(document3),
                range: range2,
                context: context2
              };
              return this.sendRequest(import_vscode_languageserver_protocol59.InlineValueRequest.type, requestParams, token2);
            };
            const middleware = client.middleware;
            return middleware.provideInlineValues ? middleware.provideInlineValues(document2, viewPort, context, token, provideInlineValues) : provideInlineValues(document2, viewPort, context, token);
          }
        };
        const selector = options2.documentSelector;
        return [languages_default.registerInlineValuesProvider(selector, provider), { provider, onDidChangeInlineValues: eventEmitter }];
      }
    };
  }
});

// src/language-client/linkedEditingRange.ts
var import_vscode_languageserver_protocol60, logger57, LinkedEditingFeature;
var init_linkedEditingRange = __esm({
  "src/language-client/linkedEditingRange.ts"() {
    "use strict";
    import_vscode_languageserver_protocol60 = __toESM(require_main2());
    init_languages();
    init_features();
    init_converter();
    logger57 = require_logger2()("languageclient-linkedEditingRange");
    LinkedEditingFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol60.LinkedEditingRangeRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const linkedEditingSupport = ensure(ensure(capabilities, "textDocument"), "linkedEditingRange");
        linkedEditingSupport.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let [id, options2] = this.getRegistration(documentSelector, capabilities.linkedEditingRangeProvider);
        if (!id || !options2) {
          return;
        }
        this.register({ id, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideLinkedEditingRanges: (document2, position, token) => {
            const client = this._client;
            const provideLinkedEditing = (document3, position2, token2) => {
              const params = asTextDocumentPositionParams(document3, position2);
              return this.sendRequest(import_vscode_languageserver_protocol60.LinkedEditingRangeRequest.type, params, token2);
            };
            const middleware = client.middleware;
            return middleware.provideLinkedEditingRange ? middleware.provideLinkedEditingRange(document2, position, token, provideLinkedEditing) : provideLinkedEditing(document2, position, token);
          }
        };
        return [languages_default.registerLinkedEditingRangeProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/progressPart.ts
function validPercent(n) {
  if (typeof n !== "number")
    return false;
  return n >= 0 && n <= 100;
}
var import_vscode_languageserver_protocol61, logger58, ProgressPart;
var init_progressPart = __esm({
  "src/language-client/progressPart.ts"() {
    "use strict";
    import_vscode_languageserver_protocol61 = __toESM(require_main2());
    init_util();
    init_window();
    logger58 = require_logger2()("language-client-progressPart");
    ProgressPart = class {
      constructor(client, token, done) {
        this.client = client;
        this.token = token;
        this.disposables = [];
        this._cancelled = false;
        this._percent = 0;
        this._started = false;
        this.disposables.push(client.onProgress(import_vscode_languageserver_protocol61.WorkDoneProgress.type, this.token, (value) => {
          switch (value.kind) {
            case "begin":
              this.begin(value);
              break;
            case "report":
              this.report(value);
              break;
            case "end":
              this.done(value.message);
              done && done(this);
              break;
          }
        }));
      }
      begin(params) {
        if (this._started || this._cancelled)
          return false;
        this._started = true;
        void window_default.withProgress({
          source: `language-client-${this.client.id}`,
          cancellable: params.cancellable,
          title: params.title
        }, (progress, token) => {
          this.progress = progress;
          this.report(params);
          if (this._cancelled)
            return Promise.resolve();
          this.disposables.push(token.onCancellationRequested(() => {
            this.client.sendNotification(import_vscode_languageserver_protocol61.WorkDoneProgressCancelNotification.type, { token: this.token });
            this.cancel();
          }));
          return new Promise((resolve3, reject) => {
            this._resolve = resolve3;
            this._reject = reject;
          });
        });
        return true;
      }
      report(params) {
        if (!this.progress)
          return;
        let msg = {};
        if (params.message)
          msg.message = params.message;
        if (validPercent(params.percentage)) {
          msg.increment = params.percentage - this._percent;
          this._percent = params.percentage;
        }
        if (Object.keys(msg).length > 0) {
          this.progress.report(msg);
        }
      }
      cancel() {
        if (this._cancelled)
          return;
        this.cleanUp();
        if (this._reject !== void 0) {
          this._reject();
          this._resolve = void 0;
          this._reject = void 0;
        }
      }
      done(message) {
        if (this.progress) {
          let msg = {};
          if (message)
            msg.message = message;
          if (typeof this._percent === "number" && this._percent > 0)
            msg.increment = 100 - this._percent;
          this.progress.report(msg);
        }
        this.cleanUp();
        if (this._resolve) {
          this._resolve();
          this._resolve = void 0;
          this._reject = void 0;
        }
      }
      cleanUp() {
        this._cancelled = true;
        this.progress = void 0;
        disposeAll(this.disposables);
      }
    };
  }
});

// src/language-client/progress.ts
var import_vscode_languageserver_protocol62, ProgressFeature;
var init_progress2 = __esm({
  "src/language-client/progress.ts"() {
    "use strict";
    import_vscode_languageserver_protocol62 = __toESM(require_main2());
    init_progressPart();
    init_features();
    ProgressFeature = class {
      constructor(_client) {
        this._client = _client;
        this.activeParts = /* @__PURE__ */ new Set();
      }
      get method() {
        return import_vscode_languageserver_protocol62.WorkDoneProgressCreateRequest.method;
      }
      fillClientCapabilities(capabilities) {
        ensure(capabilities, "window").workDoneProgress = true;
      }
      getState() {
        return { kind: "window", id: import_vscode_languageserver_protocol62.WorkDoneProgressCreateRequest.method, registrations: this.activeParts.size > 0 };
      }
      initialize() {
        let client = this._client;
        const deleteHandler = (part) => {
          this.activeParts.delete(part);
        };
        const createHandler = (params) => {
          this.activeParts.add(new ProgressPart(this._client, params.token, deleteHandler));
        };
        client.onRequest(import_vscode_languageserver_protocol62.WorkDoneProgressCreateRequest.type, createHandler);
      }
      dispose() {
        for (const part of this.activeParts) {
          part.done();
        }
        this.activeParts.clear();
      }
    };
  }
});

// src/language-client/reference.ts
var import_vscode_languageserver_protocol63, ReferencesFeature;
var init_reference = __esm({
  "src/language-client/reference.ts"() {
    "use strict";
    import_vscode_languageserver_protocol63 = __toESM(require_main2());
    init_languages();
    init_features();
    init_converter();
    init_uuid();
    ReferencesFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol63.ReferencesRequest.type);
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "references").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.referencesProvider);
        if (!options2) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideReferences: (document2, position, options3, token) => {
            const client = this._client;
            const _providerReferences = (document3, position2, options4, token2) => {
              return this.sendRequest(import_vscode_languageserver_protocol63.ReferencesRequest.type, asReferenceParams(document3, position2, options4), token2);
            };
            const middleware = client.middleware;
            return middleware.provideReferences ? middleware.provideReferences(document2, position, options3, token, _providerReferences) : _providerReferences(document2, position, options3, token);
          }
        };
        return [languages_default.registerReferencesProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/rename.ts
var import_vscode_languageserver_protocol64, RenameFeature;
var init_rename = __esm({
  "src/language-client/rename.ts"() {
    "use strict";
    import_vscode_languageserver_protocol64 = __toESM(require_main2());
    init_languages();
    init_is();
    init_features();
    init_converter();
    init_uuid();
    RenameFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol64.RenameRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let rename = ensure(ensure(capabilities, "textDocument"), "rename");
        rename.dynamicRegistration = true;
        rename.prepareSupport = true;
        rename.honorsChangeAnnotations = true;
        rename.prepareSupportDefaultBehavior = import_vscode_languageserver_protocol64.PrepareSupportDefaultBehavior.Identifier;
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.renameProvider);
        if (!options2) {
          return;
        }
        if (boolean(capabilities.renameProvider)) {
          options2.prepareProvider = false;
        }
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideRenameEdits: (document2, position, newName, token) => {
            const client = this._client;
            const provideRenameEdits = (document3, position2, newName2, token2) => {
              const params = {
                textDocument: { uri: document3.uri },
                position: position2,
                newName: newName2
              };
              return this.sendRequest(import_vscode_languageserver_protocol64.RenameRequest.type, params, token2);
            };
            const middleware = client.middleware;
            return middleware.provideRenameEdits ? middleware.provideRenameEdits(document2, position, newName, token, provideRenameEdits) : provideRenameEdits(document2, position, newName, token);
          },
          prepareRename: options2.prepareProvider ? (document2, position, token) => {
            const client = this._client;
            const prepareRename = (document3, position2, token2) => {
              const params = {
                textDocument: asTextDocumentIdentifier(document3),
                position: position2
              };
              return this.sendRequest(import_vscode_languageserver_protocol64.PrepareRenameRequest.type, params, token2).then((result) => {
                if (!result)
                  return null;
                if (import_vscode_languageserver_protocol64.Range.is(result)) {
                  return result;
                } else if (this.isDefaultBehavior(result)) {
                  return result.defaultBehavior === true ? null : Promise.reject(new Error(`The element can't be renamed.`));
                } else if (result && import_vscode_languageserver_protocol64.Range.is(result.range)) {
                  return {
                    range: result.range,
                    placeholder: result.placeholder
                  };
                }
              });
            };
            const middleware = client.middleware;
            return middleware.prepareRename ? middleware.prepareRename(document2, position, token, prepareRename) : prepareRename(document2, position, token);
          } : void 0
        };
        return [languages_default.registerRenameProvider(options2.documentSelector, provider), provider];
      }
      isDefaultBehavior(value) {
        const candidate = value;
        return candidate && boolean(candidate.defaultBehavior);
      }
    };
  }
});

// src/language-client/selectionRange.ts
var import_vscode_languageserver_protocol65, SelectionRangeFeature;
var init_selectionRange = __esm({
  "src/language-client/selectionRange.ts"() {
    "use strict";
    import_vscode_languageserver_protocol65 = __toESM(require_main2());
    init_languages();
    init_features();
    SelectionRangeFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol65.SelectionRangeRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let capability = ensure(ensure(capabilities, "textDocument"), "selectionRange");
        capability.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let [id, options2] = this.getRegistration(documentSelector, capabilities.selectionRangeProvider);
        if (!id || !options2) {
          return;
        }
        this.register({ id, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideSelectionRanges: (document2, positions2, token) => {
            const client = this._client;
            const provideSelectionRanges = (document3, positions3, token2) => {
              const requestParams = {
                textDocument: { uri: document3.uri },
                positions: positions3
              };
              return this.sendRequest(import_vscode_languageserver_protocol65.SelectionRangeRequest.type, requestParams, token2);
            };
            const middleware = client.middleware;
            return middleware.provideSelectionRanges ? middleware.provideSelectionRanges(document2, positions2, token, provideSelectionRanges) : provideSelectionRanges(document2, positions2, token);
          }
        };
        return [languages_default.registerSelectionRangeProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/semanticTokens.ts
var import_vscode_languageserver_protocol66, logger59, SemanticTokensFeature;
var init_semanticTokens = __esm({
  "src/language-client/semanticTokens.ts"() {
    "use strict";
    import_vscode_languageserver_protocol66 = __toESM(require_main2());
    init_languages();
    init_is();
    init_features();
    init_converter();
    logger59 = require_logger2()("languageclient-semanticTokens");
    SemanticTokensFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol66.SemanticTokensRegistrationType.type);
      }
      fillClientCapabilities(capabilities) {
        const capability = ensure(ensure(capabilities, "textDocument"), "semanticTokens");
        capability.dynamicRegistration = true;
        capability.tokenTypes = [
          import_vscode_languageserver_protocol66.SemanticTokenTypes.namespace,
          import_vscode_languageserver_protocol66.SemanticTokenTypes.type,
          import_vscode_languageserver_protocol66.SemanticTokenTypes.class,
          import_vscode_languageserver_protocol66.SemanticTokenTypes.enum,
          import_vscode_languageserver_protocol66.SemanticTokenTypes.interface,
          import_vscode_languageserver_protocol66.SemanticTokenTypes.struct,
          import_vscode_languageserver_protocol66.SemanticTokenTypes.typeParameter,
          import_vscode_languageserver_protocol66.SemanticTokenTypes.parameter,
          import_vscode_languageserver_protocol66.SemanticTokenTypes.variable,
          import_vscode_languageserver_protocol66.SemanticTokenTypes.property,
          import_vscode_languageserver_protocol66.SemanticTokenTypes.enumMember,
          import_vscode_languageserver_protocol66.SemanticTokenTypes.event,
          import_vscode_languageserver_protocol66.SemanticTokenTypes.function,
          import_vscode_languageserver_protocol66.SemanticTokenTypes.method,
          import_vscode_languageserver_protocol66.SemanticTokenTypes.macro,
          import_vscode_languageserver_protocol66.SemanticTokenTypes.keyword,
          import_vscode_languageserver_protocol66.SemanticTokenTypes.modifier,
          import_vscode_languageserver_protocol66.SemanticTokenTypes.comment,
          import_vscode_languageserver_protocol66.SemanticTokenTypes.string,
          import_vscode_languageserver_protocol66.SemanticTokenTypes.number,
          import_vscode_languageserver_protocol66.SemanticTokenTypes.regexp,
          import_vscode_languageserver_protocol66.SemanticTokenTypes.decorator,
          import_vscode_languageserver_protocol66.SemanticTokenTypes.operator
        ];
        capability.tokenModifiers = [
          import_vscode_languageserver_protocol66.SemanticTokenModifiers.declaration,
          import_vscode_languageserver_protocol66.SemanticTokenModifiers.definition,
          import_vscode_languageserver_protocol66.SemanticTokenModifiers.readonly,
          import_vscode_languageserver_protocol66.SemanticTokenModifiers.static,
          import_vscode_languageserver_protocol66.SemanticTokenModifiers.deprecated,
          import_vscode_languageserver_protocol66.SemanticTokenModifiers.abstract,
          import_vscode_languageserver_protocol66.SemanticTokenModifiers.async,
          import_vscode_languageserver_protocol66.SemanticTokenModifiers.modification,
          import_vscode_languageserver_protocol66.SemanticTokenModifiers.documentation,
          import_vscode_languageserver_protocol66.SemanticTokenModifiers.defaultLibrary
        ];
        capability.formats = [import_vscode_languageserver_protocol66.TokenFormat.Relative];
        capability.requests = {
          range: true,
          full: {
            delta: true
          }
        };
        capability.multilineTokenSupport = false;
        capability.overlappingTokenSupport = false;
        capability.serverCancelSupport = true;
        capability.augmentsSyntaxTokens = true;
        ensure(ensure(capabilities, "workspace"), "semanticTokens").refreshSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(import_vscode_languageserver_protocol66.SemanticTokensRefreshRequest.type, async () => {
          for (const provider of this.getAllProviders()) {
            provider.onDidChangeSemanticTokensEmitter.fire();
          }
        });
        const [id, options2] = this.getRegistration(documentSelector, capabilities.semanticTokensProvider);
        if (!id || !options2) {
          return;
        }
        this.register({ id, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const fullProvider = boolean(options2.full) ? options2.full : options2.full !== void 0;
        const hasEditProvider = options2.full !== void 0 && typeof options2.full !== "boolean" && options2.full.delta === true;
        const eventEmitter = new import_vscode_languageserver_protocol66.Emitter();
        const documentProvider = fullProvider ? {
          onDidChangeSemanticTokens: eventEmitter.event,
          provideDocumentSemanticTokens: (document2, token) => {
            const client = this._client;
            const middleware = client.middleware;
            const provideDocumentSemanticTokens = (document3, token2) => {
              const params = {
                textDocument: asTextDocumentIdentifier(document3)
              };
              return this.sendRequest(import_vscode_languageserver_protocol66.SemanticTokensRequest.type, params, token2);
            };
            return middleware.provideDocumentSemanticTokens ? middleware.provideDocumentSemanticTokens(document2, token, provideDocumentSemanticTokens) : provideDocumentSemanticTokens(document2, token);
          },
          provideDocumentSemanticTokensEdits: hasEditProvider ? (document2, previousResultId, token) => {
            const client = this._client;
            const middleware = client.middleware;
            const provideDocumentSemanticTokensEdits = (document3, previousResultId2, token2) => {
              const params = {
                textDocument: asTextDocumentIdentifier(document3),
                previousResultId: previousResultId2
              };
              return this.sendRequest(import_vscode_languageserver_protocol66.SemanticTokensDeltaRequest.type, params, token2);
            };
            return middleware.provideDocumentSemanticTokensEdits ? middleware.provideDocumentSemanticTokensEdits(document2, previousResultId, token, provideDocumentSemanticTokensEdits) : provideDocumentSemanticTokensEdits(document2, previousResultId, token);
          } : void 0
        } : void 0;
        const hasRangeProvider = options2.range === true;
        const rangeProvider = hasRangeProvider ? {
          provideDocumentRangeSemanticTokens: (document2, range2, token) => {
            const client = this._client;
            const middleware = client.middleware;
            const provideDocumentRangeSemanticTokens = (document3, range3, token2) => {
              const params = {
                textDocument: asTextDocumentIdentifier(document3),
                range: range3
              };
              return this.sendRequest(import_vscode_languageserver_protocol66.SemanticTokensRangeRequest.type, params, token2);
            };
            return middleware.provideDocumentRangeSemanticTokens ? middleware.provideDocumentRangeSemanticTokens(document2, range2, token, provideDocumentRangeSemanticTokens) : provideDocumentRangeSemanticTokens(document2, range2, token);
          }
        } : void 0;
        const disposables = [];
        if (documentProvider !== void 0) {
          disposables.push(languages_default.registerDocumentSemanticTokensProvider(options2.documentSelector, documentProvider, options2.legend));
        }
        if (rangeProvider !== void 0) {
          disposables.push(languages_default.registerDocumentRangeSemanticTokensProvider(options2.documentSelector, rangeProvider, options2.legend));
        }
        return [import_vscode_languageserver_protocol66.Disposable.create(() => disposables.forEach((item) => item.dispose())), { range: rangeProvider, full: documentProvider, onDidChangeSemanticTokensEmitter: eventEmitter }];
      }
    };
  }
});

// src/language-client/signatureHelp.ts
var import_vscode_languageserver_protocol67, SignatureHelpFeature;
var init_signatureHelp = __esm({
  "src/language-client/signatureHelp.ts"() {
    "use strict";
    import_vscode_languageserver_protocol67 = __toESM(require_main2());
    init_languages();
    init_features();
    init_converter();
    init_uuid();
    SignatureHelpFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol67.SignatureHelpRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let config = ensure(ensure(capabilities, "textDocument"), "signatureHelp");
        config.dynamicRegistration = true;
        config.contextSupport = true;
        config.signatureInformation = {
          documentationFormat: this._client.supportedMarkupKind,
          activeParameterSupport: true,
          parameterInformation: {
            labelOffsetSupport: true
          }
        };
      }
      initialize(capabilities, documentSelector) {
        const options2 = this.getRegistrationOptions(documentSelector, capabilities.signatureHelpProvider);
        if (!options2)
          return;
        this.register({
          id: generateUuid(),
          registerOptions: options2
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideSignatureHelp: (document2, position, token, context) => {
            const client = this._client;
            const providerSignatureHelp = (document3, position2, context2, token2) => {
              return this.sendRequest(import_vscode_languageserver_protocol67.SignatureHelpRequest.type, asSignatureHelpParams(document3, position2, context2), token2);
            };
            const middleware = client.middleware;
            return middleware.provideSignatureHelp ? middleware.provideSignatureHelp(document2, position, context, token, providerSignatureHelp) : providerSignatureHelp(document2, position, context, token);
          }
        };
        const disposable = languages_default.registerSignatureHelpProvider(options2.documentSelector, provider, options2.triggerCharacters);
        return [disposable, provider];
      }
    };
  }
});

// src/language-client/textSynchronization.ts
var import_vscode_languageserver_protocol68, DidOpenTextDocumentFeature, DidCloseTextDocumentFeature, DidChangeTextDocumentFeature, WillSaveFeature, WillSaveWaitUntilFeature, DidSaveTextDocumentFeature;
var init_textSynchronization = __esm({
  "src/language-client/textSynchronization.ts"() {
    "use strict";
    import_vscode_languageserver_protocol68 = __toESM(require_main2());
    init_workspace();
    init_features();
    init_converter();
    init_uuid();
    DidOpenTextDocumentFeature = class extends TextDocumentEventFeature {
      constructor(client, _syncedDocuments) {
        super(client, workspace_default.onDidOpenTextDocument, import_vscode_languageserver_protocol68.DidOpenTextDocumentNotification.type, "didOpen", (textDocument) => asOpenTextDocumentParams(textDocument), TextDocumentEventFeature.textDocumentFilter);
        this._syncedDocuments = _syncedDocuments;
      }
      get registrationType() {
        return import_vscode_languageserver_protocol68.DidOpenTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
          this.register({
            id: generateUuid(),
            registerOptions: { documentSelector }
          });
        }
      }
      register(data) {
        super.register(data);
        if (!data.registerOptions.documentSelector)
          return;
        workspace_default.textDocuments.forEach((textDocument) => {
          let uri = textDocument.uri;
          if (this._syncedDocuments.has(uri))
            return;
          void this.callback(textDocument);
        });
      }
      notificationSent(textDocument, type, params) {
        super.notificationSent(textDocument, type, params);
        this._syncedDocuments.set(textDocument.uri.toString(), textDocument);
      }
    };
    DidCloseTextDocumentFeature = class extends TextDocumentEventFeature {
      constructor(client, _syncedDocuments) {
        super(client, workspace_default.onDidCloseTextDocument, import_vscode_languageserver_protocol68.DidCloseTextDocumentNotification.type, "didClose", (textDocument) => asCloseTextDocumentParams(textDocument), TextDocumentEventFeature.textDocumentFilter);
        this._syncedDocuments = _syncedDocuments;
      }
      get registrationType() {
        return import_vscode_languageserver_protocol68.DidCloseTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
          this.register({
            id: generateUuid(),
            registerOptions: { documentSelector }
          });
        }
      }
      notificationSent(textDocument, type, params) {
        super.notificationSent(textDocument, type, params);
        this._syncedDocuments.delete(textDocument.uri.toString());
      }
      unregister(id) {
        let selector = this._selectors.get(id);
        if (!selector)
          return;
        super.unregister(id);
        let selectors = this._selectors.values();
        this._syncedDocuments.forEach((textDocument) => {
          if (workspace_default.match(selector, textDocument) > 0 && !this._selectorFilter(selectors, textDocument)) {
            let middleware = this._client.middleware;
            let didClose = (textDocument2) => {
              return this._client.sendNotification(this._type, this._createParams(textDocument2));
            };
            this._syncedDocuments.delete(textDocument.uri.toString());
            let promise = middleware.didClose ? middleware.didClose(textDocument, didClose) : didClose(textDocument);
            if (promise) {
              promise.catch((error) => {
                this._client.error(`Sending document notification ${this._type.method} failed`, error);
              });
            }
          }
        });
      }
    };
    DidChangeTextDocumentFeature = class extends DynamicDocumentFeature {
      constructor(client) {
        super(client);
        this._changeData = /* @__PURE__ */ new Map();
        this._onNotificationSent = new import_vscode_languageserver_protocol68.Emitter();
      }
      *getDocumentSelectors() {
        for (const data of this._changeData.values()) {
          yield data.documentSelector;
        }
      }
      get registrationType() {
        return import_vscode_languageserver_protocol68.DidChangeTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "synchronization").dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.change !== void 0 && textDocumentSyncOptions.change !== import_vscode_languageserver_protocol68.TextDocumentSyncKind.None) {
          this.register({
            id: generateUuid(),
            registerOptions: Object.assign({}, { documentSelector }, { syncKind: textDocumentSyncOptions.change })
          });
        }
      }
      register(data) {
        if (!data.registerOptions.documentSelector)
          return;
        if (!this._listener) {
          this._listener = workspace_default.onDidChangeTextDocument(this.callback, this);
        }
        this._changeData.set(data.id, {
          documentSelector: data.registerOptions.documentSelector,
          syncKind: data.registerOptions.syncKind
        });
      }
      callback(event) {
        if (event.contentChanges.length === 0) {
          return;
        }
        let doc = workspace_default.getDocument(event.textDocument.uri);
        let { textDocument } = doc;
        const promises = [];
        for (const changeData of this._changeData.values()) {
          if (workspace_default.match(changeData.documentSelector, textDocument) > 0) {
            let middleware = this._client.middleware;
            let promise;
            let didChange;
            if (changeData.syncKind === import_vscode_languageserver_protocol68.TextDocumentSyncKind.Incremental) {
              didChange = async (event2) => {
                const params = asChangeTextDocumentParams(event2);
                await this._client.sendNotification(import_vscode_languageserver_protocol68.DidChangeTextDocumentNotification.type, params);
                this.notificationSent(event2, import_vscode_languageserver_protocol68.DidChangeTextDocumentNotification.type, params);
              };
            } else if (changeData.syncKind === import_vscode_languageserver_protocol68.TextDocumentSyncKind.Full) {
              didChange = async (event2) => {
                const params = asFullChangeTextDocumentParams(textDocument);
                await this._client.sendNotification(import_vscode_languageserver_protocol68.DidChangeTextDocumentNotification.type, params);
                this.notificationSent(event2, import_vscode_languageserver_protocol68.DidChangeTextDocumentNotification.type, params);
              };
            } else {
              didChange = () => Promise.resolve(void 0);
            }
            promise = middleware.didChange ? middleware.didChange(event, didChange) : didChange(event);
            if (promise)
              promises.push(promise);
          }
        }
        return Promise.all(promises).then(void 0, (error) => {
          this._client.error(`Sending document notification ${import_vscode_languageserver_protocol68.DidChangeTextDocumentNotification.type.method} failed`, error);
          throw error;
        });
      }
      get onNotificationSent() {
        return this._onNotificationSent.event;
      }
      notificationSent(changeEvent, type, params) {
        this._onNotificationSent.fire({ original: changeEvent, type, params });
      }
      unregister(id) {
        this._changeData.delete(id);
      }
      dispose() {
        this._changeData.clear();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      getProvider(document2) {
        for (const changeData of this._changeData.values()) {
          if (workspace_default.match(changeData.documentSelector, document2) > 0) {
            return {
              send: (event) => {
                return this.callback(event);
              }
            };
          }
        }
        return void 0;
      }
    };
    WillSaveFeature = class extends TextDocumentEventFeature {
      constructor(client) {
        super(client, workspace_default.onWillSaveTextDocument, import_vscode_languageserver_protocol68.WillSaveTextDocumentNotification.type, "willSave", (willSaveEvent) => asWillSaveTextDocumentParams(willSaveEvent), (selectors, willSaveEvent) => TextDocumentEventFeature.textDocumentFilter(selectors, willSaveEvent.document));
      }
      get registrationType() {
        return import_vscode_languageserver_protocol68.WillSaveTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        let value = ensure(ensure(capabilities, "textDocument"), "synchronization");
        value.willSave = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSave) {
          this.register({
            id: generateUuid(),
            registerOptions: { documentSelector }
          });
        }
      }
    };
    WillSaveWaitUntilFeature = class extends DynamicDocumentFeature {
      constructor(client) {
        super(client);
        this._selectors = /* @__PURE__ */ new Map();
      }
      getDocumentSelectors() {
        return this._selectors.values();
      }
      get registrationType() {
        return import_vscode_languageserver_protocol68.WillSaveTextDocumentWaitUntilRequest.type;
      }
      fillClientCapabilities(capabilities) {
        let value = ensure(ensure(capabilities, "textDocument"), "synchronization");
        value.willSaveWaitUntil = true;
      }
      initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && documentSelector.length > 0 && textDocumentSyncOptions && textDocumentSyncOptions.willSaveWaitUntil) {
          this.register({
            id: generateUuid(),
            registerOptions: { documentSelector }
          });
        }
      }
      register(data) {
        if (!data.registerOptions.documentSelector) {
          return;
        }
        if (!this._listener) {
          this._listener = workspace_default.onWillSaveTextDocument(this.callback, this);
        }
        this._selectors.set(data.id, data.registerOptions.documentSelector);
      }
      callback(event) {
        if (TextDocumentEventFeature.textDocumentFilter(this._selectors.values(), event.document)) {
          let middleware = this._client.middleware;
          let willSaveWaitUntil = (event2) => {
            return this.sendRequest(import_vscode_languageserver_protocol68.WillSaveTextDocumentWaitUntilRequest.type, asWillSaveTextDocumentParams(event2), import_vscode_languageserver_protocol68.CancellationToken.None);
          };
          event.waitUntil(middleware.willSaveWaitUntil ? middleware.willSaveWaitUntil(event, willSaveWaitUntil) : willSaveWaitUntil(event));
        }
      }
      unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
      dispose() {
        this._selectors.clear();
        if (this._listener) {
          this._listener.dispose();
          this._listener = void 0;
        }
      }
    };
    DidSaveTextDocumentFeature = class extends TextDocumentEventFeature {
      constructor(client) {
        super(client, workspace_default.onDidSaveTextDocument, import_vscode_languageserver_protocol68.DidSaveTextDocumentNotification.type, "didSave", (textDocument) => asSaveTextDocumentParams(textDocument, this._includeText), TextDocumentEventFeature.textDocumentFilter);
        this._includeText = false;
      }
      get registrationType() {
        return import_vscode_languageserver_protocol68.DidSaveTextDocumentNotification.type;
      }
      fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, "textDocument"), "synchronization").didSave = true;
      }
      initialize(capabilities, documentSelector) {
        const textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.save) {
          const saveOptions = typeof textDocumentSyncOptions.save === "boolean" ? { includeText: false } : { includeText: !!textDocumentSyncOptions.save.includeText };
          this.register({
            id: generateUuid(),
            registerOptions: Object.assign({}, { documentSelector }, saveOptions)
          });
        }
      }
      register(data) {
        this._includeText = !!data.registerOptions.includeText;
        super.register(data);
      }
    };
  }
});

// src/language-client/typeDefinition.ts
var import_vscode_languageserver_protocol69, TypeDefinitionFeature;
var init_typeDefinition = __esm({
  "src/language-client/typeDefinition.ts"() {
    "use strict";
    import_vscode_languageserver_protocol69 = __toESM(require_main2());
    init_languages();
    init_converter();
    init_features();
    TypeDefinitionFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol69.TypeDefinitionRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const typeDefinitionSupport = ensure(ensure(capabilities, "textDocument"), "typeDefinition");
        typeDefinitionSupport.dynamicRegistration = true;
        typeDefinitionSupport.linkSupport = true;
      }
      initialize(capabilities, documentSelector) {
        const [id, options2] = this.getRegistration(documentSelector, capabilities.typeDefinitionProvider);
        if (!id || !options2) {
          return;
        }
        this.register({ id, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideTypeDefinition: (document2, position, token) => {
            const client = this._client;
            const provideTypeDefinition = (document3, position2, token2) => this.sendRequest(import_vscode_languageserver_protocol69.TypeDefinitionRequest.type, asTextDocumentPositionParams(document3, position2), token2);
            const middleware = client.middleware;
            return middleware.provideTypeDefinition ? middleware.provideTypeDefinition(document2, position, token, provideTypeDefinition) : provideTypeDefinition(document2, position, token);
          }
        };
        return [languages_default.registerTypeDefinitionProvider(options2.documentSelector, provider), provider];
      }
    };
  }
});

// src/language-client/typeHierarchy.ts
var import_vscode_languageserver_protocol70, TypeHierarchyFeature;
var init_typeHierarchy = __esm({
  "src/language-client/typeHierarchy.ts"() {
    "use strict";
    import_vscode_languageserver_protocol70 = __toESM(require_main2());
    init_languages();
    init_features();
    init_converter();
    TypeHierarchyFeature = class extends TextDocumentLanguageFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol70.TypeHierarchyPrepareRequest.type);
      }
      fillClientCapabilities(capabilities) {
        const capability = ensure(ensure(capabilities, "textDocument"), "typeHierarchy");
        capability.dynamicRegistration = true;
      }
      initialize(capabilities, documentSelector) {
        const [id, options2] = this.getRegistration(documentSelector, capabilities.typeHierarchyProvider);
        if (!id || !options2) {
          return;
        }
        this.register({ id, registerOptions: options2 });
      }
      registerLanguageProvider(options2) {
        const client = this._client;
        const selector = options2.documentSelector;
        const provider = {
          prepareTypeHierarchy: (document2, position, token) => {
            const prepareTypeHierarchy = (document3, position2, token2) => {
              const params = asTextDocumentPositionParams(document3, position2);
              return this.sendRequest(import_vscode_languageserver_protocol70.TypeHierarchyPrepareRequest.type, params, token2);
            };
            const middleware = client.middleware;
            return middleware.prepareTypeHierarchy ? middleware.prepareTypeHierarchy(document2, position, token, prepareTypeHierarchy) : prepareTypeHierarchy(document2, position, token);
          },
          provideTypeHierarchySupertypes: (item, token) => {
            const provideTypeHierarchySupertypes = (item2, token2) => {
              return this.sendRequest(import_vscode_languageserver_protocol70.TypeHierarchySupertypesRequest.type, { item: item2 }, token2);
            };
            const middleware = client.middleware;
            return middleware.provideTypeHierarchySupertypes ? middleware.provideTypeHierarchySupertypes(item, token, provideTypeHierarchySupertypes) : provideTypeHierarchySupertypes(item, token);
          },
          provideTypeHierarchySubtypes: (item, token) => {
            const provideTypeHierarchySubtypes = (item2, token2) => {
              return this.sendRequest(import_vscode_languageserver_protocol70.TypeHierarchySubtypesRequest.type, { item: item2 }, token2);
            };
            const middleware = client.middleware;
            return middleware.provideTypeHierarchySubtypes ? middleware.provideTypeHierarchySubtypes(item, token, provideTypeHierarchySubtypes) : provideTypeHierarchySubtypes(item, token);
          }
        };
        return [languages_default.registerTypeHierarchyProvider(selector, provider), provider];
      }
    };
  }
});

// src/language-client/utils/errorHandler.ts
var CloseAction, ErrorAction, DefaultErrorHandler;
var init_errorHandler = __esm({
  "src/language-client/utils/errorHandler.ts"() {
    "use strict";
    init_window();
    CloseAction = /* @__PURE__ */ ((CloseAction2) => {
      CloseAction2[CloseAction2["DoNotRestart"] = 1] = "DoNotRestart";
      CloseAction2[CloseAction2["Restart"] = 2] = "Restart";
      return CloseAction2;
    })(CloseAction || {});
    ErrorAction = /* @__PURE__ */ ((ErrorAction2) => {
      ErrorAction2[ErrorAction2["Continue"] = 1] = "Continue";
      ErrorAction2[ErrorAction2["Shutdown"] = 2] = "Shutdown";
      return ErrorAction2;
    })(ErrorAction || {});
    DefaultErrorHandler = class {
      constructor(name2, maxRestartCount) {
        this.name = name2;
        this.maxRestartCount = maxRestartCount;
        this.restarts = [];
      }
      error(_error, _message, count) {
        if (count && count <= 3) {
          return 1 /* Continue */;
        }
        return 2 /* Shutdown */;
      }
      closed() {
        this.restarts.push(Date.now());
        if (this.restarts.length < this.maxRestartCount) {
          return 2 /* Restart */;
        } else {
          let diff = this.restarts[this.restarts.length - 1] - this.restarts[0];
          if (diff <= 3 * 60 * 1e3) {
            window_default.showMessage(`The "${this.name}" server crashed ${this.maxRestartCount} times in the last 3 minutes. The server will not be restarted.`, "error");
            return 1 /* DoNotRestart */;
          } else {
            this.restarts.shift();
            return 2 /* Restart */;
          }
        }
      }
    };
  }
});

// src/language-client/utils/logger.ts
var logger60, ConsoleLogger, NullLogger;
var init_logger = __esm({
  "src/language-client/utils/logger.ts"() {
    "use strict";
    logger60 = require_logger2()("language-client");
    ConsoleLogger = class {
      error(message) {
        logger60.error(message);
      }
      warn(message) {
        logger60.warn(message);
      }
      info(message) {
        logger60.info(message);
      }
      log(message) {
        logger60.log(message);
      }
    };
    NullLogger = class {
      error(_message) {
      }
      warn(_message) {
      }
      info(_message) {
      }
      log(_message) {
      }
    };
  }
});

// src/language-client/workspaceFolders.ts
function access2(target, key) {
  if (target === void 0) {
    return void 0;
  }
  return target[key];
}
function arrayDiff(left, right) {
  return left.filter((element) => !right.includes(element));
}
var import_vscode_languageserver_protocol71, logger61, WorkspaceFoldersFeature;
var init_workspaceFolders = __esm({
  "src/language-client/workspaceFolders.ts"() {
    "use strict";
    import_vscode_languageserver_protocol71 = __toESM(require_main2());
    init_esm();
    init_fs();
    init_workspace();
    init_uuid();
    logger61 = require_logger2()("language-client-workspaceFolder");
    WorkspaceFoldersFeature = class {
      constructor(_client) {
        this._client = _client;
        this._listeners = /* @__PURE__ */ new Map();
      }
      getState() {
        return { kind: "workspace", id: this.registrationType.method, registrations: this._listeners.size > 0 };
      }
      get registrationType() {
        return import_vscode_languageserver_protocol71.DidChangeWorkspaceFoldersNotification.type;
      }
      getValidWorkspaceFolders() {
        let { workspaceFolders } = workspace_default;
        if (!workspaceFolders || workspaceFolders.length == 0)
          return void 0;
        let ignoredRootPaths = this._client.clientOptions.ignoredRootPaths ?? [];
        let arr = workspaceFolders.filter((o) => {
          let fsPath2 = URI2.parse(o.uri).fsPath;
          return ignoredRootPaths.every((p) => !sameFile(p, fsPath2));
        });
        return arr.length ? arr : void 0;
      }
      fillInitializeParams(params) {
        const folders = this.getValidWorkspaceFolders();
        this.initializeWithFolders(folders);
        if (folders === void 0) {
          this._client.warn(`No valid workspaceFolder exists`);
          params.workspaceFolders = null;
        } else {
          params.workspaceFolders = folders.map((folder) => this.asProtocol(folder));
        }
      }
      initializeWithFolders(currentWorkspaceFolders) {
        this._initialFolders = currentWorkspaceFolders;
      }
      fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.workspaceFolders = true;
      }
      initialize(capabilities) {
        let client = this._client;
        client.onRequest(import_vscode_languageserver_protocol71.WorkspaceFoldersRequest.type, (token) => {
          let workspaceFolders = () => {
            let folders = this.getValidWorkspaceFolders();
            if (folders === void 0) {
              return null;
            }
            let result = folders.map((folder) => this.asProtocol(folder));
            return result;
          };
          const middleware = client.middleware.workspace;
          return (middleware == null ? void 0 : middleware.workspaceFolders) ? middleware.workspaceFolders(token, workspaceFolders) : workspaceFolders(token);
        });
        const value = access2(access2(access2(capabilities, "workspace"), "workspaceFolders"), "changeNotifications");
        let id;
        if (typeof value === "string") {
          id = value;
        } else if (value) {
          id = generateUuid();
        }
        if (id) {
          this.register({
            id,
            registerOptions: void 0
          });
        }
      }
      doSendEvent(addedFolders, removedFolders) {
        let params = {
          event: {
            added: addedFolders.map((folder) => this.asProtocol(folder)),
            removed: removedFolders.map((folder) => this.asProtocol(folder))
          }
        };
        return this._client.sendNotification(import_vscode_languageserver_protocol71.DidChangeWorkspaceFoldersNotification.type, params);
      }
      sendInitialEvent(currentWorkspaceFolders) {
        let promise;
        if (this._initialFolders && currentWorkspaceFolders) {
          const removed = arrayDiff(this._initialFolders, currentWorkspaceFolders);
          const added = arrayDiff(currentWorkspaceFolders, this._initialFolders);
          if (added.length > 0 || removed.length > 0) {
            promise = this.doSendEvent(added, removed);
          }
        } else if (this._initialFolders) {
          promise = this.doSendEvent([], this._initialFolders);
        } else if (currentWorkspaceFolders) {
          promise = this.doSendEvent(currentWorkspaceFolders, []);
        }
        if (promise) {
          promise.catch((error) => {
            this._client.error(`Sending notification ${import_vscode_languageserver_protocol71.DidChangeWorkspaceFoldersNotification.type.method} failed`, error);
          });
        }
      }
      register(data) {
        let id = data.id;
        let client = this._client;
        let disposable = workspace_default.onDidChangeWorkspaceFolders((event) => {
          let didChangeWorkspaceFolders = (e) => {
            return this.doSendEvent(e.added, e.removed);
          };
          let middleware = client.middleware.workspace;
          const promise = (middleware == null ? void 0 : middleware.didChangeWorkspaceFolders) ? middleware.didChangeWorkspaceFolders(event, didChangeWorkspaceFolders) : didChangeWorkspaceFolders(event);
          if (promise) {
            promise.catch((error) => {
              this._client.error(`Sending notification ${import_vscode_languageserver_protocol71.DidChangeWorkspaceFoldersNotification.type.method} failed`, error);
            });
          }
        });
        this._listeners.set(id, disposable);
        let workspaceFolders = this.getValidWorkspaceFolders();
        this.sendInitialEvent(workspaceFolders);
      }
      unregister(id) {
      }
      dispose() {
        for (let disposable of this._listeners.values()) {
          disposable.dispose();
        }
        this._listeners.clear();
      }
      asProtocol(workspaceFolder) {
        if (workspaceFolder == null)
          return null;
        return { uri: workspaceFolder.uri, name: workspaceFolder.name };
      }
    };
  }
});

// src/language-client/workspaceSymbol.ts
var import_vscode_languageserver_protocol72, WorkspaceFeature, WorkspaceSymbolFeature;
var init_workspaceSymbol = __esm({
  "src/language-client/workspaceSymbol.ts"() {
    "use strict";
    import_vscode_languageserver_protocol72 = __toESM(require_main2());
    init_languages();
    init_documentSymbol();
    init_features();
    init_uuid();
    WorkspaceFeature = class extends BaseFeature {
      constructor(_client, _registrationType) {
        super(_client);
        this._registrationType = _registrationType;
        this._registrations = /* @__PURE__ */ new Map();
      }
      getState() {
        const registrations = this._registrations.size > 0;
        return { kind: "workspace", id: this._registrationType.method, registrations };
      }
      get registrationType() {
        return this._registrationType;
      }
      register(data) {
        const registration = this.registerLanguageProvider(data.registerOptions);
        this._registrations.set(data.id, { disposable: registration[0], provider: registration[1] });
      }
      unregister(id) {
        const registration = this._registrations.get(id);
        if (registration)
          registration.disposable.dispose();
      }
      dispose() {
        this._registrations.forEach((value) => {
          value.disposable.dispose();
        });
        this._registrations.clear();
      }
      getProviders() {
        const result = [];
        for (const registration of this._registrations.values()) {
          result.push(registration.provider);
        }
        return result;
      }
    };
    WorkspaceSymbolFeature = class extends WorkspaceFeature {
      constructor(client) {
        super(client, import_vscode_languageserver_protocol72.WorkspaceSymbolRequest.type);
      }
      fillClientCapabilities(capabilities) {
        let symbolCapabilities = ensure(ensure(capabilities, "workspace"), "symbol");
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
          valueSet: SupportedSymbolKinds
        };
        symbolCapabilities.tagSupport = {
          valueSet: SupportedSymbolTags
        };
        symbolCapabilities.resolveSupport = { properties: ["location.range"] };
      }
      initialize(capabilities) {
        if (!capabilities.workspaceSymbolProvider) {
          return;
        }
        this.register({
          id: generateUuid(),
          registerOptions: capabilities.workspaceSymbolProvider === true ? { workDoneProgress: false } : capabilities.workspaceSymbolProvider
        });
      }
      registerLanguageProvider(options2) {
        const provider = {
          provideWorkspaceSymbols: (query, token) => {
            const client = this._client;
            const provideWorkspaceSymbols = (query2, token2) => {
              return this.sendRequest(import_vscode_languageserver_protocol72.WorkspaceSymbolRequest.type, { query: query2 }, token2);
            };
            const middleware = client.middleware;
            return middleware.provideWorkspaceSymbols ? middleware.provideWorkspaceSymbols(query, token, provideWorkspaceSymbols) : provideWorkspaceSymbols(query, token);
          },
          resolveWorkspaceSymbol: options2.resolveProvider === true ? (item, token) => {
            const client = this._client;
            const resolveWorkspaceSymbol = (item2, token2) => {
              return this.sendRequest(import_vscode_languageserver_protocol72.WorkspaceSymbolResolveRequest.type, item2, token2);
            };
            const middleware = client.middleware;
            return middleware.resolveWorkspaceSymbol ? middleware.resolveWorkspaceSymbol(item, token, resolveWorkspaceSymbol) : resolveWorkspaceSymbol(item, token);
          } : void 0
        };
        return [languages_default.registerWorkspaceSymbolProvider(provider), provider];
      }
    };
  }
});

// src/language-client/client.ts
function createConnection(input, output, errorHandler, closeHandler, options2) {
  let logger138 = new ConsoleLogger();
  let connection = (0, import_vscode_languageserver_protocol73.createProtocolConnection)(input, output, logger138, options2);
  connection.onError((data) => {
    errorHandler(data[0], data[1], data[2]);
  });
  connection.onClose(closeHandler);
  let result = {
    id: "",
    hasPendingResponse: () => connection.hasPendingResponse(),
    listen: () => connection.listen(),
    sendRequest: (type, ...params) => {
      return connection.sendRequest(string(type) ? type : type.method, ...params);
    },
    onRequest: (type, handler) => connection.onRequest(string(type) ? type : type.method, handler),
    sendNotification: (type, params) => {
      return connection.sendNotification(string(type) ? type : type.method, params);
    },
    onNotification: (type, handler) => connection.onNotification(string(type) ? type : type.method, handler),
    onProgress: connection.onProgress,
    sendProgress: connection.sendProgress,
    trace: (value, tracer, sendNotificationOrTraceOptions) => {
      return connection.trace(value, tracer, sendNotificationOrTraceOptions);
    },
    initialize: (params) => {
      return connection.sendRequest(import_vscode_languageserver_protocol73.InitializeRequest.type, params);
    },
    shutdown: () => {
      return connection.sendRequest(import_vscode_languageserver_protocol73.ShutdownRequest.type, void 0);
    },
    exit: () => {
      return connection.sendNotification(import_vscode_languageserver_protocol73.ExitNotification.type);
    },
    end: () => connection.end(),
    dispose: () => connection.dispose()
  };
  return result;
}
var import_os11, import_path21, import_vscode_languageserver_protocol73, logger62, RevealOutputChannelOn, State, ClientState, MessageTransports, _BaseLanguageClient, BaseLanguageClient, ProposedFeatures;
var init_client = __esm({
  "src/language-client/client.ts"() {
    "use strict";
    import_os11 = __toESM(require("os"));
    import_path21 = __toESM(require("path"));
    import_vscode_languageserver_protocol73 = __toESM(require_main2());
    init_esm();
    init_languages();
    init_errors();
    init_fs();
    init_is();
    init_position();
    init_window();
    init_workspace();
    init_callHierarchy();
    init_codeAction();
    init_codeLens();
    init_colorProvider();
    init_completion();
    init_configuration3();
    init_declaration();
    init_definition();
    init_diagnostic();
    init_documentHighlight();
    init_documentLink();
    init_documentSymbol();
    init_executeCommand();
    init_features();
    init_fileOperations();
    init_fileSystemWatcher2();
    init_foldingRange();
    init_formatting();
    init_hover();
    init_implementation();
    init_inlayHint();
    init_inlineValue();
    init_linkedEditingRange();
    init_progress2();
    init_progressPart();
    init_reference();
    init_rename();
    init_selectionRange();
    init_semanticTokens();
    init_signatureHelp();
    init_textSynchronization();
    init_typeDefinition();
    init_typeHierarchy();
    init_converter();
    init_errorHandler();
    init_logger();
    init_uuid();
    init_workspaceFolders();
    init_workspaceSymbol();
    logger62 = require_logger2()("language-client-client");
    RevealOutputChannelOn = /* @__PURE__ */ ((RevealOutputChannelOn2) => {
      RevealOutputChannelOn2[RevealOutputChannelOn2["Info"] = 1] = "Info";
      RevealOutputChannelOn2[RevealOutputChannelOn2["Warn"] = 2] = "Warn";
      RevealOutputChannelOn2[RevealOutputChannelOn2["Error"] = 3] = "Error";
      RevealOutputChannelOn2[RevealOutputChannelOn2["Never"] = 4] = "Never";
      return RevealOutputChannelOn2;
    })(RevealOutputChannelOn || {});
    State = /* @__PURE__ */ ((State2) => {
      State2[State2["Stopped"] = 1] = "Stopped";
      State2[State2["Running"] = 2] = "Running";
      State2[State2["Starting"] = 3] = "Starting";
      return State2;
    })(State || {});
    ClientState = /* @__PURE__ */ ((ClientState2) => {
      ClientState2[ClientState2["Initial"] = 0] = "Initial";
      ClientState2[ClientState2["Starting"] = 1] = "Starting";
      ClientState2[ClientState2["StartFailed"] = 2] = "StartFailed";
      ClientState2[ClientState2["Running"] = 3] = "Running";
      ClientState2[ClientState2["Stopping"] = 4] = "Stopping";
      ClientState2[ClientState2["Stopped"] = 5] = "Stopped";
      return ClientState2;
    })(ClientState || {});
    ((MessageTransports2) => {
      function is(value) {
        let candidate = value;
        return candidate && import_vscode_languageserver_protocol73.MessageReader.is(value.reader) && import_vscode_languageserver_protocol73.MessageWriter.is(value.writer);
      }
      MessageTransports2.is = is;
    })(MessageTransports || (MessageTransports = {}));
    _BaseLanguageClient = class {
      constructor(id, name2, clientOptions) {
        this._features = [];
        this._dynamicFeatures = /* @__PURE__ */ new Map();
        this._id = id;
        this._name = name2;
        if (clientOptions.outputChannel) {
          this._outputChannel = clientOptions.outputChannel;
        } else {
          this._outputChannel = void 0;
        }
        this._clientOptions = this.resolveClientOptions(clientOptions);
        this.$state = 0 /* Initial */;
        this._connection = void 0;
        this._initializeResult = void 0;
        this._listeners = [];
        this._diagnostics = void 0;
        this._notificationHandlers = /* @__PURE__ */ new Map();
        this._pendingNotificationHandlers = /* @__PURE__ */ new Map();
        this._notificationDisposables = /* @__PURE__ */ new Map();
        this._requestHandlers = /* @__PURE__ */ new Map();
        this._pendingRequestHandlers = /* @__PURE__ */ new Map();
        this._requestDisposables = /* @__PURE__ */ new Map();
        this._progressHandlers = /* @__PURE__ */ new Map();
        this._pendingProgressHandlers = /* @__PURE__ */ new Map();
        this._progressDisposables = /* @__PURE__ */ new Map();
        this._ignoredRegistrations = /* @__PURE__ */ new Set();
        this._onStop = void 0;
        this._stateChangeEmitter = new import_vscode_languageserver_protocol73.Emitter();
        this._trace = import_vscode_languageserver_protocol73.Trace.Off;
        this._tracer = {
          log: (messageOrDataObject, data) => {
            if (string(messageOrDataObject)) {
              this.logTrace(messageOrDataObject, data);
            } else {
              this.logObjectTrace(messageOrDataObject);
            }
          }
        };
        this._syncedDocuments = /* @__PURE__ */ new Map();
        this.registerBuiltinFeatures();
      }
      resolveClientOptions(clientOptions) {
        var _a;
        const markdown = { isTrusted: false, supportHtml: false };
        if (clientOptions.markdown != null) {
          markdown.isTrusted = clientOptions.markdown.isTrusted === true;
          markdown.supportHtml = clientOptions.markdown.supportHtml === true;
        }
        let disableSnippetCompletion = clientOptions.disableSnippetCompletion;
        if (clientOptions.disableSnippetCompletion === void 0) {
          let suggest = workspace_default.getConfiguration("suggest");
          if (suggest.get("snippetsSupport", true) === false) {
            disableSnippetCompletion = true;
          }
        }
        let disableMarkdown = clientOptions.disableMarkdown;
        if (disableMarkdown === void 0) {
          let preferences = workspace_default.getConfiguration("coc.preferences");
          disableMarkdown = preferences.get("enableMarkdown", true) === false;
        }
        const pullConfig = workspace_default.getConfiguration("pullDiagnostic");
        let pullOption = clientOptions.diagnosticPullOptions ?? {};
        if (pullOption.onChange === void 0)
          pullOption.onChange = pullConfig.get("onChange");
        if (pullOption.onSave === void 0)
          pullOption.onSave = pullConfig.get("onSave");
        if (pullOption.workspace === void 0)
          pullOption.workspace = pullConfig.get("workspace");
        pullOption.ignored = pullConfig.get("ignored", []).concat(pullOption.ignored ?? []);
        let disabledFeatures = clientOptions.disabledFeatures ?? [];
        for (let key of ["disableCompletion", "disableWorkspaceFolders", "disableDiagnostics"]) {
          if (typeof clientOptions[key] === "boolean") {
            let stack = "\n" + Error().stack.split("\n").slice(2, 4).join("\n");
            logger62.warn(`${key} in the client options is deprecated. use disabledFeatures instead.`, stack);
            if (clientOptions[key] === true) {
              let s = key.slice(7);
              disabledFeatures.push(s[0].toLowerCase() + s.slice(1));
            }
          }
        }
        let separateDiagnostics = clientOptions.separateDiagnostics;
        if (clientOptions.separateDiagnostics === void 0) {
          separateDiagnostics = workspace_default.getConfiguration("diagnostic").get("separateRelatedInformationAsDiagnostics");
        }
        return {
          disabledFeatures,
          disableMarkdown,
          disableSnippetCompletion,
          separateDiagnostics,
          diagnosticPullOptions: pullOption,
          rootPatterns: clientOptions.rootPatterns ?? [],
          requireRootPattern: clientOptions.requireRootPattern,
          disableDynamicRegister: clientOptions.disableDynamicRegister,
          formatterPriority: clientOptions.formatterPriority ?? 0,
          ignoredRootPaths: clientOptions.ignoredRootPaths ?? [],
          documentSelector: clientOptions.documentSelector ?? [],
          synchronize: clientOptions.synchronize ?? {},
          diagnosticCollectionName: clientOptions.diagnosticCollectionName,
          outputChannelName: clientOptions.outputChannelName ?? this._id,
          revealOutputChannelOn: clientOptions.revealOutputChannelOn ?? 4 /* Never */,
          stdioEncoding: clientOptions.stdioEncoding ?? "utf8",
          initializationOptions: clientOptions.initializationOptions,
          initializationFailedHandler: clientOptions.initializationFailedHandler,
          progressOnInitialization: clientOptions.progressOnInitialization === true,
          errorHandler: clientOptions.errorHandler ?? this.createDefaultErrorHandler((_a = clientOptions.connectionOptions) == null ? void 0 : _a.maxRestartCount),
          middleware: clientOptions.middleware ?? {},
          workspaceFolder: clientOptions.workspaceFolder,
          connectionOptions: clientOptions.connectionOptions,
          markdown
        };
      }
      get supportedMarkupKind() {
        if (!this.clientOptions.disableMarkdown)
          return [import_vscode_languageserver_protocol73.MarkupKind.Markdown, import_vscode_languageserver_protocol73.MarkupKind.PlainText];
        return [import_vscode_languageserver_protocol73.MarkupKind.PlainText];
      }
      get state() {
        return this.getPublicState();
      }
      get $state() {
        return this._state;
      }
      set $state(value) {
        let oldState = this.getPublicState();
        this._state = value;
        let newState = this.getPublicState();
        if (newState !== oldState) {
          this._stateChangeEmitter.fire({ oldState, newState });
        }
      }
      get id() {
        return this._id;
      }
      get name() {
        return this._name;
      }
      get middleware() {
        return this._clientOptions.middleware;
      }
      getPublicState() {
        if (this.$state === 3 /* Running */) {
          return 2 /* Running */;
        } else if (this.$state === 1 /* Starting */) {
          return 3 /* Starting */;
        } else {
          return 1 /* Stopped */;
        }
      }
      get initializeResult() {
        return this._initializeResult;
      }
      async sendRequest(type, ...params) {
        this.checkState();
        try {
          const connection = await this.$start();
          return await connection.sendRequest(type, ...params);
        } catch (error) {
          this.error(`Sending request ${string(type) ? type : type.method} failed.`, error);
          throw error;
        }
      }
      onRequest(type, handler) {
        const method = typeof type === "string" ? type : type.method;
        this._requestHandlers.set(method, handler);
        const connection = this.activeConnection();
        let disposable;
        if (connection !== void 0) {
          this._requestDisposables.set(method, connection.onRequest(type, handler));
          disposable = {
            dispose: () => {
              const disposable2 = this._requestDisposables.get(method);
              if (disposable2 !== void 0) {
                disposable2.dispose();
                this._requestDisposables.delete(method);
              }
            }
          };
        } else {
          this._pendingRequestHandlers.set(method, handler);
          disposable = {
            dispose: () => {
              this._pendingRequestHandlers.delete(method);
              const disposable2 = this._requestDisposables.get(method);
              if (disposable2 !== void 0) {
                disposable2.dispose();
                this._requestDisposables.delete(method);
              }
            }
          };
        }
        return {
          dispose: () => {
            this._requestHandlers.delete(method);
            disposable.dispose();
          }
        };
      }
      async sendNotification(type, params) {
        this.checkState();
        try {
          const connection = await this.$start();
          return await connection.sendNotification(type, params);
        } catch (error) {
          this.error(`Sending notification ${string(type) ? type : type.method} failed.`, error);
          throw error;
        }
      }
      onNotification(type, handler) {
        const method = typeof type === "string" ? type : type.method;
        this._notificationHandlers.set(method, handler);
        const connection = this.activeConnection();
        let disposable;
        if (connection !== void 0) {
          this._notificationDisposables.set(method, connection.onNotification(type, handler));
          disposable = {
            dispose: () => {
              const disposable2 = this._notificationDisposables.get(method);
              if (disposable2 !== void 0) {
                disposable2.dispose();
                this._notificationDisposables.delete(method);
              }
            }
          };
        } else {
          this._pendingNotificationHandlers.set(method, handler);
          disposable = {
            dispose: () => {
              this._pendingNotificationHandlers.delete(method);
              const disposable2 = this._notificationDisposables.get(method);
              if (disposable2 !== void 0) {
                disposable2.dispose();
                this._notificationDisposables.delete(method);
              }
            }
          };
        }
        return {
          dispose: () => {
            this._notificationHandlers.delete(method);
            disposable.dispose();
          }
        };
      }
      onProgress(type, token, handler) {
        this._progressHandlers.set(token, { type, handler });
        const connection = this.activeConnection();
        let disposable;
        const handleWorkDoneProgress = this._clientOptions.middleware.handleWorkDoneProgress;
        const realHandler = import_vscode_languageserver_protocol73.WorkDoneProgress.is(type) && handleWorkDoneProgress !== void 0 ? (params) => {
          handleWorkDoneProgress(token, params, () => handler(params));
        } : handler;
        if (connection !== void 0) {
          this._progressDisposables.set(token, connection.onProgress(type, token, realHandler));
          disposable = {
            dispose: () => {
              const disposable2 = this._progressDisposables.get(token);
              if (disposable2 !== void 0) {
                disposable2.dispose();
                this._progressDisposables.delete(token);
              }
            }
          };
        } else {
          this._pendingProgressHandlers.set(token, { type, handler });
          disposable = {
            dispose: () => {
              this._pendingProgressHandlers.delete(token);
              const disposable2 = this._progressDisposables.get(token);
              if (disposable2 !== void 0) {
                disposable2.dispose();
                this._progressDisposables.delete(token);
              }
            }
          };
        }
        return {
          dispose: () => {
            this._progressHandlers.delete(token);
            disposable.dispose();
          }
        };
      }
      async sendProgress(type, token, value) {
        this.checkState();
        try {
          const connection = await this.$start();
          await connection.sendProgress(type, token, value);
        } catch (error) {
          this.error(`Sending progress for token ${token} failed.`, error);
          throw error;
        }
      }
      get configuredSection() {
        var _a;
        let section2 = (_a = this._clientOptions.synchronize) == null ? void 0 : _a.configurationSection;
        return typeof section2 === "string" && section2.startsWith("languageserver.") ? section2 : void 0;
      }
      get clientOptions() {
        return this._clientOptions;
      }
      get onDidChangeState() {
        return this._stateChangeEmitter.event;
      }
      get outputChannel() {
        if (!this._outputChannel) {
          let { outputChannelName } = this._clientOptions;
          this._outputChannel = window_default.createOutputChannel(outputChannelName ? outputChannelName : this._name);
        }
        return this._outputChannel;
      }
      get diagnostics() {
        return this._diagnostics;
      }
      createDefaultErrorHandler(maxRestartCount) {
        return new DefaultErrorHandler(this._id, maxRestartCount ?? 4);
      }
      set trace(value) {
        this._trace = value;
        const connection = this.activeConnection();
        if (connection !== void 0) {
          void connection.trace(this._trace, this._tracer, {
            sendNotification: false,
            traceFormat: this._traceFormat
          });
        }
      }
      logObjectTrace(data) {
        if (data.isLSPMessage && data.type) {
          this.outputChannel.append(`[LSP   - ${new Date().toLocaleTimeString()}] `);
        } else {
          this.outputChannel.append(`[Trace - ${new Date().toLocaleTimeString()}] `);
        }
        if (data) {
          this.outputChannel.appendLine(`${JSON.stringify(data)}`);
        }
      }
      data2String(data) {
        if (data instanceof import_vscode_languageserver_protocol73.ResponseError) {
          const responseError = data;
          return `  Message: ${responseError.message}
  Code: ${responseError.code} ${responseError.data ? "\n" + responseError.data.toString() : ""}`;
        }
        if (data instanceof Error) {
          if (string(data.stack)) {
            return data.stack;
          }
          return data.message;
        }
        if (string(data)) {
          return data;
        }
        return data.toString();
      }
      info(message, data, showNotification = true) {
        this.outputChannel.appendLine(`[Info  - ${new Date().toLocaleTimeString()}] ${message}`);
        if (data !== null && data !== void 0) {
          this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification && this._clientOptions.revealOutputChannelOn <= 1 /* Info */) {
          this.showNotificationMessage(import_vscode_languageserver_protocol73.MessageType.Info, message);
        }
      }
      warn(message, data, showNotification = true) {
        this.outputChannel.appendLine(`[Warn  - ${new Date().toLocaleTimeString()}] ${message}`);
        if (data !== null && data !== void 0) {
          this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification && this._clientOptions.revealOutputChannelOn <= 2 /* Warn */) {
          this.showNotificationMessage(import_vscode_languageserver_protocol73.MessageType.Warning, message);
        }
      }
      error(message, data, showNotification = true) {
        this.outputChannel.appendLine(`[Error - ${new Date().toLocaleTimeString()}] ${message}`);
        if (data !== null && data !== void 0) {
          this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification === "force" || showNotification && this._clientOptions.revealOutputChannelOn <= 3 /* Error */) {
          this.showNotificationMessage(import_vscode_languageserver_protocol73.MessageType.Error, message);
        }
      }
      showNotificationMessage(type, message) {
        message = message ?? "A request has failed. See the output for more information.";
        const messageFunc = type === import_vscode_languageserver_protocol73.MessageType.Error ? window_default.showErrorMessage.bind(window_default) : type === import_vscode_languageserver_protocol73.MessageType.Warning ? window_default.showWarningMessage.bind(window_default) : window_default.showInformationMessage.bind(window_default);
        void messageFunc(message);
      }
      logTrace(message, data) {
        this.outputChannel.appendLine(`[Trace - ${new Date().toLocaleTimeString()}] ${message}`);
        if (data) {
          this.outputChannel.appendLine(this.data2String(data));
        }
      }
      needsStart() {
        return this.$state === 0 /* Initial */ || this.$state === 4 /* Stopping */ || this.$state === 5 /* Stopped */;
      }
      needsStop() {
        return this.$state === 1 /* Starting */ || this.$state === 3 /* Running */;
      }
      activeConnection() {
        return this.$state === 3 /* Running */ && this._connection !== void 0 ? this._connection : void 0;
      }
      get hasPendingResponse() {
        var _a;
        return (_a = this._connection) == null ? void 0 : _a.hasPendingResponse();
      }
      onReady() {
        if (this._onStart)
          return this._onStart;
        return new Promise((resolve3) => {
          let disposable = this.onDidChangeState((e) => {
            if (e.newState === 2 /* Running */) {
              disposable.dispose();
              resolve3();
            }
          });
        });
      }
      get started() {
        return this.$state != 0 /* Initial */;
      }
      isRunning() {
        return this.$state === 3 /* Running */;
      }
      async _start() {
        if (this._disposed === "disposing" || this._disposed === "disposed") {
          throw new Error(`Client got disposed and can't be restarted.`);
        }
        if (this.$state === 4 /* Stopping */) {
          throw new Error(`Client is currently stopping. Can only restart a full stopped client`);
        }
        if (this._onStart !== void 0) {
          return this._onStart;
        }
        this._rootPath = this.resolveRootPath();
        const [promise, resolve3, reject] = this.createOnStartPromise();
        this._onStart = promise;
        if (this._diagnostics === void 0) {
          let opts = this._clientOptions;
          let name2 = opts.diagnosticCollectionName ? opts.diagnosticCollectionName : this._id;
          if (!opts.disabledFeatures.includes("diagnostics")) {
            this._diagnostics = languages_default.createDiagnosticCollection(name2);
          }
        }
        for (const [method, handler] of this._notificationHandlers) {
          if (!this._pendingNotificationHandlers.has(method)) {
            this._pendingNotificationHandlers.set(method, handler);
          }
        }
        for (const [method, handler] of this._requestHandlers) {
          if (!this._pendingRequestHandlers.has(method)) {
            this._pendingRequestHandlers.set(method, handler);
          }
        }
        for (const [token, data] of this._progressHandlers) {
          if (!this._pendingProgressHandlers.has(token)) {
            this._pendingProgressHandlers.set(token, data);
          }
        }
        this.$state = 1 /* Starting */;
        try {
          const connection = await this.createConnection();
          this.handleConnectionEvents(connection);
          connection.listen();
          await this.initialize(connection);
          resolve3();
        } catch (error) {
          this.$state = 2 /* StartFailed */;
          this.error(`${this._name} client: couldn't create connection to server.`, error, "force");
          reject(error);
        }
        return this._onStart;
      }
      start() {
        let p = this._start();
        p.dispose = () => {
          if (this.needsStop()) {
            void this.stop();
          }
        };
        return p;
      }
      async $start() {
        if (this.$state === 2 /* StartFailed */) {
          throw new Error(`Previous start failed. Can't restart server.`);
        }
        await this._start();
        const connection = this.activeConnection();
        if (connection === void 0) {
          throw new Error(`Starting server failed`);
        }
        return connection;
      }
      handleConnectionEvents(connection) {
        connection.onNotification(import_vscode_languageserver_protocol73.LogMessageNotification.type, (message) => {
          switch (message.type) {
            case import_vscode_languageserver_protocol73.MessageType.Error:
              this.error(message.message);
              break;
            case import_vscode_languageserver_protocol73.MessageType.Warning:
              this.warn(message.message);
              break;
            case import_vscode_languageserver_protocol73.MessageType.Info:
              this.info(message.message);
              break;
            default:
              this.outputChannel.appendLine(message.message);
          }
        });
        connection.onNotification(import_vscode_languageserver_protocol73.ShowMessageNotification.type, (message) => {
          switch (message.type) {
            case import_vscode_languageserver_protocol73.MessageType.Error:
              void window_default.showErrorMessage(message.message);
              break;
            case import_vscode_languageserver_protocol73.MessageType.Warning:
              void window_default.showWarningMessage(message.message);
              break;
            case import_vscode_languageserver_protocol73.MessageType.Info:
              void window_default.showInformationMessage(message.message);
              break;
            default:
              void window_default.showInformationMessage(message.message);
          }
        });
        connection.onNotification(import_vscode_languageserver_protocol73.TelemetryEventNotification.type, (data) => {
        });
        connection.onRequest(import_vscode_languageserver_protocol73.ShowMessageRequest.type, (params) => {
          let messageFunc;
          switch (params.type) {
            case import_vscode_languageserver_protocol73.MessageType.Error:
              messageFunc = window_default.showErrorMessage.bind(window_default);
              break;
            case import_vscode_languageserver_protocol73.MessageType.Warning:
              messageFunc = window_default.showWarningMessage.bind(window_default);
              break;
            case import_vscode_languageserver_protocol73.MessageType.Info:
              messageFunc = window_default.showInformationMessage.bind(window_default);
              break;
            default:
              messageFunc = window_default.showInformationMessage.bind(window_default);
          }
          let actions = params.actions || [];
          return messageFunc(params.message, ...actions).then((res) => {
            return res == null ? null : res;
          });
        });
        connection.onRequest(import_vscode_languageserver_protocol73.ShowDocumentRequest.type, async (params) => {
          var _a;
          const showDocument = async (params2) => {
            try {
              if (params2.external === true || /^https?:\/\//.test(params2.uri)) {
                await workspace_default.openResource(params2.uri);
                return { success: true };
              } else {
                let { selection, takeFocus } = params2;
                if (takeFocus === false) {
                  await workspace_default.loadFile(params2.uri);
                } else {
                  await workspace_default.jumpTo(params2.uri, selection == null ? void 0 : selection.start);
                  if (comparePosition(selection.start, selection.end) != 0) {
                    await window_default.selectRange(selection);
                  }
                }
                return { success: true };
              }
            } catch (error) {
              return { success: false };
            }
          };
          const middleware = (_a = this._clientOptions.middleware.window) == null ? void 0 : _a.showDocument;
          if (middleware !== void 0) {
            return middleware(params, showDocument);
          } else {
            return showDocument(params);
          }
        });
      }
      createOnStartPromise() {
        let resolve3;
        let reject;
        const promise = new Promise((_resolve, _reject) => {
          resolve3 = _resolve;
          reject = _reject;
        });
        return [promise, resolve3, reject];
      }
      resolveRootPath() {
        if (this._clientOptions.workspaceFolder) {
          return URI2.parse(this._clientOptions.workspaceFolder.uri).fsPath;
        }
        let { ignoredRootPaths, rootPatterns, requireRootPattern } = this._clientOptions;
        let resolved;
        if (Array.isArray(rootPatterns) && rootPatterns.length > 0) {
          let doc = workspace_default.getDocument(workspace_default.bufnr);
          if (doc && doc.schema == "file") {
            let dir = import_path21.default.dirname(URI2.parse(doc.uri).fsPath);
            resolved = resolveRoot(dir, rootPatterns, workspace_default.cwd);
          } else {
            resolved = resolveRoot(workspace_default.cwd, rootPatterns);
          }
          if (requireRootPattern && !resolved) {
            throw new Error(`Required root pattern not resolved, server won't start.`);
          }
        }
        let rootPath = resolved || workspace_default.rootPath || workspace_default.cwd;
        if (sameFile(rootPath, import_os11.default.homedir()) || Array.isArray(ignoredRootPaths) && ignoredRootPaths.some((p) => sameFile(rootPath, p))) {
          this.warn(`Ignored rootPath ${rootPath} of client "${this._id}"`);
          return null;
        }
        return rootPath;
      }
      initialize(connection) {
        let { initializationOptions, progressOnInitialization } = this._clientOptions;
        this.refreshTrace(connection, false);
        let rootPath = this._rootPath;
        let initParams = {
          processId: process.pid,
          rootPath: rootPath ? rootPath : null,
          rootUri: rootPath ? asUri(URI2.file(rootPath)) : null,
          capabilities: this.computeClientCapabilities(),
          initializationOptions: func(initializationOptions) ? initializationOptions() : initializationOptions,
          trace: import_vscode_languageserver_protocol73.Trace.toString(this._trace),
          workspaceFolders: null,
          locale: this.getLocale(),
          clientInfo: {
            name: "coc.nvim",
            version: workspace_default.version
          }
        };
        this.fillInitializeParams(initParams);
        if (progressOnInitialization) {
          const token = generateUuid();
          initParams.workDoneToken = token;
          connection.id = this._id;
          const part = new ProgressPart(connection, token);
          part.begin({ title: `Initializing ${this.id}`, kind: "begin" });
          return this.doInitialize(connection, initParams).then((result) => {
            part.done();
            return result;
          }, (error) => {
            part.cancel();
            throw error;
          });
        } else {
          return this.doInitialize(connection, initParams);
        }
      }
      async doInitialize(connection, initParams) {
        try {
          const result = await connection.initialize(initParams);
          if (result.capabilities.positionEncoding !== void 0 && result.capabilities.positionEncoding !== import_vscode_languageserver_protocol73.PositionEncodingKind.UTF16) {
            throw new Error(`Unsupported position encoding (${result.capabilities.positionEncoding}) received from server ${this.name}`);
          }
          this._initializeResult = result;
          this.$state = 3 /* Running */;
          let textDocumentSyncOptions;
          if (number(result.capabilities.textDocumentSync)) {
            if (result.capabilities.textDocumentSync === import_vscode_languageserver_protocol73.TextDocumentSyncKind.None) {
              textDocumentSyncOptions = {
                openClose: false,
                change: import_vscode_languageserver_protocol73.TextDocumentSyncKind.None,
                save: void 0
              };
            } else {
              textDocumentSyncOptions = {
                openClose: true,
                change: result.capabilities.textDocumentSync,
                save: {
                  includeText: false
                }
              };
            }
          } else if (result.capabilities.textDocumentSync !== void 0 && result.capabilities.textDocumentSync !== null) {
            textDocumentSyncOptions = result.capabilities.textDocumentSync;
          }
          this._capabilities = Object.assign({}, result.capabilities, { resolvedTextDocumentSync: textDocumentSyncOptions });
          connection.onNotification(import_vscode_languageserver_protocol73.PublishDiagnosticsNotification.type, (params) => this.handleDiagnostics(params));
          connection.onRequest(import_vscode_languageserver_protocol73.RegistrationRequest.type, (params) => this.handleRegistrationRequest(params));
          connection.onRequest("client/registerFeature", (params) => this.handleRegistrationRequest(params));
          connection.onRequest(import_vscode_languageserver_protocol73.UnregistrationRequest.type, (params) => this.handleUnregistrationRequest(params));
          connection.onRequest("client/unregisterFeature", (params) => this.handleUnregistrationRequest(params));
          connection.onRequest(import_vscode_languageserver_protocol73.ApplyWorkspaceEditRequest.type, (params) => this.handleApplyWorkspaceEdit(params));
          for (const [method, handler] of this._pendingNotificationHandlers) {
            this._notificationDisposables.set(method, connection.onNotification(method, handler));
          }
          this._pendingNotificationHandlers.clear();
          for (const [method, handler] of this._pendingRequestHandlers) {
            this._requestDisposables.set(method, connection.onRequest(method, handler));
          }
          this._pendingRequestHandlers.clear();
          for (const [token, data] of this._pendingProgressHandlers) {
            this._progressDisposables.set(token, connection.onProgress(data.type, token, data.handler));
          }
          this._pendingProgressHandlers.clear();
          await connection.sendNotification(import_vscode_languageserver_protocol73.InitializedNotification.type, {});
          this.hookConfigurationChanged(connection);
          this.initializeFeatures(connection);
          return result;
        } catch (error) {
          if (this._clientOptions.initializationFailedHandler) {
            if (this._clientOptions.initializationFailedHandler(error)) {
              this.initialize(connection).catch(() => {
              });
            } else {
              this.stop().catch(() => {
              });
            }
          } else if (error instanceof import_vscode_languageserver_protocol73.ResponseError && error.data && error.data.retry) {
            void window_default.showErrorMessage(error.message, { title: "Retry", id: "retry" }).then((item) => {
              if (item && item.id === "retry") {
                this.initialize(connection).catch(() => {
                });
              } else {
                this.stop().catch(() => {
                });
              }
            });
          } else {
            if (error && error.message) {
              void window_default.showErrorMessage(error.message);
            }
            this.error("Server initialization failed.", error);
            this.stop().catch(() => {
            });
          }
          throw error;
        }
      }
      stop(timeout = 2e3) {
        return this.shutdown("stop", timeout);
      }
      async shutdown(mode, timeout) {
        if (this.$state === 5 /* Stopped */ || this.$state === 0 /* Initial */) {
          return;
        }
        if (this.$state === 4 /* Stopping */) {
          if (this._onStop !== void 0) {
            return this._onStop;
          } else {
            throw new Error(`Client is stopping but no stop promise available.`);
          }
        }
        const connection = this.activeConnection();
        if (connection === void 0 || this.$state !== 3 /* Running */ && this.$state !== 1 /* Starting */) {
          throw new Error(`Client is not running and can't be stopped. It's current state is: ${this.$state}`);
        }
        this._initializeResult = void 0;
        this.$state = 4 /* Stopping */;
        this.cleanUp(mode);
        let tm;
        const tp = new Promise((c) => {
          tm = setTimeout(c, timeout);
        });
        const shutdown = (async (connection2) => {
          await connection2.shutdown();
          await connection2.exit();
          return connection2;
        })(connection);
        return this._onStop = Promise.race([tp, shutdown]).then((connection2) => {
          if (tm)
            clearTimeout(tm);
          if (connection2 !== void 0) {
            connection2.end();
            connection2.dispose();
          } else {
            this.error(`Stopping server timed out`, void 0);
            throw new Error(`Stopping the server timed out`);
          }
        }, (error) => {
          this.error(`Stopping server failed`, error);
          throw error;
        }).finally(() => {
          this.$state = 5 /* Stopped */;
          mode === "stop" && this.cleanUpChannel();
          this._onStart = void 0;
          this._onStop = void 0;
          this._connection = void 0;
          this._ignoredRegistrations.clear();
        });
      }
      dispose(timeout = 2e3) {
        try {
          this._disposed = "disposing";
          return this.stop(timeout);
        } finally {
          this._disposed = "disposed";
        }
      }
      cleanUp(mode) {
        if (this._listeners) {
          this._listeners.forEach((listener) => listener.dispose());
          this._listeners = [];
        }
        if (this._syncedDocuments) {
          this._syncedDocuments.clear();
        }
        for (let feature of this._features.values()) {
          if (typeof feature.dispose === "function") {
            feature.dispose();
          } else {
            logger62.error(`Feature can't be disposed`, feature);
          }
        }
        if (mode === "stop" && this._diagnostics) {
          this._diagnostics.dispose();
          this._diagnostics = void 0;
        }
      }
      cleanUpChannel() {
        if (this._outputChannel) {
          this._outputChannel.dispose();
          this._outputChannel = void 0;
        }
      }
      async forceDocumentSync() {
        let textDocuments = Array.from(this._syncedDocuments.values());
        await Promise.all(textDocuments.map((textDocument) => {
          let doc = workspace_default.getDocument(textDocument.uri);
          return doc ? doc.synchronize() : null;
        }));
      }
      handleDiagnostics(params) {
        let { uri, diagnostics, version: version2 } = params;
        if (typeof version2 === "number") {
          let doc = workspace_default.getDocument(uri);
          if (!doc || doc.version != version2)
            return;
        }
        let middleware = this.clientOptions.middleware.handleDiagnostics;
        if (middleware) {
          middleware(uri, diagnostics, (uri2, diagnostics2) => this.setDiagnostics(uri2, diagnostics2));
        } else {
          this.setDiagnostics(uri, diagnostics);
        }
      }
      async createConnection() {
        let errorHandler = (error, message, count) => {
          this.handleConnectionError(error, message, count);
        };
        let closeHandler = () => {
          this.handleConnectionClosed();
        };
        const transports = await this.createMessageTransports(this._clientOptions.stdioEncoding ?? "utf8");
        this._connection = createConnection(transports.reader, transports.writer, errorHandler, closeHandler, this._clientOptions.connectionOptions);
        return this._connection;
      }
      handleConnectionClosed() {
        if (this.$state === 5 /* Stopped */) {
          logger62.debug(`client ${this._id} normal closed`);
          return;
        }
        try {
          if (this._connection) {
            this._connection.dispose();
          }
        } catch (error) {
        }
        let action = 1 /* DoNotRestart */;
        if (this.$state !== 4 /* Stopping */) {
          try {
            action = this._clientOptions.errorHandler.closed();
          } catch (error) {
          }
        }
        this._connection = void 0;
        if (action === 1 /* DoNotRestart */) {
          this.error("Connection to server got closed. Server will not be restarted.", void 0, "force");
          this.cleanUp("stop");
          if (this.$state === 1 /* Starting */) {
            this.$state = 2 /* StartFailed */;
          } else {
            this.$state = 5 /* Stopped */;
          }
          this._onStop = Promise.resolve();
          this._onStart = void 0;
        } else if (action === 2 /* Restart */) {
          this.info("Connection to server got closed. Server will restart.");
          this.cleanUp("restart");
          this.$state = 0 /* Initial */;
          this._onStop = Promise.resolve();
          this._onStart = void 0;
          this.start().catch((error) => this.error(`Restarting server failed`, error, "force"));
        }
      }
      checkState() {
        if (this.$state === 2 /* StartFailed */ || this.$state === 4 /* Stopping */ || this.$state === 5 /* Stopped */) {
          throw new import_vscode_languageserver_protocol73.ResponseError(import_vscode_languageserver_protocol73.ErrorCodes.ConnectionInactive, `Client is not running`);
        }
      }
      handleConnectionError(error, message, count) {
        let action = this._clientOptions.errorHandler.error(error, message, count);
        if (action === 2 /* Shutdown */) {
          this.error(`Client ${this._name}: connection to server is erroring. Shutting down server.`, void 0, "force");
          this.stop().catch((error2) => {
            this.error(`Stopping server failed`, error2);
          });
        }
      }
      hookConfigurationChanged(connection) {
        workspace_default.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration(this._id)) {
            this.refreshTrace(connection, true);
          }
        }, null, this._listeners);
      }
      refreshTrace(connection, sendNotification = false) {
        let config = workspace_default.getConfiguration(this._id);
        let trace = import_vscode_languageserver_protocol73.Trace.Off;
        let traceFormat = import_vscode_languageserver_protocol73.TraceFormat.Text;
        if (config) {
          const traceConfig = config.get("trace.server", "off");
          if (typeof traceConfig === "string") {
            trace = import_vscode_languageserver_protocol73.Trace.fromString(traceConfig);
          } else {
            trace = import_vscode_languageserver_protocol73.Trace.fromString(config.get("trace.server.verbosity", "off"));
            traceFormat = import_vscode_languageserver_protocol73.TraceFormat.fromString(config.get("trace.server.format", "text"));
          }
        }
        if (sendNotification && this._trace == trace && this._traceFormat == traceFormat) {
          return;
        }
        this._trace = trace;
        this._traceFormat = traceFormat;
        connection.trace(this._trace, this._tracer, {
          sendNotification,
          traceFormat: this._traceFormat
        }).catch((error) => {
          this.error(`Updating trace failed with error`, error);
        });
      }
      registerFeatures(features) {
        for (let feature of features) {
          this.registerFeature(feature, "");
        }
      }
      registerFeature(feature, name2) {
        let { disabledFeatures } = this._clientOptions;
        if (disabledFeatures.length > 0 && disabledFeatures.includes(name2))
          return;
        this._features.push(feature);
        if (DynamicFeature.is(feature)) {
          const registrationType = feature.registrationType;
          this._dynamicFeatures.set(registrationType.method, feature);
        }
      }
      getStaticFeature(method) {
        return this._features.find((o) => StaticFeature.is(o) && o.method == method);
      }
      getFeature(request2) {
        return this._dynamicFeatures.get(request2);
      }
      registerBuiltinFeatures() {
        this.registerFeature(new SyncConfigurationFeature(this), "configuration");
        this.registerFeature(new DidOpenTextDocumentFeature(this, this._syncedDocuments), "document");
        this.registerFeature(new DidChangeTextDocumentFeature(this), "document");
        this.registerFeature(new DidCloseTextDocumentFeature(this, this._syncedDocuments), "document");
        this.registerFeature(new WillSaveFeature(this), "willSave");
        this.registerFeature(new WillSaveWaitUntilFeature(this), "willSaveWaitUntil");
        this.registerFeature(new DidSaveTextDocumentFeature(this), "didSave");
        this.registerFeature(new FileSystemWatcherFeature(this), "fileSystemWatcher");
        this.registerFeature(new CompletionItemFeature(this), "completion");
        this.registerFeature(new HoverFeature(this), "hover");
        this.registerFeature(new SignatureHelpFeature(this), "signatureHelp");
        this.registerFeature(new ReferencesFeature(this), "references");
        this.registerFeature(new DefinitionFeature(this), "definition");
        this.registerFeature(new DocumentHighlightFeature(this), "documentHighlight");
        this.registerFeature(new DocumentSymbolFeature(this), "documentSymbol");
        this.registerFeature(new CodeActionFeature(this), "codeAction");
        this.registerFeature(new CodeLensFeature(this), "codeLens");
        this.registerFeature(new DocumentFormattingFeature(this), "documentFormatting");
        this.registerFeature(new DocumentRangeFormattingFeature(this), "documentRangeFormatting");
        this.registerFeature(new DocumentOnTypeFormattingFeature(this), "documentOnTypeFormatting");
        this.registerFeature(new RenameFeature(this), "rename");
        this.registerFeature(new DocumentLinkFeature(this), "documentLink");
        this.registerFeature(new ExecuteCommandFeature(this), "executeCommand");
        this.registerFeature(new PullConfigurationFeature(this), "pullConfiguration");
        this.registerFeature(new TypeDefinitionFeature(this), "typeDefinition");
        this.registerFeature(new ImplementationFeature(this), "implementation");
        this.registerFeature(new DeclarationFeature(this), "declaration");
        this.registerFeature(new ColorProviderFeature(this), "colorProvider");
        this.registerFeature(new FoldingRangeFeature(this), "foldingRange");
        this.registerFeature(new SelectionRangeFeature(this), "selectionRange");
        this.registerFeature(new CallHierarchyFeature(this), "callHierarchy");
        this.registerFeature(new ProgressFeature(this), "progress");
        this.registerFeature(new LinkedEditingFeature(this), "linkedEditing");
        this.registerFeature(new DidCreateFilesFeature(this), "fileEvents");
        this.registerFeature(new DidRenameFilesFeature(this), "fileEvents");
        this.registerFeature(new DidDeleteFilesFeature(this), "fileEvents");
        this.registerFeature(new WillCreateFilesFeature(this), "fileEvents");
        this.registerFeature(new WillRenameFilesFeature(this), "fileEvents");
        this.registerFeature(new WillDeleteFilesFeature(this), "fileEvents");
        this.registerFeature(new SemanticTokensFeature(this), "semanticTokens");
        this.registerFeature(new InlayHintsFeature(this), "inlayHint");
        this.registerFeature(new InlineValueFeature(this), "inlineValue");
        this.registerFeature(new DiagnosticFeature(this), "pullDiagnostic");
        this.registerFeature(new TypeHierarchyFeature(this), "typeHierarchy");
        this.registerFeature(new WorkspaceSymbolFeature(this), "workspaceSymbol");
        if (this.clientOptions.workspaceFolder === void 0) {
          this.registerFeature(new WorkspaceFoldersFeature(this), "workspaceFolders");
        }
      }
      registerProposedFeatures() {
        this.registerFeatures(ProposedFeatures.createAll(this));
      }
      fillInitializeParams(params) {
        for (let feature of this._features) {
          if (func(feature.fillInitializeParams)) {
            feature.fillInitializeParams(params);
          }
        }
      }
      computeClientCapabilities() {
        const result = {};
        ensure(result, "workspace").applyEdit = true;
        const workspaceEdit = ensure(ensure(result, "workspace"), "workspaceEdit");
        workspaceEdit.documentChanges = true;
        workspaceEdit.resourceOperations = [import_vscode_languageserver_protocol73.ResourceOperationKind.Create, import_vscode_languageserver_protocol73.ResourceOperationKind.Rename, import_vscode_languageserver_protocol73.ResourceOperationKind.Delete];
        workspaceEdit.failureHandling = import_vscode_languageserver_protocol73.FailureHandlingKind.Undo;
        workspaceEdit.normalizesLineEndings = true;
        workspaceEdit.changeAnnotationSupport = {
          groupsOnLabel: false
        };
        const diagnostics = ensure(ensure(result, "textDocument"), "publishDiagnostics");
        diagnostics.relatedInformation = true;
        diagnostics.versionSupport = true;
        diagnostics.tagSupport = { valueSet: [import_vscode_languageserver_protocol73.DiagnosticTag.Unnecessary, import_vscode_languageserver_protocol73.DiagnosticTag.Deprecated] };
        diagnostics.codeDescriptionSupport = true;
        diagnostics.dataSupport = true;
        const windowCapabilities = ensure(result, "window");
        const showMessage2 = ensure(windowCapabilities, "showMessage");
        showMessage2.messageActionItem = { additionalPropertiesSupport: true };
        const showDocument = ensure(windowCapabilities, "showDocument");
        showDocument.support = true;
        const generalCapabilities = ensure(result, "general");
        generalCapabilities.regularExpressions = { engine: "ECMAScript", version: "ES2020" };
        generalCapabilities.markdown = { parser: "marked", version: "4.0.10" };
        generalCapabilities.positionEncodings = ["utf-16"];
        generalCapabilities.staleRequestSupport = {
          cancel: true,
          retryOnContentModified: Array.from(_BaseLanguageClient.RequestsToCancelOnContentModified)
        };
        for (let feature of this._features) {
          feature.fillClientCapabilities(result);
        }
        return result;
      }
      initializeFeatures(_connection) {
        let documentSelector = this._clientOptions.documentSelector;
        for (let feature of this._features) {
          if (func(feature.preInitialize)) {
            feature.preInitialize(this._capabilities, documentSelector);
          }
        }
        for (let feature of this._features) {
          feature.initialize(this._capabilities, documentSelector);
        }
      }
      handleRegistrationRequest(params) {
        if (this.clientOptions.disableDynamicRegister)
          return Promise.resolve();
        if (!this.isRunning()) {
          for (const registration of params.registrations) {
            this._ignoredRegistrations.add(registration.id);
          }
          return;
        }
        return new Promise((resolve3, reject) => {
          for (const registration of params.registrations) {
            const feature = this._dynamicFeatures.get(registration.method);
            if (!feature) {
              reject(new Error(`No feature implementation for ${registration.method} found. Registration failed.`));
              return;
            }
            const options2 = registration.registerOptions ?? {};
            options2.documentSelector = options2.documentSelector ?? this._clientOptions.documentSelector;
            const data = {
              id: registration.id,
              registerOptions: options2
            };
            try {
              feature.register(data);
            } catch (err) {
              reject(err);
              return;
            }
          }
          resolve3();
        });
      }
      handleUnregistrationRequest(params) {
        return new Promise((resolve3, reject) => {
          for (let unregistration of params.unregisterations) {
            if (this._ignoredRegistrations.has(unregistration.id))
              continue;
            const feature = this._dynamicFeatures.get(unregistration.method);
            if (!feature) {
              reject(new Error(`No feature implementation for ${unregistration.method} found. Unregistration failed.`));
              return;
            }
            feature.unregister(unregistration.id);
          }
          resolve3();
        });
      }
      setDiagnostics(uri, diagnostics) {
        var _a;
        if (!this._diagnostics)
          return;
        const separate = this.clientOptions.separateDiagnostics;
        if (separate && diagnostics.length > 0) {
          const entries = /* @__PURE__ */ new Map();
          entries.set(uri, diagnostics);
          for (const diagnostic of diagnostics) {
            if ((_a = diagnostic.relatedInformation) == null ? void 0 : _a.length) {
              let message = `${diagnostic.message}

Related diagnostics:
`;
              for (const info of diagnostic.relatedInformation) {
                const basename = import_path21.default.basename(URI2.parse(info.location.uri).fsPath);
                const ln = info.location.range.start.line;
                message = `${message}
${basename}(line ${ln + 1}): ${info.message}`;
                const diags = entries.get(info.location.uri) || [];
                diags.push(import_vscode_languageserver_protocol73.Diagnostic.create(info.location.range, info.message, import_vscode_languageserver_protocol73.DiagnosticSeverity.Hint, diagnostic.code, diagnostic.source));
                entries.set(info.location.uri, diags);
              }
              diagnostic.message = message;
            }
            this._diagnostics.set(Array.from(entries));
          }
        } else {
          this._diagnostics.set(uri, diagnostics);
        }
      }
      handleApplyWorkspaceEdit(params) {
        let workspaceEdit = params.edit;
        let openTextDocuments = /* @__PURE__ */ new Map();
        workspace_default.textDocuments.forEach((document2) => openTextDocuments.set(document2.uri.toString(), document2));
        let versionMismatch = false;
        if (workspaceEdit.documentChanges) {
          for (const change of workspaceEdit.documentChanges) {
            if (import_vscode_languageserver_protocol73.TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {
              let textDocument = openTextDocuments.get(change.textDocument.uri);
              if (textDocument && textDocument.version !== change.textDocument.version) {
                versionMismatch = true;
                break;
              }
            }
          }
        }
        if (versionMismatch) {
          return Promise.resolve({ applied: false });
        }
        return workspace_default.applyEdit(params.edit).then((value) => {
          return { applied: value };
        });
      }
      getLocale() {
        const lang = process.env.LANG;
        if (!lang)
          return "en";
        return lang.split(".")[0];
      }
      handleFailedRequest(type, token, error, defaultValue) {
        if (token && token.isCancellationRequested)
          return defaultValue;
        if (error instanceof import_vscode_languageserver_protocol73.ResponseError) {
          if (error.code === import_vscode_languageserver_protocol73.ErrorCodes.PendingResponseRejected || error.code === import_vscode_languageserver_protocol73.ErrorCodes.ConnectionInactive) {
            return defaultValue;
          }
          if (error.code === import_vscode_languageserver_protocol73.LSPErrorCodes.RequestCancelled || error.code === import_vscode_languageserver_protocol73.LSPErrorCodes.ServerCancelled) {
            if (error.data != null) {
              throw new LSPCancellationError(error.data);
            } else {
              throw new CancellationError();
            }
          } else if (error.code === import_vscode_languageserver_protocol73.LSPErrorCodes.ContentModified) {
            if (_BaseLanguageClient.RequestsToCancelOnContentModified.has(type.method)) {
              throw new CancellationError();
            } else {
              return defaultValue;
            }
          }
        }
        this.error(`Request ${type.method} failed.`, error);
        throw error;
      }
      logFailedRequest() {
      }
    };
    BaseLanguageClient = _BaseLanguageClient;
    BaseLanguageClient.RequestsToCancelOnContentModified = /* @__PURE__ */ new Set([
      import_vscode_languageserver_protocol73.SemanticTokensRequest.method,
      import_vscode_languageserver_protocol73.SemanticTokensRangeRequest.method,
      import_vscode_languageserver_protocol73.SemanticTokensDeltaRequest.method
    ]);
    ProposedFeatures = {
      createAll: (_client) => {
        let result = [];
        return result;
      }
    };
  }
});

// src/language-client/index.ts
function getRuntimePath(runtime, serverWorkingDirectory) {
  if (import_path22.default.isAbsolute(runtime)) {
    return runtime;
  }
  const mainRootPath = mainGetRootPath();
  if (mainRootPath !== void 0) {
    const result = import_path22.default.join(mainRootPath, runtime);
    if (import_fs23.default.existsSync(result)) {
      return result;
    }
  }
  if (serverWorkingDirectory !== void 0) {
    const result = import_path22.default.join(serverWorkingDirectory, runtime);
    if (import_fs23.default.existsSync(result)) {
      return result;
    }
  }
  return runtime;
}
function mainGetRootPath() {
  let folders = workspace_default.workspaceFolders;
  if (!folders || folders.length === 0) {
    return void 0;
  }
  let folder = folders[0];
  return folder.uri;
}
function getServerWorkingDir(options2) {
  let cwd = options2 && options2.cwd;
  if (cwd && !import_path22.default.isAbsolute(cwd))
    cwd = import_path22.default.join(workspace_default.cwd, cwd);
  if (!cwd)
    cwd = workspace_default.cwd;
  return new Promise((s) => {
    import_fs23.default.lstat(cwd, (err, stats) => {
      s(!err && stats.isDirectory() ? cwd : void 0);
    });
  });
}
function startedInDebugMode(args) {
  if (args) {
    return args.some((arg) => {
      return debugStartWith.some((value) => arg.startsWith(value)) || debugEquals.some((value) => arg === value);
    });
  }
  return false;
}
var import_child_process4, import_fs23, import_path22, import_node, ChildProcess2, logger63, debugStartWith, debugEquals, Executable, TransportKind, Transport, NodeModule, StreamInfo, ChildProcessInfo, LanguageClient, SettingMonitor;
var init_language_client = __esm({
  "src/language-client/index.ts"() {
    "use strict";
    import_child_process4 = __toESM(require("child_process"));
    import_fs23 = __toESM(require("fs"));
    import_path22 = __toESM(require("path"));
    import_node = __toESM(require_node3());
    init_util();
    init_is();
    init_processes();
    init_workspace();
    init_client();
    init_client();
    ChildProcess2 = import_child_process4.default.ChildProcess;
    logger63 = require_logger2()("language-client-index");
    debugStartWith = ["--debug=", "--debug-brk=", "--inspect=", "--inspect-brk="];
    debugEquals = ["--debug", "--debug-brk", "--inspect", "--inspect-brk"];
    ((Executable3) => {
      function is(value) {
        return string(value.command);
      }
      Executable3.is = is;
    })(Executable || (Executable = {}));
    TransportKind = /* @__PURE__ */ ((TransportKind2) => {
      TransportKind2[TransportKind2["stdio"] = 0] = "stdio";
      TransportKind2[TransportKind2["ipc"] = 1] = "ipc";
      TransportKind2[TransportKind2["pipe"] = 2] = "pipe";
      TransportKind2[TransportKind2["socket"] = 3] = "socket";
      return TransportKind2;
    })(TransportKind || {});
    ((Transport3) => {
      function isSocket(value) {
        let candidate = value;
        return candidate && candidate.kind === 3 /* socket */ && number(candidate.port);
      }
      Transport3.isSocket = isSocket;
    })(Transport || (Transport = {}));
    ((NodeModule2) => {
      function is(value) {
        return string(value.module);
      }
      NodeModule2.is = is;
    })(NodeModule || (NodeModule = {}));
    ((StreamInfo2) => {
      function is(value) {
        let candidate = value;
        return candidate && candidate.writer !== void 0 && candidate.reader !== void 0;
      }
      StreamInfo2.is = is;
    })(StreamInfo || (StreamInfo = {}));
    ((ChildProcessInfo2) => {
      function is(value) {
        let candidate = value;
        return candidate && candidate.process !== void 0 && typeof candidate.detached === "boolean";
      }
      ChildProcessInfo2.is = is;
    })(ChildProcessInfo || (ChildProcessInfo = {}));
    LanguageClient = class extends BaseLanguageClient {
      constructor(arg1, arg2, arg3, arg4, arg5) {
        let id;
        let name2;
        let serverOptions;
        let clientOptions;
        let forceDebug;
        if (string(arg2)) {
          id = arg1;
          name2 = arg2;
          serverOptions = arg3;
          clientOptions = arg4;
          forceDebug = !!arg5;
        } else {
          id = arg1.toLowerCase();
          name2 = arg1;
          serverOptions = arg2;
          clientOptions = arg3;
          forceDebug = arg4;
        }
        super(id, name2, clientOptions);
        this._serverOptions = serverOptions;
        this._forceDebug = !!forceDebug;
        this._isInDebugMode = !!forceDebug;
      }
      stop(timeout = 2e3) {
        return super.stop(timeout).then(() => {
          if (this._serverProcess) {
            let toCheck = this._serverProcess;
            this._serverProcess = void 0;
            if (this._isDetached === void 0 || !this._isDetached) {
              this.checkProcessDied(toCheck);
            }
            this._isDetached = void 0;
          }
        });
      }
      get serviceState() {
        return this._state;
      }
      checkProcessDied(childProcess) {
        if (!childProcess || childProcess.pid === void 0)
          return;
        setTimeout(() => {
          try {
            process.kill(childProcess.pid, 0);
            terminate(childProcess);
          } catch (error) {
          }
        }, global.__TEST__ ? 20 : 2e3);
      }
      handleConnectionClosed() {
        this._serverProcess = void 0;
        super.handleConnectionClosed();
      }
      get isInDebugMode() {
        return this._isInDebugMode;
      }
      async restart() {
        await this.stop();
        if (this.isInDebugMode) {
          await new Promise((resolve3) => setTimeout(resolve3, 1e3));
          await this._start();
        } else {
          await this._start();
        }
      }
      createMessageTransports(encoding) {
        function getEnvironment(env, fork) {
          if (!env && !fork) {
            return void 0;
          }
          let result = /* @__PURE__ */ Object.create(null);
          Object.keys(process.env).forEach((key) => result[key] = process.env[key]);
          if (env) {
            Object.keys(env).forEach((key) => result[key] = env[key]);
          }
          return result;
        }
        function assertStdio(process2) {
          if (process2.stdin === null || process2.stdout === null || process2.stderr === null) {
            throw new Error("Process created without stdio streams");
          }
        }
        let server = this._serverOptions;
        const logMessage = this.logMessage.bind(this);
        if (func(server)) {
          return server().then((result) => {
            if (MessageTransports.is(result)) {
              this._isDetached = !!result.detached;
              return result;
            } else if (StreamInfo.is(result)) {
              this._isDetached = !!result.detached;
              return {
                reader: new import_node.StreamMessageReader(result.reader),
                writer: new import_node.StreamMessageWriter(result.writer)
              };
            } else {
              let cp3;
              if (ChildProcessInfo.is(result)) {
                cp3 = result.process;
                this._isDetached = result.detached;
              } else {
                cp3 = result;
                this._isDetached = false;
              }
              cp3.stderr.on("data", logMessage);
              return {
                reader: new import_node.StreamMessageReader(cp3.stdout),
                writer: new import_node.StreamMessageWriter(cp3.stdin)
              };
            }
          });
        }
        let json;
        let runDebug = server;
        if (runDebug.run || runDebug.debug) {
          if (typeof v8debug === "object" || this._forceDebug || startedInDebugMode(process.execArgv)) {
            json = runDebug.debug;
          } else {
            json = runDebug.run;
          }
        } else {
          json = server;
        }
        return getServerWorkingDir(json.options).then((serverWorkingDir) => {
          if (NodeModule.is(json) && json.module) {
            let node = json;
            let transport = node.transport || 0 /* stdio */;
            let pipeName;
            let runtime = node.runtime ? getRuntimePath(node.runtime, serverWorkingDir) : void 0;
            return new Promise((resolve3, _reject) => {
              let args = node.args && node.args.slice() || [];
              if (transport === 1 /* ipc */) {
                args.push("--node-ipc");
              } else if (transport === 0 /* stdio */) {
                args.push("--stdio");
              } else if (transport === 2 /* pipe */) {
                pipeName = (0, import_node.generateRandomPipeName)();
                args.push(`--pipe=${pipeName}`);
              } else if (Transport.isSocket(transport)) {
                args.push(`--socket=${transport.port}`);
              }
              args.push(`--clientProcessId=${process.pid}`);
              let options2 = node.options || /* @__PURE__ */ Object.create(null);
              options2.env = getEnvironment(options2.env, true);
              options2.execArgv = options2.execArgv || [];
              options2.cwd = serverWorkingDir;
              options2.silent = true;
              if (runtime)
                options2.execPath = runtime;
              if (transport === 1 /* ipc */ || transport === 0 /* stdio */) {
                let sp = import_child_process4.default.fork(node.module, args || [], options2);
                assertStdio(sp);
                this._serverProcess = sp;
                sp.stderr.on("data", logMessage);
                if (transport === 1 /* ipc */) {
                  sp.stdout.on("data", logMessage);
                  resolve3({ reader: new import_node.IPCMessageReader(this._serverProcess), writer: new import_node.IPCMessageWriter(this._serverProcess) });
                } else {
                  resolve3({ reader: new import_node.StreamMessageReader(sp.stdout), writer: new import_node.StreamMessageWriter(sp.stdin) });
                }
              } else if (transport === 2 /* pipe */) {
                return (0, import_node.createClientPipeTransport)(pipeName).then((transport2) => {
                  let sp = import_child_process4.default.fork(node.module, args || [], options2);
                  assertStdio(sp);
                  this._serverProcess = sp;
                  sp.stderr.on("data", logMessage);
                  sp.stdout.on("data", logMessage);
                  void transport2.onConnected().then((protocol2) => {
                    resolve3({ reader: protocol2[0], writer: protocol2[1] });
                  });
                });
              } else if (Transport.isSocket(transport)) {
                return (0, import_node.createClientSocketTransport)(transport.port).then((transport2) => {
                  let sp = import_child_process4.default.fork(node.module, args || [], options2);
                  assertStdio(sp);
                  this._serverProcess = sp;
                  sp.stderr.on("data", logMessage);
                  sp.stdout.on("data", logMessage);
                  void transport2.onConnected().then((protocol2) => {
                    resolve3({ reader: protocol2[0], writer: protocol2[1] });
                  });
                });
              }
            });
          } else if (Executable.is(json) && json.command) {
            let command = json;
            let args = command.args || [];
            let options2 = Object.assign({}, command.options);
            options2.env = options2.env ? Object.assign({}, process.env, options2.env) : process.env;
            options2.cwd = options2.cwd || serverWorkingDir;
            let cmd = workspace_default.expand(json.command);
            let serverProcess = import_child_process4.default.spawn(cmd, args, options2);
            serverProcess.on("error", (e) => {
              this.error(e.message, e);
            });
            if (!serverProcess || !serverProcess.pid) {
              return Promise.reject(new Error(`Launching server "${this.id}" using command ${command.command} failed.`));
            }
            logger63.info(`Language server "${this.id}" started with ${serverProcess.pid}`);
            serverProcess.on("exit", (code) => {
              if (code != 0)
                this.error(`${command.command} exited with code: ${code}`);
            });
            serverProcess.stderr.on("data", (data) => this.outputChannel.append(string(data) ? data : data.toString(encoding)));
            this._serverProcess = serverProcess;
            this._isDetached = !!options2.detached;
            return Promise.resolve({ reader: new import_node.StreamMessageReader(serverProcess.stdout), writer: new import_node.StreamMessageWriter(serverProcess.stdin) });
          }
          return Promise.reject(`Unsupported server configuration ${JSON.stringify(server, null, 2)}`);
        });
      }
      logMessage(data) {
        let encoding = this.clientOptions.stdioEncoding;
        this.outputChannel.append(string(data) ? data : data.toString(encoding));
      }
    };
    SettingMonitor = class {
      constructor(_client, _setting) {
        this._client = _client;
        this._setting = _setting;
        this._listeners = [];
      }
      start() {
        workspace_default.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration(this._setting)) {
            this.onDidChangeConfiguration();
          }
        }, null, this._listeners);
        this.onDidChangeConfiguration();
        return {
          dispose: () => {
            disposeAll(this._listeners);
            if (this._client.needsStop()) {
              void this._client.stop();
            }
          }
        };
      }
      onDidChangeConfiguration() {
        let index = this._setting.indexOf(".");
        let primary = index >= 0 ? this._setting.substr(0, index) : this._setting;
        let rest = index >= 0 ? this._setting.substr(index + 1) : void 0;
        let enabled = rest ? workspace_default.getConfiguration(primary).get(rest, true) : workspace_default.getConfiguration(primary);
        if (enabled && this._client.needsStart()) {
          this._client.start().catch((error) => this._client.error("Start failed after configuration change", error, "force"));
        } else if (!enabled && this._client.needsStop()) {
          this._client.stop().catch((error) => this._client.error("Stop failed after configuration change", error, "force"));
        }
      }
    };
  }
});

// src/services.ts
function getStateName(state) {
  switch (state) {
    case 0 /* Initial */:
      return "init";
    case 3 /* Running */:
      return "running";
    case 1 /* Starting */:
      return "starting";
    case 2 /* StartFailed */:
      return "startFailed";
    case 4 /* Stopping */:
      return "stopping";
    case 5 /* Stopped */:
      return "stopped";
    default:
      return "unknown";
  }
}
function documentSelectorToLanguageIds(documentSelector) {
  let res = documentSelector.map((filter2) => {
    if (typeof filter2 == "string") {
      return filter2;
    }
    return filter2.language;
  });
  res = res.filter((s) => typeof s == "string");
  return Array.from(new Set(res));
}
function getLanguageServerOptions(id, name2, config) {
  let { command, module: module2, port, args, filetypes } = config;
  args = args || [];
  if (!filetypes) {
    window_default.showMessage(`Wrong configuration of LS "${name2}", filetypes not found`, "error");
    return null;
  }
  if (!command && !module2 && !port) {
    window_default.showMessage(`Wrong configuration of LS "${name2}", no command or module specified.`, "error");
    return null;
  }
  let serverOptions;
  if (module2) {
    module2 = workspace_default.expand(module2);
    if (!import_fs24.default.existsSync(module2)) {
      window_default.showMessage(`Module file "${module2}" not found for LS "${name2}"`, "error");
      return null;
    }
    serverOptions = {
      module: module2,
      runtime: config.runtime || process.execPath,
      args,
      transport: getTransportKind(config),
      options: getForkOptions(config)
    };
  } else if (command) {
    serverOptions = {
      command,
      args,
      options: getSpawnOptions(config)
    };
  } else if (port) {
    serverOptions = () => new Promise((resolve3, reject) => {
      let client = new import_net.default.Socket();
      let host = config.host || "127.0.0.1";
      logger64.info(`languageserver "${id}" connecting to ${host}:${port}`);
      client.connect(port, host, () => {
        resolve3({
          reader: client,
          writer: client
        });
      });
      client.on("error", (e) => {
        reject(new Error(`Connection error for ${id}: ${e.message}`));
      });
    });
  }
  let disabledFeatures = Array.from(config.disabledFeatures || []);
  for (let key of ["disableWorkspaceFolders", "disableCompletion", "disableDiagnostics"]) {
    if (config[key] === true) {
      let s = key.slice(7);
      disabledFeatures.push(s[0].toLowerCase() + s.slice(1));
    }
  }
  let disableSnippetCompletion = !!config.disableSnippetCompletion;
  let ignoredRootPaths = config.ignoredRootPaths || [];
  let clientOptions = {
    rootPatterns: config.rootPatterns,
    requireRootPattern: config.requireRootPattern,
    ignoredRootPaths: ignoredRootPaths.map((s) => workspace_default.expand(s)),
    disableSnippetCompletion,
    disableDynamicRegister: !!config.disableDynamicRegister,
    disabledFeatures,
    formatterPriority: config.formatterPriority || 0,
    documentSelector: getDocumentSelector(config.filetypes, config.additionalSchemes),
    revealOutputChannelOn: getRevealOutputChannelOn(config.revealOutputChannelOn),
    synchronize: {
      configurationSection: `${id}.settings`
    },
    diagnosticCollectionName: name2,
    outputChannelName: id,
    stdioEncoding: config.stdioEncoding || "utf8",
    progressOnInitialization: config.progressOnInitialization === true,
    initializationOptions: config.initializationOptions || {}
  };
  return [clientOptions, serverOptions];
}
function getRevealOutputChannelOn(revealOn) {
  switch (revealOn) {
    case "info":
      return 1 /* Info */;
    case "warn":
      return 2 /* Warn */;
    case "error":
      return 3 /* Error */;
    case "never":
      return 4 /* Never */;
    default:
      return 4 /* Never */;
  }
}
function getDocumentSelector(filetypes, additionalSchemes) {
  let documentSelector = [];
  let schemes = ["file", "untitled"].concat(additionalSchemes || []);
  if (!filetypes)
    return schemes.map((s) => ({ scheme: s }));
  filetypes.forEach((filetype) => {
    documentSelector.push(...schemes.map((scheme) => ({ language: filetype, scheme })));
  });
  return documentSelector;
}
function getTransportKind(config) {
  let { transport, transportPort } = config;
  if (!transport || transport == "ipc")
    return 1 /* ipc */;
  if (transport == "stdio")
    return 0 /* stdio */;
  if (transport == "pipe")
    return 2 /* pipe */;
  return { kind: 3 /* socket */, port: transportPort };
}
function getForkOptions(config) {
  return {
    cwd: config.cwd,
    execArgv: config.execArgv || [],
    env: config.env || void 0
  };
}
function getSpawnOptions(config) {
  return {
    cwd: config.cwd,
    detached: !!config.detached,
    shell: !!config.shell,
    env: config.env || void 0
  };
}
function stateString(state) {
  switch (state) {
    case 2 /* Running */:
      return "running";
    case 3 /* Starting */:
      return "starting";
    case 1 /* Stopped */:
      return "stopped";
    default:
      return "unknown";
  }
}
var import_events25, import_fs24, import_net, import_vscode_languageserver_protocol74, logger64, ServiceManager, services_default;
var init_services = __esm({
  "src/services.ts"() {
    "use strict";
    import_events25 = require("events");
    import_fs24 = __toESM(require("fs"));
    import_net = __toESM(require("net"));
    import_vscode_languageserver_protocol74 = __toESM(require_main2());
    init_language_client();
    init_types();
    init_util();
    init_window();
    init_workspace();
    logger64 = require_logger2()("services");
    ServiceManager = class extends import_events25.EventEmitter {
      constructor() {
        super(...arguments);
        this.registered = /* @__PURE__ */ new Map();
        this.disposables = [];
      }
      init() {
        workspace_default.onDidOpenTextDocument((document2) => {
          this.start(document2);
        }, null, this.disposables);
        workspace_default.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration("languageserver")) {
            this.createCustomServices();
          }
        }, null, this.disposables);
        this.createCustomServices();
      }
      dispose() {
        this.removeAllListeners();
        disposeAll(this.disposables);
        for (let service of this.registered.values()) {
          service.dispose();
        }
      }
      regist(service) {
        let { id } = service;
        if (!id)
          logger64.error("invalid service configuration. ", service.name);
        if (this.registered.get(id))
          return;
        this.registered.set(id, service);
        logger64.info(`registered service "${id}"`);
        if (this.shouldStart(service)) {
          service.start();
        }
        if (service.state == 3 /* Running */) {
          this.emit("ready", id);
        }
        service.onServiceReady(() => {
          logger64.info(`service ${id} started`);
          this.emit("ready", id);
        }, null, this.disposables);
        return import_vscode_languageserver_protocol74.Disposable.create(() => {
          service.stop();
          service.dispose();
          this.registered.delete(id);
        });
      }
      getService(id) {
        let service = this.registered.get(id);
        if (!service)
          service = this.registered.get(`languageserver.${id}`);
        return service;
      }
      shouldStart(service) {
        if (service.state != 0 /* Initial */) {
          return false;
        }
        let selector = service.selector;
        for (let doc of workspace_default.documents) {
          if (workspace_default.match(selector, doc.textDocument)) {
            return true;
          }
        }
        return false;
      }
      start(document2) {
        let services = this.getServices(document2);
        for (let service of services) {
          if (service.state == 0 /* Initial */) {
            service.start();
          }
        }
      }
      getServices(document2) {
        let res = [];
        for (let service of this.registered.values()) {
          if (workspace_default.match(service.selector, document2) > 0) {
            res.push(service);
          }
        }
        return res;
      }
      stop(id) {
        let service = this.registered.get(id);
        if (!service) {
          window_default.showMessage(`Service ${id} not found`, "error");
          return;
        }
        return Promise.resolve(service.stop());
      }
      stopAll() {
        for (let service of this.registered.values()) {
          service.stop();
        }
      }
      async toggle(id) {
        let service = this.registered.get(id);
        if (!service) {
          window_default.showMessage(`Service ${id} not found`, "error");
          return;
        }
        let { state } = service;
        try {
          if (state == 3 /* Running */) {
            await Promise.resolve(service.stop());
          } else if (state == 0 /* Initial */) {
            await service.start();
          } else if (state == 5 /* Stopped */) {
            await service.restart();
          }
        } catch (e) {
          window_default.showMessage(`Service error: ${e}`, "error");
        }
      }
      getServiceStats() {
        let res = [];
        for (let [id, service] of this.registered) {
          res.push({
            id,
            languageIds: documentSelectorToLanguageIds(service.selector),
            state: getStateName(service.state)
          });
        }
        return res;
      }
      createCustomServices() {
        let lspConfig = workspace_default.getConfiguration().get("languageserver", {});
        for (let key of Object.keys(lspConfig)) {
          let config = lspConfig[key];
          if (!this.validServerConfig(key, config)) {
            continue;
          }
          this.registLanguageClient(key, config);
        }
      }
      validServerConfig(key, config) {
        let errors = [];
        if (config.module != null && typeof config.module !== "string") {
          errors.push(`"module" field of languageserver ${key} should be string`);
        }
        if (config.command != null && typeof config.command !== "string") {
          errors.push(`"command" field of languageserver ${key} should be string`);
        }
        if (config.transport != null && typeof config.transport !== "string") {
          errors.push(`"transport" field of languageserver ${key} should be string`);
        }
        if (config.transportPort != null && typeof config.transportPort !== "number") {
          errors.push(`"transportPort" field of languageserver ${key} should be string`);
        }
        if (!Array.isArray(config.filetypes) || !config.filetypes.every((s) => typeof s === "string")) {
          errors.push(`"filetypes" field of languageserver ${key} should be array of string`);
        }
        if (config.additionalSchemes && (!Array.isArray(config.additionalSchemes) || config.additionalSchemes.some((s) => typeof s !== "string"))) {
          errors.push(`"additionalSchemes" field of languageserver ${key} should be array of string`);
        }
        if (errors.length) {
          window_default.showMessage(errors.join("\n"), "error");
          return false;
        }
        return true;
      }
      waitClient(id) {
        let service = this.getService(id);
        if (service && service.state == 3 /* Running */)
          return Promise.resolve();
        if (service)
          return new Promise((resolve3) => {
            service.onServiceReady(() => {
              resolve3();
            });
          });
        return new Promise((resolve3) => {
          let listener = (clientId) => {
            if (clientId == id || clientId == `languageserver.${id}`) {
              this.off("ready", listener);
              resolve3();
            }
          };
          this.on("ready", listener);
        });
      }
      async registNotification(id, method) {
        await this.waitClient(id);
        let service = this.getService(id);
        if (!service.client) {
          window_default.showMessage(`Not a language client: ${id}`, "error");
          return;
        }
        let client = service.client;
        client.onNotification(method, async (result) => {
          workspace_default.nvim.call("coc#do_notify", [id, method, result], true);
        });
      }
      async sendNotification(id, method, params) {
        if (!method)
          throw new Error(`method required for ontification`);
        let service = this.getService(id);
        if (!service || !service.client)
          throw new Error(`Language server ${id} not found`);
        if (service.state == 1 /* Starting */) {
          await service.client.onReady();
        }
        if (service.state != 3 /* Running */) {
          throw new Error(`Language server ${id} not running`);
        }
        await Promise.resolve(service.client.sendNotification(method, params));
      }
      async sendRequest(id, method, params, token) {
        if (!method)
          throw new Error(`method required for sendRequest`);
        let service = this.getService(id);
        if (!service)
          await wait(100);
        service = this.getService(id);
        if (!service || !service.client) {
          throw new Error(`Language server ${id} not found`);
        }
        if (service.state == 1 /* Starting */) {
          await service.client.onReady();
        }
        if (service.state != 3 /* Running */) {
          throw new Error(`Language server ${id} not running`);
        }
        if (!token) {
          let tokenSource = new import_vscode_languageserver_protocol74.CancellationTokenSource();
          token = tokenSource.token;
        }
        return await Promise.resolve(service.client.sendRequest(method, params, token));
      }
      registLanguageClient(name2, config) {
        let id = typeof name2 === "string" ? `languageserver.${name2}` : name2.id;
        let disposables = [];
        let onDidServiceReady = new import_vscode_languageserver_protocol74.Emitter();
        let client = typeof name2 === "string" ? null : name2;
        if (this.registered.has(id))
          return;
        let created = false;
        let service = {
          id,
          client,
          name: typeof name2 === "string" ? name2 : name2.name,
          selector: typeof name2 === "string" ? getDocumentSelector(config.filetypes, config.additionalSchemes) : name2.clientOptions.documentSelector,
          state: 0 /* Initial */,
          onServiceReady: onDidServiceReady.event,
          start: () => {
            if (service.state == 1 /* Starting */ || service.state == 3 /* Running */) {
              return;
            }
            if (client && !client.needsStart()) {
              return;
            }
            if (created && client) {
              return client.restart();
            }
            if (!created) {
              if (typeof name2 == "string" && !client) {
                let config2 = workspace_default.getConfiguration().get("languageserver", {})[name2];
                if (!config2 || config2.enable === false)
                  return;
                let opts = getLanguageServerOptions(id, name2, config2);
                if (!opts)
                  return;
                client = new LanguageClient(id, name2, opts[1], opts[0]);
                disposables.push(client);
                service.selector = opts[0].documentSelector;
                service.client = client;
              }
              client.onDidChangeState((changeEvent) => {
                let { oldState, newState } = changeEvent;
                if (newState == 3 /* Starting */) {
                  service.state = 1 /* Starting */;
                } else if (newState == 2 /* Running */) {
                  service.state = 3 /* Running */;
                } else if (newState == 1 /* Stopped */) {
                  service.state = 5 /* Stopped */;
                }
                let oldStr = stateString(oldState);
                let newStr = stateString(newState);
                logger64.info(`${client.name} state change: ${oldStr} => ${newStr}`);
              }, null, disposables);
              created = true;
            }
            service.state = 1 /* Starting */;
            logger64.debug(`starting service: ${id}`);
            client._start().then(() => {
              onDidServiceReady.fire(void 0);
            }, (e) => {
              window_default.showMessage(`Server ${id} failed to start: ${e}`, "error");
              logger64.error(`Server ${id} failed to start:`, e);
              service.state = 2 /* StartFailed */;
            });
          },
          dispose: async () => {
            onDidServiceReady.dispose();
            disposeAll(disposables);
          },
          stop: async () => {
            if (!client || !client.needsStop())
              return;
            await Promise.resolve(client.stop());
          },
          restart: async () => {
            if (client) {
              service.state = 1 /* Starting */;
              await client.restart();
            } else {
              await service.start();
            }
          }
        };
        return this.regist(service);
      }
    };
    services_default = new ServiceManager();
  }
});

// src/list/configuration.ts
var import_events26, validKeys, ListConfiguration;
var init_configuration4 = __esm({
  "src/list/configuration.ts"() {
    "use strict";
    init_workspace();
    init_window();
    import_events26 = require("events");
    validKeys = [
      "<esc>",
      "<space>",
      "<tab>",
      "<s-tab>",
      "<bs>",
      "<right>",
      "<left>",
      "<up>",
      "<down>",
      "<home>",
      "<end>",
      "<cr>",
      "<FocusGained>",
      "<FocusLost>",
      "<ScrollWheelUp>",
      "<ScrollWheelDown>",
      "<LeftMouse>",
      "<LeftDrag>",
      "<LeftRelease>",
      "<2-LeftMouse>",
      "<C-a>",
      "<C-b>",
      "<C-c>",
      "<C-d>",
      "<C-e>",
      "<C-f>",
      "<C-g>",
      "<C-h>",
      "<C-i>",
      "<C-j>",
      "<C-k>",
      "<C-l>",
      "<C-m>",
      "<C-n>",
      "<C-o>",
      "<C-p>",
      "<C-q>",
      "<C-r>",
      "<C-s>",
      "<C-t>",
      "<C-u>",
      "<C-v>",
      "<C-w>",
      "<C-x>",
      "<C-y>",
      "<C-z>",
      "<A-a>",
      "<A-b>",
      "<A-c>",
      "<A-d>",
      "<A-e>",
      "<A-f>",
      "<A-g>",
      "<A-h>",
      "<A-i>",
      "<A-j>",
      "<A-k>",
      "<A-l>",
      "<A-m>",
      "<A-n>",
      "<A-o>",
      "<A-p>",
      "<A-q>",
      "<A-r>",
      "<A-s>",
      "<A-t>",
      "<A-u>",
      "<A-v>",
      "<A-w>",
      "<A-x>",
      "<A-y>",
      "<A-z>"
    ];
    ListConfiguration = class extends import_events26.EventEmitter {
      constructor() {
        super();
        this.configuration = workspace_default.getConfiguration("list");
        this.disposable = workspace_default.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration("list")) {
            this.configuration = workspace_default.getConfiguration("list");
            this.emit("change");
          }
        });
      }
      get smartcase() {
        return this.get("smartCase", false);
      }
      get(key, defaultValue) {
        return this.configuration.get(key, defaultValue);
      }
      get previousKey() {
        return this.fixKey(this.configuration.get("previousKeymap", "<C-j>"));
      }
      get nextKey() {
        return this.fixKey(this.configuration.get("nextKeymap", "<C-k>"));
      }
      dispose() {
        this.disposable.dispose();
        this.removeAllListeners();
      }
      fixKey(key) {
        if (validKeys.includes(key))
          return key;
        let find = validKeys.find((s) => s.toLowerCase() == key.toLowerCase());
        if (find)
          return find;
        window_default.showMessage(`Configured key "${key}" not supported.`, "error");
        return null;
      }
    };
  }
});

// src/list/mappings.ts
var logger65, Mappings;
var init_mappings = __esm({
  "src/list/mappings.ts"() {
    "use strict";
    init_window();
    init_configuration4();
    logger65 = require_logger2()("list-mappings");
    Mappings = class {
      constructor(manager, nvim, config) {
        this.manager = manager;
        this.nvim = nvim;
        this.config = config;
        this.insertMappings = /* @__PURE__ */ new Map();
        this.normalMappings = /* @__PURE__ */ new Map();
        this.userInsertMappings = /* @__PURE__ */ new Map();
        this.userNormalMappings = /* @__PURE__ */ new Map();
        this.actions = /* @__PURE__ */ new Map();
        let { prompt } = manager;
        this.addAction("do:switch", async () => {
          await manager.switchMatcher();
        });
        this.addAction("do:selectall", async () => {
          var _a;
          await ((_a = manager.session) == null ? void 0 : _a.ui.selectAll());
        });
        this.addAction("do:help", async () => {
          var _a;
          await ((_a = manager.session) == null ? void 0 : _a.showHelp());
        });
        this.addAction("do:refresh", async () => {
          var _a;
          await ((_a = manager.session) == null ? void 0 : _a.reloadItems());
        });
        this.addAction("do:exit", async () => {
          await manager.cancel();
        });
        this.addAction("do:stop", () => {
          manager.stop();
        });
        this.addAction("do:cancel", async () => {
          await manager.cancel(false);
        });
        this.addAction("do:toggle", async () => {
          var _a;
          await ((_a = manager.session) == null ? void 0 : _a.ui.toggleSelection());
        });
        this.addAction("do:jumpback", () => {
          var _a;
          (_a = manager.session) == null ? void 0 : _a.jumpBack();
        });
        this.addAction("do:previous", async () => {
          await manager.normal("k");
        });
        this.addAction("do:next", async () => {
          await manager.normal("j");
        });
        this.addAction("do:defaultaction", async () => {
          await manager.doAction();
        });
        this.addAction("do:chooseaction", async () => {
          await manager.chooseAction();
        });
        this.addAction("do:togglemode", () => {
          manager.toggleMode();
        });
        this.addAction("do:previewtoggle", async () => {
          await manager.togglePreview();
        });
        this.addAction("do:previewup", () => {
          this.scrollPreview("up");
        });
        this.addAction("do:previewdown", () => {
          this.scrollPreview("down");
        });
        this.addAction("do:command", async () => {
          await manager.cancel(false);
          await nvim.eval('feedkeys(":")');
        });
        this.addAction("prompt:previous", () => {
          var _a;
          (_a = manager.session) == null ? void 0 : _a.history.previous();
        });
        this.addAction("prompt:next", () => {
          var _a;
          (_a = manager.session) == null ? void 0 : _a.history.next();
        });
        this.addAction("prompt:start", () => {
          prompt.moveToStart();
        });
        this.addAction("prompt:end", () => {
          prompt.moveToEnd();
        });
        this.addAction("prompt:left", () => {
          prompt.moveLeft();
        });
        this.addAction("prompt:right", () => {
          prompt.moveRight();
        });
        this.addAction("prompt:deleteforward", () => {
          prompt.onBackspace();
        });
        this.addAction("prompt:deletebackward", () => {
          prompt.removeNext();
        });
        this.addAction("prompt:removetail", () => {
          prompt.removeTail();
        });
        this.addAction("prompt:removeahead", () => {
          prompt.removeAhead();
        });
        this.addAction("prompt:removeword", () => {
          prompt.removeWord();
        });
        this.addAction("prompt:insertregister", () => {
          prompt.insertRegister();
        });
        this.addAction("prompt:paste", async () => {
          await prompt.paste();
        });
        this.addAction("eval", async (expr) => {
          await prompt.eval(expr);
        });
        this.addAction("command", async (expr) => {
          await manager.command(expr);
        });
        this.addAction("action", async (expr) => {
          await manager.doAction(expr);
        });
        this.addAction("feedkeys", async (expr) => {
          await manager.feedkeys(expr);
        });
        this.addAction("normal", async (expr) => {
          await manager.normal(expr, false);
        });
        this.addAction("normal!", async (expr) => {
          await manager.normal(expr, true);
        });
        this.addAction("call", async (expr) => {
          await manager.call(expr);
        });
        this.addAction("expr", async (expr) => {
          let name2 = await manager.call(expr);
          if (name2)
            await manager.doAction(name2);
        });
        this.addKeyMapping("insert", "<C-s>", "do:switch");
        this.addKeyMapping("insert", "<C-n>", "prompt:next");
        this.addKeyMapping("insert", "<C-p>", "prompt:previous");
        this.addKeyMapping("insert", "<C-v>", "prompt:paste");
        this.addKeyMapping("insert", ["<C-m>", "<cr>"], "do:defaultaction");
        this.addKeyMapping("insert", ["<tab>", "<C-i>", "	"], "do:chooseaction");
        this.addKeyMapping("insert", "<C-o>", "do:togglemode");
        this.addKeyMapping("insert", "<C-c>", "do:stop");
        this.addKeyMapping("insert", "<C-l>", "do:refresh");
        this.addKeyMapping("insert", "<left>", "prompt:left");
        this.addKeyMapping("insert", "<right>", "prompt:right");
        this.addKeyMapping("insert", ["<end>", "<C-e>"], "prompt:end");
        this.addKeyMapping("insert", ["<home>", "<C-a>"], "prompt:start");
        this.addKeyMapping("insert", ["<C-h>", "<bs>", "<backspace>"], "prompt:deleteforward");
        this.addKeyMapping("insert", "<C-w>", "prompt:removeword");
        this.addKeyMapping("insert", "<C-u>", "prompt:removeahead");
        this.addKeyMapping("insert", "<C-r>", "prompt:insertregister");
        this.addKeyMapping("normal", "t", "action:tabe");
        this.addKeyMapping("normal", "s", "action:split");
        this.addKeyMapping("normal", "d", "action:drop");
        this.addKeyMapping("normal", ["<cr>", "<C-m>", "\r"], "do:defaultaction");
        this.addKeyMapping("normal", "<C-a>", "do:selectall");
        this.addKeyMapping("normal", " ", "do:toggle");
        this.addKeyMapping("normal", "p", "do:previewtoggle");
        this.addKeyMapping("normal", ["<tab>", "	", "<C-i>"], "do:chooseaction");
        this.addKeyMapping("normal", "<C-c>", "do:stop");
        this.addKeyMapping("normal", "<C-l>", "do:refresh");
        this.addKeyMapping("normal", "<C-o>", "do:jumpback");
        this.addKeyMapping("normal", "<C-e>", "do:previewdown");
        this.addKeyMapping("normal", "<C-y>", "do:previewup");
        this.addKeyMapping("normal", ["i", "I", "o", "O", "a", "A"], "do:togglemode");
        this.addKeyMapping("normal", "?", "do:help");
        this.addKeyMapping("normal", ":", "do:command");
        this.createMappings();
        config.on("change", () => {
          this.createMappings();
        });
      }
      createMappings() {
        let insertMappings = this.config.get("insertMappings", {});
        this.userInsertMappings = this.fixUserMappings(insertMappings, "list.insertMappings");
        let normalMappings = this.config.get("normalMappings", {});
        this.userNormalMappings = this.fixUserMappings(normalMappings, "list.normalMappings");
      }
      hasUserMapping(mode, key) {
        let map = mode == "insert" ? this.userInsertMappings : this.userNormalMappings;
        return map.has(key);
      }
      isValidAction(action) {
        if (this.actions.has(action))
          return true;
        let [key, expr] = action.split(":", 2);
        if (!expr || !this.actions.has(key))
          return false;
        return true;
      }
      fixUserMappings(mappings, entry) {
        let res = /* @__PURE__ */ new Map();
        for (let [key, value] of Object.entries(mappings)) {
          if (!this.isValidAction(value)) {
            window_default.showMessage(`Invalid configuration - unable to support action "${value}" in "${entry}"`, "warning");
            continue;
          }
          if (key.length == 1) {
            res.set(key, value);
          } else if (key.startsWith("<") && key.endsWith(">")) {
            if (key.toLowerCase() == "<space>") {
              res.set(" ", value);
            } else if (key.toLowerCase() == "<backspace>") {
              res.set("<bs>", value);
            } else if (validKeys.includes(key)) {
              res.set(key, value);
            } else {
              let find = false;
              for (let i = 0; i < validKeys.length; i++) {
                if (validKeys[i].toLowerCase() == key.toLowerCase()) {
                  find = true;
                  res.set(validKeys[i], value);
                  break;
                }
              }
              if (!find)
                window_default.showMessage(`Invalid configuration - unable to recognize "${key}" in "${entry}"`, "warning");
            }
          } else {
            window_default.showMessage(`Invalid configuration - unable to recognize key "${key}" in "${entry}"`, "warning");
          }
        }
        return res;
      }
      async doInsertKeymap(key) {
        var _a, _b;
        let nextKey = this.config.nextKey;
        let previousKey = this.config.previousKey;
        if (key == nextKey) {
          (_a = this.manager) == null ? void 0 : _a.session.ui.moveDown();
          return true;
        }
        if (key == previousKey) {
          (_b = this.manager) == null ? void 0 : _b.session.ui.moveUp();
          return true;
        }
        let expr = this.userInsertMappings.get(key);
        if (expr) {
          let fn = this.getAction(expr);
          await Promise.resolve(fn());
          return true;
        }
        if (this.insertMappings.has(key)) {
          let fn = this.insertMappings.get(key);
          await Promise.resolve(fn());
          return true;
        }
        return false;
      }
      async doNormalKeymap(key) {
        let expr = this.userNormalMappings.get(key);
        if (expr) {
          let fn = this.getAction(expr);
          await Promise.resolve(fn());
          return true;
        }
        if (this.normalMappings.has(key)) {
          let fn = this.normalMappings.get(key);
          await Promise.resolve(fn());
          return true;
        }
        return false;
      }
      addKeyMapping(mode, key, action) {
        let mappings = mode == "insert" ? this.insertMappings : this.normalMappings;
        let fn = this.getAction(action);
        if (Array.isArray(key)) {
          for (let k of key) {
            mappings.set(k, fn);
          }
        } else {
          mappings.set(key, fn);
        }
      }
      addAction(key, fn) {
        this.actions.set(key, fn);
      }
      getAction(action) {
        if (this.actions.has(action))
          return () => {
            return this.doAction(action);
          };
        let [key, expr] = action.split(":", 2);
        if (!expr || !this.actions.has(key))
          throw new Error(`Invalid action ${action}`);
        return () => {
          return this.doAction(key, expr);
        };
      }
      async doAction(key, expr) {
        let fn = this.actions.get(key);
        if (!fn)
          throw new Error(`Action ${key} doesn't exist`);
        await Promise.resolve(fn(expr));
      }
      scrollPreview(dir) {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.call("coc#list#scroll_preview", [dir], true);
        nvim.command("redraw", true);
        nvim.resumeNotification(false, true);
      }
    };
  }
});

// src/list/prompt.ts
var import_vscode_languageserver_protocol75, logger66, Prompt;
var init_prompt = __esm({
  "src/list/prompt.ts"() {
    "use strict";
    import_vscode_languageserver_protocol75 = __toESM(require_main2());
    logger66 = require_logger2()("list-prompt");
    Prompt = class {
      constructor(nvim, config) {
        this.nvim = nvim;
        this.config = config;
        this.cusorIndex = 0;
        this._input = "";
        this._mode = "insert";
        this.interactive = false;
        this.requestInput = false;
        this._onDidChangeInput = new import_vscode_languageserver_protocol75.Emitter();
        this.onDidChangeInput = this._onDidChangeInput.event;
      }
      get input() {
        return this._input;
      }
      set input(str) {
        if (this._input == str)
          return;
        this.cusorIndex = str.length;
        this._input = str;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      get mode() {
        return this._mode;
      }
      set mode(val) {
        if (val == this._mode)
          return;
        this._mode = val;
        this.drawPrompt();
      }
      set matcher(val) {
        this._matcher = val;
        this.drawPrompt();
      }
      start(opts) {
        if (opts) {
          this.interactive = opts.interactive;
          this.cusorIndex = opts.input.length;
          this._input = opts.input;
          this._mode = opts.mode;
          this._matcher = opts.interactive ? "" : opts.matcher;
        }
        this.nvim.call("coc#prompt#start_prompt", ["list"], true);
        this.drawPrompt();
      }
      cancel() {
        let { nvim } = this;
        nvim.call("coc#prompt#stop_prompt", ["list"], true);
      }
      reset() {
        this._input = "";
        this.cusorIndex = 0;
      }
      drawPrompt() {
        let indicator = this.config.get("indicator", ">");
        let { cusorIndex, interactive, input, _matcher } = this;
        let cmds = ['echo ""'];
        if (this.mode == "insert") {
          if (interactive) {
            cmds.push(`echohl MoreMsg | echon 'INTERACTIVE ' | echohl None`);
          } else if (_matcher) {
            cmds.push(`echohl MoreMsg | echon '${_matcher.toUpperCase()} ' | echohl None`);
          }
          cmds.push(`echohl Special | echon '${indicator} ' | echohl None`);
          if (cusorIndex == input.length) {
            cmds.push(`echon '${input.replace(/'/g, "''")}'`);
            cmds.push(`echohl Cursor | echon ' ' | echohl None`);
          } else {
            let pre = input.slice(0, cusorIndex);
            if (pre)
              cmds.push(`echon '${pre.replace(/'/g, "''")}'`);
            cmds.push(`echohl Cursor | echon '${input[cusorIndex].replace(/'/, "''")}' | echohl None`);
            let post = input.slice(cusorIndex + 1);
            cmds.push(`echon '${post.replace(/'/g, "''")}'`);
          }
        } else {
          cmds.push(`echohl MoreMsg | echo "" | echohl None`);
        }
        cmds.push("redraw");
        let cmd = cmds.join("|");
        this.nvim.command(cmd, true);
      }
      moveLeft() {
        if (this.cusorIndex == 0)
          return;
        this.cusorIndex = this.cusorIndex - 1;
        this.drawPrompt();
      }
      moveRight() {
        if (this.cusorIndex == this._input.length)
          return;
        this.cusorIndex = this.cusorIndex + 1;
        this.drawPrompt();
      }
      moveToEnd() {
        if (this.cusorIndex == this._input.length)
          return;
        this.cusorIndex = this._input.length;
        this.drawPrompt();
      }
      moveToStart() {
        if (this.cusorIndex == 0)
          return;
        this.cusorIndex = 0;
        this.drawPrompt();
      }
      onBackspace() {
        let { cusorIndex, input } = this;
        if (cusorIndex == 0)
          return;
        let pre = input.slice(0, cusorIndex);
        let post = input.slice(cusorIndex);
        this.cusorIndex = cusorIndex - 1;
        this._input = `${pre.slice(0, pre.length - 1)}${post}`;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      removeNext() {
        let { cusorIndex, input } = this;
        if (cusorIndex == input.length - 1)
          return;
        let pre = input.slice(0, cusorIndex);
        let post = input.slice(cusorIndex + 1);
        this._input = `${pre}${post}`;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      removeWord() {
        let { cusorIndex, input } = this;
        if (cusorIndex == 0)
          return;
        let pre = input.slice(0, cusorIndex);
        let post = input.slice(cusorIndex);
        let remain = pre.replace(/[\w$]+([^\w$]+)?$/, "");
        this.cusorIndex = cusorIndex - (pre.length - remain.length);
        this._input = `${remain}${post}`;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      removeTail() {
        let { cusorIndex, input } = this;
        if (cusorIndex == input.length)
          return;
        let pre = input.slice(0, cusorIndex);
        this._input = pre;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      removeAhead() {
        let { cusorIndex, input } = this;
        if (cusorIndex == 0)
          return;
        let post = input.slice(cusorIndex);
        this.cusorIndex = 0;
        this._input = post;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
      async acceptCharacter(ch) {
        if (this.requestInput) {
          this.requestInput = false;
          if (/^[0-9a-z"%#*+/:\-.]$/.test(ch)) {
            let text = await this.nvim.call("getreg", ch);
            text = text.replace(/\n/g, " ");
            this.addText(text);
          }
        } else {
          this.addText(ch);
        }
      }
      insertRegister() {
        this.requestInput = true;
      }
      async paste() {
        let text = await this.nvim.eval("@*");
        text = text.replace(/\n/g, "");
        if (!text)
          return;
        this.addText(text);
      }
      async eval(expression) {
        let text = await this.nvim.call("eval", [expression]);
        text = text.replace(/\n/g, "");
        this.addText(text);
      }
      addText(text) {
        let { cusorIndex, input } = this;
        this.cusorIndex = cusorIndex + text.length;
        let pre = input.slice(0, cusorIndex);
        let post = input.slice(cusorIndex);
        this._input = `${pre}${text}${post}`;
        this.drawPrompt();
        this._onDidChangeInput.fire(this._input);
      }
    };
  }
});

// src/util/fuzzy.ts
function getCharCodes(str) {
  let res = [];
  for (let i = 0, l = str.length; i < l; i++) {
    res.push(str.charCodeAt(i));
  }
  return res;
}
function wordChar(ch) {
  return ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90;
}
function caseMatch(input, code, ignorecase = false) {
  if (input == code)
    return true;
  if (input >= 97 && input <= 122 && code + 32 === input)
    return true;
  if (ignorecase && input <= 90 && input + 32 === code)
    return true;
  return false;
}
function fuzzyChar(a, b, ignorecase = false) {
  let ca = a.charCodeAt(0);
  let cb = b.charCodeAt(0);
  if (ca === cb)
    return true;
  if (ca >= 97 && ca <= 122 && cb + 32 === ca)
    return true;
  if (ignorecase && ca <= 90 && ca + 32 === cb)
    return true;
  return false;
}
function fuzzyMatch(needle, text) {
  let totalCount = needle.length;
  if (needle.length > text.length)
    return false;
  let i = 0;
  for (let j = 0; j < text.length; j++) {
    if (i === totalCount)
      break;
    let code = text.charCodeAt(j);
    let m = needle[i];
    if (code === m) {
      i = i + 1;
      continue;
    }
    if (m >= 97 && m <= 122 && code + 32 === m) {
      i = i + 1;
      continue;
    }
  }
  return i === totalCount;
}
function fuzzyPositions(input, text, smartcase, excludes = []) {
  let totalCount = input.length;
  if (totalCount === 0)
    return [];
  if (totalCount > text.length)
    return void 0;
  let ignorecase = smartcase === false || !hasUpperCase(input);
  let i = 0;
  let res = [];
  let charCodes = getCharCodes(input);
  for (let j = 0; j < text.length; j++) {
    if (excludes.includes(j))
      continue;
    let m = charCodes[i];
    let code = text.charCodeAt(j);
    if (caseMatch(m, code, !smartcase)) {
      if (i > 0 && j > 0 && j - res[i - 1] > 1) {
        let matched = [];
        for (let k = 0; k < i; k++) {
          let idx = j - k - 1;
          let p = text.charCodeAt(idx);
          if (!excludes.includes(idx) && caseMatch(charCodes[i - k - 1], p, ignorecase)) {
            matched.unshift(idx);
          } else {
            break;
          }
        }
        if (matched.length === i) {
          res = matched;
        }
      }
      i = i + 1;
      res.push(j);
      if (i === totalCount) {
        if (i > 1 && res[i - 1] - res[i - 2] > 1 && text.length - res[i - 1] + 1 >= totalCount) {
          let idx = ignorecase ? text.toLowerCase().indexOf(input.toLowerCase(), j - 1) : text.indexOf(input, j - 1);
          if (idx !== -1 && !excludes.includes(idx)) {
            res = range(idx, idx + totalCount - 1);
          }
        }
        break;
      }
      continue;
    }
  }
  return res.length === totalCount ? res : void 0;
}
var range;
var init_fuzzy = __esm({
  "src/util/fuzzy.ts"() {
    "use strict";
    init_string();
    range = (x, y) => Array.from(function* () {
      while (x <= y)
        yield x++;
    }());
  }
});

// src/list/history.ts
var logger67, InputHistory;
var init_history = __esm({
  "src/list/history.ts"() {
    "use strict";
    init_fuzzy();
    init_workspace();
    logger67 = require_logger2()("list-history");
    InputHistory = class {
      constructor(prompt, name2) {
        this.prompt = prompt;
        this.name = name2;
        this.index = -1;
        this.loaded = [];
        this.current = [];
        this.db = workspace_default.createDatabase(`list-${name2}-history`);
        this.key = Buffer.from(workspace_default.cwd).toString("base64");
      }
      filter() {
        let { input } = this.prompt;
        if (input == this.curr)
          return;
        this.historyInput = "";
        let codes = getCharCodes(input);
        this.current = this.loaded.filter((s) => fuzzyMatch(codes, s));
        this.index = -1;
      }
      get curr() {
        return this.index == -1 ? null : this.current[this.index];
      }
      load(input) {
        let { db } = this;
        input = input || "";
        let arr = db.fetch(this.key);
        if (!arr || !Array.isArray(arr)) {
          this.loaded = [];
        } else {
          this.loaded = arr;
        }
        this.index = -1;
        this.current = this.loaded.filter((s) => s.startsWith(input));
      }
      add() {
        let { loaded, db, prompt } = this;
        let { input } = prompt;
        if (!input || input.length < 2 || input == this.historyInput)
          return;
        let idx = loaded.indexOf(input);
        if (idx != -1)
          loaded.splice(idx, 1);
        loaded.push(input);
        if (loaded.length > 200) {
          loaded = loaded.slice(-200);
        }
        db.push(this.key, loaded);
      }
      previous() {
        let { current, index } = this;
        if (!current || !current.length)
          return;
        if (index <= 0) {
          this.index = current.length - 1;
        } else {
          this.index = index - 1;
        }
        this.historyInput = this.prompt.input = current[this.index] || "";
      }
      next() {
        let { current, index } = this;
        if (!current || !current.length)
          return;
        if (index == current.length - 1) {
          this.index = 0;
        } else {
          this.index = index + 1;
        }
        this.historyInput = this.prompt.input = current[this.index] || "";
      }
    };
  }
});

// src/list/ui.ts
var import_debounce5, import_vscode_languageserver_protocol76, logger68, ListUI;
var init_ui2 = __esm({
  "src/list/ui.ts"() {
    "use strict";
    import_debounce5 = __toESM(require_debounce());
    import_vscode_languageserver_protocol76 = __toESM(require_main2());
    init_events();
    init_util();
    init_mutex();
    init_workspace();
    logger68 = require_logger2()("list-ui");
    ListUI = class {
      constructor(nvim, name2, listOptions, config) {
        this.nvim = nvim;
        this.name = name2;
        this.listOptions = listOptions;
        this.config = config;
        this.newTab = false;
        this.reversed = false;
        this.currIndex = 0;
        this.items = [];
        this.disposables = [];
        this.selected = /* @__PURE__ */ new Set();
        this.mutex = new Mutex();
        this._onDidChangeLine = new import_vscode_languageserver_protocol76.Emitter();
        this._onDidOpen = new import_vscode_languageserver_protocol76.Emitter();
        this._onDidClose = new import_vscode_languageserver_protocol76.Emitter();
        this._onDidLineChange = new import_vscode_languageserver_protocol76.Emitter();
        this._onDoubleClick = new import_vscode_languageserver_protocol76.Emitter();
        this.onDidChangeLine = this._onDidChangeLine.event;
        this.onDidLineChange = this._onDidLineChange.event;
        this.onDidOpen = this._onDidOpen.event;
        this.onDidClose = this._onDidClose.event;
        this.onDidDoubleClick = this._onDoubleClick.event;
        this.signOffset = config.get("signOffset");
        this.newTab = listOptions.position == "tab";
        this.reversed = listOptions.reverse === true;
        events_default.on("BufWinLeave", async (bufnr) => {
          if (bufnr != this.bufnr || this.window == null)
            return;
          this.window = null;
          this._onDidClose.fire(bufnr);
        }, null, this.disposables);
        events_default.on("CursorMoved", async (bufnr, cursor) => {
          if (bufnr != this.bufnr)
            return;
          let idx = this.lnumToIndex(cursor[0]);
          this.onLineChange(idx);
        }, null, this.disposables);
        let debounced = (0, import_debounce5.default)(async (bufnr) => {
          if (bufnr != this.bufnr)
            return;
          let [winid, start, end] = await nvim.eval('[win_getid(),line("w0"),line("w$")]');
          if (end < 300 || winid != this.winid)
            return;
          let h = end - start + 1;
          let s = this.lnumToIndex(start);
          let e = this.lnumToIndex(start + h * 2);
          nvim.pauseNotification();
          this.doHighlight(s, e);
          nvim.command("redraw", true);
          nvim.resumeNotification(false, true);
        }, global.hasOwnProperty("__TEST__") ? 20 : 100);
        this.disposables.push({
          dispose: () => {
            debounced.clear();
          }
        });
        events_default.on("CursorMoved", debounced, null, this.disposables);
      }
      lnumToIndex(lnum) {
        let { reversed, length } = this;
        if (!reversed)
          return lnum - 1;
        return Math.max(0, length - lnum);
      }
      indexToLnum(index) {
        let { reversed, length } = this;
        if (!reversed)
          return Math.min(index + 1, length);
        return Math.max(Math.min(length, length - index), 1);
      }
      get bufnr() {
        var _a;
        return (_a = this.buffer) == null ? void 0 : _a.id;
      }
      get winid() {
        var _a;
        return (_a = this.window) == null ? void 0 : _a.id;
      }
      get limitLines() {
        return this.config.get("limitLines", Infinity);
      }
      onLineChange(index) {
        if (this.currIndex == index)
          return;
        this.currIndex = index;
        this._onDidChangeLine.fire(index);
      }
      set index(n) {
        if (n < 0 || n >= this.items.length)
          return;
        let { nvim } = this;
        let lnum = this.indexToLnum(n);
        nvim.pauseNotification();
        this.setCursor(lnum);
        nvim.command("redraw", true);
        nvim.resumeNotification(false, true);
      }
      get index() {
        return this.currIndex;
      }
      getItem(index) {
        return this.items[index];
      }
      get item() {
        let { window: window2 } = this;
        if (!window2)
          return Promise.resolve(null);
        return window2.cursor.then((cursor) => {
          this.currIndex = this.lnumToIndex(cursor[0]);
          return this.items[this.currIndex];
        });
      }
      async echoMessage(item) {
        let { items } = this;
        let idx = items.indexOf(item);
        let msg = `[${idx + 1}/${items.length}] ${item.label || ""}`;
        this.nvim.callTimer("coc#ui#echo_lines", [[msg]], true);
      }
      updateItem(item, index, labelChanged) {
        if (!this.buffer || index >= this.length)
          return;
        let prev = this.items[index];
        Object.assign(prev, item, { resolved: true });
        if (!labelChanged)
          return;
        let { nvim } = this;
        let lnum = this.indexToLnum(index);
        nvim.pauseNotification();
        this.buffer.setOption("modifiable", true, true);
        nvim.call("setbufline", [this.bufnr, lnum, prev.label], true);
        this.doHighlight(index, index + 1);
        this.buffer.setOption("modifiable", false, true);
        nvim.resumeNotification(true, true);
      }
      async getItems() {
        if (this.length == 0 || !this.window)
          return [];
        let mode = await this.nvim.call("mode");
        if (mode == "v" || mode == "V") {
          let [start, end] = await this.getSelectedRange();
          let res = [];
          for (let i = start; i <= end; i++) {
            let idx = this.lnumToIndex(i);
            let item2 = this.items[idx];
            if (item2)
              res.push(item2);
          }
          return res;
        }
        let { selectedItems } = this;
        if (selectedItems.length)
          return selectedItems;
        let item = await this.item;
        return item == null ? [] : [item];
      }
      async onMouse(event) {
        let { nvim, window: window2 } = this;
        if (!window2)
          return;
        let [winid, lnum, col] = await nvim.eval(`[v:mouse_winid,v:mouse_lnum,v:mouse_col]`);
        if (event == "mouseDown") {
          this.mouseDown = { winid, lnum, col, current: winid == window2.id };
          return;
        }
        let current = winid == window2.id;
        if (current && event == "doubleClick") {
          this.setCursor(lnum);
          this._onDoubleClick.fire();
        }
        if (current && event == "mouseDrag") {
          if (!this.mouseDown)
            return;
          await this.selectLines(this.mouseDown.lnum, lnum);
        } else if (current && event == "mouseUp") {
          if (!this.mouseDown)
            return;
          if (this.mouseDown.lnum == lnum) {
            this.setCursor(lnum);
            nvim.command("redraw", true);
          } else {
            await this.selectLines(this.mouseDown.lnum, lnum);
          }
        } else if (!current && event == "mouseUp") {
          nvim.pauseNotification();
          nvim.call("win_gotoid", winid, true);
          nvim.call("cursor", [lnum, col], true);
          nvim.command("redraw", true);
          nvim.resumeNotification(false, true);
        }
      }
      async resume() {
        var _a;
        let { items, selected, nvim } = this;
        await this.drawItems(items, this.height, true);
        if (!selected.size || !this.buffer)
          return;
        nvim.pauseNotification();
        for (let lnum of selected) {
          (_a = this.buffer) == null ? void 0 : _a.placeSign({ lnum, id: this.signOffset + lnum, name: "CocSelected", group: "coc-list" });
        }
        nvim.command("redraw", true);
        nvim.resumeNotification(false, true);
      }
      async toggleSelection() {
        let { nvim, reversed } = this;
        await nvim.call("win_gotoid", [this.winid]);
        let lnum = await nvim.call("line", ".");
        let mode = await nvim.call("mode");
        if (mode == "v" || mode == "V") {
          let [start, end] = await this.getSelectedRange();
          let reverse = start > end;
          if (reverse)
            [start, end] = [end, start];
          for (let i = start; i <= end; i++) {
            this.toggleLine(i);
          }
          this.setCursor(end);
          nvim.command("redraw", true);
          await nvim.resumeNotification();
          return;
        }
        nvim.pauseNotification();
        this.toggleLine(lnum);
        this.setCursor(reversed ? lnum - 1 : lnum + 1);
        nvim.command("redraw", true);
        await nvim.resumeNotification();
      }
      toggleLine(lnum) {
        let { selected, buffer, signOffset: signOffset2 } = this;
        let exists = selected.has(lnum);
        if (!exists) {
          selected.add(lnum);
          buffer.placeSign({ lnum, id: signOffset2 + lnum, name: "CocSelected", group: "coc-list" });
        } else {
          selected.delete(lnum);
          buffer.unplaceSign({ id: signOffset2 + lnum, group: "coc-list" });
        }
      }
      async selectLines(start, end) {
        let { nvim, signOffset: signOffset2, buffer, length } = this;
        this.clearSelection();
        let { selected } = this;
        nvim.pauseNotification();
        let reverse = start > end;
        if (reverse)
          [start, end] = [end, start];
        for (let i = start; i <= end; i++) {
          if (i > length)
            break;
          selected.add(i);
          buffer.placeSign({ lnum: i, id: signOffset2 + i, name: "CocSelected", group: "coc-list" });
        }
        this.setCursor(end);
        nvim.command("redraw", true);
        await nvim.resumeNotification();
      }
      async selectAll() {
        let { length } = this;
        if (length > 0)
          await this.selectLines(1, length);
      }
      clearSelection() {
        let { selected, buffer } = this;
        if (selected.size > 0) {
          buffer == null ? void 0 : buffer.unplaceSign({ group: "coc-list" });
          this.selected.clear();
        }
      }
      get ready() {
        if (this.window)
          return Promise.resolve();
        return new Promise((resolve3) => {
          let disposable = this.onDidLineChange(() => {
            disposable.dispose();
            resolve3();
          });
        });
      }
      async drawItems(items, height, reload = false) {
        const { nvim, name: name2, listOptions } = this;
        await this.mutex.use(async () => {
          this.items = items.length > this.limitLines ? items.slice(0, this.limitLines) : items;
          if (!this.window) {
            let { position, numberSelect } = listOptions;
            let [bufnr, winid, tabnr] = await nvim.call("coc#list#create", [position, height, name2, numberSelect]);
            this.tabnr = tabnr;
            this.height = height;
            this.buffer = nvim.createBuffer(bufnr);
            let win = this.window = nvim.createWindow(winid);
            let statusSegments = this.config.get("statusLineSegments");
            if (statusSegments)
              win.setOption("statusline", statusSegments.join(" "), true);
            this._onDidOpen.fire(this.bufnr);
          }
          const lines = [];
          let selectIndex = 0;
          this.items.forEach((item, idx) => {
            lines.push(item.label);
            if (!reload && selectIndex == 0 && item.preselect)
              selectIndex = idx;
          });
          let newIndex = reload ? this.currIndex : selectIndex;
          this.setLines(lines, 0, newIndex);
          this._onDidLineChange.fire();
        });
      }
      async appendItems(items) {
        if (!this.window || items.length === 0)
          return;
        await this.mutex.use(async () => {
          let curr = this.items.length;
          let remain = this.limitLines - curr;
          if (remain > 0) {
            let append = remain < items.length ? items.slice(0, remain) : items;
            this.items = this.items.concat(append);
            this.setLines(append.map((item) => item.label), append.length, this.currIndex);
          }
        });
      }
      setLines(lines, append, index) {
        let { nvim, buffer, window: window2, reversed, newTab } = this;
        if (!buffer || !window2)
          return;
        nvim.pauseNotification();
        if (!append) {
          nvim.call("coc#compat#clear_matches", [window2.id], true);
          if (!lines.length) {
            lines = ["No results, press ? on normal mode to get help."];
            nvim.call("coc#compat#matchaddpos", ["Comment", [[1]], 99, window2.id], true);
          }
        }
        buffer.setOption("modifiable", true, true);
        if (reversed) {
          let replacement = lines.reverse();
          if (append) {
            nvim.call("coc#compat#prepend_lines", [buffer.id, replacement], true);
          } else {
            buffer.setLines(replacement, { start: 0, end: -1, strictIndexing: false }, true);
          }
        } else {
          buffer.setLines(lines, { start: append ? -1 : 0, end: -1, strictIndexing: false }, true);
        }
        buffer.setOption("modifiable", false, true);
        if (reversed && !newTab) {
          let maxHeight = this.config.get("height", 10);
          nvim.call("coc#window#set_height", [window2.id, Math.max(Math.min(maxHeight, this.length), 1)], true);
        }
        if (index > this.items.length - 1)
          index = 0;
        if (index == 0) {
          if (append == 0) {
            this.doHighlight(0, 299);
          } else {
            let s = this.length - append - 1;
            if (s < 300)
              this.doHighlight(s, Math.min(299, this.length - 1));
          }
        } else {
          let height = newTab ? workspace_default.env.lines : this.height;
          this.doHighlight(Math.max(0, index - height), Math.min(index + height + 1, this.length - 1));
        }
        if (!append) {
          this.currIndex = index;
          let lnum = this.indexToLnum(index);
          window2.setCursor([lnum, 0], true);
          nvim.call("coc#list#select", [buffer.id, lnum], true);
        }
        if (reversed)
          nvim.command("normal! zb", true);
        nvim.command("redraws", true);
        nvim.resumeNotification(true, true);
      }
      restoreWindow() {
        if (this.newTab)
          return;
        let { winid, height } = this;
        if (winid && height) {
          this.nvim.call("coc#window#set_height", [winid, height], true);
        }
      }
      get length() {
        return this.items.length;
      }
      get selectedItems() {
        let { selected, items } = this;
        let res = [];
        for (let i of selected) {
          let idx = this.lnumToIndex(i);
          if (items[i - 1])
            res.push(items[idx]);
        }
        return res;
      }
      doHighlight(start, end) {
        let { items, reversed, length, buffer } = this;
        if (!buffer)
          return;
        const highlightItems = [];
        const iterate = (i) => {
          let lnum = this.indexToLnum(i) - 1;
          let { ansiHighlights, highlights } = items[i];
          if (ansiHighlights) {
            for (let hi of ansiHighlights) {
              let { span, hlGroup } = hi;
              highlightItems.push({ hlGroup, lnum, colStart: span[0], colEnd: span[1] });
            }
          }
          if (highlights && Array.isArray(highlights.spans)) {
            let { spans, hlGroup } = highlights;
            for (let span of spans) {
              hlGroup = hlGroup ?? "CocListSearch";
              highlightItems.push({ hlGroup, lnum, colStart: span[0], colEnd: span[1] });
            }
          }
        };
        if (reversed) {
          for (let i = Math.min(end, length - 1); i >= start; i--) {
            iterate(i);
          }
        } else {
          for (let i = start; i <= Math.min(end, length - 1); i++) {
            iterate(i);
          }
        }
        start = this.indexToLnum(start) - 1;
        end = this.indexToLnum(end) - 1;
        if (start > end) {
          [start, end] = [end, start];
        }
        if (highlightItems.length == 0)
          return;
        buffer.updateHighlights("list", highlightItems, { start, end: end + 1, priority: 99 });
      }
      setCursor(lnum, col = 0) {
        var _a;
        let { items } = this;
        let max = items.length == 0 ? 1 : items.length;
        if (lnum > max)
          return;
        let idx = this.lnumToIndex(lnum);
        this.onLineChange(idx);
        (_a = this.window) == null ? void 0 : _a.setCursor([lnum, col], true);
        this.nvim.call("coc#list#select", [this.bufnr, lnum], true);
      }
      moveUp() {
        let { index, reversed } = this;
        this.index = reversed ? index + 1 : index - 1;
      }
      moveDown() {
        let { index, reversed } = this;
        this.index = reversed ? index - 1 : index + 1;
      }
      async getSelectedRange() {
        let { nvim } = this;
        await nvim.call("coc#prompt#stop_prompt", ["list"]);
        await nvim.eval('feedkeys("\\<esc>", "in")');
        let [, start] = await nvim.call("getpos", "'<");
        let [, end] = await nvim.call("getpos", "'>");
        this.nvim.call("coc#prompt#start_prompt", ["list"], true);
        return [start, end];
      }
      reset() {
        if (this.window) {
          this.window = null;
          this.buffer = null;
          this.tabnr = void 0;
        }
      }
      dispose() {
        disposeAll(this.disposables);
        this.nvim.call("coc#window#close", [this.winid || -1], true);
        this.window = null;
        this.buffer = null;
        this.items = [];
        this._onDidChangeLine.dispose();
        this._onDidOpen.dispose();
        this._onDidClose.dispose();
        this._onDidLineChange.dispose();
        this._onDoubleClick.dispose();
      }
    };
  }
});

// src/util/async.ts
async function filter(items, isValid, onFilter, token) {
  if (items.length === 0)
    return;
  const timer = new Timer();
  const len = items.length;
  function convertBatch(start) {
    const result = [];
    timer.start();
    for (let i = start; i < len; i++) {
      let item = items[i];
      let res = isValid(item);
      if (res)
        typeof res === "boolean" ? result.push(item) : result.push(Object.assign({}, item, res));
      if (timer.shouldYield()) {
        let done = i === len - 1;
        onFilter(result, done);
        return done ? -1 : i + 1;
      }
    }
    onFilter(result, true);
    return -1;
  }
  let index = convertBatch(0);
  while (index !== -1) {
    if (token !== void 0 && token.isCancellationRequested) {
      break;
    }
    index = await new Promise((resolve3) => {
      setImmediate(() => {
        resolve3(convertBatch(index));
      });
    });
  }
}
var defaultYieldTimeout, Timer;
var init_async = __esm({
  "src/util/async.ts"() {
    defaultYieldTimeout = 15;
    Timer = class {
      constructor(yieldAfter = defaultYieldTimeout) {
        this.yieldAfter = Math.max(yieldAfter, defaultYieldTimeout);
        this.startTime = Date.now();
        this.counter = 0;
        this.total = 0;
        this.counterInterval = 1;
      }
      start() {
        this.startTime = Date.now();
      }
      shouldYield() {
        if (++this.counter >= this.counterInterval) {
          const timeTaken = Date.now() - this.startTime;
          const timeLeft = Math.max(0, this.yieldAfter - timeTaken);
          this.total += this.counter;
          this.counter = 0;
          if (timeTaken >= this.yieldAfter || timeLeft <= 1) {
            this.counterInterval = 1;
            this.total = 0;
            return true;
          } else {
            switch (timeTaken) {
              case 0:
              case 1:
                this.counterInterval = this.total * 2;
                break;
            }
          }
        }
        return false;
      }
    };
  }
});

// src/util/score.ts
function getMatchHighlights(input, text, start = 0, hlGroup = "CocSearch", ignorecase = true) {
  let res = [];
  let curr = 0;
  let lastIndex;
  let len = text.length;
  for (let index = 0; index < input.length; index++) {
    const ch = input[index];
    let i = curr;
    while (i < len) {
      if (fuzzyChar(ch, text[i], ignorecase)) {
        if (i == lastIndex + 1) {
          let last = res[res.length - 1];
          last.span[1] = last.span[1] + byteLength(text[i]);
        } else {
          let s = byteIndex(text, i) + start;
          res.push({ span: [s, s + byteLength(text[i])], hlGroup });
        }
        lastIndex = i;
        curr = i + 1;
        break;
      }
      i += 1;
    }
  }
  return res;
}
function getMatchResult(text, query, filename = "") {
  if (!text)
    return { score: 0 };
  if (!query)
    return { score: 1 };
  let matches = [];
  let codes = getCharCodes(query);
  let filenameIdx = filename ? text.indexOf(filename) : -1;
  let matchBase = filenameIdx != -1 && fuzzyMatch(codes, filename);
  let score5 = 0;
  let c = query[0];
  let idx = 0;
  let first = text[0];
  if (matchBase) {
    if (filename.startsWith(c)) {
      score5 = score5 + 2;
      idx = filenameIdx + 1;
      matches.push(filenameIdx);
    } else if (filename[0].toLowerCase() == c) {
      score5 = score5 + 1.5;
      idx = filenameIdx + 1;
      matches.push(filenameIdx);
    } else {
      for (let i = 1; i < filename.length; i++) {
        if (fuzzyChar(c, filename[i])) {
          score5 = score5 + 1;
          idx = filenameIdx + i + 1;
          matches.push(filenameIdx + i);
          break;
        }
      }
    }
  } else if (first.toLowerCase() === c.toLowerCase()) {
    score5 = score5 + (first == c ? 1 : 0.5);
    matches.push(0);
    idx = 1;
  } else {
    for (let i = 1; i < text.length; i++) {
      let pre = text[i - 1];
      if (pre == import_path23.sep && text[i] == c) {
        score5 = score5 + 1;
        matches.push(i);
        idx = i + 1;
        break;
      }
    }
    if (idx == 0) {
      for (let i = 0; i < text.length; i++) {
        if (fuzzyChar(c.toLowerCase(), text[i])) {
          score5 = score5 + (c === text[i] ? 0.5 : 0.3);
          matches.push(i);
          idx = i + 1;
          break;
        }
      }
    }
  }
  if (idx == 0)
    return { score: 0 };
  if (codes.length == 1)
    return { score: score5, matches };
  return nextResult(codes.slice(1), text, idx, { score: score5, matches });
}
function nextResult(codes, text, idx, curr) {
  let { score: score5, matches } = curr;
  let results = [];
  let c = codes[0];
  let remain = codes.slice(1);
  let result;
  function getRemainResult(index) {
    if (!result)
      return;
    if (remain.length == 0) {
      results.push(result);
    } else if (result) {
      let res = nextResult(remain, text, index, result);
      if (res)
        results.push(res);
    }
  }
  let followed = idx < text.length ? text[idx].charCodeAt(0) : null;
  if (!followed)
    return null;
  if (followed == c) {
    result = { score: score5 + 1, matches: matches.concat([idx]) };
    getRemainResult(idx + 1);
  } else if (caseMatch(c, followed, true)) {
    result = { score: score5 + 0.5, matches: matches.concat([idx]) };
    getRemainResult(idx + 1);
  }
  if (idx + 1 < text.length) {
    for (let i = idx + 1; i < text.length; i++) {
      let ch = text[i].charCodeAt(0);
      if (text[i - 1] == import_path23.sep && caseMatch(c, ch, true)) {
        let add = c == ch ? 1 : 0.5;
        result = { score: score5 + add, matches: matches.concat([i]) };
        getRemainResult(i + 1);
        break;
      }
    }
    for (let i = idx + 1; i < text.length; i++) {
      let ch = text[i].charCodeAt(0);
      if (caseMatch(c, ch, true)) {
        let add = c == ch ? 0.5 : 0.2;
        result = { score: score5 + add, matches: matches.concat([i]) };
        getRemainResult(i + 1);
        break;
      }
    }
  }
  return results.length ? bestResult(results) : null;
}
function bestResult(results) {
  let res = results[0];
  for (let i = 1; i < results.length; i++) {
    if (results[i].score > res.score) {
      res = results[i];
    }
  }
  return res;
}
var import_path23;
var init_score = __esm({
  "src/util/score.ts"() {
    "use strict";
    import_path23 = require("path");
    init_fuzzy();
    init_string();
  }
});

// src/list/worker.ts
function getFilterLabel(item) {
  return item.filterText != null ? patchLine(item.filterText, item.label) : item.label;
}
function parseInput(input) {
  let res = [];
  let startIdx = 0;
  let currIdx = 0;
  let prev = "";
  for (; currIdx < input.length; currIdx++) {
    let ch = input[currIdx];
    if (ch.charCodeAt(0) === 32) {
      if (prev && prev != "\\" && startIdx != currIdx) {
        res.push(input.slice(startIdx, currIdx));
        startIdx = currIdx + 1;
      }
    } else {
    }
    prev = ch;
  }
  if (startIdx != input.length) {
    res.push(input.slice(startIdx, input.length));
  }
  return res.map((s) => s.replace(/\\\s/g, " ").trim()).filter((s) => s.length > 0);
}
function getHighlights(text, matches) {
  let spans = [];
  if (matches && matches.length) {
    let start = matches.shift();
    let next = matches.shift();
    let curr = start;
    while (next) {
      if (next == curr + 1) {
        curr = next;
        next = matches.shift();
        continue;
      }
      spans.push([byteIndex(text, start), byteIndex(text, curr) + 1]);
      start = next;
      curr = start;
      next = matches.shift();
    }
    spans.push([byteIndex(text, start), byteIndex(text, curr) + 1]);
  }
  return { spans };
}
function getItemHighlights(input, item) {
  let filterLabel = getFilterLabel(item);
  let res = getMatchResult(filterLabel, input);
  if (!(res == null ? void 0 : res.score))
    return { spans: [] };
  return getHighlights(filterLabel, res.matches);
}
var import_vscode_languageserver_protocol77, logger69, controlCode, Worker;
var init_worker = __esm({
  "src/list/worker.ts"() {
    "use strict";
    import_vscode_languageserver_protocol77 = __toESM(require_main2());
    init_ansiparse();
    init_async();
    init_diff();
    init_fuzzy();
    init_fzy();
    init_mutex();
    init_score();
    init_string();
    logger69 = require_logger2()("list-worker");
    controlCode = "\x1B";
    Worker = class {
      constructor(nvim, list2, prompt, listOptions, config) {
        this.nvim = nvim;
        this.list = list2;
        this.prompt = prompt;
        this.listOptions = listOptions;
        this.config = config;
        this._loading = false;
        this._finished = false;
        this.mutex = new Mutex();
        this.totalItems = [];
        this._onDidChangeItems = new import_vscode_languageserver_protocol77.Emitter();
        this._onDidChangeLoading = new import_vscode_languageserver_protocol77.Emitter();
        this.onDidChangeItems = this._onDidChangeItems.event;
        this.onDidChangeLoading = this._onDidChangeLoading.event;
      }
      set loading(loading) {
        if (this._loading == loading)
          return;
        this._loading = loading;
        this._onDidChangeLoading.fire(loading);
      }
      get isLoading() {
        return this._loading;
      }
      async loadItems(context, reload = false) {
        this.cancelFilter();
        this.filteredCount = 0;
        this._finished = false;
        let { list: list2, listOptions } = this;
        this.loading = true;
        let { interactive } = listOptions;
        this.tokenSource = new import_vscode_languageserver_protocol77.CancellationTokenSource();
        let token = this.tokenSource.token;
        let items = await list2.loadItems(context, token);
        if (token.isCancellationRequested)
          return;
        items = items ?? [];
        if (Array.isArray(items)) {
          this.tokenSource = null;
          this.totalItems = items;
          this.loading = false;
          this._finished = true;
          let filtered;
          if (!interactive) {
            let tokenSource = this.filterTokenSource = new import_vscode_languageserver_protocol77.CancellationTokenSource();
            await this.mutex.use(async () => {
              let token2 = tokenSource.token;
              if (token2.isCancellationRequested)
                return;
              await this.filterItems(items, { reload }, token2);
            });
          } else {
            filtered = this.convertToHighlightItems(items);
            this._onDidChangeItems.fire({
              items: filtered,
              reload,
              finished: true
            });
          }
        } else {
          let task = items;
          let totalItems = this.totalItems = [];
          let taken = 0;
          let currInput = context.input;
          let filtering = false;
          this.filterTokenSource = new import_vscode_languageserver_protocol77.CancellationTokenSource();
          let _onData = async (finished) => {
            filtering = true;
            await this.mutex.use(async () => {
              let inputChanged = this.input != currInput;
              if (inputChanged) {
                currInput = this.input;
                taken = this.filteredCount ?? 0;
              }
              if (taken >= totalItems.length)
                return;
              let append = taken > 0;
              let remain = totalItems.slice(taken);
              taken = totalItems.length;
              if (!interactive) {
                let tokenSource = this.filterTokenSource;
                if (tokenSource && !tokenSource.token.isCancellationRequested) {
                  await this.filterItems(remain, { append, reload }, tokenSource.token);
                }
              } else {
                let items2 = this.convertToHighlightItems(remain);
                this._onDidChangeItems.fire({ items: items2, append, reload, finished });
              }
            });
            filtering = false;
          };
          let promise = Promise.resolve();
          let interval = setInterval(() => {
            if (filtering)
              return;
            promise = _onData();
          }, 50);
          task.on("data", (item) => {
            if (token.isCancellationRequested)
              return;
            totalItems.push(item);
          });
          let onEnd = () => {
            if (task == null)
              return;
            this.tokenSource = null;
            task = null;
            this.loading = false;
            this._finished = true;
            disposable.dispose();
            clearInterval(interval);
            promise.then(() => {
              if (token.isCancellationRequested)
                return;
              if (totalItems.length == 0) {
                this._onDidChangeItems.fire({ items: [], append: false, reload, finished: true });
                return;
              }
              return _onData(true);
            }).catch((e) => {
              logger69.error("Error on filter", e);
            });
          };
          let disposable = token.onCancellationRequested(() => {
            task == null ? void 0 : task.dispose();
            onEnd();
          });
          task.on("error", async (error) => {
            if (task == null)
              return;
            task = null;
            this.tokenSource = null;
            this.loading = false;
            disposable.dispose();
            clearInterval(interval);
            this.nvim.call("coc#prompt#stop_prompt", ["list"], true);
            this.nvim.echoError(`Task error: ${error.toString()}`);
            logger69.error("Task error:", error);
          });
          task.on("end", onEnd);
        }
      }
      async drawItems() {
        let { totalItems } = this;
        if (totalItems.length === 0)
          return;
        this.cancelFilter();
        let tokenSource = this.filterTokenSource = new import_vscode_languageserver_protocol77.CancellationTokenSource();
        let token = tokenSource.token;
        await this.mutex.use(async () => {
          if (token.isCancellationRequested)
            return;
          let { totalItems: totalItems2 } = this;
          this.filteredCount = totalItems2.length;
          await this.filterItems(totalItems2, {}, tokenSource.token);
        });
      }
      cancelFilter() {
        if (this.filterTokenSource) {
          this.filterTokenSource.cancel();
          this.filterTokenSource = null;
        }
      }
      stop() {
        this.cancelFilter();
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource = null;
        }
        this.loading = false;
      }
      get length() {
        return this.totalItems.length;
      }
      get input() {
        return this.prompt.input;
      }
      convertToHighlightItems(items) {
        let input = this.input ?? "";
        let res = items.map((item) => {
          this.convertItemLabel(item);
          let highlights = input.length > 0 ? getItemHighlights(input, item) : void 0;
          return Object.assign({}, item, { highlights });
        });
        return res;
      }
      async filterItemsByInclude(inputs, items, token, onFilter) {
        let { ignorecase, smartcase } = this.listOptions;
        if (ignorecase)
          inputs = inputs.map((s) => s.toLowerCase());
        await filter(items, (item) => {
          this.convertItemLabel(item);
          let spans = [];
          let filterLabel = getFilterLabel(item);
          let match = true;
          for (let input of inputs) {
            let idx;
            if (smartcase) {
              idx = smartcaseIndex(input, filterLabel);
            } else {
              idx = ignorecase ? filterLabel.toLowerCase().indexOf(input) : filterLabel.indexOf(input);
            }
            if (idx == -1) {
              match = false;
              break;
            }
            spans.push([byteIndex(filterLabel, idx), byteIndex(filterLabel, idx + byteLength(input))]);
          }
          if (!match)
            return false;
          return { highlights: { spans } };
        }, onFilter, token);
      }
      async filterItemsByRegex(inputs, items, token, onFilter) {
        let { ignorecase } = this.listOptions;
        let flags = ignorecase ? "iu" : "u";
        let regexes = inputs.reduce((p, c) => {
          try {
            p.push(new RegExp(c, flags));
          } catch (e) {
          }
          return p;
        }, []);
        await filter(items, (item) => {
          this.convertItemLabel(item);
          let spans = [];
          let filterLabel = getFilterLabel(item);
          let match = true;
          for (let regex3 of regexes) {
            let ms = filterLabel.match(regex3);
            if (ms == null) {
              match = false;
              break;
            }
            spans.push([byteIndex(filterLabel, ms.index), byteIndex(filterLabel, ms.index + byteLength(ms[0]))]);
          }
          if (!match)
            return false;
          return { highlights: { spans } };
        }, onFilter, token);
      }
      async filterItemsByFuzzyMatch(inputs, items, token, onFilter) {
        let { sort, smartcase } = this.listOptions;
        let idx = 0;
        await filter(items, (item) => {
          this.convertItemLabel(item);
          let filterText = item.filterText ?? item.label;
          let matchScore = 0;
          let matches = [];
          let filterLabel = getFilterLabel(item);
          let match = true;
          for (let input of inputs) {
            let positions2 = fuzzyPositions(input, filterLabel, smartcase, matches);
            if (!positions2) {
              match = false;
              break;
            }
            matches.push(...positions2);
            if (sort)
              matchScore += score(input, filterText);
          }
          idx = idx + 1;
          if (!match)
            return false;
          return {
            sortText: typeof item.sortText === "string" ? item.sortText : String.fromCharCode(idx),
            score: matchScore,
            highlights: getHighlights(filterLabel, matches)
          };
        }, (items2, done) => {
          onFilter(items2, done, sort);
        }, token);
      }
      async filterItems(arr, opts, token) {
        let { input } = this;
        if (input.length === 0) {
          let items = arr.map((item) => {
            return this.convertItemLabel(item);
          });
          this._onDidChangeItems.fire(__spreadValues({ items, finished: this._finished }, opts));
          return;
        }
        let inputs = this.config.extendedSearchMode ? parseInput(input) : [input];
        let called = false;
        const onFilter = (items, finished, sort) => {
          finished = finished && this._finished;
          if (token.isCancellationRequested || !finished && items.length == 0)
            return;
          if (sort) {
            items.sort((a, b) => {
              if (a.score != b.score)
                return b.score - a.score;
              if (a.sortText > b.sortText)
                return 1;
              return -1;
            });
          }
          let append = opts.append === true || called;
          called = true;
          this._onDidChangeItems.fire({ items, append, reload: opts.reload, finished });
        };
        switch (this.listOptions.matcher) {
          case "strict":
            await this.filterItemsByInclude(inputs, arr, token, onFilter);
            break;
          case "regex":
            await this.filterItemsByRegex(inputs, arr, token, onFilter);
            break;
          default:
            await this.filterItemsByFuzzyMatch(inputs, arr, token, onFilter);
        }
      }
      convertItemLabel(item) {
        let { label, converted } = item;
        if (converted)
          return item;
        if (label.includes("\n")) {
          label = item.label = label.replace(/\r?\n/g, " ");
        }
        if (label.includes(controlCode)) {
          let { line, highlights } = parseAnsiHighlights(label);
          item.label = line;
          if (!Array.isArray(item.ansiHighlights))
            item.ansiHighlights = highlights;
        }
        item.converted = true;
        return item;
      }
      dispose() {
        this.stop();
      }
    };
  }
});

// src/list/session.ts
var import_debounce6, import_vscode_languageserver_protocol78, frames2, logger70, ListSession;
var init_session = __esm({
  "src/list/session.ts"() {
    "use strict";
    import_debounce6 = __toESM(require_debounce());
    import_vscode_languageserver_protocol78 = __toESM(require_main2());
    init_extensions3();
    init_highligher();
    init_util();
    init_window();
    init_workspace();
    init_history();
    init_ui2();
    init_worker();
    frames2 = ["\u280B", "\u2819", "\u2839", "\u2838", "\u283C", "\u2834", "\u2826", "\u2827", "\u2807", "\u280F"];
    logger70 = require_logger2()("list-session");
    ListSession = class {
      constructor(nvim, prompt, list2, listOptions, listArgs = [], config) {
        this.nvim = nvim;
        this.prompt = prompt;
        this.list = list2;
        this.listOptions = listOptions;
        this.listArgs = listArgs;
        this.config = config;
        this.loadingFrame = "";
        this.hidden = false;
        this.disposables = [];
        this.args = [];
        this.ui = new ListUI(nvim, list2.name, listOptions, config);
        this.history = new InputHistory(prompt, list2.name);
        this.worker = new Worker(nvim, list2, prompt, listOptions, {
          interactiveDebounceTime: config.get("interactiveDebounceTime", 100),
          extendedSearchMode: config.get("extendedSearchMode", true)
        });
        this.interactiveDebounceTime = config.get("interactiveDebounceTime", 100);
        let debouncedChangeLine = (0, import_debounce6.default)(async () => {
          let [previewing, currwin, lnum] = await nvim.eval('[coc#list#has_preview(),win_getid(),line(".")]');
          if (previewing && currwin == this.winid) {
            let idx = this.ui.lnumToIndex(lnum);
            await this.doPreview(idx);
          }
        }, 50);
        this.disposables.push({
          dispose: () => {
            debouncedChangeLine.clear();
          }
        });
        this.ui.onDidChangeLine(debouncedChangeLine, null, this.disposables);
        this.ui.onDidChangeLine(this.resolveItem, this, this.disposables);
        this.ui.onDidLineChange(this.resolveItem, this, this.disposables);
        let debounced = (0, import_debounce6.default)(async () => {
          this.updateStatus();
          let { autoPreview } = this.listOptions;
          if (!autoPreview) {
            let [previewing, mode] = await nvim.eval("[coc#list#has_preview(),mode()]");
            if (!previewing || mode != "n")
              return;
          }
          await this.doAction("preview");
        }, 50);
        this.disposables.push({
          dispose: () => {
            debounced.clear();
          }
        });
        this.ui.onDidLineChange(debounced, null, this.disposables);
        this.ui.onDidOpen(async () => {
          if (typeof this.list.doHighlight == "function") {
            this.list.doHighlight();
          }
          if (workspace_default.isVim)
            this.prompt.drawPrompt();
          if (this.listOptions.first) {
            await this.doAction();
          }
        }, null, this.disposables);
        this.ui.onDidClose(async () => {
          await this.hide();
        }, null, this.disposables);
        this.ui.onDidDoubleClick(async () => {
          await this.doAction();
        }, null, this.disposables);
        this.worker.onDidChangeItems(async ({ items, reload, append, finished }) => {
          if (this.hidden)
            return;
          if (append) {
            await this.ui.appendItems(items);
          } else {
            let height = this.config.get("height", 10);
            if (finished && !listOptions.interactive && listOptions.input.length == 0) {
              height = Math.min(items.length, height);
            }
            await this.ui.drawItems(items, Math.max(1, height), reload);
          }
        }, null, this.disposables);
        let start = 0;
        let timer;
        let interval;
        this.disposables.push(import_vscode_languageserver_protocol78.Disposable.create(() => {
          if (timer)
            clearTimeout(timer);
          if (interval)
            clearInterval(interval);
        }));
        this.worker.onDidChangeLoading((loading) => {
          if (this.hidden)
            return;
          if (timer)
            clearTimeout(timer);
          if (loading) {
            start = Date.now();
            if (interval)
              clearInterval(interval);
            interval = setInterval(() => {
              let idx = Math.floor((Date.now() - start) % 1e3 / 100);
              this.loadingFrame = frames2[idx];
              this.updateStatus();
            }, 100);
          } else {
            timer = setTimeout(() => {
              this.loadingFrame = "";
              if (interval)
                clearInterval(interval);
              interval = null;
              this.updateStatus();
            }, Math.max(0, 200 - (Date.now() - start)));
          }
        }, null, this.disposables);
      }
      async start(args) {
        this.args = args;
        this.cwd = workspace_default.cwd;
        this.hidden = false;
        let { listOptions, listArgs } = this;
        let res = await this.nvim.eval('[win_getid(),bufnr("%"),winheight("%")]');
        this.listArgs = listArgs;
        this.history.load(listOptions.input || "");
        this.window = this.nvim.createWindow(res[0]);
        this.buffer = this.nvim.createBuffer(res[1]);
        this.savedHeight = res[2];
        await this.worker.loadItems(this.context);
      }
      async reloadItems() {
        if (!this.ui.winid)
          return;
        await this.worker.loadItems(this.context, true);
      }
      async call(fname) {
        var _a, _b;
        await this.nvim.call("coc#prompt#stop_prompt", ["list"]);
        let targets = await this.ui.getItems();
        let context = {
          name: this.name,
          args: this.listArgs,
          input: this.prompt.input,
          winid: (_a = this.window) == null ? void 0 : _a.id,
          bufnr: (_b = this.buffer) == null ? void 0 : _b.id,
          targets
        };
        let res = await this.nvim.call(fname, [context]);
        this.prompt.start();
        return res;
      }
      async chooseAction() {
        let { nvim, defaultAction } = this;
        let { actions } = this.list;
        let names = actions.map((o) => o.name);
        let idx = names.indexOf(defaultAction.name);
        if (idx != -1) {
          names.splice(idx, 1);
          names.unshift(defaultAction.name);
        }
        let shortcuts = /* @__PURE__ */ new Set();
        let choices = [];
        let invalids = [];
        let menuAction = workspace_default.env.dialog && this.config.get("menuAction", false);
        for (let name2 of names) {
          let i = 0;
          for (let ch of name2) {
            if (!shortcuts.has(ch)) {
              shortcuts.add(ch);
              choices.push(`${name2.slice(0, i)}&${name2.slice(i)}`);
              break;
            }
            i++;
          }
          if (i == name2.length) {
            invalids.push(name2);
          }
        }
        if (invalids.length && !menuAction) {
          names = names.filter((s) => !invalids.includes(s));
        }
        let n;
        if (menuAction) {
          nvim.call("coc#prompt#stop_prompt", ["list"], true);
          n = await window_default.showMenuPicker(names, { title: "Choose action", shortcuts: true });
          n = n + 1;
          if (workspace_default.isVim)
            await wait(10);
          this.prompt.start();
        } else {
          await nvim.call("coc#prompt#stop_prompt", ["list"]);
          n = await nvim.call("confirm", ["Choose action:", choices.join("\n")]);
          await wait(10);
          this.prompt.start();
        }
        if (n)
          await this.doAction(names[n - 1]);
      }
      async doAction(name2) {
        let { list: list2 } = this;
        let action;
        if (name2 != null) {
          action = list2.actions.find((o) => o.name == name2);
          if (!action) {
            void window_default.showErrorMessage(`Action ${name2} not found`);
            return;
          }
        } else {
          action = this.defaultAction;
        }
        let items;
        if (name2 == "preview") {
          let item = await this.ui.item;
          items = item ? [item] : [];
        } else {
          items = await this.ui.getItems();
        }
        if (items.length)
          await this.doItemAction(items, action);
      }
      async doPreview(index) {
        let item = this.ui.getItem(index);
        let action = this.list.actions.find((o) => o.name == "preview");
        if (!item || !action)
          return;
        await this.doItemAction([item], action);
      }
      async first() {
        await this.doDefaultAction(0);
      }
      async last() {
        await this.doDefaultAction(this.ui.length - 1);
      }
      async previous() {
        await this.doDefaultAction(this.ui.index - 1);
      }
      async next() {
        await this.doDefaultAction(this.ui.index + 1);
      }
      async doDefaultAction(index) {
        let { ui } = this;
        let item = ui.getItem(index);
        if (!item)
          return;
        ui.index = index;
        await this.doItemAction([item], this.defaultAction);
        await ui.echoMessage(item);
      }
      get name() {
        return this.list.name;
      }
      get winid() {
        return this.ui.winid;
      }
      get length() {
        return this.ui.length;
      }
      get defaultAction() {
        let { defaultAction, actions, name: name2 } = this.list;
        let config = workspace_default.getConfiguration(`list.source.${name2}`);
        let action;
        if (config.defaultAction)
          action = actions.find((o) => o.name == config.defaultAction);
        if (!action)
          action = actions.find((o) => o.name == defaultAction);
        if (!action)
          action = actions[0];
        if (!action)
          throw new Error(`default action "${defaultAction}" not found`);
        return action;
      }
      async hide(notify = false) {
        if (this.hidden)
          return;
        let { nvim, timer, window: window2 } = this;
        let { winid, tabnr } = this.ui;
        if (timer)
          clearTimeout(timer);
        this.worker.stop();
        this.history.add();
        this.ui.reset();
        this.hidden = true;
        let { isVim: isVim6 } = workspace_default;
        nvim.pauseNotification();
        if (!isVim6)
          nvim.call("coc#prompt#stop_prompt", ["list"], true);
        if (tabnr)
          nvim.call("coc#list#close_preview", [tabnr], true);
        if (window2)
          nvim.call("win_gotoid", [window2.id], true);
        if (winid)
          nvim.call("coc#window#close", [winid], true);
        if (window2 && this.savedHeight && this.listOptions.position !== "tab") {
          nvim.call("coc#window#set_height", [window2.id, this.savedHeight], true);
        }
        if (notify)
          return nvim.resumeNotification(false, true);
        await nvim.resumeNotification(false);
        if (isVim6) {
          await wait(10);
          nvim.call("feedkeys", ["\x1B", "int"], true);
          nvim.command("redraw", true);
        }
      }
      toggleMode() {
        let mode = this.prompt.mode == "normal" ? "insert" : "normal";
        this.prompt.mode = mode;
        this.listOptions.mode = mode;
        this.updateStatus();
      }
      stop() {
        this.worker.stop();
      }
      async resolveItem() {
        let index = this.ui.index;
        let item = this.ui.getItem(index);
        if (!item || item.resolved)
          return;
        let { list: list2 } = this;
        if (typeof list2.resolveItem == "function") {
          let label = item.label;
          let resolved = await Promise.resolve(list2.resolveItem(item));
          if (resolved && index == this.ui.index) {
            let highlights = getItemHighlights(this.prompt.input, resolved);
            this.ui.updateItem(Object.assign({ highlights }, resolved), index, label != resolved.label);
          }
        }
      }
      async showHelp() {
        await this.hide();
        let { list: list2, nvim } = this;
        if (!list2)
          return;
        nvim.pauseNotification();
        nvim.command(`tabe +setl\\ previewwindow [LIST HELP]`, true);
        nvim.command("setl nobuflisted noswapfile buftype=nofile bufhidden=wipe", true);
        await nvim.resumeNotification();
        let hasOptions = list2.options && list2.options.length;
        let buf = await nvim.buffer;
        let highligher = new Highlighter();
        highligher.addLine("NAME", "Label");
        highligher.addLine(`  ${list2.name} - ${list2.description || ""}
`);
        highligher.addLine("SYNOPSIS", "Label");
        highligher.addLine(`  :CocList [LIST OPTIONS] ${list2.name}${hasOptions ? " [ARGUMENTS]" : ""}
`);
        if (list2.detail) {
          highligher.addLine("DESCRIPTION", "Label");
          let lines = list2.detail.split("\n").map((s) => "  " + s);
          highligher.addLine(lines.join("\n") + "\n");
        }
        if (hasOptions) {
          highligher.addLine("ARGUMENTS", "Label");
          highligher.addLine("");
          for (let opt of list2.options) {
            highligher.addLine(opt.name, "Special");
            highligher.addLine(`  ${opt.description}`);
            highligher.addLine("");
          }
          highligher.addLine("");
        }
        let config = workspace_default.getConfiguration(`list.source.${list2.name}`);
        if (Object.keys(config).length) {
          highligher.addLine("CONFIGURATIONS", "Label");
          highligher.addLine("");
          let props = {};
          extensions_default.all.forEach((extension) => {
            let { packageJSON } = extension;
            let { contributes } = packageJSON;
            if (!contributes)
              return;
            let { configuration } = contributes;
            if (configuration) {
              let { properties } = configuration;
              if (properties) {
                for (let key of Object.keys(properties)) {
                  props[key] = properties[key];
                }
              }
            }
          });
          for (let key of Object.keys(config)) {
            let val = config[key];
            let name2 = `list.source.${list2.name}.${key}`;
            let description = props[name2] && props[name2].description ? props[name2].description : key;
            highligher.addLine(`  "${name2}"`, "MoreMsg");
            highligher.addText(` - ${description}, current value: `);
            highligher.addText(JSON.stringify(val), "Special");
          }
          highligher.addLine("");
        }
        highligher.addLine("ACTIONS", "Label");
        highligher.addLine(`  ${list2.actions.map((o) => o.name).join(", ")}`);
        highligher.addLine("");
        highligher.addLine(`see ':h coc-list-options' for available list options.`, "Comment");
        nvim.pauseNotification();
        highligher.render(buf, 0, -1);
        nvim.command("setl nomod", true);
        nvim.command("setl nomodifiable", true);
        nvim.command("normal! gg", true);
        nvim.command("nnoremap <buffer> q :bd!<CR>", true);
        await nvim.resumeNotification();
      }
      async switchMatcher() {
        let { matcher, interactive } = this.listOptions;
        if (interactive)
          return;
        const list2 = ["fuzzy", "strict", "regex"];
        let idx = list2.indexOf(matcher) + 1;
        if (idx >= list2.length)
          idx = 0;
        this.listOptions.matcher = list2[idx];
        this.prompt.matcher = list2[idx];
        await this.worker.drawItems();
      }
      updateStatus() {
        let { ui, list: list2, nvim } = this;
        if (!ui.bufnr)
          return;
        let buf = nvim.createBuffer(ui.bufnr);
        let status = {
          mode: this.prompt.mode.toUpperCase(),
          args: this.args.join(" "),
          name: list2.name,
          cwd: this.cwd,
          loading: this.loadingFrame,
          total: this.worker.length
        };
        buf.setVar("list_status", status, true);
        nvim.command("redraws", true);
      }
      get context() {
        let { winid } = this.ui;
        return {
          options: this.listOptions,
          args: this.listArgs,
          input: this.prompt.input,
          cwd: workspace_default.cwd,
          window: this.window,
          buffer: this.buffer,
          listWindow: winid ? this.nvim.createWindow(winid) : void 0
        };
      }
      onMouseEvent(key) {
        switch (key) {
          case "<LeftMouse>":
            return this.ui.onMouse("mouseDown");
          case "<LeftDrag>":
            return this.ui.onMouse("mouseDrag");
          case "<LeftRelease>":
            return this.ui.onMouse("mouseUp");
          case "<2-LeftMouse>":
            return this.ui.onMouse("doubleClick");
        }
      }
      async doNumberSelect(ch) {
        if (!this.listOptions.numberSelect)
          return false;
        let code = ch.charCodeAt(0);
        if (code >= 48 && code <= 57) {
          let n = Number(ch);
          if (n == 0)
            n = 10;
          if (this.ui.length >= n) {
            this.nvim.pauseNotification();
            this.ui.setCursor(n);
            await this.nvim.resumeNotification();
            await this.doAction();
            return true;
          }
        }
        return false;
      }
      jumpBack() {
        let { window: window2, nvim } = this;
        if (window2) {
          nvim.pauseNotification();
          nvim.call("coc#prompt#stop_prompt", ["list"], true);
          this.nvim.call("win_gotoid", [window2.id], true);
          nvim.resumeNotification(false, true);
        }
      }
      async resume() {
        if (this.winid)
          await this.hide();
        let res = await this.nvim.eval('[win_getid(),bufnr("%"),winheight("%")]');
        this.hidden = false;
        this.window = this.nvim.createWindow(res[0]);
        this.buffer = this.nvim.createBuffer(res[1]);
        this.savedHeight = res[2];
        this.prompt.start();
        await this.ui.resume();
        if (this.listOptions.autoPreview) {
          await this.doAction("preview");
        }
      }
      async doItemAction(items, action) {
        let { noQuit, position } = this.listOptions;
        let { nvim } = this;
        let persistAction = action.persist === true || action.name == "preview";
        if (position === "tab" && action.tabPersist)
          persistAction = true;
        let persist = this.winid && (persistAction || noQuit);
        try {
          if (persist) {
            if (!persistAction) {
              nvim.pauseNotification();
              nvim.call("coc#prompt#stop_prompt", ["list"], true);
              nvim.call("win_gotoid", [this.context.window.id], true);
              await nvim.resumeNotification();
            }
          } else {
            await this.hide();
          }
          if (action.multiple) {
            await Promise.resolve(action.execute(items, this.context));
          } else if (action.parallel) {
            await Promise.all(items.map((item) => Promise.resolve(action.execute(item, this.context))));
          } else {
            for (let item of items) {
              await Promise.resolve(action.execute(item, this.context));
            }
          }
          if (persist)
            this.ui.restoreWindow();
          if (action.reload && persist) {
            await this.reloadItems();
          } else if (persist) {
            this.nvim.command("redraw", true);
          }
        } catch (e) {
          logger70.error(`Error on action ${action.name}`, e);
          this.nvim.echoError(e);
        }
      }
      onInputChange() {
        if (this.timer)
          clearTimeout(this.timer);
        this.listOptions.input = this.prompt.input;
        if (this.listOptions.interactive) {
          this.worker.stop();
          this.timer = setTimeout(async () => {
            await this.worker.loadItems(this.context);
          }, this.interactiveDebounceTime);
        } else {
          void this.worker.drawItems();
        }
      }
      dispose() {
        void this.hide(true);
        disposeAll(this.disposables);
        this.worker.dispose();
        this.ui.dispose();
      }
    };
  }
});

// src/list/commandTask.ts
var import_child_process5, import_events28, import_readline3, logger71, CommandTask;
var init_commandTask = __esm({
  "src/list/commandTask.ts"() {
    "use strict";
    import_child_process5 = require("child_process");
    import_events28 = require("events");
    import_readline3 = __toESM(require("readline"));
    init_util();
    init_workspace();
    logger71 = require_logger2()("list-commandTask");
    CommandTask = class extends import_events28.EventEmitter {
      constructor(opt) {
        super();
        this.opt = opt;
        this.disposables = [];
        this.start();
      }
      start() {
        let { cmd, args, cwd, onLine } = this.opt;
        let proc = (0, import_child_process5.spawn)(cmd, args, { cwd: cwd || workspace_default.cwd, windowsHide: true });
        this.disposables.push({
          dispose: () => {
            proc.kill();
          }
        });
        proc.on("error", (e) => {
          this.emit("error", e.message);
        });
        proc.stderr.on("data", (chunk) => {
          logger71.error(`[${cmd} Error]`, chunk.toString("utf8"));
        });
        const rl = import_readline3.default.createInterface(proc.stdout);
        rl.on("line", (line) => {
          let res = onLine(line);
          if (res)
            this.emit("data", res);
        });
        rl.on("close", () => {
          this.emit("end");
        });
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
  }
});

// src/list/basic.ts
function toVimFiletype(filetype) {
  switch (filetype) {
    case "latex":
      return "tex";
    default:
      return filetype;
  }
}
var import_fs25, import_path24, import_readline4, import_vscode_languageserver_protocol79, logger72, BasicList;
var init_basic = __esm({
  "src/list/basic.ts"() {
    "use strict";
    import_fs25 = __toESM(require("fs"));
    import_path24 = __toESM(require("path"));
    import_readline4 = __toESM(require("readline"));
    import_vscode_languageserver_protocol79 = __toESM(require_main2());
    init_esm();
    init_util();
    init_fs();
    init_position();
    init_workspace();
    init_commandTask();
    init_configuration4();
    logger72 = require_logger2()("list-basic");
    BasicList = class {
      constructor(nvim) {
        this.nvim = nvim;
        this.defaultAction = "open";
        this.actions = [];
        this.options = [];
        this.disposables = [];
        this.config = new ListConfiguration();
      }
      get alignColumns() {
        return this.config.get("alignColumns", false);
      }
      get hlGroup() {
        return this.config.get("previewHighlightGroup", "Search");
      }
      get previewHeight() {
        return this.config.get("maxPreviewHeight", 12);
      }
      get splitRight() {
        return this.config.get("previewSplitRight", false);
      }
      get toplineStyle() {
        return this.config.get("previewToplineStyle", "offset");
      }
      get toplineOffset() {
        return this.config.get("previewToplineOffset", 3);
      }
      parseArguments(args) {
        if (!this.optionMap) {
          this.optionMap = /* @__PURE__ */ new Map();
          for (let opt of this.options) {
            let parts = opt.name.split(/,\s*/g).map((s) => s.replace(/\s+.*/g, ""));
            let name2 = opt.key ? opt.key : parts[parts.length - 1].replace(/^-/, "");
            for (let p of parts) {
              this.optionMap.set(p, { name: name2, hasValue: opt.hasValue });
            }
          }
        }
        let res = {};
        for (let i = 0; i < args.length; i++) {
          let arg = args[i];
          let def = this.optionMap.get(arg);
          if (!def)
            continue;
          let value = true;
          if (def.hasValue) {
            value = args[i + 1] || "";
            i = i + 1;
          }
          res[def.name] = value;
        }
        return res;
      }
      getConfig() {
        return workspace_default.getConfiguration(`list.source.${this.name}`);
      }
      addAction(name2, fn, options2) {
        this.createAction(Object.assign({
          name: name2,
          execute: fn
        }, options2 || {}));
      }
      addMultipleAction(name2, fn, options2) {
        this.createAction(Object.assign({
          name: name2,
          multiple: true,
          execute: fn
        }, options2 || {}));
      }
      createCommandTask(opt) {
        return new CommandTask(opt);
      }
      addLocationActions() {
        this.createAction({
          name: "preview",
          execute: async (item, context) => {
            let loc = await this.convertLocation(item.location);
            await this.previewLocation(loc, context);
          }
        });
        let { nvim } = this;
        this.createAction({
          name: "quickfix",
          multiple: true,
          execute: async (items) => {
            let quickfixItems = await Promise.all(items.map((item) => this.convertLocation(item.location).then((loc) => workspace_default.getQuickfixItem(loc))));
            await nvim.call("setqflist", [quickfixItems]);
            let openCommand = await nvim.getVar("coc_quickfix_open_command");
            nvim.command(typeof openCommand === "string" ? openCommand : "copen", true);
          }
        });
        for (let name2 of ["open", "tabe", "drop", "vsplit", "split"]) {
          this.createAction({
            name: name2,
            execute: async (item, context) => {
              await this.jumpTo(item.location, name2 == "open" ? null : name2, context);
            },
            tabPersist: name2 === "open"
          });
        }
      }
      async convertLocation(location) {
        if (typeof location == "string")
          return import_vscode_languageserver_protocol79.Location.create(location, import_vscode_languageserver_protocol79.Range.create(0, 0, 0, 0));
        if (import_vscode_languageserver_protocol79.Location.is(location))
          return location;
        let u = URI2.parse(location.uri);
        if (u.scheme != "file")
          return import_vscode_languageserver_protocol79.Location.create(location.uri, import_vscode_languageserver_protocol79.Range.create(0, 0, 0, 0));
        const rl = import_readline4.default.createInterface({
          input: import_fs25.default.createReadStream(u.fsPath, { encoding: "utf8" })
        });
        let match = location.line;
        let n = 0;
        let resolved = false;
        let line = await new Promise((resolve3) => {
          rl.on("line", (line2) => {
            if (resolved)
              return;
            if (line2.includes(match)) {
              rl.removeAllListeners();
              rl.close();
              resolved = true;
              resolve3(line2);
              return;
            }
            n = n + 1;
          });
          rl.on("error", (e) => {
            this.nvim.errWriteLine(`Read ${u.fsPath} error: ${e.message}`);
            resolve3(null);
          });
        });
        if (line != null) {
          let character = location.text ? line.indexOf(location.text) : 0;
          if (character == 0)
            character = line.match(/^\s*/)[0].length;
          let end = import_vscode_languageserver_protocol79.Position.create(n, character + (location.text ? location.text.length : 0));
          return import_vscode_languageserver_protocol79.Location.create(location.uri, import_vscode_languageserver_protocol79.Range.create(import_vscode_languageserver_protocol79.Position.create(n, character), end));
        }
        return import_vscode_languageserver_protocol79.Location.create(location.uri, import_vscode_languageserver_protocol79.Range.create(0, 0, 0, 0));
      }
      async jumpTo(location, command, context) {
        if (command == null && context && context.options.position === "tab") {
          command = "tabe";
        }
        if (typeof location == "string") {
          await workspace_default.jumpTo(location, null, command);
          return;
        }
        let { range: range2, uri } = await this.convertLocation(location);
        let position = range2.start;
        if (position.line == 0 && position.character == 0 && comparePosition(position, range2.end) == 0) {
          position = null;
        }
        await workspace_default.jumpTo(uri, position, command);
      }
      createAction(action) {
        let { name: name2 } = action;
        let idx = this.actions.findIndex((o) => o.name == name2);
        if (idx !== -1)
          this.actions.splice(idx, 1);
        this.actions.push(action);
      }
      async previewLocation(location, context) {
        if (!context.listWindow)
          return;
        let { nvim } = this;
        let { uri, range: range2 } = location;
        let doc = workspace_default.getDocument(location.uri);
        let u = URI2.parse(uri);
        let lines = [];
        if (doc) {
          lines = doc.getLines();
        } else if (u.scheme == "file") {
          try {
            let content = await readFile(u.fsPath, "utf8");
            lines = content.split(/\r?\n/);
          } catch (e) {
            [`Error on read file ${u.fsPath}`, e.toString()];
          }
        }
        let config = {
          winid: context.window.id,
          range: emptyRange(range2) ? null : range2,
          lnum: range2.start.line + 1,
          name: u.scheme == "file" ? u.fsPath : uri,
          filetype: toVimFiletype(doc ? doc.languageId : this.getLanguageId(u.fsPath)),
          position: context.options.position,
          maxHeight: this.previewHeight,
          splitRight: this.splitRight,
          hlGroup: this.hlGroup,
          scheme: u.scheme,
          toplineStyle: this.toplineStyle,
          toplineOffset: this.toplineOffset
        };
        await nvim.call("coc#list#preview", [lines, config]);
      }
      async preview(options2, context) {
        let { nvim } = this;
        let { bufname, filetype, range: range2, lines, lnum } = options2;
        let config = {
          winid: context.window.id,
          lnum: range2 ? range2.start.line + 1 : lnum || 1,
          filetype: filetype || "txt",
          position: context.options.position,
          maxHeight: this.previewHeight,
          splitRight: this.splitRight,
          hlGroup: this.hlGroup,
          toplineStyle: this.toplineStyle,
          toplineOffset: this.toplineOffset
        };
        if (bufname)
          config.name = bufname;
        if (range2)
          config.range = range2;
        await nvim.call("coc#list#preview", [lines, config]);
        nvim.command("redraw", true);
      }
      doHighlight() {
      }
      dispose() {
        disposeAll(this.disposables);
      }
      getLanguageId(filepath) {
        let extname = import_path24.default.extname(filepath);
        if (!extname)
          return "";
        for (let doc of workspace_default.documents) {
          let fsPath2 = URI2.parse(doc.uri).fsPath;
          if (import_path24.default.extname(fsPath2) == extname) {
            return doc.languageId;
          }
        }
        return "";
      }
    };
  }
});

// src/list/formatting.ts
function formatListItems(align, list2) {
  if (list2.length === 0) {
    return [];
  }
  let processedList = [];
  if (align) {
    const maxWidths = Array(Math.min(...list2.map((item) => item.label.length))).fill(0);
    for (let item of list2) {
      for (let i = 0; i < maxWidths.length; i++) {
        maxWidths[i] = Math.max(maxWidths[i], item.label[i].length);
      }
    }
    processedList = list2.map((item) => __spreadProps(__spreadValues({}, item), {
      label: item.label.map((element, idx) => element.padEnd(maxWidths[idx])).join("	")
    }));
  } else {
    processedList = list2.map((item) => __spreadProps(__spreadValues({}, item), { label: item.label.join("	") }));
  }
  return processedList;
}
function formatPath(format2, pathToFormat) {
  if (format2 === "hidden") {
    return "";
  } else if (format2 === "full") {
    return pathToFormat;
  } else if (format2 === "short") {
    const segments = pathToFormat.split(import_path25.default.sep);
    if (segments.length < 2) {
      return pathToFormat;
    }
    const shortenedInit = segments.slice(0, segments.length - 2).filter((seg) => seg.length > 0).map((seg) => seg[0]);
    return [...shortenedInit, segments[segments.length - 1]].join(import_path25.default.sep);
  } else {
    const segments = pathToFormat.split(import_path25.default.sep);
    return segments[segments.length - 1] ?? "";
  }
}
var import_path25;
var init_formatting2 = __esm({
  "src/list/formatting.ts"() {
    "use strict";
    import_path25 = __toESM(require("path"));
  }
});

// src/list/source/commands.ts
function score3(list2, key) {
  let idx = list2.indexOf(key);
  return idx == -1 ? -1 : list2.length - idx;
}
var CommandsList;
var init_commands = __esm({
  "src/list/source/commands.ts"() {
    "use strict";
    init_commands2();
    init_workspace();
    init_basic();
    init_formatting2();
    CommandsList = class extends BasicList {
      constructor(nvim) {
        super(nvim);
        this.defaultAction = "run";
        this.description = "registered commands of coc.nvim";
        this.name = "commands";
        this.mru = workspace_default.createMru("commands");
        this.addAction("run", async (item) => {
          await commands_default.fireCommand(item.data.cmd);
        });
        this.addAction("append", async (item) => {
          let { cmd } = item.data;
          await nvim.feedKeys(`:CocCommand ${cmd} `, "n", false);
        });
      }
      async loadItems(_context) {
        let items = [];
        let mruList = await this.mru.load();
        let { commandList, onCommandList, titles } = commands_default;
        let ids = commandList.map((c) => c.id).concat(onCommandList);
        for (const id of [...new Set(ids)]) {
          items.push({
            label: [id, ...titles.get(id) ? [titles.get(id)] : []],
            filterText: id,
            data: { cmd: id, score: score3(mruList, id) }
          });
        }
        items.sort((a, b) => b.data.score - a.data.score);
        return formatListItems(this.alignColumns, items);
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocCommandsTitle /\\t.*$/ contained containedin=CocCommandsLine", true);
        nvim.command("highlight default link CocCommandsTitle Comment", true);
        nvim.resumeNotification(false, true);
      }
    };
  }
});

// src/list/source/location.ts
function createItem(filename, loc) {
  let label = "";
  const ansiHighlights = [];
  let start = 0;
  if (filename.length > 0) {
    label = filename + " ";
    ansiHighlights.push({ span: [start, start + byteLength(filename)], hlGroup: "Directory" });
  }
  start = byteLength(label);
  let lnum = loc.lnum ?? loc.range.start.line + 1;
  let col = loc.col ?? byteLength(loc.text.slice(0, loc.range.start.character)) + 1;
  let position = `|${loc.type ? loc.type + " " : ""}${lnum} Col ${col}|`;
  label += position;
  ansiHighlights.push({ span: [start, start + byteLength(position)], hlGroup: "LineNr" });
  if (loc.type) {
    let hl = loc.type.toLowerCase() === "error" ? "Error" : "WarningMsg";
    ansiHighlights.push({ span: [start + 1, start + byteLength(loc.type)], hlGroup: hl });
  }
  if (loc.range && loc.range.start.line == loc.range.end.line) {
    let len = byteLength(label) + 1;
    let start2 = len + byteLength(loc.text.slice(0, loc.range.start.character));
    let end = len + byteLength(loc.text.slice(0, loc.range.end.character));
    ansiHighlights.push({ span: [start2, end], hlGroup: "Search" });
  }
  label += " " + loc.text;
  let filterText = `${filename}${loc.text.trim()}`;
  let location;
  if (loc.range) {
    location = Location.create(loc.uri, loc.range);
  } else {
    let pos = Position.create(loc.lnum - 1, loc.col - 1);
    location = Location.create(loc.uri, Range.create(pos, pos));
  }
  return {
    label,
    location,
    filterText,
    ansiHighlights
  };
}
var import_path26, logger73, LocationList;
var init_location = __esm({
  "src/list/source/location.ts"() {
    "use strict";
    import_path26 = __toESM(require("path"));
    init_main();
    init_esm();
    init_commands2();
    init_fs();
    init_string();
    init_workspace();
    init_basic();
    logger73 = require_logger2()("list-location");
    LocationList = class extends BasicList {
      constructor(nvim) {
        super(nvim);
        this.defaultAction = "open";
        this.description = "show locations saved by g:coc_jump_locations variable";
        this.name = "location";
        this.createAction({
          name: "refactor",
          multiple: true,
          execute: async (items) => {
            let locations = items.map((o) => o.location);
            await commands_default.executeCommand("workspace.refactor", locations);
          }
        });
        this.addLocationActions();
      }
      async loadItems(context, token) {
        let locs = await this.nvim.getVar("coc_jump_locations");
        if (token.isCancellationRequested)
          return [];
        locs = locs || [];
        locs.forEach((loc) => {
          if (!loc.uri) {
            let fullpath = import_path26.default.isAbsolute(loc.filename) ? loc.filename : import_path26.default.join(context.cwd, loc.filename);
            loc.uri = URI2.file(fullpath).toString();
          }
          if (!loc.bufnr && workspace_default.getDocument(loc.uri) != null) {
            loc.bufnr = workspace_default.getDocument(loc.uri).bufnr;
          }
        });
        let bufnr = context.buffer.id;
        let ignoreFilepath = locs.every((o) => o.bufnr && bufnr && o.bufnr == bufnr);
        let items = locs.map((loc) => {
          let filename = ignoreFilepath ? "" : loc.filename;
          if (filename.length > 0 && import_path26.default.isAbsolute(filename)) {
            filename = isParentFolder(context.cwd, filename) ? import_path26.default.relative(context.cwd, filename) : filename;
          }
          return createItem(filename, loc);
        });
        return items;
      }
    };
  }
});

// src/list/source/diagnostics.ts
var import_path27, logger74, DiagnosticsList;
var init_diagnostics = __esm({
  "src/list/source/diagnostics.ts"() {
    "use strict";
    import_path27 = __toESM(require("path"));
    init_manager4();
    init_fs();
    init_formatting2();
    init_location();
    logger74 = require_logger2()("list-symbols");
    DiagnosticsList = class extends LocationList {
      constructor(nvim, manager) {
        super(nvim);
        this.defaultAction = "open";
        this.description = "diagnostics of current workspace";
        this.name = "diagnostics";
        manager_default.onDidRefresh(async () => {
          let session = manager.getSession("diagnostics");
          if (session)
            await session.reloadItems();
        }, null, this.disposables);
      }
      async loadItems(context) {
        let list2 = await manager_default.getDiagnosticList();
        let { cwd } = context;
        const config = this.getConfig();
        const shouldIncludeCode = config.get("includeCode", true);
        const pathFormat = config.get("pathFormat", "full");
        const unformatted = list2.map((item) => {
          const file = isParentFolder(cwd, item.file) ? import_path27.default.relative(cwd, item.file) : item.file;
          const formattedPath = formatPath(pathFormat, file);
          const formattedPosition = pathFormat !== "hidden" ? [`${formattedPath}:${item.lnum}`] : [];
          const code = shouldIncludeCode ? [`[${item.source}${item.code ? "" : "]"}`, item.code ? `${item.code}]` : ""] : [];
          return {
            label: [...formattedPosition, ...code, item.severity, item.message],
            location: item.location
          };
        });
        return formatListItems(this.alignColumns, unformatted);
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocDiagnosticsFile /\\v^\\s*\\S+/ contained containedin=CocDiagnosticsLine", true);
        nvim.command("syntax match CocDiagnosticsError /\\tError\\s*\\t/ contained containedin=CocDiagnosticsLine", true);
        nvim.command("syntax match CocDiagnosticsWarning /\\tWarning\\s*\\t/ contained containedin=CocDiagnosticsLine", true);
        nvim.command("syntax match CocDiagnosticsInfo /\\tInformation\\s*\\t/ contained containedin=CocDiagnosticsLine", true);
        nvim.command("syntax match CocDiagnosticsHint /\\tHint\\s*\\t/ contained containedin=CocDiagnosticsLine", true);
        nvim.command("highlight default link CocDiagnosticsFile Comment", true);
        nvim.command("highlight default link CocDiagnosticsError CocErrorSign", true);
        nvim.command("highlight default link CocDiagnosticsWarning CocWarningSign", true);
        nvim.command("highlight default link CocDiagnosticsInfo CocInfoSign", true);
        nvim.command("highlight default link CocDiagnosticsHint CocHintSign", true);
        nvim.resumeNotification(false, true);
      }
    };
  }
});

// src/list/source/extensions.ts
function getPriority(stat) {
  switch (stat) {
    case "unknown":
      return 2;
    case "activated":
      return 1;
    case "disabled":
      return -1;
    default:
      return 0;
  }
}
var import_fs_extra9, import_os12, import_path28, logger75, ExtensionList;
var init_extensions2 = __esm({
  "src/list/source/extensions.ts"() {
    "use strict";
    import_fs_extra9 = __toESM(require_lib4());
    import_os12 = __toESM(require("os"));
    import_path28 = __toESM(require("path"));
    init_esm();
    init_extensions3();
    init_util();
    init_workspace();
    init_window();
    init_basic();
    init_formatting2();
    logger75 = require_logger2()("list-extensions");
    ExtensionList = class extends BasicList {
      constructor(nvim) {
        super(nvim);
        this.defaultAction = "toggle";
        this.description = "manage coc extensions";
        this.name = "extensions";
        this.addAction("toggle", async (item) => {
          let { id, state } = item.data;
          if (state == "disabled")
            return;
          if (state == "activated") {
            await extensions_default.deactivate(id);
          } else {
            await extensions_default.activate(id);
          }
          await wait(100);
        }, { persist: true, reload: true, parallel: true });
        this.addAction("configuration", async (item) => {
          let { root } = item.data;
          let jsonFile = import_path28.default.join(root, "package.json");
          if (import_fs_extra9.default.existsSync(jsonFile)) {
            let lines = import_fs_extra9.default.readFileSync(jsonFile, "utf8").split(/\r?\n/);
            let idx = lines.findIndex((s) => s.includes('"contributes"'));
            await workspace_default.jumpTo(URI2.file(jsonFile).toString(), { line: idx == -1 ? 0 : idx, character: 0 });
          }
        });
        this.addAction("open", async (item) => {
          let { root } = item.data;
          if (workspace_default.env.isiTerm) {
            nvim.call("coc#ui#iterm_open", [root], true);
          } else {
            nvim.call("coc#ui#open_url", [root], true);
          }
        });
        this.addAction("disable", async (item) => {
          let { id, state } = item.data;
          if (state !== "disabled")
            await extensions_default.toggleExtension(id);
        }, { persist: true, reload: true, parallel: true });
        this.addAction("enable", async (item) => {
          let { id, state } = item.data;
          if (state == "disabled")
            await extensions_default.toggleExtension(id);
        }, { persist: true, reload: true, parallel: true });
        this.addAction("lock", async (item) => {
          let { id } = item.data;
          await extensions_default.lockExtension(id);
        }, { persist: true, reload: true });
        this.addAction("help", async (item) => {
          let { root } = item.data;
          let files = await import_fs_extra9.default.readdir(root);
          let file = files.find((f) => /^readme/i.test(f));
          if (file)
            await workspace_default.callAsync("coc#util#jump", ["edit", import_path28.default.join(root, file)]);
        });
        this.addAction("reload", async (item) => {
          let { id } = item.data;
          await extensions_default.reloadExtension(id);
        }, { persist: true, reload: true });
        this.addAction("fix", async (item) => {
          let { root, isLocal } = item.data;
          let { npm } = extensions_default;
          if (isLocal) {
            window_default.showMessage(`Can't fix for local extension.`, "warning");
            return;
          }
          if (!npm)
            return;
          let folder = import_path28.default.join(root, "node_modules");
          if (import_fs_extra9.default.existsSync(folder)) {
            import_fs_extra9.default.removeSync(folder);
          }
          let terminal = await window_default.createTerminal({
            cwd: root
          });
          let shown = await terminal.show(false);
          if (!shown)
            return;
          workspace_default.nvim.command(`startinsert`, true);
          terminal.sendText(`${npm} install --production --ignore-scripts --no-lockfile`, true);
        });
        this.addMultipleAction("uninstall", async (items) => {
          let ids = [];
          for (let item of items) {
            if (item.data.isLocal)
              continue;
            ids.push(item.data.id);
          }
          extensions_default.uninstallExtension(ids).catch((e) => {
            logger75.error(e);
          });
        });
      }
      async loadItems(_context) {
        let items = [];
        let list2 = await extensions_default.getExtensionStates();
        let lockedList = await extensions_default.getLockedList();
        for (let stat of list2) {
          let prefix = "+";
          if (stat.state == "disabled") {
            prefix = "-";
          } else if (stat.state == "activated") {
            prefix = "*";
          } else if (stat.state == "unknown") {
            prefix = "?";
          }
          let root = await this.nvim.call("resolve", stat.root);
          let locked = lockedList.includes(stat.id);
          items.push({
            label: [`${prefix} ${stat.id}${locked ? " \uE0A2" : ""}`, ...stat.isLocal ? ["[RTP]"] : [], stat.version, root.replace(import_os12.default.homedir(), "~")],
            filterText: stat.id,
            data: {
              id: stat.id,
              root,
              state: stat.state,
              isLocal: stat.isLocal,
              priority: getPriority(stat.state)
            }
          });
        }
        items.sort((a, b) => {
          if (a.data.priority != b.data.priority) {
            return b.data.priority - a.data.priority;
          }
          return b.data.id - a.data.id ? 1 : -1;
        });
        return formatListItems(this.alignColumns, items);
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocExtensionsActivited /\\v^\\*/ contained containedin=CocExtensionsLine", true);
        nvim.command("syntax match CocExtensionsLoaded /\\v^\\+/ contained containedin=CocExtensionsLine", true);
        nvim.command("syntax match CocExtensionsDisabled /\\v^-/ contained containedin=CocExtensionsLine", true);
        nvim.command("syntax match CocExtensionsName /\\v%3c\\S+/ contained containedin=CocExtensionsLine", true);
        nvim.command("syntax match CocExtensionsRoot /\\v\\t[^\\t]*$/ contained containedin=CocExtensionsLine", true);
        nvim.command("syntax match CocExtensionsLocal /\\v\\[RTP\\]/ contained containedin=CocExtensionsLine", true);
        nvim.command("highlight default link CocExtensionsActivited Special", true);
        nvim.command("highlight default link CocExtensionsLoaded Normal", true);
        nvim.command("highlight default link CocExtensionsDisabled Comment", true);
        nvim.command("highlight default link CocExtensionsName String", true);
        nvim.command("highlight default link CocExtensionsLocal MoreMsg", true);
        nvim.command("highlight default link CocExtensionsRoot Comment", true);
        nvim.resumeNotification(false, true);
      }
    };
  }
});

// src/list/source/folders.ts
var import_path29, import_fs_extra10, FoldList;
var init_folders = __esm({
  "src/list/source/folders.ts"() {
    "use strict";
    import_path29 = __toESM(require("path"));
    init_esm();
    import_fs_extra10 = __toESM(require_lib4());
    init_fs();
    init_workspace();
    init_window();
    init_basic();
    FoldList = class extends BasicList {
      constructor(nvim) {
        super(nvim);
        this.defaultAction = "edit";
        this.description = "list of current workspace folders";
        this.name = "folders";
        this.addAction("edit", async (item) => {
          let newPath = await nvim.call("input", ["Folder: ", item.label, "dir"]);
          let stat = await statAsync(newPath);
          if (!stat || !stat.isDirectory()) {
            window_default.showMessage(`invalid path: ${newPath}`, "error");
            return;
          }
          workspace_default.workspaceFolderControl.renameWorkspaceFolder(item.label, newPath);
        });
        this.addAction("delete", async (item) => {
          workspace_default.workspaceFolderControl.removeWorkspaceFolder(item.label);
        }, { reload: true, persist: true });
        this.addAction("newfile", async (item, context) => {
          let file = await window_default.requestInput("File name", item.label + "/");
          if (!file)
            return;
          let dir = import_path29.default.dirname(file);
          let stat = await statAsync(dir);
          if (!stat || !stat.isDirectory()) {
            import_fs_extra10.default.mkdirpSync(dir);
          }
          await workspace_default.createFile(file, { overwrite: false, ignoreIfExists: true });
          await this.jumpTo(URI2.file(file).toString(), null, context);
        });
      }
      async loadItems(_context) {
        return workspace_default.folderPaths.map((p) => ({ label: p }));
      }
    };
  }
});

// src/list/source/links.ts
function formatUri(uri) {
  if (!uri.startsWith("file:"))
    return uri;
  let filepath = URI2.parse(uri).fsPath;
  return isParentFolder(workspace_default.cwd, filepath) ? import_path30.default.relative(workspace_default.cwd, filepath) : filepath;
}
var import_path30, LinksList;
var init_links = __esm({
  "src/list/source/links.ts"() {
    "use strict";
    init_languages();
    init_workspace();
    import_path30 = __toESM(require("path"));
    init_basic();
    init_main();
    init_esm();
    init_fs();
    LinksList = class extends BasicList {
      constructor(nvim) {
        super(nvim);
        this.defaultAction = "open";
        this.description = "links of current buffer";
        this.name = "links";
        this.addAction("open", async (item) => {
          let { target } = item.data;
          let uri = URI2.parse(target);
          if (uri.scheme.startsWith("http")) {
            await nvim.call("coc#ui#open_url", target);
          } else {
            await workspace_default.jumpTo(target);
          }
        });
        this.addAction("jump", async (item) => {
          let { location } = item.data;
          await workspace_default.jumpTo(location.uri, location.range.start);
        });
      }
      async loadItems(context, token) {
        let buf = await context.window.buffer;
        let doc = workspace_default.getDocument(buf.id);
        if (!doc)
          return null;
        let items = [];
        let links2 = await languages_default.getDocumentLinks(doc.textDocument, token);
        if (token.isCancellationRequested)
          return null;
        if (links2 == null)
          throw new Error("Links provider not found.");
        let res = [];
        for (let link of links2) {
          if (link.target) {
            items.push({
              label: formatUri(link.target),
              data: {
                target: link.target,
                location: Location.create(doc.uri, link.range)
              }
            });
          } else {
            link = await languages_default.resolveDocumentLink(link, token);
            if (link.target) {
              items.push({
                label: formatUri(link.target),
                data: {
                  target: link.target,
                  location: Location.create(doc.uri, link.range)
                }
              });
            }
            res.push(link);
          }
        }
        return items;
      }
    };
  }
});

// src/list/source/lists.ts
function score4(list2, key) {
  let idx = list2.indexOf(key);
  return idx == -1 ? -1 : list2.length - idx;
}
var ListsList;
var init_lists = __esm({
  "src/list/source/lists.ts"() {
    "use strict";
    init_basic();
    init_mru();
    init_formatting2();
    ListsList = class extends BasicList {
      constructor(nvim, listMap) {
        super(nvim);
        this.listMap = listMap;
        this.name = "lists";
        this.defaultAction = "open";
        this.description = "registered lists of coc.nvim";
        this.mru = new Mru("lists");
        this.addAction("open", async (item) => {
          let { name: name2 } = item.data;
          await this.mru.add(name2);
          nvim.command(`CocList ${name2}`, true);
        });
      }
      async loadItems(_context) {
        let items = [];
        let mruList = await this.mru.load();
        for (let list2 of this.listMap.values()) {
          if (list2.name == "lists")
            continue;
          items.push({
            label: [list2.name, ...list2.description ? [list2.description] : []],
            data: {
              name: list2.name,
              interactive: list2.interactive,
              score: score4(mruList, list2.name)
            }
          });
        }
        items.sort((a, b) => b.data.score - a.data.score);
        return formatListItems(this.alignColumns, items);
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocListsDesc /\\t.*$/ contained containedin=CocListsLine", true);
        nvim.command("highlight default link CocListsDesc Comment", true);
        nvim.resumeNotification(false, true);
      }
    };
  }
});

// src/util/convert.ts
function getSymbolKind(kind) {
  switch (kind) {
    case import_vscode_languageserver_protocol80.SymbolKind.File:
      return "File";
    case import_vscode_languageserver_protocol80.SymbolKind.Module:
      return "Module";
    case import_vscode_languageserver_protocol80.SymbolKind.Namespace:
      return "Namespace";
    case import_vscode_languageserver_protocol80.SymbolKind.Package:
      return "Package";
    case import_vscode_languageserver_protocol80.SymbolKind.Class:
      return "Class";
    case import_vscode_languageserver_protocol80.SymbolKind.Method:
      return "Method";
    case import_vscode_languageserver_protocol80.SymbolKind.Property:
      return "Property";
    case import_vscode_languageserver_protocol80.SymbolKind.Field:
      return "Field";
    case import_vscode_languageserver_protocol80.SymbolKind.Constructor:
      return "Constructor";
    case import_vscode_languageserver_protocol80.SymbolKind.Enum:
      return "Enum";
    case import_vscode_languageserver_protocol80.SymbolKind.Interface:
      return "Interface";
    case import_vscode_languageserver_protocol80.SymbolKind.Function:
      return "Function";
    case import_vscode_languageserver_protocol80.SymbolKind.Variable:
      return "Variable";
    case import_vscode_languageserver_protocol80.SymbolKind.Constant:
      return "Constant";
    case import_vscode_languageserver_protocol80.SymbolKind.String:
      return "String";
    case import_vscode_languageserver_protocol80.SymbolKind.Number:
      return "Number";
    case import_vscode_languageserver_protocol80.SymbolKind.Boolean:
      return "Boolean";
    case import_vscode_languageserver_protocol80.SymbolKind.Array:
      return "Array";
    case import_vscode_languageserver_protocol80.SymbolKind.Object:
      return "Object";
    case import_vscode_languageserver_protocol80.SymbolKind.Key:
      return "Key";
    case import_vscode_languageserver_protocol80.SymbolKind.Null:
      return "Null";
    case import_vscode_languageserver_protocol80.SymbolKind.EnumMember:
      return "EnumMember";
    case import_vscode_languageserver_protocol80.SymbolKind.Struct:
      return "Struct";
    case import_vscode_languageserver_protocol80.SymbolKind.Event:
      return "Event";
    case import_vscode_languageserver_protocol80.SymbolKind.Operator:
      return "Operator";
    case import_vscode_languageserver_protocol80.SymbolKind.TypeParameter:
      return "TypeParameter";
    default:
      return "Unknown";
  }
}
var import_vscode_languageserver_protocol80;
var init_convert = __esm({
  "src/util/convert.ts"() {
    "use strict";
    import_vscode_languageserver_protocol80 = __toESM(require_main2());
  }
});

// src/list/source/outline.ts
function getFilterText(s, kind) {
  return `${s.name}${kind ? ` ${kind}` : ""}`;
}
function sortSymbols(a, b) {
  let ra = a.selectionRange;
  let rb = b.selectionRange;
  if (ra.start.line != rb.start.line) {
    return ra.start.line - rb.start.line;
  }
  return ra.start.character - rb.start.character;
}
var import_path31, import_which3, logger76, Outline;
var init_outline = __esm({
  "src/list/source/outline.ts"() {
    "use strict";
    import_path31 = __toESM(require("path"));
    init_main();
    init_esm();
    import_which3 = __toESM(require_which());
    init_languages();
    init_util();
    init_fs();
    init_workspace();
    init_location();
    init_convert();
    init_formatting2();
    logger76 = require_logger2()("list-symbols");
    Outline = class extends LocationList {
      constructor() {
        super(...arguments);
        this.description = "symbols of current document";
        this.name = "outline";
        this.options = [{
          name: "-k, -kind KIND",
          hasValue: true,
          description: "filter symbol by kind"
        }];
      }
      async loadItems(context, token) {
        let buf = await context.window.buffer;
        let document2 = workspace_default.getDocument(buf.id);
        if (!document2)
          return null;
        let config = this.getConfig();
        let ctagsFiletypes = config.get("ctagsFiletypes", []);
        let symbols;
        let args = this.parseArguments(context.args);
        if (!ctagsFiletypes.includes(document2.filetype)) {
          symbols = await languages_default.getDocumentSymbol(document2.textDocument, token);
        }
        if (token.isCancellationRequested)
          return [];
        if (!symbols)
          return await this.loadCtagsSymbols(document2);
        if (symbols.length == 0)
          return [];
        let filterKind = args.kind ? args.kind.toLowerCase() : null;
        let items = [];
        let isSymbols = !symbols[0].hasOwnProperty("location");
        if (isSymbols) {
          let addSymbols = function(symbols2, level = 0) {
            symbols2.sort(sortSymbols);
            for (let s of symbols2) {
              let kind = getSymbolKind(s.kind);
              let location = Location.create(document2.uri, s.selectionRange);
              items.push({
                label: [`${"| ".repeat(level)}${s.name}`, `[${kind}]`, `${s.range.start.line + 1}`],
                filterText: getFilterText(s, args.kind == "" ? kind : null),
                location,
                data: { kind }
              });
              if (s.children && s.children.length) {
                addSymbols(s.children, level + 1);
              }
            }
          };
          addSymbols(symbols);
          if (filterKind) {
            items = items.filter((o) => o.data.kind.toLowerCase().indexOf(filterKind) == 0);
          }
        } else {
          symbols.sort((a, b) => {
            let sa = a.location.range.start;
            let sb = b.location.range.start;
            let d = sa.line - sb.line;
            return d == 0 ? sa.character - sb.character : d;
          });
          for (let s of symbols) {
            let kind = getSymbolKind(s.kind);
            if (s.name.endsWith(") callback"))
              continue;
            if (filterKind && !kind.toLowerCase().startsWith(filterKind)) {
              continue;
            }
            if (s.location.uri === void 0) {
              s.location.uri = document2.uri;
            }
            items.push({
              label: [s.name, `[${kind}]`, `${s.location.range.start.line + 1}`],
              filterText: getFilterText(s, args.kind == "" ? kind : null),
              location: s.location
            });
          }
        }
        return formatListItems(this.alignColumns, items);
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocOutlineName /\\v\\s?[^\\t]+\\s/ contained containedin=CocOutlineLine", true);
        nvim.command("syntax match CocOutlineIndentLine /\\v\\|/ contained containedin=CocOutlineLine,CocOutlineName", true);
        nvim.command("syntax match CocOutlineKind /\\[\\w\\+\\]/ contained containedin=CocOutlineLine", true);
        nvim.command("syntax match CocOutlineLine /\\d\\+$/ contained containedin=CocOutlineLine", true);
        nvim.command("highlight default link CocOutlineName Normal", true);
        nvim.command("highlight default link CocOutlineIndentLine Comment", true);
        nvim.command("highlight default link CocOutlineKind Typedef", true);
        nvim.command("highlight default link CocOutlineLine Comment", true);
        nvim.resumeNotification(false, true);
      }
      async loadCtagsSymbols(document2) {
        if (!import_which3.default.sync("ctags", { nothrow: true })) {
          return [];
        }
        let uri = URI2.parse(document2.uri);
        let extname = import_path31.default.extname(uri.fsPath);
        let content = "";
        let tempname = await this.nvim.call("tempname");
        let filepath = `${tempname}.${extname}`;
        let escaped = await this.nvim.call("fnameescape", filepath);
        await writeFile(escaped, document2.getDocumentContent());
        try {
          content = await runCommand(`ctags -f - --excmd=number --language-force=${document2.filetype} ${escaped}`);
        } catch (e) {
        }
        if (!content.trim().length) {
          content = await runCommand(`ctags -f - --excmd=number ${escaped}`);
        }
        content = content.trim();
        if (!content)
          return [];
        let lines = content.split(/\r?\n/);
        let items = [];
        for (let line of lines) {
          let parts = line.split("	");
          if (parts.length < 4)
            continue;
          let lnum = Number(parts[2].replace(/;"$/, ""));
          let text = document2.getline(lnum - 1);
          if (!text)
            continue;
          let idx = text.indexOf(parts[0]);
          let start = idx == -1 ? 0 : idx;
          let range2 = Range.create(lnum - 1, start, lnum - 1, start + parts[0].length);
          items.push({
            label: `${parts[0]} [${parts[3]}] ${lnum}`,
            filterText: parts[0],
            location: Location.create(document2.uri, range2),
            data: { line: lnum }
          });
        }
        items.sort((a, b) => a.data.line - b.data.line);
        return items;
      }
    };
  }
});

// src/list/source/services.ts
var ServicesList;
var init_services2 = __esm({
  "src/list/source/services.ts"() {
    "use strict";
    init_services();
    init_basic();
    init_util();
    init_formatting2();
    ServicesList = class extends BasicList {
      constructor(nvim) {
        super(nvim);
        this.defaultAction = "toggle";
        this.description = "registered services of coc.nvim";
        this.name = "services";
        this.addAction("toggle", async (item) => {
          let { id } = item.data;
          await services_default.toggle(id);
          await wait(100);
        }, { persist: true, reload: true });
      }
      async loadItems(_context) {
        let stats = services_default.getServiceStats();
        stats.sort((a, b) => a.id > b.id ? -1 : 1);
        return formatListItems(this.alignColumns, stats.map((stat) => {
          let prefix = stat.state == "running" ? "*" : " ";
          return {
            label: [prefix, stat.id, `[${stat.state}]`, stat.languageIds.join(", ")],
            data: { id: stat.id }
          };
        }));
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocServicesPrefix /\\v^./ contained containedin=CocServicesLine", true);
        nvim.command("syntax match CocServicesName /\\v%3c\\S+/ contained containedin=CocServicesLine", true);
        nvim.command("syntax match CocServicesStat /\\v\\t\\[\\w+\\]/ contained containedin=CocServicesLine", true);
        nvim.command("syntax match CocServicesLanguages /\\v(\\])@<=.*$/ contained containedin=CocServicesLine", true);
        nvim.command("highlight default link CocServicesPrefix Special", true);
        nvim.command("highlight default link CocServicesName Type", true);
        nvim.command("highlight default link CocServicesStat Statement", true);
        nvim.command("highlight default link CocServicesLanguages Comment", true);
        nvim.resumeNotification(false, true);
      }
    };
  }
});

// src/list/source/sources.ts
function fixWidth(str, width) {
  if (str.length > width) {
    return str.slice(0, width - 1) + ".";
  }
  return str + " ".repeat(width - str.length);
}
var logger77, SourcesList;
var init_sources = __esm({
  "src/list/source/sources.ts"() {
    "use strict";
    init_main();
    init_esm();
    init_sources2();
    init_basic();
    logger77 = require_logger2()("list-sources");
    SourcesList = class extends BasicList {
      constructor(nvim) {
        super(nvim);
        this.defaultAction = "toggle";
        this.description = "registered completion sources";
        this.name = "sources";
        this.addAction("toggle", async (item) => {
          let { name: name2 } = item.data;
          sources_default.toggleSource(name2);
        }, { persist: true, reload: true });
        this.addAction("refresh", async (item) => {
          let { name: name2 } = item.data;
          await sources_default.refresh(name2);
        }, { persist: true, reload: true });
        this.addAction("open", async (item, context) => {
          let { location } = item;
          if (location)
            await this.jumpTo(location, null, context);
        });
      }
      async loadItems(context) {
        let stats = sources_default.sourceStats();
        stats.sort((a, b) => {
          if (a.type != b.type)
            return a.type < b.type ? 1 : -1;
          return a.name > b.name ? -1 : 1;
        });
        return stats.map((stat) => {
          let prefix = stat.disabled ? " " : "*";
          let location;
          if (stat.filepath) {
            location = Location.create(URI2.file(stat.filepath).toString(), Range.create(0, 0, 0, 0));
          }
          return {
            label: `${prefix} ${fixWidth(stat.name, 22)} ${fixWidth("[" + stat.shortcut + "]", 10)} ${fixWidth(stat.triggerCharacters.join(""), 10)} ${fixWidth(stat.priority.toString(), 3)} ${stat.filetypes.join(",")}`,
            location,
            data: { name: stat.name }
          };
        });
      }
      doHighlight() {
        let { nvim } = this;
        nvim.pauseNotification();
        nvim.command("syntax match CocSourcesPrefix /\\v^./ contained containedin=CocSourcesLine", true);
        nvim.command("syntax match CocSourcesName /\\v%3c\\S+/ contained containedin=CocSourcesLine", true);
        nvim.command("syntax match CocSourcesType /\\v%25v.*%36v/ contained containedin=CocSourcesLine", true);
        nvim.command("syntax match CocSourcesPriority /\\v%46v.*%50v/ contained containedin=CocSourcesLine", true);
        nvim.command("syntax match CocSourcesFileTypes /\\v\\S+$/ contained containedin=CocSourcesLine", true);
        nvim.command("highlight default link CocSourcesPrefix Special", true);
        nvim.command("highlight default link CocSourcesName Type", true);
        nvim.command("highlight default link CocSourcesPriority Number", true);
        nvim.command("highlight default link CocSourcesFileTypes Comment", true);
        nvim.command("highlight default link CocSourcesType Statement", true);
        nvim.resumeNotification(false, true);
      }
    };
  }
});

// src/list/source/symbols.ts
function createItem2(input, name2, kind, file, location) {
  let label = "";
  let ansiHighlights = [];
  let parts = [name2, `[${kind}]`, file];
  let highlights = ["Normal", "Typedef", "Comment"];
  for (let index = 0; index < parts.length; index++) {
    const text = parts[index];
    let start = byteLength(label);
    label += text;
    let end = byteLength(label);
    if (index != parts.length - 1) {
      label += " ";
    }
    ansiHighlights.push({ span: [start, end], hlGroup: highlights[index] });
  }
  let arr = getMatchHighlights(input, name2, 0, "CocListSearch");
  ansiHighlights.push(...arr);
  return {
    label,
    filterText: "",
    ansiHighlights,
    location
  };
}
var import_path32, import_minimatch7, import_vscode_languageserver_protocol81, logger78, Symbols;
var init_symbols = __esm({
  "src/list/source/symbols.ts"() {
    "use strict";
    import_path32 = __toESM(require("path"));
    import_minimatch7 = __toESM(require_minimatch());
    init_esm();
    init_languages();
    init_workspace();
    init_location();
    init_convert();
    init_fs();
    init_fzy();
    import_vscode_languageserver_protocol81 = __toESM(require_main2());
    init_string();
    init_score();
    logger78 = require_logger2()("list-symbols");
    Symbols = class extends LocationList {
      constructor() {
        super(...arguments);
        this.interactive = true;
        this.description = "search workspace symbols";
        this.detail = "Symbols list is provided by server, it works on interactive mode only.";
        this.name = "symbols";
        this.options = [{
          name: "-k, -kind KIND",
          description: "Filter symbols by kind.",
          hasValue: true
        }];
      }
      async loadItems(context, token) {
        let { input } = context;
        this.cwd = context.cwd;
        let args = this.parseArguments(context.args);
        let filterKind = args.kind ? args.kind.toLowerCase() : "";
        if (!context.options.interactive) {
          throw new Error("Symbols only works on interactive mode");
        }
        let symbols = await languages_default.getWorkspaceSymbols(input, token);
        if (!symbols) {
          throw new Error("No workspace symbols provider registered");
        }
        let config = this.getConfig();
        let excludes = config.get("excludes", []);
        let items = [];
        for (let s of symbols) {
          let kind = getSymbolKind(s.kind);
          if (filterKind && kind.toLowerCase() != filterKind) {
            continue;
          }
          let file = URI2.parse(s.location.uri).fsPath;
          if (isParentFolder(workspace_default.cwd, file)) {
            file = import_path32.default.relative(workspace_default.cwd, file);
          }
          if (excludes.some((p) => (0, import_minimatch7.default)(file, p))) {
            continue;
          }
          let item = createItem2(input, s.name, kind, file, s.location);
          item.data = { original: s, input, kind: s.kind, file, score: score(input, s.name) };
          items.push(item);
        }
        items.sort((a, b) => {
          if (a.data.score != b.data.score) {
            return b.data.score - a.data.score;
          }
          if (a.data.kind != b.data.kind) {
            return a.data.kind - b.data.kind;
          }
          return a.data.file.length - b.data.file.length;
        });
        return items;
      }
      async resolveItem(item) {
        let s = item.data.original;
        if (!s)
          return null;
        let tokenSource = new import_vscode_languageserver_protocol81.CancellationTokenSource();
        let resolved = await languages_default.resolveWorkspaceSymbol(s, tokenSource.token);
        if (!resolved)
          return null;
        let kind = getSymbolKind(resolved.kind);
        let file = URI2.parse(resolved.location.uri).fsPath;
        if (isParentFolder(this.cwd, file)) {
          file = import_path32.default.relative(this.cwd, file);
        }
        return createItem2(item.data.input, s.name, kind, file, s.location);
      }
      doHighlight() {
      }
    };
  }
});

// src/list/manager.ts
var import_debounce7, import_vscode_languageserver_protocol82, import_strip_ansi3, logger79, mouseKeys, ListManager, manager_default2;
var init_manager2 = __esm({
  "src/list/manager.ts"() {
    "use strict";
    import_debounce7 = __toESM(require_debounce());
    import_vscode_languageserver_protocol82 = __toESM(require_main2());
    init_events();
    init_extensions3();
    init_util();
    init_workspace();
    init_window();
    init_configuration4();
    init_mappings();
    init_prompt();
    init_session();
    init_commands();
    init_diagnostics();
    init_extensions2();
    init_folders();
    init_links();
    init_lists();
    init_location();
    init_outline();
    init_services2();
    init_sources();
    init_symbols();
    import_strip_ansi3 = __toESM(require_strip_ansi());
    logger79 = require_logger2()("list-manager");
    mouseKeys = ["<LeftMouse>", "<LeftDrag>", "<LeftRelease>", "<2-LeftMouse>"];
    ListManager = class {
      constructor() {
        this.plugTs = 0;
        this.sessionsMap = /* @__PURE__ */ new Map();
        this.disposables = [];
        this.listMap = /* @__PURE__ */ new Map();
      }
      init(nvim) {
        this.nvim = nvim;
        this.config = new ListConfiguration();
        this.prompt = new Prompt(nvim, this.config);
        this.mappings = new Mappings(this, nvim, this.config);
        let signText = this.config.get("selectedSignText", "*");
        nvim.command(`sign define CocSelected text=${signText} texthl=CocSelectedText linehl=CocSelectedLine`, true);
        events_default.on("InputChar", this.onInputChar, this, this.disposables);
        let debounced = (0, import_debounce7.default)(async () => {
          let session = await this.getCurrentSession();
          if (session)
            this.prompt.drawPrompt();
        }, 100);
        events_default.on("FocusGained", debounced, null, this.disposables);
        events_default.on("WinEnter", (winid) => {
          let session = this.getSessionByWinid(winid);
          if (session)
            this.prompt.start(session.listOptions);
        }, null, this.disposables);
        let timer;
        events_default.on("WinLeave", (winid) => {
          if (timer)
            clearTimeout(timer);
          let session = this.getSessionByWinid(winid);
          if (session) {
            setTimeout(() => {
              this.prompt.cancel();
            }, workspace_default.isVim ? 50 : 0);
          }
        }, null, this.disposables);
        this.disposables.push({
          dispose: () => {
            debounced.clear();
          }
        });
        this.prompt.onDidChangeInput(() => {
          let { session } = this;
          if (!session)
            return;
          session.onInputChange();
          session.history.filter();
        });
        this.registerList(new LinksList(nvim));
        this.registerList(new LocationList(nvim));
        this.registerList(new Symbols(nvim));
        this.registerList(new Outline(nvim));
        this.registerList(new CommandsList(nvim));
        this.registerList(new ExtensionList(nvim));
        this.registerList(new DiagnosticsList(nvim, this));
        this.registerList(new SourcesList(nvim));
        this.registerList(new ServicesList(nvim));
        this.registerList(new ListsList(nvim, this.listMap));
        this.registerList(new FoldList(nvim));
      }
      async start(args) {
        let res = this.parseArgs(args);
        if (!res)
          return;
        let { name: name2 } = res.list;
        let curr = this.sessionsMap.get(name2);
        if (curr)
          curr.dispose();
        this.prompt.start(res.options);
        let session = new ListSession(this.nvim, this.prompt, res.list, res.options, res.listArgs, this.config);
        this.sessionsMap.set(name2, session);
        this.lastSession = session;
        try {
          await session.start(args);
        } catch (e) {
          this.nvim.call("coc#prompt#stop_prompt", ["list"], true);
          let msg = e instanceof Error ? e.message : e.toString();
          window_default.showMessage(`Error on "CocList ${name2}": ${msg}`, "error");
          logger79.error(e);
        }
      }
      getSessionByWinid(winid) {
        for (let session of this.sessionsMap.values()) {
          if (session && session.winid == winid) {
            this.lastSession = session;
            return session;
          }
        }
        return null;
      }
      async getCurrentSession() {
        let { id } = await this.nvim.window;
        for (let session of this.sessionsMap.values()) {
          if (session && session.winid == id) {
            this.lastSession = session;
            return session;
          }
        }
        return null;
      }
      async resume(name2) {
        var _a;
        if (!name2) {
          await ((_a = this.session) == null ? void 0 : _a.resume());
        } else {
          let session = this.sessionsMap.get(name2);
          if (!session) {
            window_default.showMessage(`Can't find exists ${name2} list`);
            return;
          }
          await session.resume();
        }
      }
      async doAction(name2) {
        let lastSession = this.lastSession;
        if (!lastSession)
          return;
        await lastSession.doAction(name2);
      }
      async first(name2) {
        let s = this.getSession(name2);
        if (s)
          await s.first();
      }
      async last(name2) {
        let s = this.getSession(name2);
        if (s)
          await s.last();
      }
      async previous(name2) {
        let s = this.getSession(name2);
        if (s)
          await s.previous();
      }
      async next(name2) {
        let s = this.getSession(name2);
        if (s)
          await s.next();
      }
      getSession(name2) {
        if (!name2)
          return this.session;
        return this.sessionsMap.get(name2);
      }
      async cancel(close = true) {
        this.prompt.cancel();
        if (!close)
          return;
        if (this.session)
          await this.session.hide();
      }
      reset() {
        this.prompt.cancel();
        this.lastSession = void 0;
        for (let session of this.sessionsMap.values()) {
          session.dispose();
        }
        this.sessionsMap.clear();
        this.nvim.call("coc#prompt#stop_prompt", ["list"], true);
      }
      async switchMatcher() {
        var _a;
        await ((_a = this.session) == null ? void 0 : _a.switchMatcher());
      }
      async togglePreview() {
        let { nvim } = this;
        let winid = await nvim.call("coc#list#get_preview", [0]);
        if (winid != -1) {
          await nvim.call("coc#window#close", [winid]);
          await nvim.command("redraw");
        } else {
          await this.doAction("preview");
        }
      }
      async chooseAction() {
        let { lastSession } = this;
        if (lastSession)
          await lastSession.chooseAction();
      }
      parseArgs(args) {
        let options2 = [];
        let interactive = false;
        let autoPreview = false;
        let numberSelect = false;
        let noQuit = false;
        let first = false;
        let reverse = false;
        let name2;
        let input = "";
        let matcher = "fuzzy";
        let position = "bottom";
        let listArgs = [];
        let listOptions = [];
        for (let arg of args) {
          if (!name2 && arg.startsWith("-")) {
            listOptions.push(arg);
          } else if (!name2) {
            if (!/^\w+$/.test(arg)) {
              window_default.showMessage(`Invalid list option: "${arg}"`, "error");
              return null;
            }
            name2 = arg;
          } else {
            listArgs.push(arg);
          }
        }
        name2 = name2 || "lists";
        let config = workspace_default.getConfiguration(`list.source.${name2}`);
        if (!listOptions.length && !listArgs.length)
          listOptions = config.get("defaultOptions", []);
        if (!listArgs.length)
          listArgs = config.get("defaultArgs", []);
        for (let opt of listOptions) {
          if (opt.startsWith("--input")) {
            input = opt.slice(8);
          } else if (opt == "--number-select" || opt == "-N") {
            numberSelect = true;
          } else if (opt == "--auto-preview" || opt == "-A") {
            autoPreview = true;
          } else if (opt == "--regex" || opt == "-R") {
            matcher = "regex";
          } else if (opt == "--strict" || opt == "-S") {
            matcher = "strict";
          } else if (opt == "--interactive" || opt == "-I") {
            interactive = true;
          } else if (opt == "--top") {
            position = "top";
          } else if (opt == "--tab") {
            position = "tab";
          } else if (opt == "--ignore-case" || opt == "--normal" || opt == "--no-sort") {
            options2.push(opt.slice(2));
          } else if (opt == "--first") {
            first = true;
          } else if (opt == "--reverse") {
            reverse = true;
          } else if (opt == "--no-quit") {
            noQuit = true;
          } else {
            window_default.showMessage(`Invalid option "${opt}" of list`, "error");
            return null;
          }
        }
        let list2 = this.listMap.get(name2);
        if (!list2) {
          window_default.showMessage(`List ${name2} not found`, "error");
          return null;
        }
        if (interactive && !list2.interactive) {
          window_default.showMessage(`Interactive mode of "${name2}" list not supported`, "error");
          return null;
        }
        return {
          list: list2,
          listArgs,
          options: {
            numberSelect,
            autoPreview,
            reverse,
            noQuit,
            first,
            input,
            interactive,
            matcher,
            position,
            smartcase: this.config.smartcase,
            ignorecase: options2.includes("ignore-case") ? true : false,
            mode: !options2.includes("normal") ? "insert" : "normal",
            sort: !options2.includes("no-sort") ? true : false
          }
        };
      }
      async onInputChar(session, ch, charmod) {
        if (session != "list")
          return;
        let { mode } = this.prompt;
        let now = Date.now();
        if (ch == "<plug>" || this.plugTs && now - this.plugTs < 20) {
          this.plugTs = now;
          return;
        }
        if (!ch)
          return;
        if (ch == "<esc>") {
          await this.cancel();
          return;
        }
        if (mode == "insert") {
          await this.onInsertInput(ch, charmod);
        } else {
          await this.onNormalInput(ch, charmod);
        }
      }
      async onInsertInput(ch, charmod) {
        let { session } = this;
        if (!session)
          return;
        if (mouseKeys.includes(ch)) {
          await this.onMouseEvent(ch);
          return;
        }
        let n = await session.doNumberSelect(ch);
        if (n)
          return;
        let done = await this.mappings.doInsertKeymap(ch);
        if (done || charmod)
          return;
        if (ch.startsWith("<") && ch.endsWith(">")) {
          await this.feedkeys(ch, false);
          return;
        }
        for (let s of ch) {
          let code = s.codePointAt(0);
          if (code == 65533)
            return;
          if (code < 32 || code >= 127 && code <= 159)
            return;
          await this.prompt.acceptCharacter(s);
        }
      }
      async onNormalInput(ch, _charmod) {
        if (mouseKeys.includes(ch)) {
          await this.onMouseEvent(ch);
          return;
        }
        let used = await this.mappings.doNormalKeymap(ch);
        if (!used)
          await this.feedkeys(ch);
      }
      onMouseEvent(key) {
        if (this.session)
          return this.session.onMouseEvent(key);
      }
      async feedkeys(key, remap = true) {
        let { nvim } = this;
        key = key.startsWith("<") && key.endsWith(">") ? `\\${key}` : key;
        await nvim.call("coc#prompt#stop_prompt", ["list"]);
        await nvim.call("eval", [`feedkeys("${key}", "${remap ? "i" : "in"}")`]);
        this.prompt.start();
      }
      async command(command) {
        let { nvim } = this;
        await nvim.call("coc#prompt#stop_prompt", ["list"]);
        await nvim.command(command);
        this.prompt.start();
      }
      async normal(command, bang = true) {
        let { nvim } = this;
        await nvim.call("coc#prompt#stop_prompt", ["list"]);
        await nvim.command(`normal${bang ? "!" : ""} ${command}`);
        this.prompt.start();
      }
      async call(fname) {
        if (this.session)
          return await this.session.call(fname);
      }
      get session() {
        return this.lastSession;
      }
      registerList(list2) {
        let { name: name2 } = list2;
        let exists = this.listMap.get(name2);
        if (this.listMap.has(name2)) {
          if (exists) {
            if (typeof exists.dispose == "function") {
              exists.dispose();
            }
            this.listMap.delete(name2);
          }
          window_default.showMessage(`list "${name2}" recreated.`);
        }
        this.listMap.set(name2, list2);
        extensions_default.addSchemeProperty(`list.source.${name2}.defaultAction`, {
          type: "string",
          default: null,
          description: `Default action of "${name2}" list.`
        });
        extensions_default.addSchemeProperty(`list.source.${name2}.defaultOptions`, {
          type: "array",
          default: list2.interactive ? ["--interactive"] : [],
          description: `Default list options of "${name2}" list, only used when both list option and argument are empty.`,
          uniqueItems: true,
          items: {
            type: "string",
            enum: [
              "--top",
              "--normal",
              "--no-sort",
              "--input",
              "--tab",
              "--strict",
              "--regex",
              "--ignore-case",
              "--number-select",
              "--interactive",
              "--auto-preview",
              "--first",
              "--no-quit"
            ]
          }
        });
        extensions_default.addSchemeProperty(`list.source.${name2}.defaultArgs`, {
          type: "array",
          default: [],
          description: `Default argument list of "${name2}" list, only used when list argument is empty.`,
          uniqueItems: true,
          items: { type: "string" }
        });
        return import_vscode_languageserver_protocol82.Disposable.create(() => {
          if (typeof list2.dispose == "function") {
            list2.dispose();
          }
          this.listMap.delete(name2);
        });
      }
      get names() {
        return Array.from(this.listMap.keys());
      }
      get descriptions() {
        let d = {};
        for (let name2 of this.listMap.keys()) {
          let list2 = this.listMap.get(name2);
          d[name2] = list2.description;
        }
        return d;
      }
      async loadItems(name2) {
        let args = [name2];
        let res = this.parseArgs(args);
        if (!res)
          return;
        let { list: list2, options: options2, listArgs } = res;
        let source = new import_vscode_languageserver_protocol82.CancellationTokenSource();
        let token = source.token;
        let arr = await this.nvim.eval('[win_getid(),bufnr("%")]');
        let items = await list2.loadItems({
          options: options2,
          args: listArgs,
          input: "",
          cwd: workspace_default.cwd,
          window: this.nvim.createWindow(arr[0]),
          buffer: this.nvim.createBuffer(arr[1]),
          listWindow: null
        }, token);
        if (!items || Array.isArray(items)) {
          return items;
        }
        let task = items;
        let newItems = await new Promise((resolve3, reject) => {
          let items2 = [];
          task.on("data", (item) => {
            item.label = (0, import_strip_ansi3.default)(item.label);
            items2.push(item);
          });
          task.on("end", () => {
            resolve3(items2);
          });
          task.on("error", (msg) => {
            reject(msg);
          });
        });
        return newItems;
      }
      toggleMode() {
        let lastSession = this.lastSession;
        if (lastSession)
          lastSession.toggleMode();
      }
      get isActivated() {
        var _a;
        return ((_a = this.session) == null ? void 0 : _a.winid) != null;
      }
      stop() {
        let lastSession = this.lastSession;
        if (lastSession)
          lastSession.stop();
      }
      dispose() {
        for (let session of this.sessionsMap.values()) {
          session.dispose();
        }
        this.sessionsMap.clear();
        if (this.config) {
          this.config.dispose();
        }
        this.lastSession = void 0;
        disposeAll(this.disposables);
      }
    };
    manager_default2 = new ListManager();
  }
});

// node_modules/unidecode/data/x00.js
var require_x00 = __commonJS({
  "node_modules/unidecode/data/x00.js"(exports, module2) {
    module2.exports = ["\0", "", "", "", "", "", "", "\x07", "\b", "	", "\n", "\v", "\f", "\r", "", "", "", "", "", "", "", "", "", "", "", "", "", "\x1B", "", "", "", "", " ", "!", '"', "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ":", ";", "<", "=", ">", "?", "@", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "[", "\\", "]", "^", "_", "`", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "{", "|", "}", "~", "\x7F", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", " ", "!", "C/", "PS", "$?", "Y=", "|", "SS", '"', "(c)", "a", "<<", "!", "", "(r)", "-", "deg", "+-", "2", "3", "'", "u", "P", "*", ",", "1", "o", ">>", "1/4", "1/2", "3/4", "?", "A", "A", "A", "A", "A", "A", "AE", "C", "E", "E", "E", "E", "I", "I", "I", "I", "D", "N", "O", "O", "O", "O", "O", "x", "O", "U", "U", "U", "U", "U", "Th", "ss", "a", "a", "a", "a", "a", "a", "ae", "c", "e", "e", "e", "e", "i", "i", "i", "i", "d", "n", "o", "o", "o", "o", "o", "/", "o", "u", "u", "u", "u", "y", "th", "y"];
  }
});

// node_modules/unidecode/data/x01.js
var require_x01 = __commonJS({
  "node_modules/unidecode/data/x01.js"(exports, module2) {
    module2.exports = ["A", "a", "A", "a", "A", "a", "C", "c", "C", "c", "C", "c", "C", "c", "D", "d", "D", "d", "E", "e", "E", "e", "E", "e", "E", "e", "E", "e", "G", "g", "G", "g", "G", "g", "G", "g", "H", "h", "H", "h", "I", "i", "I", "i", "I", "i", "I", "i", "I", "i", "IJ", "", "J", "j", "K", "k", "k", "L", "l", "L", "l", "L", "l", "L", "l", "L", "l", "N", "n", "N", "n", "N", "n", "'n", "ng", "NG", "O", "o", "O", "o", "O", "o", "OE", "oe", "R", "r", "R", "r", "R", "r", "S", "s", "S", "s", "S", "s", "S", "s", "T", "t", "T", "t", "T", "t", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "W", "w", "Y", "y", "Y", "Z", "z", "Z", "z", "Z", "z", "s", "b", "B", "B", "b", "6", "6", "O", "C", "c", "D", "D", "D", "d", "d", "3", "@", "E", "F", "f", "G", "G", "hv", "I", "I", "K", "k", "l", "l", "W", "N", "n", "O", "O", "o", "OI", "oi", "P", "p", "YR", "2", "2", "SH", "sh", "t", "T", "t", "T", "U", "u", "Y", "V", "Y", "y", "Z", "z", "ZH", "ZH", "zh", "zh", "2", "5", "5", "ts", "w", "|", "||", "|=", "!", "DZ", "Dz", "dz", "LJ", "Lj", "lj", "NJ", "Nj", "nj", "A", "a", "I", "i", "O", "o", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "@", "A", "a", "A", "a", "AE", "ae", "G", "g", "G", "g", "K", "k", "O", "o", "O", "o", "ZH", "zh", "j", "DZ", "D", "dz", "G", "g", "HV", "W", "N", "n", "A", "a", "AE", "ae", "O", "o"];
  }
});

// node_modules/unidecode/data/x02.js
var require_x02 = __commonJS({
  "node_modules/unidecode/data/x02.js"(exports, module2) {
    module2.exports = ["A", "a", "A", "a", "E", "e", "E", "e", "I", "i", "I", "i", "O", "o", "O", "o", "R", "r", "R", "r", "U", "u", "U", "u", "S", "s", "T", "t", "Y", "y", "H", "h", "[?]", "[?]", "OU", "ou", "Z", "z", "A", "a", "E", "e", "O", "o", "O", "o", "O", "o", "O", "o", "Y", "y", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "a", "a", "a", "b", "o", "c", "d", "d", "e", "@", "@", "e", "e", "e", "e", "j", "g", "g", "g", "g", "u", "Y", "h", "h", "i", "i", "I", "l", "l", "l", "lZ", "W", "W", "m", "n", "n", "n", "o", "OE", "O", "F", "R", "R", "R", "R", "r", "r", "R", "R", "R", "s", "S", "j", "S", "S", "t", "t", "U", "U", "v", "^", "W", "Y", "Y", "z", "z", "Z", "Z", "?", "?", "?", "C", "@", "B", "E", "G", "H", "j", "k", "L", "q", "?", "?", "dz", "dZ", "dz", "ts", "tS", "tC", "fN", "ls", "lz", "WW", "]]", "[?]", "[?]", "k", "h", "j", "r", "r", "r", "r", "w", "y", "'", '"', "`", "'", "`", "`", "'", "?", "?", "<", ">", "^", "V", "^", "V", "'", "-", "/", "\\", ",", "_", "\\", "/", ":", ".", "`", "'", "^", "V", "+", "-", "V", ".", "@", ",", "~", '"', "R", "X", "G", "l", "s", "x", "?", "", "", "", "", "", "", "", "V", "=", '"', "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x03.js
var require_x03 = __commonJS({
  "node_modules/unidecode/data/x03.js"(exports, module2) {
    module2.exports = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "'", ",", "[?]", "[?]", "[?]", "[?]", "", "[?]", "[?]", "[?]", "?", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "A", ";", "E", "E", "I", "[?]", "O", "[?]", "U", "O", "I", "A", "B", "G", "D", "E", "Z", "E", "Th", "I", "K", "L", "M", "N", "Ks", "O", "P", "R", "[?]", "S", "T", "U", "Ph", "Kh", "Ps", "O", "I", "U", "a", "e", "e", "i", "u", "a", "b", "g", "d", "e", "z", "e", "th", "i", "k", "l", "m", "n", "x", "o", "p", "r", "s", "s", "t", "u", "ph", "kh", "ps", "o", "i", "u", "o", "u", "o", "[?]", "b", "th", "U", "U", "U", "ph", "p", "&", "[?]", "[?]", "St", "st", "W", "w", "Q", "q", "Sp", "sp", "Sh", "sh", "F", "f", "Kh", "kh", "H", "h", "G", "g", "CH", "ch", "Ti", "ti", "k", "r", "c", "j", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x04.js
var require_x04 = __commonJS({
  "node_modules/unidecode/data/x04.js"(exports, module2) {
    module2.exports = ["Ie", "Io", "Dj", "Gj", "Ie", "Dz", "I", "Yi", "J", "Lj", "Nj", "Tsh", "Kj", "I", "U", "Dzh", "A", "B", "V", "G", "D", "Ie", "Zh", "Z", "I", "I", "K", "L", "M", "N", "O", "P", "R", "S", "T", "U", "F", "Kh", "Ts", "Ch", "Sh", "Shch", "", "Y", "'", "E", "Iu", "Ia", "a", "b", "v", "gh", "d", "ie", "zh", "z", "i", "i", "k", "l", "m", "n", "o", "p", "r", "s", "t", "u", "f", "kh", "ts", "ch", "sh", "shch", "", "y", "'", "e", "iu", "ia", "ie", "io", "dj", "gj", "ie", "dz", "i", "yi", "j", "lj", "nj", "tsh", "kj", "i", "u", "dzh", "O", "o", "E", "e", "Ie", "ie", "E", "e", "Ie", "ie", "O", "o", "Io", "io", "Ks", "ks", "Ps", "ps", "F", "f", "Y", "y", "Y", "y", "u", "u", "O", "o", "O", "o", "Ot", "ot", "Q", "q", "*1000*", "", "", "", "", "[?]", "*100.000*", "*1.000.000*", "[?]", "[?]", '"', '"', "R'", "r'", "G'", "g'", "G'", "g'", "G'", "g'", "Zh'", "zh'", "Z'", "z'", "K'", "k'", "K'", "k'", "K'", "k'", "K'", "k'", "N'", "n'", "Ng", "ng", "P'", "p'", "Kh", "kh", "S'", "s'", "T'", "t'", "U", "u", "U'", "u'", "Kh'", "kh'", "Tts", "tts", "Ch'", "ch'", "Ch'", "ch'", "H", "h", "Ch", "ch", "Ch'", "ch'", "`", "Zh", "zh", "K'", "k'", "[?]", "[?]", "N'", "n'", "[?]", "[?]", "Ch", "ch", "[?]", "[?]", "[?]", "a", "a", "A", "a", "Ae", "ae", "Ie", "ie", "@", "@", "@", "@", "Zh", "zh", "Z", "z", "Dz", "dz", "I", "i", "I", "i", "O", "o", "O", "o", "O", "o", "E", "e", "U", "u", "U", "u", "U", "u", "Ch", "ch", "[?]", "[?]", "Y", "y", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x05.js
var require_x05 = __commonJS({
  "node_modules/unidecode/data/x05.js"(exports, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "A", "B", "G", "D", "E", "Z", "E", "E", "T`", "Zh", "I", "L", "Kh", "Ts", "K", "H", "Dz", "Gh", "Ch", "M", "Y", "N", "Sh", "O", "Ch`", "P", "J", "Rh", "S", "V", "T", "R", "Ts`", "W", "P`", "K`", "O", "F", "[?]", "[?]", "<", "'", "/", "!", ",", "?", ".", "[?]", "a", "b", "g", "d", "e", "z", "e", "e", "t`", "zh", "i", "l", "kh", "ts", "k", "h", "dz", "gh", "ch", "m", "y", "n", "sh", "o", "ch`", "p", "j", "rh", "s", "v", "t", "r", "ts`", "w", "p`", "k`", "o", "f", "ew", "[?]", ".", "-", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "@", "e", "a", "o", "i", "e", "e", "a", "a", "o", "[?]", "u", "'", "", "", "", "", "", "", ":", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "b", "g", "d", "h", "v", "z", "kh", "t", "y", "k", "k", "l", "m", "m", "n", "n", "s", "`", "p", "p", "ts", "ts", "q", "r", "sh", "t", "[?]", "[?]", "[?]", "[?]", "[?]", "V", "oy", "i", "'", '"', "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x06.js
var require_x06 = __commonJS({
  "node_modules/unidecode/data/x06.js"(exports, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", ",", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", ";", "[?]", "[?]", "[?]", "?", "[?]", "", "a", "'", "w'", "", "y'", "", "b", "@", "t", "th", "j", "H", "kh", "d", "dh", "r", "z", "s", "sh", "S", "D", "T", "Z", "aa", "G", "[?]", "[?]", "[?]", "[?]", "[?]", "", "f", "q", "k", "l", "m", "n", "h", "w", "~", "y", "an", "un", "in", "a", "u", "i", "W", "", "", "'", "'", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "%", ".", ",", "*", "[?]", "[?]", "", "'", "'", "'", "", "'", "'w", "'u", "'y", "tt", "tth", "b", "t", "T", "p", "th", "bh", "'h", "H", "ny", "dy", "H", "ch", "cch", "dd", "D", "D", "Dt", "dh", "ddh", "d", "D", "D", "rr", "R", "R", "R", "R", "R", "R", "j", "R", "S", "S", "S", "S", "S", "T", "GH", "F", "F", "F", "v", "f", "ph", "Q", "Q", "kh", "k", "K", "K", "ng", "K", "g", "G", "N", "G", "G", "G", "L", "L", "L", "L", "N", "N", "N", "N", "N", "h", "Ch", "hy", "h", "H", "@", "W", "oe", "oe", "u", "yu", "yu", "W", "v", "y", "Y", "Y", "W", "", "", "y", "y'", ".", "ae", "", "", "", "", "", "", "", "@", "#", "", "", "", "", "", "", "", "", "", "", "^", "", "", "", "", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "Sh", "D", "Gh", "&", "+m"];
  }
});

// node_modules/unidecode/data/x07.js
var require_x07 = __commonJS({
  "node_modules/unidecode/data/x07.js"(exports, module2) {
    module2.exports = ["//", "/", ",", "!", "!", "-", ",", ",", ";", "?", "~", "{", "}", "*", "[?]", "", "'", "", "b", "g", "g", "d", "d", "h", "w", "z", "H", "t", "t", "y", "yh", "k", "l", "m", "n", "s", "s", "`", "p", "p", "S", "q", "r", "sh", "t", "[?]", "[?]", "[?]", "a", "a", "a", "A", "A", "A", "e", "e", "e", "E", "i", "i", "u", "u", "u", "o", "", "`", "'", "", "", "X", "Q", "@", "@", "|", "+", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "h", "sh", "n", "r", "b", "L", "k", "'", "v", "m", "f", "dh", "th", "l", "g", "ny", "s", "d", "z", "t", "y", "p", "j", "ch", "tt", "hh", "kh", "th", "z", "sh", "s", "d", "t", "z", "`", "gh", "q", "w", "a", "aa", "i", "ee", "u", "oo", "e", "ey", "o", "oa", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x09.js
var require_x09 = __commonJS({
  "node_modules/unidecode/data/x09.js"(exports, module2) {
    module2.exports = ["[?]", "N", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "R", "L", "eN", "e", "e", "ai", "oN", "o", "o", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "nnn", "p", "ph", "b", "bh", "m", "y", "r", "rr", "l", "l", "lll", "v", "sh", "ss", "s", "h", "[?]", "[?]", "'", "'", "aa", "i", "ii", "u", "uu", "R", "RR", "eN", "e", "e", "ai", "oN", "o", "o", "au", "", "[?]", "[?]", "AUM", "'", "'", "`", "'", "[?]", "[?]", "[?]", "q", "khh", "ghh", "z", "dddh", "rh", "f", "yy", "RR", "LL", "L", "LL", " / ", " // ", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "N", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "R", "RR", "[?]", "[?]", "e", "ai", "[?]", "[?]", "o", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "[?]", "p", "ph", "b", "bh", "m", "y", "r", "[?]", "l", "[?]", "[?]", "[?]", "sh", "ss", "s", "h", "[?]", "[?]", "'", "[?]", "aa", "i", "ii", "u", "uu", "R", "RR", "[?]", "[?]", "e", "ai", "[?]", "[?]", "o", "au", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "+", "[?]", "[?]", "[?]", "[?]", "rr", "rh", "[?]", "yy", "RR", "LL", "L", "LL", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "r'", "r`", "Rs", "Rs", "1/", "2/", "3/", "4/", " 1 - 1/", "/16", "", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x0a.js
var require_x0a = __commonJS({
  "node_modules/unidecode/data/x0a.js"(exports, module2) {
    module2.exports = ["[?]", "[?]", "N", "[?]", "[?]", "a", "aa", "i", "ii", "u", "uu", "[?]", "[?]", "[?]", "[?]", "ee", "ai", "[?]", "[?]", "oo", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "[?]", "p", "ph", "b", "bb", "m", "y", "r", "[?]", "l", "ll", "[?]", "v", "sh", "[?]", "s", "h", "[?]", "[?]", "'", "[?]", "aa", "i", "ii", "u", "uu", "[?]", "[?]", "[?]", "[?]", "ee", "ai", "[?]", "[?]", "oo", "au", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "khh", "ghh", "z", "rr", "[?]", "f", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "N", "H", "", "", "G.E.O.", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "N", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "R", "[?]", "eN", "[?]", "e", "ai", "oN", "[?]", "o", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "[?]", "p", "ph", "b", "bh", "m", "ya", "r", "[?]", "l", "ll", "[?]", "v", "sh", "ss", "s", "h", "[?]", "[?]", "'", "'", "aa", "i", "ii", "u", "uu", "R", "RR", "eN", "[?]", "e", "ai", "oN", "[?]", "o", "au", "", "[?]", "[?]", "AUM", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "RR", "[?]", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x0b.js
var require_x0b = __commonJS({
  "node_modules/unidecode/data/x0b.js"(exports, module2) {
    module2.exports = ["[?]", "N", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "R", "L", "[?]", "[?]", "e", "ai", "[?]", "[?]", "o", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "[?]", "p", "ph", "b", "bh", "m", "y", "r", "[?]", "l", "ll", "[?]", "", "sh", "ss", "s", "h", "[?]", "[?]", "'", "'", "aa", "i", "ii", "u", "uu", "R", "[?]", "[?]", "[?]", "e", "ai", "[?]", "[?]", "o", "au", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "+", "+", "[?]", "[?]", "[?]", "[?]", "rr", "rh", "[?]", "yy", "RR", "LL", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "[?]", "[?]", "[?]", "e", "ee", "ai", "[?]", "o", "oo", "au", "k", "[?]", "[?]", "[?]", "ng", "c", "[?]", "j", "[?]", "ny", "tt", "[?]", "[?]", "[?]", "nn", "t", "[?]", "[?]", "[?]", "n", "nnn", "p", "[?]", "[?]", "[?]", "m", "y", "r", "rr", "l", "ll", "lll", "v", "[?]", "ss", "s", "h", "[?]", "[?]", "[?]", "[?]", "aa", "i", "ii", "u", "uu", "[?]", "[?]", "[?]", "e", "ee", "ai", "[?]", "o", "oo", "au", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "+", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+10+", "+100+", "+1000+", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x0c.js
var require_x0c = __commonJS({
  "node_modules/unidecode/data/x0c.js"(exports, module2) {
    module2.exports = ["[?]", "N", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "R", "L", "[?]", "e", "ee", "ai", "[?]", "o", "oo", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "[?]", "p", "ph", "b", "bh", "m", "y", "r", "rr", "l", "ll", "[?]", "v", "sh", "ss", "s", "h", "[?]", "[?]", "[?]", "[?]", "aa", "i", "ii", "u", "uu", "R", "RR", "[?]", "e", "ee", "ai", "[?]", "o", "oo", "au", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "+", "+", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "RR", "LL", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "R", "L", "[?]", "e", "ee", "ai", "[?]", "o", "oo", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "[?]", "p", "ph", "b", "bh", "m", "y", "r", "rr", "l", "ll", "[?]", "v", "sh", "ss", "s", "h", "[?]", "[?]", "[?]", "[?]", "aa", "i", "ii", "u", "uu", "R", "RR", "[?]", "e", "ee", "ai", "[?]", "o", "oo", "au", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "+", "+", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "lll", "[?]", "RR", "LL", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x0d.js
var require_x0d = __commonJS({
  "node_modules/unidecode/data/x0d.js"(exports, module2) {
    module2.exports = ["[?]", "[?]", "N", "H", "[?]", "a", "aa", "i", "ii", "u", "uu", "R", "L", "[?]", "e", "ee", "ai", "[?]", "o", "oo", "au", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "[?]", "p", "ph", "b", "bh", "m", "y", "r", "rr", "l", "ll", "lll", "v", "sh", "ss", "s", "h", "[?]", "[?]", "[?]", "[?]", "aa", "i", "ii", "u", "uu", "R", "[?]", "[?]", "e", "ee", "ai", "", "o", "oo", "au", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "+", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "RR", "LL", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "N", "H", "[?]", "a", "aa", "ae", "aae", "i", "ii", "u", "uu", "R", "RR", "L", "LL", "e", "ee", "ai", "o", "oo", "au", "[?]", "[?]", "[?]", "k", "kh", "g", "gh", "ng", "nng", "c", "ch", "j", "jh", "ny", "jny", "nyj", "tt", "tth", "dd", "ddh", "nn", "nndd", "t", "th", "d", "dh", "n", "[?]", "nd", "p", "ph", "b", "bh", "m", "mb", "y", "r", "[?]", "l", "[?]", "[?]", "v", "sh", "ss", "s", "h", "ll", "f", "[?]", "[?]", "[?]", "", "[?]", "[?]", "[?]", "[?]", "aa", "ae", "aae", "i", "ii", "u", "[?]", "uu", "[?]", "R", "e", "ee", "ai", "o", "oo", "au", "L", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "RR", "LL", " . ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x0e.js
var require_x0e = __commonJS({
  "node_modules/unidecode/data/x0e.js"(exports, module2) {
    module2.exports = ["[?]", "k", "kh", "kh", "kh", "kh", "kh", "ng", "cch", "ch", "ch", "ch", "ch", "y", "d", "t", "th", "th", "th", "n", "d", "t", "th", "th", "th", "n", "b", "p", "ph", "f", "ph", "f", "ph", "m", "y", "r", "R", "l", "L", "w", "s", "s", "s", "h", "l", "`", "h", "~", "a", "a", "aa", "am", "i", "ii", "ue", "uue", "u", "uu", "'", "[?]", "[?]", "[?]", "[?]", "Bh.", "e", "ae", "o", "ai", "ai", "ao", "+", "", "", "", "", "", "", "M", "", " * ", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", " // ", " /// ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "k", "kh", "[?]", "kh", "[?]", "[?]", "ng", "ch", "[?]", "s", "[?]", "[?]", "ny", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "d", "h", "th", "th", "[?]", "n", "b", "p", "ph", "f", "ph", "f", "[?]", "m", "y", "r", "[?]", "l", "[?]", "w", "[?]", "[?]", "s", "h", "[?]", "`", "", "~", "a", "", "aa", "am", "i", "ii", "y", "yy", "u", "uu", "[?]", "o", "l", "ny", "[?]", "[?]", "e", "ei", "o", "ay", "ai", "[?]", "+", "[?]", "", "", "", "", "", "M", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "[?]", "[?]", "hn", "hm", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x0f.js
var require_x0f = __commonJS({
  "node_modules/unidecode/data/x0f.js"(exports, module2) {
    module2.exports = ["AUM", "", "", "", "", "", "", "", " // ", " * ", "", "-", " / ", " / ", " // ", " -/ ", " +/ ", " X/ ", " /XX/ ", " /X/ ", ", ", "", "", "", "", "", "", "", "", "", "", "", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ".5", "1.5", "2.5", "3.5", "4.5", "5.5", "6.5", "7.5", "8.5", "-.5", "+", "*", "^", "_", "", "~", "[?]", "]", "[[", "]]", "", "", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "[?]", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "p", "ph", "b", "bh", "m", "ts", "tsh", "dz", "dzh", "w", "zh", "z", "'", "y", "r", "l", "sh", "ssh", "s", "h", "a", "kss", "r", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "aa", "i", "ii", "u", "uu", "R", "RR", "L", "LL", "e", "ee", "o", "oo", "M", "H", "i", "ii", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "[?]", "ny", "tt", "tth", "dd", "ddh", "nn", "t", "th", "d", "dh", "n", "p", "ph", "b", "bh", "m", "ts", "tsh", "dz", "dzh", "w", "zh", "z", "'", "y", "r", "l", "sh", "ss", "s", "h", "a", "kss", "w", "y", "r", "[?]", "X", " :X: ", " /O/ ", " /o/ ", " \\o\\ ", " (O) ", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x10.js
var require_x10 = __commonJS({
  "node_modules/unidecode/data/x10.js"(exports, module2) {
    module2.exports = ["k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "nny", "tt", "tth", "dd", "ddh", "nn", "tt", "th", "d", "dh", "n", "p", "ph", "b", "bh", "m", "y", "r", "l", "w", "s", "h", "ll", "a", "[?]", "i", "ii", "u", "uu", "e", "[?]", "o", "au", "[?]", "aa", "i", "ii", "u", "uu", "e", "ai", "[?]", "[?]", "[?]", "N", "'", ":", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", " / ", " // ", "n*", "r*", "l*", "e*", "sh", "ss", "R", "RR", "L", "LL", "R", "RR", "L", "LL", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "A", "B", "G", "D", "E", "V", "Z", "T`", "I", "K", "L", "M", "N", "O", "P", "Zh", "R", "S", "T", "U", "P`", "K`", "G'", "Q", "Sh", "Ch`", "C`", "Z'", "C", "Ch", "X", "J", "H", "E", "Y", "W", "Xh", "OE", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "a", "b", "g", "d", "e", "v", "z", "t`", "i", "k", "l", "m", "n", "o", "p", "zh", "r", "s", "t", "u", "p`", "k`", "g'", "q", "sh", "ch`", "c`", "z'", "c", "ch", "x", "j", "h", "e", "y", "w", "xh", "oe", "f", "[?]", "[?]", "[?]", "[?]", " // ", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x11.js
var require_x11 = __commonJS({
  "node_modules/unidecode/data/x11.js"(exports, module2) {
    module2.exports = ["g", "gg", "n", "d", "dd", "r", "m", "b", "bb", "s", "ss", "", "j", "jj", "c", "k", "t", "p", "h", "ng", "nn", "nd", "nb", "dg", "rn", "rr", "rh", "rN", "mb", "mN", "bg", "bn", "", "bs", "bsg", "bst", "bsb", "bss", "bsj", "bj", "bc", "bt", "bp", "bN", "bbN", "sg", "sn", "sd", "sr", "sm", "sb", "sbg", "sss", "s", "sj", "sc", "sk", "st", "sp", "sh", "", "", "", "", "Z", "g", "d", "m", "b", "s", "Z", "", "j", "c", "t", "p", "N", "j", "", "", "", "", "ck", "ch", "", "", "pb", "pN", "hh", "Q", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "a", "ae", "ya", "yae", "eo", "e", "yeo", "ye", "o", "wa", "wae", "oe", "yo", "u", "weo", "we", "wi", "yu", "eu", "yi", "i", "a-o", "a-u", "ya-o", "ya-yo", "eo-o", "eo-u", "eo-eu", "yeo-o", "yeo-u", "o-eo", "o-e", "o-ye", "o-o", "o-u", "yo-ya", "yo-yae", "yo-yeo", "yo-o", "yo-i", "u-a", "u-ae", "u-eo-eu", "u-ye", "u-u", "yu-a", "yu-eo", "yu-e", "yu-yeo", "yu-ye", "yu-u", "yu-i", "eu-u", "eu-eu", "yi-u", "i-a", "i-ya", "i-o", "i-u", "i-eu", "i-U", "U", "U-eo", "U-u", "U-i", "UU", "[?]", "[?]", "[?]", "[?]", "[?]", "g", "gg", "gs", "n", "nj", "nh", "d", "l", "lg", "lm", "lb", "ls", "lt", "lp", "lh", "m", "b", "bs", "s", "ss", "ng", "j", "c", "k", "t", "p", "h", "gl", "gsg", "ng", "nd", "ns", "nZ", "nt", "dg", "tl", "lgs", "ln", "ld", "lth", "ll", "lmg", "lms", "lbs", "lbh", "rNp", "lss", "lZ", "lk", "lQ", "mg", "ml", "mb", "ms", "mss", "mZ", "mc", "mh", "mN", "bl", "bp", "ph", "pN", "sg", "sd", "sl", "sb", "Z", "g", "ss", "", "kh", "N", "Ns", "NZ", "pb", "pN", "hn", "hl", "hm", "hb", "Q", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x12.js
var require_x12 = __commonJS({
  "node_modules/unidecode/data/x12.js"(exports, module2) {
    module2.exports = ["ha", "hu", "hi", "haa", "hee", "he", "ho", "[?]", "la", "lu", "li", "laa", "lee", "le", "lo", "lwa", "hha", "hhu", "hhi", "hhaa", "hhee", "hhe", "hho", "hhwa", "ma", "mu", "mi", "maa", "mee", "me", "mo", "mwa", "sza", "szu", "szi", "szaa", "szee", "sze", "szo", "szwa", "ra", "ru", "ri", "raa", "ree", "re", "ro", "rwa", "sa", "su", "si", "saa", "see", "se", "so", "swa", "sha", "shu", "shi", "shaa", "shee", "she", "sho", "shwa", "qa", "qu", "qi", "qaa", "qee", "qe", "qo", "[?]", "qwa", "[?]", "qwi", "qwaa", "qwee", "qwe", "[?]", "[?]", "qha", "qhu", "qhi", "qhaa", "qhee", "qhe", "qho", "[?]", "qhwa", "[?]", "qhwi", "qhwaa", "qhwee", "qhwe", "[?]", "[?]", "ba", "bu", "bi", "baa", "bee", "be", "bo", "bwa", "va", "vu", "vi", "vaa", "vee", "ve", "vo", "vwa", "ta", "tu", "ti", "taa", "tee", "te", "to", "twa", "ca", "cu", "ci", "caa", "cee", "ce", "co", "cwa", "xa", "xu", "xi", "xaa", "xee", "xe", "xo", "[?]", "xwa", "[?]", "xwi", "xwaa", "xwee", "xwe", "[?]", "[?]", "na", "nu", "ni", "naa", "nee", "ne", "no", "nwa", "nya", "nyu", "nyi", "nyaa", "nyee", "nye", "nyo", "nywa", "'a", "'u", "[?]", "'aa", "'ee", "'e", "'o", "'wa", "ka", "ku", "ki", "kaa", "kee", "ke", "ko", "[?]", "kwa", "[?]", "kwi", "kwaa", "kwee", "kwe", "[?]", "[?]", "kxa", "kxu", "kxi", "kxaa", "kxee", "kxe", "kxo", "[?]", "kxwa", "[?]", "kxwi", "kxwaa", "kxwee", "kxwe", "[?]", "[?]", "wa", "wu", "wi", "waa", "wee", "we", "wo", "[?]", "`a", "`u", "`i", "`aa", "`ee", "`e", "`o", "[?]", "za", "zu", "zi", "zaa", "zee", "ze", "zo", "zwa", "zha", "zhu", "zhi", "zhaa", "zhee", "zhe", "zho", "zhwa", "ya", "yu", "yi", "yaa", "yee", "ye", "yo", "[?]", "da", "du", "di", "daa", "dee", "de", "do", "dwa", "dda", "ddu", "ddi", "ddaa", "ddee", "dde", "ddo", "ddwa"];
  }
});

// node_modules/unidecode/data/x13.js
var require_x13 = __commonJS({
  "node_modules/unidecode/data/x13.js"(exports, module2) {
    module2.exports = ["ja", "ju", "ji", "jaa", "jee", "je", "jo", "jwa", "ga", "gu", "gi", "gaa", "gee", "ge", "go", "[?]", "gwa", "[?]", "gwi", "gwaa", "gwee", "gwe", "[?]", "[?]", "gga", "ggu", "ggi", "ggaa", "ggee", "gge", "ggo", "[?]", "tha", "thu", "thi", "thaa", "thee", "the", "tho", "thwa", "cha", "chu", "chi", "chaa", "chee", "che", "cho", "chwa", "pha", "phu", "phi", "phaa", "phee", "phe", "pho", "phwa", "tsa", "tsu", "tsi", "tsaa", "tsee", "tse", "tso", "tswa", "tza", "tzu", "tzi", "tzaa", "tzee", "tze", "tzo", "[?]", "fa", "fu", "fi", "faa", "fee", "fe", "fo", "fwa", "pa", "pu", "pi", "paa", "pee", "pe", "po", "pwa", "rya", "mya", "fya", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", " ", ".", ",", ";", ":", ":: ", "?", "//", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10+", "20+", "30+", "40+", "50+", "60+", "70+", "80+", "90+", "100+", "10,000+", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "a", "e", "i", "o", "u", "v", "ga", "ka", "ge", "gi", "go", "gu", "gv", "ha", "he", "hi", "ho", "hu", "hv", "la", "le", "li", "lo", "lu", "lv", "ma", "me", "mi", "mo", "mu", "na", "hna", "nah", "ne", "ni", "no", "nu", "nv", "qua", "que", "qui", "quo", "quu", "quv", "sa", "s", "se", "si", "so", "su", "sv", "da", "ta", "de", "te", "di", "ti", "do", "du", "dv", "dla", "tla", "tle", "tli", "tlo", "tlu", "tlv", "tsa", "tse", "tsi", "tso", "tsu", "tsv", "wa", "we", "wi", "wo", "wu", "wv", "ya", "ye", "yi", "yo", "yu", "yv", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x14.js
var require_x14 = __commonJS({
  "node_modules/unidecode/data/x14.js"(exports, module2) {
    module2.exports = ["[?]", "e", "aai", "i", "ii", "o", "oo", "oo", "ee", "i", "a", "aa", "we", "we", "wi", "wi", "wii", "wii", "wo", "wo", "woo", "woo", "woo", "wa", "wa", "waa", "waa", "waa", "ai", "w", "'", "t", "k", "sh", "s", "n", "w", "n", "[?]", "w", "c", "?", "l", "en", "in", "on", "an", "pe", "paai", "pi", "pii", "po", "poo", "poo", "hee", "hi", "pa", "paa", "pwe", "pwe", "pwi", "pwi", "pwii", "pwii", "pwo", "pwo", "pwoo", "pwoo", "pwa", "pwa", "pwaa", "pwaa", "pwaa", "p", "p", "h", "te", "taai", "ti", "tii", "to", "too", "too", "dee", "di", "ta", "taa", "twe", "twe", "twi", "twi", "twii", "twii", "two", "two", "twoo", "twoo", "twa", "twa", "twaa", "twaa", "twaa", "t", "tte", "tti", "tto", "tta", "ke", "kaai", "ki", "kii", "ko", "koo", "koo", "ka", "kaa", "kwe", "kwe", "kwi", "kwi", "kwii", "kwii", "kwo", "kwo", "kwoo", "kwoo", "kwa", "kwa", "kwaa", "kwaa", "kwaa", "k", "kw", "keh", "kih", "koh", "kah", "ce", "caai", "ci", "cii", "co", "coo", "coo", "ca", "caa", "cwe", "cwe", "cwi", "cwi", "cwii", "cwii", "cwo", "cwo", "cwoo", "cwoo", "cwa", "cwa", "cwaa", "cwaa", "cwaa", "c", "th", "me", "maai", "mi", "mii", "mo", "moo", "moo", "ma", "maa", "mwe", "mwe", "mwi", "mwi", "mwii", "mwii", "mwo", "mwo", "mwoo", "mwoo", "mwa", "mwa", "mwaa", "mwaa", "mwaa", "m", "m", "mh", "m", "m", "ne", "naai", "ni", "nii", "no", "noo", "noo", "na", "naa", "nwe", "nwe", "nwa", "nwa", "nwaa", "nwaa", "nwaa", "n", "ng", "nh", "le", "laai", "li", "lii", "lo", "loo", "loo", "la", "laa", "lwe", "lwe", "lwi", "lwi", "lwii", "lwii", "lwo", "lwo", "lwoo", "lwoo", "lwa", "lwa", "lwaa", "lwaa", "l", "l", "l", "se", "saai", "si", "sii", "so", "soo", "soo", "sa", "saa", "swe", "swe", "swi", "swi", "swii", "swii", "swo", "swo", "swoo", "swoo"];
  }
});

// node_modules/unidecode/data/x15.js
var require_x15 = __commonJS({
  "node_modules/unidecode/data/x15.js"(exports, module2) {
    module2.exports = ["swa", "swa", "swaa", "swaa", "swaa", "s", "s", "sw", "s", "sk", "skw", "sW", "spwa", "stwa", "skwa", "scwa", "she", "shi", "shii", "sho", "shoo", "sha", "shaa", "shwe", "shwe", "shwi", "shwi", "shwii", "shwii", "shwo", "shwo", "shwoo", "shwoo", "shwa", "shwa", "shwaa", "shwaa", "sh", "ye", "yaai", "yi", "yii", "yo", "yoo", "yoo", "ya", "yaa", "ywe", "ywe", "ywi", "ywi", "ywii", "ywii", "ywo", "ywo", "ywoo", "ywoo", "ywa", "ywa", "ywaa", "ywaa", "ywaa", "y", "y", "y", "yi", "re", "re", "le", "raai", "ri", "rii", "ro", "roo", "lo", "ra", "raa", "la", "rwaa", "rwaa", "r", "r", "r", "fe", "faai", "fi", "fii", "fo", "foo", "fa", "faa", "fwaa", "fwaa", "f", "the", "the", "thi", "thi", "thii", "thii", "tho", "thoo", "tha", "thaa", "thwaa", "thwaa", "th", "tthe", "tthi", "ttho", "ttha", "tth", "tye", "tyi", "tyo", "tya", "he", "hi", "hii", "ho", "hoo", "ha", "haa", "h", "h", "hk", "qaai", "qi", "qii", "qo", "qoo", "qa", "qaa", "q", "tlhe", "tlhi", "tlho", "tlha", "re", "ri", "ro", "ra", "ngaai", "ngi", "ngii", "ngo", "ngoo", "nga", "ngaa", "ng", "nng", "she", "shi", "sho", "sha", "the", "thi", "tho", "tha", "th", "lhi", "lhii", "lho", "lhoo", "lha", "lhaa", "lh", "the", "thi", "thii", "tho", "thoo", "tha", "thaa", "th", "b", "e", "i", "o", "a", "we", "wi", "wo", "wa", "ne", "ni", "no", "na", "ke", "ki", "ko", "ka", "he", "hi", "ho", "ha", "ghu", "gho", "ghe", "ghee", "ghi", "gha", "ru", "ro", "re", "ree", "ri", "ra", "wu", "wo", "we", "wee", "wi", "wa", "hwu", "hwo", "hwe", "hwee", "hwi", "hwa", "thu", "tho", "the", "thee", "thi", "tha", "ttu", "tto", "tte", "ttee", "tti", "tta", "pu", "po", "pe", "pee", "pi", "pa", "p", "gu", "go", "ge", "gee", "gi", "ga", "khu", "kho", "khe", "khee", "khi", "kha", "kku", "kko", "kke", "kkee", "kki"];
  }
});

// node_modules/unidecode/data/x16.js
var require_x16 = __commonJS({
  "node_modules/unidecode/data/x16.js"(exports, module2) {
    module2.exports = ["kka", "kk", "nu", "no", "ne", "nee", "ni", "na", "mu", "mo", "me", "mee", "mi", "ma", "yu", "yo", "ye", "yee", "yi", "ya", "ju", "ju", "jo", "je", "jee", "ji", "ji", "ja", "jju", "jjo", "jje", "jjee", "jji", "jja", "lu", "lo", "le", "lee", "li", "la", "dlu", "dlo", "dle", "dlee", "dli", "dla", "lhu", "lho", "lhe", "lhee", "lhi", "lha", "tlhu", "tlho", "tlhe", "tlhee", "tlhi", "tlha", "tlu", "tlo", "tle", "tlee", "tli", "tla", "zu", "zo", "ze", "zee", "zi", "za", "z", "z", "dzu", "dzo", "dze", "dzee", "dzi", "dza", "su", "so", "se", "see", "si", "sa", "shu", "sho", "she", "shee", "shi", "sha", "sh", "tsu", "tso", "tse", "tsee", "tsi", "tsa", "chu", "cho", "che", "chee", "chi", "cha", "ttsu", "ttso", "ttse", "ttsee", "ttsi", "ttsa", "X", ".", "qai", "ngai", "nngi", "nngii", "nngo", "nngoo", "nnga", "nngaa", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", " ", "b", "l", "f", "s", "n", "h", "d", "t", "c", "q", "m", "g", "ng", "z", "r", "a", "o", "u", "e", "i", "ch", "th", "ph", "p", "x", "p", "<", ">", "[?]", "[?]", "[?]", "f", "v", "u", "yr", "y", "w", "th", "th", "a", "o", "ac", "ae", "o", "o", "o", "oe", "on", "r", "k", "c", "k", "g", "ng", "g", "g", "w", "h", "h", "h", "h", "n", "n", "n", "i", "e", "j", "g", "ae", "a", "eo", "p", "z", "s", "s", "s", "c", "z", "t", "t", "d", "b", "b", "p", "p", "e", "m", "m", "m", "l", "l", "ng", "ng", "d", "o", "ear", "ior", "qu", "qu", "qu", "s", "yr", "yr", "yr", "q", "x", ".", ":", "+", "17", "18", "19", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x17.js
var require_x17 = __commonJS({
  "node_modules/unidecode/data/x17.js"(exports, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "k", "kh", "g", "gh", "ng", "c", "ch", "j", "jh", "ny", "t", "tth", "d", "ddh", "nn", "t", "th", "d", "dh", "n", "p", "ph", "b", "bh", "m", "y", "r", "l", "v", "sh", "ss", "s", "h", "l", "q", "a", "aa", "i", "ii", "u", "uk", "uu", "uuv", "ry", "ryy", "ly", "lyy", "e", "ai", "oo", "oo", "au", "a", "aa", "aa", "i", "ii", "y", "yy", "u", "uu", "ua", "oe", "ya", "ie", "e", "ae", "ai", "oo", "au", "M", "H", "a`", "", "", "", "r", "", "!", "", "", "", "", "", ".", " // ", ":", "+", "++", " * ", " /// ", "KR", "'", "[?]", "[?]", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x18.js
var require_x18 = __commonJS({
  "node_modules/unidecode/data/x18.js"(exports, module2) {
    module2.exports = [" @ ", " ... ", ", ", ". ", ": ", " // ", "", "-", ", ", ". ", "", "", "", "", "", "[?]", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "a", "e", "i", "o", "u", "O", "U", "ee", "n", "ng", "b", "p", "q", "g", "m", "l", "s", "sh", "t", "d", "ch", "j", "y", "r", "w", "f", "k", "kha", "ts", "z", "h", "zr", "lh", "zh", "ch", "-", "e", "i", "o", "u", "O", "U", "ng", "b", "p", "q", "g", "m", "t", "d", "ch", "j", "ts", "y", "w", "k", "g", "h", "jy", "ny", "dz", "e", "i", "iy", "U", "u", "ng", "k", "g", "h", "p", "sh", "t", "d", "j", "f", "g", "h", "ts", "z", "r", "ch", "zh", "i", "k", "r", "f", "zh", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "H", "X", "W", "M", " 3 ", " 333 ", "a", "i", "k", "ng", "c", "tt", "tth", "dd", "nn", "t", "d", "p", "ph", "ss", "zh", "z", "a", "t", "zh", "gh", "ng", "c", "jh", "tta", "ddh", "t", "dh", "ss", "cy", "zh", "z", "u", "y", "bh", "'", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x1e.js
var require_x1e = __commonJS({
  "node_modules/unidecode/data/x1e.js"(exports, module2) {
    module2.exports = ["A", "a", "B", "b", "B", "b", "B", "b", "C", "c", "D", "d", "D", "d", "D", "d", "D", "d", "D", "d", "E", "e", "E", "e", "E", "e", "E", "e", "E", "e", "F", "f", "G", "g", "H", "h", "H", "h", "H", "h", "H", "h", "H", "h", "I", "i", "I", "i", "K", "k", "K", "k", "K", "k", "L", "l", "L", "l", "L", "l", "L", "l", "M", "m", "M", "m", "M", "m", "N", "n", "N", "n", "N", "n", "N", "n", "O", "o", "O", "o", "O", "o", "O", "o", "P", "p", "P", "p", "R", "r", "R", "r", "R", "r", "R", "r", "S", "s", "S", "s", "S", "s", "S", "s", "S", "s", "T", "t", "T", "t", "T", "t", "T", "t", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "V", "v", "V", "v", "W", "w", "W", "w", "W", "w", "W", "w", "W", "w", "X", "x", "X", "x", "Y", "y", "Z", "z", "Z", "z", "Z", "z", "h", "t", "w", "y", "a", "S", "[?]", "[?]", "[?]", "[?]", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "A", "a", "E", "e", "E", "e", "E", "e", "E", "e", "E", "e", "E", "e", "E", "e", "E", "e", "I", "i", "I", "i", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "O", "o", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "U", "u", "Y", "y", "Y", "y", "Y", "y", "Y", "y", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x1f.js
var require_x1f = __commonJS({
  "node_modules/unidecode/data/x1f.js"(exports, module2) {
    module2.exports = ["a", "a", "a", "a", "a", "a", "a", "a", "A", "A", "A", "A", "A", "A", "A", "A", "e", "e", "e", "e", "e", "e", "[?]", "[?]", "E", "E", "E", "E", "E", "E", "[?]", "[?]", "e", "e", "e", "e", "e", "e", "e", "e", "E", "E", "E", "E", "E", "E", "E", "E", "i", "i", "i", "i", "i", "i", "i", "i", "I", "I", "I", "I", "I", "I", "I", "I", "o", "o", "o", "o", "o", "o", "[?]", "[?]", "O", "O", "O", "O", "O", "O", "[?]", "[?]", "u", "u", "u", "u", "u", "u", "u", "u", "[?]", "U", "[?]", "U", "[?]", "U", "[?]", "U", "o", "o", "o", "o", "o", "o", "o", "o", "O", "O", "O", "O", "O", "O", "O", "O", "a", "a", "e", "e", "e", "e", "i", "i", "o", "o", "u", "u", "o", "o", "[?]", "[?]", "a", "a", "a", "a", "a", "a", "a", "a", "A", "A", "A", "A", "A", "A", "A", "A", "e", "e", "e", "e", "e", "e", "e", "e", "E", "E", "E", "E", "E", "E", "E", "E", "o", "o", "o", "o", "o", "o", "o", "o", "O", "O", "O", "O", "O", "O", "O", "O", "a", "a", "a", "a", "a", "[?]", "a", "a", "A", "A", "A", "A", "A", "'", "i", "'", "~", '"~', "e", "e", "e", "[?]", "e", "e", "E", "E", "E", "E", "E", "'`", "''", "'~", "i", "i", "i", "i", "[?]", "[?]", "i", "i", "I", "I", "I", "I", "[?]", "`'", "`'", "`~", "u", "u", "u", "u", "R", "R", "u", "u", "U", "U", "U", "U", "R", '"`', `"'`, "`", "[?]", "[?]", "o", "o", "o", "[?]", "o", "o", "O", "O", "O", "O", "O", "'", "`"];
  }
});

// node_modules/unidecode/data/x20.js
var require_x20 = __commonJS({
  "node_modules/unidecode/data/x20.js"(exports, module2) {
    module2.exports = [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "", "", "", "", "-", "-", "-", "-", "--", "--", "||", "_", "'", "'", ",", "'", '"', '"', ",,", '"', "+", "++", "*", "*>", ".", "..", "...", ".", "\n", "\n\n", "", "", "", "", "", " ", "%0", "%00", "'", "''", "'''", "`", "``", "```", "^", "<", ">", "*", "!!", "!?", "-", "_", "-", "^", "***", "--", "/", "-[", "]-", "[?]", "?!", "!?", "7", "PP", "(]", "[)", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "0", "", "", "", "4", "5", "6", "7", "8", "9", "+", "-", "=", "(", ")", "n", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "-", "=", "(", ")", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "ECU", "CL", "Cr", "FF", "L", "mil", "N", "Pts", "Rs", "W", "NS", "D", "EU", "K", "T", "Dr", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x21.js
var require_x21 = __commonJS({
  "node_modules/unidecode/data/x21.js"(exports, module2) {
    module2.exports = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", " 1/3 ", " 2/3 ", " 1/5 ", " 2/5 ", " 3/5 ", " 4/5 ", " 1/6 ", " 5/6 ", " 1/8 ", " 3/8 ", " 5/8 ", " 7/8 ", " 1/", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX", "X", "XI", "XII", "L", "C", "D", "M", "i", "ii", "iii", "iv", "v", "vi", "vii", "viii", "ix", "x", "xi", "xii", "l", "c", "d", "m", "(D", "D)", "((|))", ")", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "-", "|", "-", "|", "-", "|", "\\", "/", "\\", "/", "-", "-", "~", "~", "-", "|", "-", "|", "-", "-", "-", "|", "-", "|", "|", "-", "-", "-", "-", "-", "-", "|", "|", "|", "|", "|", "|", "|", "^", "V", "\\", "=", "V", "^", "-", "-", "|", "|", "-", "-", "|", "|", "=", "|", "=", "=", "|", "=", "|", "=", "=", "=", "=", "=", "=", "|", "=", "|", "=", "|", "\\", "/", "\\", "/", "=", "=", "~", "~", "|", "|", "-", "|", "-", "|", "-", "-", "-", "|", "-", "|", "|", "|", "|", "|", "|", "|", "-", "\\", "\\", "|", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x22.js
var require_x22 = __commonJS({
  "node_modules/unidecode/data/x22.js"(exports, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x23.js
var require_x23 = __commonJS({
  "node_modules/unidecode/data/x23.js"(exports, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x24.js
var require_x24 = __commonJS({
  "node_modules/unidecode/data/x24.js"(exports, module2) {
    module2.exports = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x25.js
var require_x25 = __commonJS({
  "node_modules/unidecode/data/x25.js"(exports, module2) {
    module2.exports = ["-", "-", "|", "|", "-", "-", "|", "|", "-", "-", "|", "|", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "-", "-", "|", "|", "-", "|", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "+", "/", "\\", "X", "-", "|", "-", "|", "-", "|", "-", "|", "-", "|", "-", "|", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "-", "|", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "#", "^", "^", "^", "^", ">", ">", ">", ">", ">", ">", "V", "V", "V", "V", "<", "<", "<", "<", "<", "<", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "*", "#", "#", "#", "#", "#", "^", "^", "^", "O", "#", "#", "#", "#", "#", "#", "#", "#", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x26.js
var require_x26 = __commonJS({
  "node_modules/unidecode/data/x26.js"(exports, module2) {
    module2.exports = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x27.js
var require_x27 = __commonJS({
  "node_modules/unidecode/data/x27.js"(exports, module2) {
    module2.exports = ["[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x28.js
var require_x28 = __commonJS({
  "node_modules/unidecode/data/x28.js"(exports, module2) {
    module2.exports = [" ", "a", "1", "b", "'", "k", "2", "l", "@", "c", "i", "f", "/", "m", "s", "p", '"', "e", "3", "h", "9", "o", "6", "r", "^", "d", "j", "g", ">", "n", "t", "q", ",", "*", "5", "<", "-", "u", "8", "v", ".", "%", "[", "$", "+", "x", "!", "&", ";", ":", "4", "\\", "0", "z", "7", "(", "_", "?", "w", "]", "#", "y", ")", "=", "[d7]", "[d17]", "[d27]", "[d127]", "[d37]", "[d137]", "[d237]", "[d1237]", "[d47]", "[d147]", "[d247]", "[d1247]", "[d347]", "[d1347]", "[d2347]", "[d12347]", "[d57]", "[d157]", "[d257]", "[d1257]", "[d357]", "[d1357]", "[d2357]", "[d12357]", "[d457]", "[d1457]", "[d2457]", "[d12457]", "[d3457]", "[d13457]", "[d23457]", "[d123457]", "[d67]", "[d167]", "[d267]", "[d1267]", "[d367]", "[d1367]", "[d2367]", "[d12367]", "[d467]", "[d1467]", "[d2467]", "[d12467]", "[d3467]", "[d13467]", "[d23467]", "[d123467]", "[d567]", "[d1567]", "[d2567]", "[d12567]", "[d3567]", "[d13567]", "[d23567]", "[d123567]", "[d4567]", "[d14567]", "[d24567]", "[d124567]", "[d34567]", "[d134567]", "[d234567]", "[d1234567]", "[d8]", "[d18]", "[d28]", "[d128]", "[d38]", "[d138]", "[d238]", "[d1238]", "[d48]", "[d148]", "[d248]", "[d1248]", "[d348]", "[d1348]", "[d2348]", "[d12348]", "[d58]", "[d158]", "[d258]", "[d1258]", "[d358]", "[d1358]", "[d2358]", "[d12358]", "[d458]", "[d1458]", "[d2458]", "[d12458]", "[d3458]", "[d13458]", "[d23458]", "[d123458]", "[d68]", "[d168]", "[d268]", "[d1268]", "[d368]", "[d1368]", "[d2368]", "[d12368]", "[d468]", "[d1468]", "[d2468]", "[d12468]", "[d3468]", "[d13468]", "[d23468]", "[d123468]", "[d568]", "[d1568]", "[d2568]", "[d12568]", "[d3568]", "[d13568]", "[d23568]", "[d123568]", "[d4568]", "[d14568]", "[d24568]", "[d124568]", "[d34568]", "[d134568]", "[d234568]", "[d1234568]", "[d78]", "[d178]", "[d278]", "[d1278]", "[d378]", "[d1378]", "[d2378]", "[d12378]", "[d478]", "[d1478]", "[d2478]", "[d12478]", "[d3478]", "[d13478]", "[d23478]", "[d123478]", "[d578]", "[d1578]", "[d2578]", "[d12578]", "[d3578]", "[d13578]", "[d23578]", "[d123578]", "[d4578]", "[d14578]", "[d24578]", "[d124578]", "[d34578]", "[d134578]", "[d234578]", "[d1234578]", "[d678]", "[d1678]", "[d2678]", "[d12678]", "[d3678]", "[d13678]", "[d23678]", "[d123678]", "[d4678]", "[d14678]", "[d24678]", "[d124678]", "[d34678]", "[d134678]", "[d234678]", "[d1234678]", "[d5678]", "[d15678]", "[d25678]", "[d125678]", "[d35678]", "[d135678]", "[d235678]", "[d1235678]", "[d45678]", "[d145678]", "[d245678]", "[d1245678]", "[d345678]", "[d1345678]", "[d2345678]", "[d12345678]"];
  }
});

// node_modules/unidecode/data/x2e.js
var require_x2e = __commonJS({
  "node_modules/unidecode/data/x2e.js"(exports, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?]", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x2f.js
var require_x2f = __commonJS({
  "node_modules/unidecode/data/x2f.js"(exports, module2) {
    module2.exports = ["[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x30.js
var require_x30 = __commonJS({
  "node_modules/unidecode/data/x30.js"(exports, module2) {
    module2.exports = [" ", ", ", ". ", '"', "[JIS]", '"', "/", "0", "<", "> ", "<<", ">> ", "[", "] ", "{", "} ", "[(", ")] ", "@", "X ", "[", "] ", "[[", "]] ", "((", ")) ", "[[", "]] ", "~ ", "``", "''", ",,", "@", "1", "2", "3", "4", "5", "6", "7", "8", "9", "", "", "", "", "", "", "~", "+", "+", "+", "+", "", "@", " // ", "+10+", "+20+", "+30+", "[?]", "[?]", "[?]", "", "", "[?]", "a", "a", "i", "i", "u", "u", "e", "e", "o", "o", "ka", "ga", "ki", "gi", "ku", "gu", "ke", "ge", "ko", "go", "sa", "za", "si", "zi", "su", "zu", "se", "ze", "so", "zo", "ta", "da", "ti", "di", "tu", "tu", "du", "te", "de", "to", "do", "na", "ni", "nu", "ne", "no", "ha", "ba", "pa", "hi", "bi", "pi", "hu", "bu", "pu", "he", "be", "pe", "ho", "bo", "po", "ma", "mi", "mu", "me", "mo", "ya", "ya", "yu", "yu", "yo", "yo", "ra", "ri", "ru", "re", "ro", "wa", "wa", "wi", "we", "wo", "n", "vu", "[?]", "[?]", "[?]", "[?]", "", "", "", "", '"', '"', "[?]", "[?]", "a", "a", "i", "i", "u", "u", "e", "e", "o", "o", "ka", "ga", "ki", "gi", "ku", "gu", "ke", "ge", "ko", "go", "sa", "za", "si", "zi", "su", "zu", "se", "ze", "so", "zo", "ta", "da", "ti", "di", "tu", "tu", "du", "te", "de", "to", "do", "na", "ni", "nu", "ne", "no", "ha", "ba", "pa", "hi", "bi", "pi", "hu", "bu", "pu", "he", "be", "pe", "ho", "bo", "po", "ma", "mi", "mu", "me", "mo", "ya", "ya", "yu", "yu", "yo", "yo", "ra", "ri", "ru", "re", "ro", "wa", "wa", "wi", "we", "wo", "n", "vu", "ka", "ke", "va", "vi", "ve", "vo", "", "", '"', '"'];
  }
});

// node_modules/unidecode/data/x31.js
var require_x31 = __commonJS({
  "node_modules/unidecode/data/x31.js"(exports, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "B", "P", "M", "F", "D", "T", "N", "L", "G", "K", "H", "J", "Q", "X", "ZH", "CH", "SH", "R", "Z", "C", "S", "A", "O", "E", "EH", "AI", "EI", "AU", "OU", "AN", "EN", "ANG", "ENG", "ER", "I", "U", "IU", "V", "NG", "GN", "[?]", "[?]", "[?]", "[?]", "g", "gg", "gs", "n", "nj", "nh", "d", "dd", "r", "lg", "lm", "lb", "ls", "lt", "lp", "rh", "m", "b", "bb", "bs", "s", "ss", "", "j", "jj", "c", "k", "t", "p", "h", "a", "ae", "ya", "yae", "eo", "e", "yeo", "ye", "o", "wa", "wae", "oe", "yo", "u", "weo", "we", "wi", "yu", "eu", "yi", "i", "", "nn", "nd", "ns", "nZ", "lgs", "ld", "lbs", "lZ", "lQ", "mb", "ms", "mZ", "mN", "bg", "", "bsg", "bst", "bj", "bt", "bN", "bbN", "sg", "sn", "sd", "sb", "sj", "Z", "", "N", "Ns", "NZ", "pN", "hh", "Q", "yo-ya", "yo-yae", "yo-i", "yu-yeo", "yu-ye", "yu-i", "U", "U-i", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "BU", "ZI", "JI", "GU", "EE", "ENN", "OO", "ONN", "IR", "ANN", "INN", "UNN", "IM", "NGG", "AINN", "AUNN", "AM", "OM", "ONG", "INNN", "P", "T", "K", "H", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x32.js
var require_x32 = __commonJS({
  "node_modules/unidecode/data/x32.js"(exports, module2) {
    module2.exports = ["(g)", "(n)", "(d)", "(r)", "(m)", "(b)", "(s)", "()", "(j)", "(c)", "(k)", "(t)", "(p)", "(h)", "(ga)", "(na)", "(da)", "(ra)", "(ma)", "(ba)", "(sa)", "(a)", "(ja)", "(ca)", "(ka)", "(ta)", "(pa)", "(ha)", "(ju)", "[?]", "[?]", "[?]", "(1) ", "(2) ", "(3) ", "(4) ", "(5) ", "(6) ", "(7) ", "(8) ", "(9) ", "(10) ", "(Yue) ", "(Huo) ", "(Shui) ", "(Mu) ", "(Jin) ", "(Tu) ", "(Ri) ", "(Zhu) ", "(You) ", "(She) ", "(Ming) ", "(Te) ", "(Cai) ", "(Zhu) ", "(Lao) ", "(Dai) ", "(Hu) ", "(Xue) ", "(Jian) ", "(Qi) ", "(Zi) ", "(Xie) ", "(Ji) ", "(Xiu) ", "<<", ">>", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "(g)", "(n)", "(d)", "(r)", "(m)", "(b)", "(s)", "()", "(j)", "(c)", "(k)", "(t)", "(p)", "(h)", "(ga)", "(na)", "(da)", "(ra)", "(ma)", "(ba)", "(sa)", "(a)", "(ja)", "(ca)", "(ka)", "(ta)", "(pa)", "(ha)", "[?]", "[?]", "[?]", "KIS ", "(1) ", "(2) ", "(3) ", "(4) ", "(5) ", "(6) ", "(7) ", "(8) ", "(9) ", "(10) ", "(Yue) ", "(Huo) ", "(Shui) ", "(Mu) ", "(Jin) ", "(Tu) ", "(Ri) ", "(Zhu) ", "(You) ", "(She) ", "(Ming) ", "(Te) ", "(Cai) ", "(Zhu) ", "(Lao) ", "(Mi) ", "(Nan) ", "(Nu) ", "(Shi) ", "(You) ", "(Yin) ", "(Zhu) ", "(Xiang) ", "(Xiu) ", "(Xie) ", "(Zheng) ", "(Shang) ", "(Zhong) ", "(Xia) ", "(Zuo) ", "(You) ", "(Yi) ", "(Zong) ", "(Xue) ", "(Jian) ", "(Qi) ", "(Zi) ", "(Xie) ", "(Ye) ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "1M", "2M", "3M", "4M", "5M", "6M", "7M", "8M", "9M", "10M", "11M", "12M", "[?]", "[?]", "[?]", "[?]", "a", "i", "u", "u", "o", "ka", "ki", "ku", "ke", "ko", "sa", "si", "su", "se", "so", "ta", "ti", "tu", "te", "to", "na", "ni", "nu", "ne", "no", "ha", "hi", "hu", "he", "ho", "ma", "mi", "mu", "me", "mo", "ya", "yu", "yo", "ra", "ri", "ru", "re", "ro", "wa", "wi", "we", "wo"];
  }
});

// node_modules/unidecode/data/x33.js
var require_x33 = __commonJS({
  "node_modules/unidecode/data/x33.js"(exports, module2) {
    module2.exports = ["apartment", "alpha", "ampere", "are", "inning", "inch", "won", "escudo", "acre", "ounce", "ohm", "kai-ri", "carat", "calorie", "gallon", "gamma", "giga", "guinea", "curie", "guilder", "kilo", "kilogram", "kilometer", "kilowatt", "gram", "gram ton", "cruzeiro", "krone", "case", "koruna", "co-op", "cycle", "centime", "shilling", "centi", "cent", "dozen", "desi", "dollar", "ton", "nano", "knot", "heights", "percent", "parts", "barrel", "piaster", "picul", "pico", "building", "farad", "feet", "bushel", "franc", "hectare", "peso", "pfennig", "hertz", "pence", "page", "beta", "point", "volt", "hon", "pound", "hall", "horn", "micro", "mile", "mach", "mark", "mansion", "micron", "milli", "millibar", "mega", "megaton", "meter", "yard", "yard", "yuan", "liter", "lira", "rupee", "ruble", "rem", "roentgen", "watt", "0h", "1h", "2h", "3h", "4h", "5h", "6h", "7h", "8h", "9h", "10h", "11h", "12h", "13h", "14h", "15h", "16h", "17h", "18h", "19h", "20h", "21h", "22h", "23h", "24h", "HPA", "da", "AU", "bar", "oV", "pc", "[?]", "[?]", "[?]", "[?]", "Heisei", "Syouwa", "Taisyou", "Meiji", "Inc.", "pA", "nA", "microamp", "mA", "kA", "kB", "MB", "GB", "cal", "kcal", "pF", "nF", "microFarad", "microgram", "mg", "kg", "Hz", "kHz", "MHz", "GHz", "THz", "microliter", "ml", "dl", "kl", "fm", "nm", "micrometer", "mm", "cm", "km", "mm^2", "cm^2", "m^2", "km^2", "mm^4", "cm^3", "m^3", "km^3", "m/s", "m/s^2", "Pa", "kPa", "MPa", "GPa", "rad", "rad/s", "rad/s^2", "ps", "ns", "microsecond", "ms", "pV", "nV", "microvolt", "mV", "kV", "MV", "pW", "nW", "microwatt", "mW", "kW", "MW", "kOhm", "MOhm", "a.m.", "Bq", "cc", "cd", "C/kg", "Co.", "dB", "Gy", "ha", "HP", "in", "K.K.", "KM", "kt", "lm", "ln", "log", "lx", "mb", "mil", "mol", "pH", "p.m.", "PPM", "PR", "sr", "Sv", "Wb", "[?]", "[?]", "1d", "2d", "3d", "4d", "5d", "6d", "7d", "8d", "9d", "10d", "11d", "12d", "13d", "14d", "15d", "16d", "17d", "18d", "19d", "20d", "21d", "22d", "23d", "24d", "25d", "26d", "27d", "28d", "29d", "30d", "31d"];
  }
});

// node_modules/unidecode/data/x4d.js
var require_x4d = __commonJS({
  "node_modules/unidecode/data/x4d.js"(exports, module2) {
    module2.exports = ["[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?] ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/x4e.js
var require_x4e = __commonJS({
  "node_modules/unidecode/data/x4e.js"(exports, module2) {
    module2.exports = ["Yi ", "Ding ", "Kao ", "Qi ", "Shang ", "Xia ", "[?] ", "Mo ", "Zhang ", "San ", "Shang ", "Xia ", "Ji ", "Bu ", "Yu ", "Mian ", "Gai ", "Chou ", "Chou ", "Zhuan ", "Qie ", "Pi ", "Shi ", "Shi ", "Qiu ", "Bing ", "Ye ", "Cong ", "Dong ", "Si ", "Cheng ", "Diu ", "Qiu ", "Liang ", "Diu ", "You ", "Liang ", "Yan ", "Bing ", "Sang ", "Gun ", "Jiu ", "Ge ", "Ya ", "Qiang ", "Zhong ", "Ji ", "Jie ", "Feng ", "Guan ", "Chuan ", "Chan ", "Lin ", "Zhuo ", "Zhu ", "Ha ", "Wan ", "Dan ", "Wei ", "Zhu ", "Jing ", "Li ", "Ju ", "Pie ", "Fu ", "Yi ", "Yi ", "Nai ", "Shime ", "Jiu ", "Jiu ", "Zhe ", "Yao ", "Yi ", "[?] ", "Zhi ", "Wu ", "Zha ", "Hu ", "Fa ", "Le ", "Zhong ", "Ping ", "Pang ", "Qiao ", "Hu ", "Guai ", "Cheng ", "Cheng ", "Yi ", "Yin ", "[?] ", "Mie ", "Jiu ", "Qi ", "Ye ", "Xi ", "Xiang ", "Gai ", "Diu ", "Hal ", "[?] ", "Shu ", "Twul ", "Shi ", "Ji ", "Nang ", "Jia ", "Kel ", "Shi ", "[?] ", "Ol ", "Mai ", "Luan ", "Cal ", "Ru ", "Xue ", "Yan ", "Fu ", "Sha ", "Na ", "Gan ", "Sol ", "El ", "Cwul ", "[?] ", "Gan ", "Chi ", "Gui ", "Gan ", "Luan ", "Lin ", "Yi ", "Jue ", "Liao ", "Ma ", "Yu ", "Zheng ", "Shi ", "Shi ", "Er ", "Chu ", "Yu ", "Yu ", "Yu ", "Yun ", "Hu ", "Qi ", "Wu ", "Jing ", "Si ", "Sui ", "Gen ", "Gen ", "Ya ", "Xie ", "Ya ", "Qi ", "Ya ", "Ji ", "Tou ", "Wang ", "Kang ", "Ta ", "Jiao ", "Hai ", "Yi ", "Chan ", "Heng ", "Mu ", "[?] ", "Xiang ", "Jing ", "Ting ", "Liang ", "Xiang ", "Jing ", "Ye ", "Qin ", "Bo ", "You ", "Xie ", "Dan ", "Lian ", "Duo ", "Wei ", "Ren ", "Ren ", "Ji ", "La ", "Wang ", "Yi ", "Shi ", "Ren ", "Le ", "Ding ", "Ze ", "Jin ", "Pu ", "Chou ", "Ba ", "Zhang ", "Jin ", "Jie ", "Bing ", "Reng ", "Cong ", "Fo ", "San ", "Lun ", "Sya ", "Cang ", "Zi ", "Shi ", "Ta ", "Zhang ", "Fu ", "Xian ", "Xian ", "Tuo ", "Hong ", "Tong ", "Ren ", "Qian ", "Gan ", "Yi ", "Di ", "Dai ", "Ling ", "Yi ", "Chao ", "Chang ", "Sa ", "[?] ", "Yi ", "Mu ", "Men ", "Ren ", "Jia ", "Chao ", "Yang ", "Qian ", "Zhong ", "Pi ", "Wan ", "Wu ", "Jian ", "Jie ", "Yao ", "Feng ", "Cang ", "Ren ", "Wang ", "Fen ", "Di ", "Fang "];
  }
});

// node_modules/unidecode/data/x4f.js
var require_x4f = __commonJS({
  "node_modules/unidecode/data/x4f.js"(exports, module2) {
    module2.exports = ["Zhong ", "Qi ", "Pei ", "Yu ", "Diao ", "Dun ", "Wen ", "Yi ", "Xin ", "Kang ", "Yi ", "Ji ", "Ai ", "Wu ", "Ji ", "Fu ", "Fa ", "Xiu ", "Jin ", "Bei ", "Dan ", "Fu ", "Tang ", "Zhong ", "You ", "Huo ", "Hui ", "Yu ", "Cui ", "Chuan ", "San ", "Wei ", "Chuan ", "Che ", "Ya ", "Xian ", "Shang ", "Chang ", "Lun ", "Cang ", "Xun ", "Xin ", "Wei ", "Zhu ", "[?] ", "Xuan ", "Nu ", "Bo ", "Gu ", "Ni ", "Ni ", "Xie ", "Ban ", "Xu ", "Ling ", "Zhou ", "Shen ", "Qu ", "Si ", "Beng ", "Si ", "Jia ", "Pi ", "Yi ", "Si ", "Ai ", "Zheng ", "Dian ", "Han ", "Mai ", "Dan ", "Zhu ", "Bu ", "Qu ", "Bi ", "Shao ", "Ci ", "Wei ", "Di ", "Zhu ", "Zuo ", "You ", "Yang ", "Ti ", "Zhan ", "He ", "Bi ", "Tuo ", "She ", "Yu ", "Yi ", "Fo ", "Zuo ", "Kou ", "Ning ", "Tong ", "Ni ", "Xuan ", "Qu ", "Yong ", "Wa ", "Qian ", "[?] ", "Ka ", "[?] ", "Pei ", "Huai ", "He ", "Lao ", "Xiang ", "Ge ", "Yang ", "Bai ", "Fa ", "Ming ", "Jia ", "Er ", "Bing ", "Ji ", "Hen ", "Huo ", "Gui ", "Quan ", "Tiao ", "Jiao ", "Ci ", "Yi ", "Shi ", "Xing ", "Shen ", "Tuo ", "Kan ", "Zhi ", "Gai ", "Lai ", "Yi ", "Chi ", "Kua ", "Guang ", "Li ", "Yin ", "Shi ", "Mi ", "Zhu ", "Xu ", "You ", "An ", "Lu ", "Mou ", "Er ", "Lun ", "Tong ", "Cha ", "Chi ", "Xun ", "Gong ", "Zhou ", "Yi ", "Ru ", "Jian ", "Xia ", "Jia ", "Zai ", "Lu ", "Ko ", "Jiao ", "Zhen ", "Ce ", "Qiao ", "Kuai ", "Chai ", "Ning ", "Nong ", "Jin ", "Wu ", "Hou ", "Jiong ", "Cheng ", "Zhen ", "Zuo ", "Chou ", "Qin ", "Lu ", "Ju ", "Shu ", "Ting ", "Shen ", "Tuo ", "Bo ", "Nan ", "Hao ", "Bian ", "Tui ", "Yu ", "Xi ", "Cu ", "E ", "Qiu ", "Xu ", "Kuang ", "Ku ", "Wu ", "Jun ", "Yi ", "Fu ", "Lang ", "Zu ", "Qiao ", "Li ", "Yong ", "Hun ", "Jing ", "Xian ", "San ", "Pai ", "Su ", "Fu ", "Xi ", "Li ", "Fu ", "Ping ", "Bao ", "Yu ", "Si ", "Xia ", "Xin ", "Xiu ", "Yu ", "Ti ", "Che ", "Chou ", "[?] ", "Yan ", "Lia ", "Li ", "Lai ", "[?] ", "Jian ", "Xiu ", "Fu ", "He ", "Ju ", "Xiao ", "Pai ", "Jian ", "Biao ", "Chu ", "Fei ", "Feng ", "Ya ", "An ", "Bei ", "Yu ", "Xin ", "Bi ", "Jian "];
  }
});

// node_modules/unidecode/data/x50.js
var require_x50 = __commonJS({
  "node_modules/unidecode/data/x50.js"(exports, module2) {
    module2.exports = ["Chang ", "Chi ", "Bing ", "Zan ", "Yao ", "Cui ", "Lia ", "Wan ", "Lai ", "Cang ", "Zong ", "Ge ", "Guan ", "Bei ", "Tian ", "Shu ", "Shu ", "Men ", "Dao ", "Tan ", "Jue ", "Chui ", "Xing ", "Peng ", "Tang ", "Hou ", "Yi ", "Qi ", "Ti ", "Gan ", "Jing ", "Jie ", "Sui ", "Chang ", "Jie ", "Fang ", "Zhi ", "Kong ", "Juan ", "Zong ", "Ju ", "Qian ", "Ni ", "Lun ", "Zhuo ", "Wei ", "Luo ", "Song ", "Leng ", "Hun ", "Dong ", "Zi ", "Ben ", "Wu ", "Ju ", "Nai ", "Cai ", "Jian ", "Zhai ", "Ye ", "Zhi ", "Sha ", "Qing ", "[?] ", "Ying ", "Cheng ", "Jian ", "Yan ", "Nuan ", "Zhong ", "Chun ", "Jia ", "Jie ", "Wei ", "Yu ", "Bing ", "Ruo ", "Ti ", "Wei ", "Pian ", "Yan ", "Feng ", "Tang ", "Wo ", "E ", "Xie ", "Che ", "Sheng ", "Kan ", "Di ", "Zuo ", "Cha ", "Ting ", "Bei ", "Ye ", "Huang ", "Yao ", "Zhan ", "Chou ", "Yan ", "You ", "Jian ", "Xu ", "Zha ", "Ci ", "Fu ", "Bi ", "Zhi ", "Zong ", "Mian ", "Ji ", "Yi ", "Xie ", "Xun ", "Si ", "Duan ", "Ce ", "Zhen ", "Ou ", "Tou ", "Tou ", "Bei ", "Za ", "Lu ", "Jie ", "Wei ", "Fen ", "Chang ", "Gui ", "Sou ", "Zhi ", "Su ", "Xia ", "Fu ", "Yuan ", "Rong ", "Li ", "Ru ", "Yun ", "Gou ", "Ma ", "Bang ", "Dian ", "Tang ", "Hao ", "Jie ", "Xi ", "Shan ", "Qian ", "Jue ", "Cang ", "Chu ", "San ", "Bei ", "Xiao ", "Yong ", "Yao ", "Tan ", "Suo ", "Yang ", "Fa ", "Bing ", "Jia ", "Dai ", "Zai ", "Tang ", "[?] ", "Bin ", "Chu ", "Nuo ", "Can ", "Lei ", "Cui ", "Yong ", "Zao ", "Zong ", "Peng ", "Song ", "Ao ", "Chuan ", "Yu ", "Zhai ", "Cou ", "Shang ", "Qiang ", "Jing ", "Chi ", "Sha ", "Han ", "Zhang ", "Qing ", "Yan ", "Di ", "Xi ", "Lu ", "Bei ", "Piao ", "Jin ", "Lian ", "Lu ", "Man ", "Qian ", "Xian ", "Tan ", "Ying ", "Dong ", "Zhuan ", "Xiang ", "Shan ", "Qiao ", "Jiong ", "Tui ", "Zun ", "Pu ", "Xi ", "Lao ", "Chang ", "Guang ", "Liao ", "Qi ", "Deng ", "Chan ", "Wei ", "Ji ", "Fan ", "Hui ", "Chuan ", "Jian ", "Dan ", "Jiao ", "Jiu ", "Seng ", "Fen ", "Xian ", "Jue ", "E ", "Jiao ", "Jian ", "Tong ", "Lin ", "Bo ", "Gu ", "[?] ", "Su ", "Xian ", "Jiang ", "Min ", "Ye ", "Jin ", "Jia ", "Qiao ", "Pi ", "Feng ", "Zhou ", "Ai ", "Sai "];
  }
});

// node_modules/unidecode/data/x51.js
var require_x51 = __commonJS({
  "node_modules/unidecode/data/x51.js"(exports, module2) {
    module2.exports = ["Yi ", "Jun ", "Nong ", "Chan ", "Yi ", "Dang ", "Jing ", "Xuan ", "Kuai ", "Jian ", "Chu ", "Dan ", "Jiao ", "Sha ", "Zai ", "[?] ", "Bin ", "An ", "Ru ", "Tai ", "Chou ", "Chai ", "Lan ", "Ni ", "Jin ", "Qian ", "Meng ", "Wu ", "Ning ", "Qiong ", "Ni ", "Chang ", "Lie ", "Lei ", "Lu ", "Kuang ", "Bao ", "Du ", "Biao ", "Zan ", "Zhi ", "Si ", "You ", "Hao ", "Chen ", "Chen ", "Li ", "Teng ", "Wei ", "Long ", "Chu ", "Chan ", "Rang ", "Shu ", "Hui ", "Li ", "Luo ", "Zan ", "Nuo ", "Tang ", "Yan ", "Lei ", "Nang ", "Er ", "Wu ", "Yun ", "Zan ", "Yuan ", "Xiong ", "Chong ", "Zhao ", "Xiong ", "Xian ", "Guang ", "Dui ", "Ke ", "Dui ", "Mian ", "Tu ", "Chang ", "Er ", "Dui ", "Er ", "Xin ", "Tu ", "Si ", "Yan ", "Yan ", "Shi ", "Shi ", "Dang ", "Qian ", "Dou ", "Fen ", "Mao ", "Shen ", "Dou ", "Bai ", "Jing ", "Li ", "Huang ", "Ru ", "Wang ", "Nei ", "Quan ", "Liang ", "Yu ", "Ba ", "Gong ", "Liu ", "Xi ", "[?] ", "Lan ", "Gong ", "Tian ", "Guan ", "Xing ", "Bing ", "Qi ", "Ju ", "Dian ", "Zi ", "Ppwun ", "Yang ", "Jian ", "Shou ", "Ji ", "Yi ", "Ji ", "Chan ", "Jiong ", "Mao ", "Ran ", "Nei ", "Yuan ", "Mao ", "Gang ", "Ran ", "Ce ", "Jiong ", "Ce ", "Zai ", "Gua ", "Jiong ", "Mao ", "Zhou ", "Mou ", "Gou ", "Xu ", "Mian ", "Mi ", "Rong ", "Yin ", "Xie ", "Kan ", "Jun ", "Nong ", "Yi ", "Mi ", "Shi ", "Guan ", "Meng ", "Zhong ", "Ju ", "Yuan ", "Ming ", "Kou ", "Lam ", "Fu ", "Xie ", "Mi ", "Bing ", "Dong ", "Tai ", "Gang ", "Feng ", "Bing ", "Hu ", "Chong ", "Jue ", "Hu ", "Kuang ", "Ye ", "Leng ", "Pan ", "Fu ", "Min ", "Dong ", "Xian ", "Lie ", "Xia ", "Jian ", "Jing ", "Shu ", "Mei ", "Tu ", "Qi ", "Gu ", "Zhun ", "Song ", "Jing ", "Liang ", "Qing ", "Diao ", "Ling ", "Dong ", "Gan ", "Jian ", "Yin ", "Cou ", "Yi ", "Li ", "Cang ", "Ming ", "Zhuen ", "Cui ", "Si ", "Duo ", "Jin ", "Lin ", "Lin ", "Ning ", "Xi ", "Du ", "Ji ", "Fan ", "Fan ", "Fan ", "Feng ", "Ju ", "Chu ", "Tako ", "Feng ", "Mok ", "Ci ", "Fu ", "Feng ", "Ping ", "Feng ", "Kai ", "Huang ", "Kai ", "Gan ", "Deng ", "Ping ", "Qu ", "Xiong ", "Kuai ", "Tu ", "Ao ", "Chu ", "Ji ", "Dang ", "Han ", "Han ", "Zao "];
  }
});

// node_modules/unidecode/data/x52.js
var require_x52 = __commonJS({
  "node_modules/unidecode/data/x52.js"(exports, module2) {
    module2.exports = ["Dao ", "Diao ", "Dao ", "Ren ", "Ren ", "Chuang ", "Fen ", "Qie ", "Yi ", "Ji ", "Kan ", "Qian ", "Cun ", "Chu ", "Wen ", "Ji ", "Dan ", "Xing ", "Hua ", "Wan ", "Jue ", "Li ", "Yue ", "Lie ", "Liu ", "Ze ", "Gang ", "Chuang ", "Fu ", "Chu ", "Qu ", "Ju ", "Shan ", "Min ", "Ling ", "Zhong ", "Pan ", "Bie ", "Jie ", "Jie ", "Bao ", "Li ", "Shan ", "Bie ", "Chan ", "Jing ", "Gua ", "Gen ", "Dao ", "Chuang ", "Kui ", "Ku ", "Duo ", "Er ", "Zhi ", "Shua ", "Quan ", "Cha ", "Ci ", "Ke ", "Jie ", "Gui ", "Ci ", "Gui ", "Kai ", "Duo ", "Ji ", "Ti ", "Jing ", "Lou ", "Gen ", "Ze ", "Yuan ", "Cuo ", "Xue ", "Ke ", "La ", "Qian ", "Cha ", "Chuang ", "Gua ", "Jian ", "Cuo ", "Li ", "Ti ", "Fei ", "Pou ", "Chan ", "Qi ", "Chuang ", "Zi ", "Gang ", "Wan ", "Bo ", "Ji ", "Duo ", "Qing ", "Yan ", "Zhuo ", "Jian ", "Ji ", "Bo ", "Yan ", "Ju ", "Huo ", "Sheng ", "Jian ", "Duo ", "Duan ", "Wu ", "Gua ", "Fu ", "Sheng ", "Jian ", "Ge ", "Zha ", "Kai ", "Chuang ", "Juan ", "Chan ", "Tuan ", "Lu ", "Li ", "Fou ", "Shan ", "Piao ", "Kou ", "Jiao ", "Gua ", "Qiao ", "Jue ", "Hua ", "Zha ", "Zhuo ", "Lian ", "Ju ", "Pi ", "Liu ", "Gui ", "Jiao ", "Gui ", "Jian ", "Jian ", "Tang ", "Huo ", "Ji ", "Jian ", "Yi ", "Jian ", "Zhi ", "Chan ", "Cuan ", "Mo ", "Li ", "Zhu ", "Li ", "Ya ", "Quan ", "Ban ", "Gong ", "Jia ", "Wu ", "Mai ", "Lie ", "Jin ", "Keng ", "Xie ", "Zhi ", "Dong ", "Zhu ", "Nu ", "Jie ", "Qu ", "Shao ", "Yi ", "Zhu ", "Miao ", "Li ", "Jing ", "Lao ", "Lao ", "Juan ", "Kou ", "Yang ", "Wa ", "Xiao ", "Mou ", "Kuang ", "Jie ", "Lie ", "He ", "Shi ", "Ke ", "Jing ", "Hao ", "Bo ", "Min ", "Chi ", "Lang ", "Yong ", "Yong ", "Mian ", "Ke ", "Xun ", "Juan ", "Qing ", "Lu ", "Pou ", "Meng ", "Lai ", "Le ", "Kai ", "Mian ", "Dong ", "Xu ", "Xu ", "Kan ", "Wu ", "Yi ", "Xun ", "Weng ", "Sheng ", "Lao ", "Mu ", "Lu ", "Piao ", "Shi ", "Ji ", "Qin ", "Qiang ", "Jiao ", "Quan ", "Yang ", "Yi ", "Jue ", "Fan ", "Juan ", "Tong ", "Ju ", "Dan ", "Xie ", "Mai ", "Xun ", "Xun ", "Lu ", "Li ", "Che ", "Rang ", "Quan ", "Bao ", "Shao ", "Yun ", "Jiu ", "Bao ", "Gou ", "Wu "];
  }
});

// node_modules/unidecode/data/x53.js
var require_x53 = __commonJS({
  "node_modules/unidecode/data/x53.js"(exports, module2) {
    module2.exports = ["Yun ", "Mwun ", "Nay ", "Gai ", "Gai ", "Bao ", "Cong ", "[?] ", "Xiong ", "Peng ", "Ju ", "Tao ", "Ge ", "Pu ", "An ", "Pao ", "Fu ", "Gong ", "Da ", "Jiu ", "Qiong ", "Bi ", "Hua ", "Bei ", "Nao ", "Chi ", "Fang ", "Jiu ", "Yi ", "Za ", "Jiang ", "Kang ", "Jiang ", "Kuang ", "Hu ", "Xia ", "Qu ", "Bian ", "Gui ", "Qie ", "Zang ", "Kuang ", "Fei ", "Hu ", "Tou ", "Gui ", "Gui ", "Hui ", "Dan ", "Gui ", "Lian ", "Lian ", "Suan ", "Du ", "Jiu ", "Qu ", "Xi ", "Pi ", "Qu ", "Yi ", "Qia ", "Yan ", "Bian ", "Ni ", "Qu ", "Shi ", "Xin ", "Qian ", "Nian ", "Sa ", "Zu ", "Sheng ", "Wu ", "Hui ", "Ban ", "Shi ", "Xi ", "Wan ", "Hua ", "Xie ", "Wan ", "Bei ", "Zu ", "Zhuo ", "Xie ", "Dan ", "Mai ", "Nan ", "Dan ", "Ji ", "Bo ", "Shuai ", "Bu ", "Kuang ", "Bian ", "Bu ", "Zhan ", "Qia ", "Lu ", "You ", "Lu ", "Xi ", "Gua ", "Wo ", "Xie ", "Jie ", "Jie ", "Wei ", "Ang ", "Qiong ", "Zhi ", "Mao ", "Yin ", "Wei ", "Shao ", "Ji ", "Que ", "Luan ", "Shi ", "Juan ", "Xie ", "Xu ", "Jin ", "Que ", "Wu ", "Ji ", "E ", "Qing ", "Xi ", "[?] ", "Han ", "Zhan ", "E ", "Ting ", "Li ", "Zhe ", "Han ", "Li ", "Ya ", "Ya ", "Yan ", "She ", "Zhi ", "Zha ", "Pang ", "[?] ", "He ", "Ya ", "Zhi ", "Ce ", "Pang ", "Ti ", "Li ", "She ", "Hou ", "Ting ", "Zui ", "Cuo ", "Fei ", "Yuan ", "Ce ", "Yuan ", "Xiang ", "Yan ", "Li ", "Jue ", "Sha ", "Dian ", "Chu ", "Jiu ", "Qin ", "Ao ", "Gui ", "Yan ", "Si ", "Li ", "Chang ", "Lan ", "Li ", "Yan ", "Yan ", "Yuan ", "Si ", "Gong ", "Lin ", "Qiu ", "Qu ", "Qu ", "Uk ", "Lei ", "Du ", "Xian ", "Zhuan ", "San ", "Can ", "Can ", "Can ", "Can ", "Ai ", "Dai ", "You ", "Cha ", "Ji ", "You ", "Shuang ", "Fan ", "Shou ", "Guai ", "Ba ", "Fa ", "Ruo ", "Shi ", "Shu ", "Zhuo ", "Qu ", "Shou ", "Bian ", "Xu ", "Jia ", "Pan ", "Sou ", "Gao ", "Wei ", "Sou ", "Die ", "Rui ", "Cong ", "Kou ", "Gu ", "Ju ", "Ling ", "Gua ", "Tao ", "Kou ", "Zhi ", "Jiao ", "Zhao ", "Ba ", "Ding ", "Ke ", "Tai ", "Chi ", "Shi ", "You ", "Qiu ", "Po ", "Xie ", "Hao ", "Si ", "Tan ", "Chi ", "Le ", "Diao ", "Ji ", "[?] ", "Hong "];
  }
});

// node_modules/unidecode/data/x54.js
var require_x54 = __commonJS({
  "node_modules/unidecode/data/x54.js"(exports, module2) {
    module2.exports = ["Mie ", "Xu ", "Mang ", "Chi ", "Ge ", "Xuan ", "Yao ", "Zi ", "He ", "Ji ", "Diao ", "Cun ", "Tong ", "Ming ", "Hou ", "Li ", "Tu ", "Xiang ", "Zha ", "Xia ", "Ye ", "Lu ", "A ", "Ma ", "Ou ", "Xue ", "Yi ", "Jun ", "Chou ", "Lin ", "Tun ", "Yin ", "Fei ", "Bi ", "Qin ", "Qin ", "Jie ", "Bu ", "Fou ", "Ba ", "Dun ", "Fen ", "E ", "Han ", "Ting ", "Hang ", "Shun ", "Qi ", "Hong ", "Zhi ", "Shen ", "Wu ", "Wu ", "Chao ", "Ne ", "Xue ", "Xi ", "Chui ", "Dou ", "Wen ", "Hou ", "Ou ", "Wu ", "Gao ", "Ya ", "Jun ", "Lu ", "E ", "Ge ", "Mei ", "Ai ", "Qi ", "Cheng ", "Wu ", "Gao ", "Fu ", "Jiao ", "Hong ", "Chi ", "Sheng ", "Ne ", "Tun ", "Fu ", "Yi ", "Dai ", "Ou ", "Li ", "Bai ", "Yuan ", "Kuai ", "[?] ", "Qiang ", "Wu ", "E ", "Shi ", "Quan ", "Pen ", "Wen ", "Ni ", "M ", "Ling ", "Ran ", "You ", "Di ", "Zhou ", "Shi ", "Zhou ", "Tie ", "Xi ", "Yi ", "Qi ", "Ping ", "Zi ", "Gu ", "Zi ", "Wei ", "Xu ", "He ", "Nao ", "Xia ", "Pei ", "Yi ", "Xiao ", "Shen ", "Hu ", "Ming ", "Da ", "Qu ", "Ju ", "Gem ", "Za ", "Tuo ", "Duo ", "Pou ", "Pao ", "Bi ", "Fu ", "Yang ", "He ", "Zha ", "He ", "Hai ", "Jiu ", "Yong ", "Fu ", "Que ", "Zhou ", "Wa ", "Ka ", "Gu ", "Ka ", "Zuo ", "Bu ", "Long ", "Dong ", "Ning ", "Tha ", "Si ", "Xian ", "Huo ", "Qi ", "Er ", "E ", "Guang ", "Zha ", "Xi ", "Yi ", "Lie ", "Zi ", "Mie ", "Mi ", "Zhi ", "Yao ", "Ji ", "Zhou ", "Ge ", "Shuai ", "Zan ", "Xiao ", "Ke ", "Hui ", "Kua ", "Huai ", "Tao ", "Xian ", "E ", "Xuan ", "Xiu ", "Wai ", "Yan ", "Lao ", "Yi ", "Ai ", "Pin ", "Shen ", "Tong ", "Hong ", "Xiong ", "Chi ", "Wa ", "Ha ", "Zai ", "Yu ", "Di ", "Pai ", "Xiang ", "Ai ", "Hen ", "Kuang ", "Ya ", "Da ", "Xiao ", "Bi ", "Yue ", "[?] ", "Hua ", "Sasou ", "Kuai ", "Duo ", "[?] ", "Ji ", "Nong ", "Mou ", "Yo ", "Hao ", "Yuan ", "Long ", "Pou ", "Mang ", "Ge ", "E ", "Chi ", "Shao ", "Li ", "Na ", "Zu ", "He ", "Ku ", "Xiao ", "Xian ", "Lao ", "Bo ", "Zhe ", "Zha ", "Liang ", "Ba ", "Mie ", "Le ", "Sui ", "Fou ", "Bu ", "Han ", "Heng ", "Geng ", "Shuo ", "Ge "];
  }
});

// node_modules/unidecode/data/x55.js
var require_x55 = __commonJS({
  "node_modules/unidecode/data/x55.js"(exports, module2) {
    module2.exports = ["You ", "Yan ", "Gu ", "Gu ", "Bai ", "Han ", "Suo ", "Chun ", "Yi ", "Ai ", "Jia ", "Tu ", "Xian ", "Huan ", "Li ", "Xi ", "Tang ", "Zuo ", "Qiu ", "Che ", "Wu ", "Zao ", "Ya ", "Dou ", "Qi ", "Di ", "Qin ", "Ma ", "Mal ", "Hong ", "Dou ", "Kes ", "Lao ", "Liang ", "Suo ", "Zao ", "Huan ", "Lang ", "Sha ", "Ji ", "Zuo ", "Wo ", "Feng ", "Yin ", "Hu ", "Qi ", "Shou ", "Wei ", "Shua ", "Chang ", "Er ", "Li ", "Qiang ", "An ", "Jie ", "Yo ", "Nian ", "Yu ", "Tian ", "Lai ", "Sha ", "Xi ", "Tuo ", "Hu ", "Ai ", "Zhou ", "Nou ", "Ken ", "Zhuo ", "Zhuo ", "Shang ", "Di ", "Heng ", "Lan ", "A ", "Xiao ", "Xiang ", "Tun ", "Wu ", "Wen ", "Cui ", "Sha ", "Hu ", "Qi ", "Qi ", "Tao ", "Dan ", "Dan ", "Ye ", "Zi ", "Bi ", "Cui ", "Chuo ", "He ", "Ya ", "Qi ", "Zhe ", "Pei ", "Liang ", "Xian ", "Pi ", "Sha ", "La ", "Ze ", "Qing ", "Gua ", "Pa ", "Zhe ", "Se ", "Zhuan ", "Nie ", "Guo ", "Luo ", "Yan ", "Di ", "Quan ", "Tan ", "Bo ", "Ding ", "Lang ", "Xiao ", "[?] ", "Tang ", "Chi ", "Ti ", "An ", "Jiu ", "Dan ", "Ke ", "Yong ", "Wei ", "Nan ", "Shan ", "Yu ", "Zhe ", "La ", "Jie ", "Hou ", "Han ", "Die ", "Zhou ", "Chai ", "Wai ", "Re ", "Yu ", "Yin ", "Zan ", "Yao ", "Wo ", "Mian ", "Hu ", "Yun ", "Chuan ", "Hui ", "Huan ", "Huan ", "Xi ", "He ", "Ji ", "Kui ", "Zhong ", "Wei ", "Sha ", "Xu ", "Huang ", "Du ", "Nie ", "Xuan ", "Liang ", "Yu ", "Sang ", "Chi ", "Qiao ", "Yan ", "Dan ", "Pen ", "Can ", "Li ", "Yo ", "Zha ", "Wei ", "Miao ", "Ying ", "Pen ", "Phos ", "Kui ", "Xi ", "Yu ", "Jie ", "Lou ", "Ku ", "Sao ", "Huo ", "Ti ", "Yao ", "He ", "A ", "Xiu ", "Qiang ", "Se ", "Yong ", "Su ", "Hong ", "Xie ", "Yi ", "Suo ", "Ma ", "Cha ", "Hai ", "Ke ", "Ta ", "Sang ", "Tian ", "Ru ", "Sou ", "Wa ", "Ji ", "Pang ", "Wu ", "Xian ", "Shi ", "Ge ", "Zi ", "Jie ", "Luo ", "Weng ", "Wa ", "Si ", "Chi ", "Hao ", "Suo ", "Jia ", "Hai ", "Suo ", "Qin ", "Nie ", "He ", "Cis ", "Sai ", "Ng ", "Ge ", "Na ", "Dia ", "Ai ", "[?] ", "Tong ", "Bi ", "Ao ", "Ao ", "Lian ", "Cui ", "Zhe ", "Mo ", "Sou ", "Sou ", "Tan "];
  }
});

// node_modules/unidecode/data/x56.js
var require_x56 = __commonJS({
  "node_modules/unidecode/data/x56.js"(exports, module2) {
    module2.exports = ["Di ", "Qi ", "Jiao ", "Chong ", "Jiao ", "Kai ", "Tan ", "San ", "Cao ", "Jia ", "Ai ", "Xiao ", "Piao ", "Lou ", "Ga ", "Gu ", "Xiao ", "Hu ", "Hui ", "Guo ", "Ou ", "Xian ", "Ze ", "Chang ", "Xu ", "Po ", "De ", "Ma ", "Ma ", "Hu ", "Lei ", "Du ", "Ga ", "Tang ", "Ye ", "Beng ", "Ying ", "Saai ", "Jiao ", "Mi ", "Xiao ", "Hua ", "Mai ", "Ran ", "Zuo ", "Peng ", "Lao ", "Xiao ", "Ji ", "Zhu ", "Chao ", "Kui ", "Zui ", "Xiao ", "Si ", "Hao ", "Fu ", "Liao ", "Qiao ", "Xi ", "Xiu ", "Tan ", "Tan ", "Mo ", "Xun ", "E ", "Zun ", "Fan ", "Chi ", "Hui ", "Zan ", "Chuang ", "Cu ", "Dan ", "Yu ", "Tun ", "Cheng ", "Jiao ", "Ye ", "Xi ", "Qi ", "Hao ", "Lian ", "Xu ", "Deng ", "Hui ", "Yin ", "Pu ", "Jue ", "Qin ", "Xun ", "Nie ", "Lu ", "Si ", "Yan ", "Ying ", "Da ", "Dan ", "Yu ", "Zhou ", "Jin ", "Nong ", "Yue ", "Hui ", "Qi ", "E ", "Zao ", "Yi ", "Shi ", "Jiao ", "Yuan ", "Ai ", "Yong ", "Jue ", "Kuai ", "Yu ", "Pen ", "Dao ", "Ge ", "Xin ", "Dun ", "Dang ", "Sin ", "Sai ", "Pi ", "Pi ", "Yin ", "Zui ", "Ning ", "Di ", "Lan ", "Ta ", "Huo ", "Ru ", "Hao ", "Xia ", "Ya ", "Duo ", "Xi ", "Chou ", "Ji ", "Jin ", "Hao ", "Ti ", "Chang ", "[?] ", "[?] ", "Ca ", "Ti ", "Lu ", "Hui ", "Bo ", "You ", "Nie ", "Yin ", "Hu ", "Mo ", "Huang ", "Zhe ", "Li ", "Liu ", "Haai ", "Nang ", "Xiao ", "Mo ", "Yan ", "Li ", "Lu ", "Long ", "Fu ", "Dan ", "Chen ", "Pin ", "Pi ", "Xiang ", "Huo ", "Mo ", "Xi ", "Duo ", "Ku ", "Yan ", "Chan ", "Ying ", "Rang ", "Dian ", "La ", "Ta ", "Xiao ", "Jiao ", "Chuo ", "Huan ", "Huo ", "Zhuan ", "Nie ", "Xiao ", "Ca ", "Li ", "Chan ", "Chai ", "Li ", "Yi ", "Luo ", "Nang ", "Zan ", "Su ", "Xi ", "So ", "Jian ", "Za ", "Zhu ", "Lan ", "Nie ", "Nang ", "[?] ", "[?] ", "Wei ", "Hui ", "Yin ", "Qiu ", "Si ", "Nin ", "Jian ", "Hui ", "Xin ", "Yin ", "Nan ", "Tuan ", "Tuan ", "Dun ", "Kang ", "Yuan ", "Jiong ", "Pian ", "Yun ", "Cong ", "Hu ", "Hui ", "Yuan ", "You ", "Guo ", "Kun ", "Cong ", "Wei ", "Tu ", "Wei ", "Lun ", "Guo ", "Qun ", "Ri ", "Ling ", "Gu ", "Guo ", "Tai ", "Guo ", "Tu ", "You "];
  }
});

// node_modules/unidecode/data/x57.js
var require_x57 = __commonJS({
  "node_modules/unidecode/data/x57.js"(exports, module2) {
    module2.exports = ["Guo ", "Yin ", "Hun ", "Pu ", "Yu ", "Han ", "Yuan ", "Lun ", "Quan ", "Yu ", "Qing ", "Guo ", "Chuan ", "Wei ", "Yuan ", "Quan ", "Ku ", "Fu ", "Yuan ", "Yuan ", "E ", "Tu ", "Tu ", "Tu ", "Tuan ", "Lue ", "Hui ", "Yi ", "Yuan ", "Luan ", "Luan ", "Tu ", "Ya ", "Tu ", "Ting ", "Sheng ", "Pu ", "Lu ", "Iri ", "Ya ", "Zai ", "Wei ", "Ge ", "Yu ", "Wu ", "Gui ", "Pi ", "Yi ", "Di ", "Qian ", "Qian ", "Zhen ", "Zhuo ", "Dang ", "Qia ", "Akutsu ", "Yama ", "Kuang ", "Chang ", "Qi ", "Nie ", "Mo ", "Ji ", "Jia ", "Zhi ", "Zhi ", "Ban ", "Xun ", "Tou ", "Qin ", "Fen ", "Jun ", "Keng ", "Tun ", "Fang ", "Fen ", "Ben ", "Tan ", "Kan ", "Pi ", "Zuo ", "Keng ", "Bi ", "Xing ", "Di ", "Jing ", "Ji ", "Kuai ", "Di ", "Jing ", "Jian ", "Tan ", "Li ", "Ba ", "Wu ", "Fen ", "Zhui ", "Po ", "Pan ", "Tang ", "Kun ", "Qu ", "Tan ", "Zhi ", "Tuo ", "Gan ", "Ping ", "Dian ", "Gua ", "Ni ", "Tai ", "Pi ", "Jiong ", "Yang ", "Fo ", "Ao ", "Liu ", "Qiu ", "Mu ", "Ke ", "Gou ", "Xue ", "Ba ", "Chi ", "Che ", "Ling ", "Zhu ", "Fu ", "Hu ", "Zhi ", "Chui ", "La ", "Long ", "Long ", "Lu ", "Ao ", "Tay ", "Pao ", "[?] ", "Xing ", "Dong ", "Ji ", "Ke ", "Lu ", "Ci ", "Chi ", "Lei ", "Gai ", "Yin ", "Hou ", "Dui ", "Zhao ", "Fu ", "Guang ", "Yao ", "Duo ", "Duo ", "Gui ", "Cha ", "Yang ", "Yin ", "Fa ", "Gou ", "Yuan ", "Die ", "Xie ", "Ken ", "Jiong ", "Shou ", "E ", "Ha ", "Dian ", "Hong ", "Wu ", "Kua ", "[?] ", "Tao ", "Dang ", "Kai ", "Gake ", "Nao ", "An ", "Xing ", "Xian ", "Huan ", "Bang ", "Pei ", "Ba ", "Yi ", "Yin ", "Han ", "Xu ", "Chui ", "Cen ", "Geng ", "Ai ", "Peng ", "Fang ", "Que ", "Yong ", "Xun ", "Jia ", "Di ", "Mai ", "Lang ", "Xuan ", "Cheng ", "Yan ", "Jin ", "Zhe ", "Lei ", "Lie ", "Bu ", "Cheng ", "Gomi ", "Bu ", "Shi ", "Xun ", "Guo ", "Jiong ", "Ye ", "Nian ", "Di ", "Yu ", "Bu ", "Ya ", "Juan ", "Sui ", "Pi ", "Cheng ", "Wan ", "Ju ", "Lun ", "Zheng ", "Kong ", "Chong ", "Dong ", "Dai ", "Tan ", "An ", "Cai ", "Shu ", "Beng ", "Kan ", "Zhi ", "Duo ", "Yi ", "Zhi ", "Yi ", "Pei ", "Ji ", "Zhun ", "Qi ", "Sao ", "Ju ", "Ni "];
  }
});

// node_modules/unidecode/data/x58.js
var require_x58 = __commonJS({
  "node_modules/unidecode/data/x58.js"(exports, module2) {
    module2.exports = ["Ku ", "Ke ", "Tang ", "Kun ", "Ni ", "Jian ", "Dui ", "Jin ", "Gang ", "Yu ", "E ", "Peng ", "Gu ", "Tu ", "Leng ", "[?] ", "Ya ", "Qian ", "[?] ", "An ", "[?] ", "Duo ", "Nao ", "Tu ", "Cheng ", "Yin ", "Hun ", "Bi ", "Lian ", "Guo ", "Die ", "Zhuan ", "Hou ", "Bao ", "Bao ", "Yu ", "Di ", "Mao ", "Jie ", "Ruan ", "E ", "Geng ", "Kan ", "Zong ", "Yu ", "Huang ", "E ", "Yao ", "Yan ", "Bao ", "Ji ", "Mei ", "Chang ", "Du ", "Tuo ", "Yin ", "Feng ", "Zhong ", "Jie ", "Zhen ", "Feng ", "Gang ", "Chuan ", "Jian ", "Pyeng ", "Toride ", "Xiang ", "Huang ", "Leng ", "Duan ", "[?] ", "Xuan ", "Ji ", "Ji ", "Kuai ", "Ying ", "Ta ", "Cheng ", "Yong ", "Kai ", "Su ", "Su ", "Shi ", "Mi ", "Ta ", "Weng ", "Cheng ", "Tu ", "Tang ", "Que ", "Zhong ", "Li ", "Peng ", "Bang ", "Sai ", "Zang ", "Dui ", "Tian ", "Wu ", "Cheng ", "Xun ", "Ge ", "Zhen ", "Ai ", "Gong ", "Yan ", "Kan ", "Tian ", "Yuan ", "Wen ", "Xie ", "Liu ", "Ama ", "Lang ", "Chang ", "Peng ", "Beng ", "Chen ", "Cu ", "Lu ", "Ou ", "Qian ", "Mei ", "Mo ", "Zhuan ", "Shuang ", "Shu ", "Lou ", "Chi ", "Man ", "Biao ", "Jing ", "Qi ", "Shu ", "Di ", "Zhang ", "Kan ", "Yong ", "Dian ", "Chen ", "Zhi ", "Xi ", "Guo ", "Qiang ", "Jin ", "Di ", "Shang ", "Mu ", "Cui ", "Yan ", "Ta ", "Zeng ", "Qi ", "Qiang ", "Liang ", "[?] ", "Zhui ", "Qiao ", "Zeng ", "Xu ", "Shan ", "Shan ", "Ba ", "Pu ", "Kuai ", "Dong ", "Fan ", "Que ", "Mo ", "Dun ", "Dun ", "Dun ", "Di ", "Sheng ", "Duo ", "Duo ", "Tan ", "Deng ", "Wu ", "Fen ", "Huang ", "Tan ", "Da ", "Ye ", "Sho ", "Mama ", "Yu ", "Qiang ", "Ji ", "Qiao ", "Ken ", "Yi ", "Pi ", "Bi ", "Dian ", "Jiang ", "Ye ", "Yong ", "Bo ", "Tan ", "Lan ", "Ju ", "Huai ", "Dang ", "Rang ", "Qian ", "Xun ", "Lan ", "Xi ", "He ", "Ai ", "Ya ", "Dao ", "Hao ", "Ruan ", "Mama ", "Lei ", "Kuang ", "Lu ", "Yan ", "Tan ", "Wei ", "Huai ", "Long ", "Long ", "Rui ", "Li ", "Lin ", "Rang ", "Ten ", "Xun ", "Yan ", "Lei ", "Ba ", "[?] ", "Shi ", "Ren ", "[?] ", "Zhuang ", "Zhuang ", "Sheng ", "Yi ", "Mai ", "Ke ", "Zhu ", "Zhuang ", "Hu ", "Hu ", "Kun ", "Yi ", "Hu ", "Xu ", "Kun ", "Shou ", "Mang ", "Zun "];
  }
});

// node_modules/unidecode/data/x59.js
var require_x59 = __commonJS({
  "node_modules/unidecode/data/x59.js"(exports, module2) {
    module2.exports = ["Shou ", "Yi ", "Zhi ", "Gu ", "Chu ", "Jiang ", "Feng ", "Bei ", "Cay ", "Bian ", "Sui ", "Qun ", "Ling ", "Fu ", "Zuo ", "Xia ", "Xiong ", "[?] ", "Nao ", "Xia ", "Kui ", "Xi ", "Wai ", "Yuan ", "Mao ", "Su ", "Duo ", "Duo ", "Ye ", "Qing ", "Uys ", "Gou ", "Gou ", "Qi ", "Meng ", "Meng ", "Yin ", "Huo ", "Chen ", "Da ", "Ze ", "Tian ", "Tai ", "Fu ", "Guai ", "Yao ", "Yang ", "Hang ", "Gao ", "Shi ", "Ben ", "Tai ", "Tou ", "Yan ", "Bi ", "Yi ", "Kua ", "Jia ", "Duo ", "Kwu ", "Kuang ", "Yun ", "Jia ", "Pa ", "En ", "Lian ", "Huan ", "Di ", "Yan ", "Pao ", "Quan ", "Qi ", "Nai ", "Feng ", "Xie ", "Fen ", "Dian ", "[?] ", "Kui ", "Zou ", "Huan ", "Qi ", "Kai ", "Zha ", "Ben ", "Yi ", "Jiang ", "Tao ", "Zang ", "Ben ", "Xi ", "Xiang ", "Fei ", "Diao ", "Xun ", "Keng ", "Dian ", "Ao ", "She ", "Weng ", "Pan ", "Ao ", "Wu ", "Ao ", "Jiang ", "Lian ", "Duo ", "Yun ", "Jiang ", "Shi ", "Fen ", "Huo ", "Bi ", "Lian ", "Duo ", "Nu ", "Nu ", "Ding ", "Nai ", "Qian ", "Jian ", "Ta ", "Jiu ", "Nan ", "Cha ", "Hao ", "Xian ", "Fan ", "Ji ", "Shuo ", "Ru ", "Fei ", "Wang ", "Hong ", "Zhuang ", "Fu ", "Ma ", "Dan ", "Ren ", "Fu ", "Jing ", "Yan ", "Xie ", "Wen ", "Zhong ", "Pa ", "Du ", "Ji ", "Keng ", "Zhong ", "Yao ", "Jin ", "Yun ", "Miao ", "Pei ", "Shi ", "Yue ", "Zhuang ", "Niu ", "Yan ", "Na ", "Xin ", "Fen ", "Bi ", "Yu ", "Tuo ", "Feng ", "Yuan ", "Fang ", "Wu ", "Yu ", "Gui ", "Du ", "Ba ", "Ni ", "Zhou ", "Zhuo ", "Zhao ", "Da ", "Nai ", "Yuan ", "Tou ", "Xuan ", "Zhi ", "E ", "Mei ", "Mo ", "Qi ", "Bi ", "Shen ", "Qie ", "E ", "He ", "Xu ", "Fa ", "Zheng ", "Min ", "Ban ", "Mu ", "Fu ", "Ling ", "Zi ", "Zi ", "Shi ", "Ran ", "Shan ", "Yang ", "Man ", "Jie ", "Gu ", "Si ", "Xing ", "Wei ", "Zi ", "Ju ", "Shan ", "Pin ", "Ren ", "Yao ", "Tong ", "Jiang ", "Shu ", "Ji ", "Gai ", "Shang ", "Kuo ", "Juan ", "Jiao ", "Gou ", "Mu ", "Jian ", "Jian ", "Yi ", "Nian ", "Zhi ", "Ji ", "Ji ", "Xian ", "Heng ", "Guang ", "Jun ", "Kua ", "Yan ", "Ming ", "Lie ", "Pei ", "Yan ", "You ", "Yan ", "Cha ", "Shen ", "Yin ", "Chi ", "Gui ", "Quan ", "Zi "];
  }
});

// node_modules/unidecode/data/x5a.js
var require_x5a = __commonJS({
  "node_modules/unidecode/data/x5a.js"(exports, module2) {
    module2.exports = ["Song ", "Wei ", "Hong ", "Wa ", "Lou ", "Ya ", "Rao ", "Jiao ", "Luan ", "Ping ", "Xian ", "Shao ", "Li ", "Cheng ", "Xiao ", "Mang ", "Fu ", "Suo ", "Wu ", "Wei ", "Ke ", "Lai ", "Chuo ", "Ding ", "Niang ", "Xing ", "Nan ", "Yu ", "Nuo ", "Pei ", "Nei ", "Juan ", "Shen ", "Zhi ", "Han ", "Di ", "Zhuang ", "E ", "Pin ", "Tui ", "Han ", "Mian ", "Wu ", "Yan ", "Wu ", "Xi ", "Yan ", "Yu ", "Si ", "Yu ", "Wa ", "[?] ", "Xian ", "Ju ", "Qu ", "Shui ", "Qi ", "Xian ", "Zhui ", "Dong ", "Chang ", "Lu ", "Ai ", "E ", "E ", "Lou ", "Mian ", "Cong ", "Pou ", "Ju ", "Po ", "Cai ", "Ding ", "Wan ", "Biao ", "Xiao ", "Shu ", "Qi ", "Hui ", "Fu ", "E ", "Wo ", "Tan ", "Fei ", "Wei ", "Jie ", "Tian ", "Ni ", "Quan ", "Jing ", "Hun ", "Jing ", "Qian ", "Dian ", "Xing ", "Hu ", "Wa ", "Lai ", "Bi ", "Yin ", "Chou ", "Chuo ", "Fu ", "Jing ", "Lun ", "Yan ", "Lan ", "Kun ", "Yin ", "Ya ", "Ju ", "Li ", "Dian ", "Xian ", "Hwa ", "Hua ", "Ying ", "Chan ", "Shen ", "Ting ", "Dang ", "Yao ", "Wu ", "Nan ", "Ruo ", "Jia ", "Tou ", "Xu ", "Yu ", "Wei ", "Ti ", "Rou ", "Mei ", "Dan ", "Ruan ", "Qin ", "Hui ", "Wu ", "Qian ", "Chun ", "Mao ", "Fu ", "Jie ", "Duan ", "Xi ", "Zhong ", "Mei ", "Huang ", "Mian ", "An ", "Ying ", "Xuan ", "Jie ", "Wei ", "Mei ", "Yuan ", "Zhen ", "Qiu ", "Ti ", "Xie ", "Tuo ", "Lian ", "Mao ", "Ran ", "Si ", "Pian ", "Wei ", "Wa ", "Jiu ", "Hu ", "Ao ", "[?] ", "Bou ", "Xu ", "Tou ", "Gui ", "Zou ", "Yao ", "Pi ", "Xi ", "Yuan ", "Ying ", "Rong ", "Ru ", "Chi ", "Liu ", "Mei ", "Pan ", "Ao ", "Ma ", "Gou ", "Kui ", "Qin ", "Jia ", "Sao ", "Zhen ", "Yuan ", "Cha ", "Yong ", "Ming ", "Ying ", "Ji ", "Su ", "Niao ", "Xian ", "Tao ", "Pang ", "Lang ", "Nao ", "Bao ", "Ai ", "Pi ", "Pin ", "Yi ", "Piao ", "Yu ", "Lei ", "Xuan ", "Man ", "Yi ", "Zhang ", "Kang ", "Yong ", "Ni ", "Li ", "Di ", "Gui ", "Yan ", "Jin ", "Zhuan ", "Chang ", "Ce ", "Han ", "Nen ", "Lao ", "Mo ", "Zhe ", "Hu ", "Hu ", "Ao ", "Nen ", "Qiang ", "Ma ", "Pie ", "Gu ", "Wu ", "Jiao ", "Tuo ", "Zhan ", "Mao ", "Xian ", "Xian ", "Mo ", "Liao ", "Lian ", "Hua "];
  }
});

// node_modules/unidecode/data/x5b.js
var require_x5b = __commonJS({
  "node_modules/unidecode/data/x5b.js"(exports, module2) {
    module2.exports = ["Gui ", "Deng ", "Zhi ", "Xu ", "Yi ", "Hua ", "Xi ", "Hui ", "Rao ", "Xi ", "Yan ", "Chan ", "Jiao ", "Mei ", "Fan ", "Fan ", "Xian ", "Yi ", "Wei ", "Jiao ", "Fu ", "Shi ", "Bi ", "Shan ", "Sui ", "Qiang ", "Lian ", "Huan ", "Xin ", "Niao ", "Dong ", "Yi ", "Can ", "Ai ", "Niang ", "Neng ", "Ma ", "Tiao ", "Chou ", "Jin ", "Ci ", "Yu ", "Pin ", "Yong ", "Xu ", "Nai ", "Yan ", "Tai ", "Ying ", "Can ", "Niao ", "Wo ", "Ying ", "Mian ", "Kaka ", "Ma ", "Shen ", "Xing ", "Ni ", "Du ", "Liu ", "Yuan ", "Lan ", "Yan ", "Shuang ", "Ling ", "Jiao ", "Niang ", "Lan ", "Xian ", "Ying ", "Shuang ", "Shuai ", "Quan ", "Mi ", "Li ", "Luan ", "Yan ", "Zhu ", "Lan ", "Zi ", "Jie ", "Jue ", "Jue ", "Kong ", "Yun ", "Zi ", "Zi ", "Cun ", "Sun ", "Fu ", "Bei ", "Zi ", "Xiao ", "Xin ", "Meng ", "Si ", "Tai ", "Bao ", "Ji ", "Gu ", "Nu ", "Xue ", "[?] ", "Zhuan ", "Hai ", "Luan ", "Sun ", "Huai ", "Mie ", "Cong ", "Qian ", "Shu ", "Chan ", "Ya ", "Zi ", "Ni ", "Fu ", "Zi ", "Li ", "Xue ", "Bo ", "Ru ", "Lai ", "Nie ", "Nie ", "Ying ", "Luan ", "Mian ", "Zhu ", "Rong ", "Ta ", "Gui ", "Zhai ", "Qiong ", "Yu ", "Shou ", "An ", "Tu ", "Song ", "Wan ", "Rou ", "Yao ", "Hong ", "Yi ", "Jing ", "Zhun ", "Mi ", "Zhu ", "Dang ", "Hong ", "Zong ", "Guan ", "Zhou ", "Ding ", "Wan ", "Yi ", "Bao ", "Shi ", "Shi ", "Chong ", "Shen ", "Ke ", "Xuan ", "Shi ", "You ", "Huan ", "Yi ", "Tiao ", "Shi ", "Xian ", "Gong ", "Cheng ", "Qun ", "Gong ", "Xiao ", "Zai ", "Zha ", "Bao ", "Hai ", "Yan ", "Xiao ", "Jia ", "Shen ", "Chen ", "Rong ", "Huang ", "Mi ", "Kou ", "Kuan ", "Bin ", "Su ", "Cai ", "Zan ", "Ji ", "Yuan ", "Ji ", "Yin ", "Mi ", "Kou ", "Qing ", "Que ", "Zhen ", "Jian ", "Fu ", "Ning ", "Bing ", "Huan ", "Mei ", "Qin ", "Han ", "Yu ", "Shi ", "Ning ", "Qin ", "Ning ", "Zhi ", "Yu ", "Bao ", "Kuan ", "Ning ", "Qin ", "Mo ", "Cha ", "Ju ", "Gua ", "Qin ", "Hu ", "Wu ", "Liao ", "Shi ", "Zhu ", "Zhai ", "Shen ", "Wei ", "Xie ", "Kuan ", "Hui ", "Liao ", "Jun ", "Huan ", "Yi ", "Yi ", "Bao ", "Qin ", "Chong ", "Bao ", "Feng ", "Cun ", "Dui ", "Si ", "Xun ", "Dao ", "Lu ", "Dui ", "Shou "];
  }
});

// node_modules/unidecode/data/x5c.js
var require_x5c = __commonJS({
  "node_modules/unidecode/data/x5c.js"(exports, module2) {
    module2.exports = ["Po ", "Feng ", "Zhuan ", "Fu ", "She ", "Ke ", "Jiang ", "Jiang ", "Zhuan ", "Wei ", "Zun ", "Xun ", "Shu ", "Dui ", "Dao ", "Xiao ", "Ji ", "Shao ", "Er ", "Er ", "Er ", "Ga ", "Jian ", "Shu ", "Chen ", "Shang ", "Shang ", "Mo ", "Ga ", "Chang ", "Liao ", "Xian ", "Xian ", "[?] ", "Wang ", "Wang ", "You ", "Liao ", "Liao ", "Yao ", "Mang ", "Wang ", "Wang ", "Wang ", "Ga ", "Yao ", "Duo ", "Kui ", "Zhong ", "Jiu ", "Gan ", "Gu ", "Gan ", "Tui ", "Gan ", "Gan ", "Shi ", "Yin ", "Chi ", "Kao ", "Ni ", "Jin ", "Wei ", "Niao ", "Ju ", "Pi ", "Ceng ", "Xi ", "Bi ", "Ju ", "Jie ", "Tian ", "Qu ", "Ti ", "Jie ", "Wu ", "Diao ", "Shi ", "Shi ", "Ping ", "Ji ", "Xie ", "Chen ", "Xi ", "Ni ", "Zhan ", "Xi ", "[?] ", "Man ", "E ", "Lou ", "Ping ", "Ti ", "Fei ", "Shu ", "Xie ", "Tu ", "Lu ", "Lu ", "Xi ", "Ceng ", "Lu ", "Ju ", "Xie ", "Ju ", "Jue ", "Liao ", "Jue ", "Shu ", "Xi ", "Che ", "Tun ", "Ni ", "Shan ", "[?] ", "Xian ", "Li ", "Xue ", "Nata ", "[?] ", "Long ", "Yi ", "Qi ", "Ren ", "Wu ", "Han ", "Shen ", "Yu ", "Chu ", "Sui ", "Qi ", "[?] ", "Yue ", "Ban ", "Yao ", "Ang ", "Ya ", "Wu ", "Jie ", "E ", "Ji ", "Qian ", "Fen ", "Yuan ", "Qi ", "Cen ", "Qian ", "Qi ", "Cha ", "Jie ", "Qu ", "Gang ", "Xian ", "Ao ", "Lan ", "Dao ", "Ba ", "Zuo ", "Zuo ", "Yang ", "Ju ", "Gang ", "Ke ", "Gou ", "Xue ", "Bei ", "Li ", "Tiao ", "Ju ", "Yan ", "Fu ", "Xiu ", "Jia ", "Ling ", "Tuo ", "Pei ", "You ", "Dai ", "Kuang ", "Yue ", "Qu ", "Hu ", "Po ", "Min ", "An ", "Tiao ", "Ling ", "Chi ", "Yuri ", "Dong ", "Cem ", "Kui ", "Xiu ", "Mao ", "Tong ", "Xue ", "Yi ", "Kura ", "He ", "Ke ", "Luo ", "E ", "Fu ", "Xun ", "Die ", "Lu ", "An ", "Er ", "Gai ", "Quan ", "Tong ", "Yi ", "Mu ", "Shi ", "An ", "Wei ", "Hu ", "Zhi ", "Mi ", "Li ", "Ji ", "Tong ", "Wei ", "You ", "Sang ", "Xia ", "Li ", "Yao ", "Jiao ", "Zheng ", "Luan ", "Jiao ", "E ", "E ", "Yu ", "Ye ", "Bu ", "Qiao ", "Qun ", "Feng ", "Feng ", "Nao ", "Li ", "You ", "Xian ", "Hong ", "Dao ", "Shen ", "Cheng ", "Tu ", "Geng ", "Jun ", "Hao ", "Xia ", "Yin ", "Yu "];
  }
});

// node_modules/unidecode/data/x5d.js
var require_x5d = __commonJS({
  "node_modules/unidecode/data/x5d.js"(exports, module2) {
    module2.exports = ["Lang ", "Kan ", "Lao ", "Lai ", "Xian ", "Que ", "Kong ", "Chong ", "Chong ", "Ta ", "Lin ", "Hua ", "Ju ", "Lai ", "Qi ", "Min ", "Kun ", "Kun ", "Zu ", "Gu ", "Cui ", "Ya ", "Ya ", "Gang ", "Lun ", "Lun ", "Leng ", "Jue ", "Duo ", "Zheng ", "Guo ", "Yin ", "Dong ", "Han ", "Zheng ", "Wei ", "Yao ", "Pi ", "Yan ", "Song ", "Jie ", "Beng ", "Zu ", "Jue ", "Dong ", "Zhan ", "Gu ", "Yin ", "[?] ", "Ze ", "Huang ", "Yu ", "Wei ", "Yang ", "Feng ", "Qiu ", "Dun ", "Ti ", "Yi ", "Zhi ", "Shi ", "Zai ", "Yao ", "E ", "Zhu ", "Kan ", "Lu ", "Yan ", "Mei ", "Gan ", "Ji ", "Ji ", "Huan ", "Ting ", "Sheng ", "Mei ", "Qian ", "Wu ", "Yu ", "Zong ", "Lan ", "Jue ", "Yan ", "Yan ", "Wei ", "Zong ", "Cha ", "Sui ", "Rong ", "Yamashina ", "Qin ", "Yu ", "Kewashii ", "Lou ", "Tu ", "Dui ", "Xi ", "Weng ", "Cang ", "Dang ", "Hong ", "Jie ", "Ai ", "Liu ", "Wu ", "Song ", "Qiao ", "Zi ", "Wei ", "Beng ", "Dian ", "Cuo ", "Qian ", "Yong ", "Nie ", "Cuo ", "Ji ", "[?] ", "Tao ", "Song ", "Zong ", "Jiang ", "Liao ", "Kang ", "Chan ", "Die ", "Cen ", "Ding ", "Tu ", "Lou ", "Zhang ", "Zhan ", "Zhan ", "Ao ", "Cao ", "Qu ", "Qiang ", "Zui ", "Zui ", "Dao ", "Dao ", "Xi ", "Yu ", "Bo ", "Long ", "Xiang ", "Ceng ", "Bo ", "Qin ", "Jiao ", "Yan ", "Lao ", "Zhan ", "Lin ", "Liao ", "Liao ", "Jin ", "Deng ", "Duo ", "Zun ", "Jiao ", "Gui ", "Yao ", "Qiao ", "Yao ", "Jue ", "Zhan ", "Yi ", "Xue ", "Nao ", "Ye ", "Ye ", "Yi ", "E ", "Xian ", "Ji ", "Xie ", "Ke ", "Xi ", "Di ", "Ao ", "Zui ", "[?] ", "Ni ", "Rong ", "Dao ", "Ling ", "Za ", "Yu ", "Yue ", "Yin ", "[?] ", "Jie ", "Li ", "Sui ", "Long ", "Long ", "Dian ", "Ying ", "Xi ", "Ju ", "Chan ", "Ying ", "Kui ", "Yan ", "Wei ", "Nao ", "Quan ", "Chao ", "Cuan ", "Luan ", "Dian ", "Dian ", "[?] ", "Yan ", "Yan ", "Yan ", "Nao ", "Yan ", "Chuan ", "Gui ", "Chuan ", "Zhou ", "Huang ", "Jing ", "Xun ", "Chao ", "Chao ", "Lie ", "Gong ", "Zuo ", "Qiao ", "Ju ", "Gong ", "Kek ", "Wu ", "Pwu ", "Pwu ", "Chai ", "Qiu ", "Qiu ", "Ji ", "Yi ", "Si ", "Ba ", "Zhi ", "Zhao ", "Xiang ", "Yi ", "Jin ", "Xun ", "Juan ", "Phas ", "Xun ", "Jin ", "Fu "];
  }
});

// node_modules/unidecode/data/x5e.js
var require_x5e = __commonJS({
  "node_modules/unidecode/data/x5e.js"(exports, module2) {
    module2.exports = ["Za ", "Bi ", "Shi ", "Bu ", "Ding ", "Shuai ", "Fan ", "Nie ", "Shi ", "Fen ", "Pa ", "Zhi ", "Xi ", "Hu ", "Dan ", "Wei ", "Zhang ", "Tang ", "Dai ", "Ma ", "Pei ", "Pa ", "Tie ", "Fu ", "Lian ", "Zhi ", "Zhou ", "Bo ", "Zhi ", "Di ", "Mo ", "Yi ", "Yi ", "Ping ", "Qia ", "Juan ", "Ru ", "Shuai ", "Dai ", "Zheng ", "Shui ", "Qiao ", "Zhen ", "Shi ", "Qun ", "Xi ", "Bang ", "Dai ", "Gui ", "Chou ", "Ping ", "Zhang ", "Sha ", "Wan ", "Dai ", "Wei ", "Chang ", "Sha ", "Qi ", "Ze ", "Guo ", "Mao ", "Du ", "Hou ", "Zheng ", "Xu ", "Mi ", "Wei ", "Wo ", "Fu ", "Yi ", "Bang ", "Ping ", "Tazuna ", "Gong ", "Pan ", "Huang ", "Dao ", "Mi ", "Jia ", "Teng ", "Hui ", "Zhong ", "Shan ", "Man ", "Mu ", "Biao ", "Guo ", "Ze ", "Mu ", "Bang ", "Zhang ", "Jiong ", "Chan ", "Fu ", "Zhi ", "Hu ", "Fan ", "Chuang ", "Bi ", "Hei ", "[?] ", "Mi ", "Qiao ", "Chan ", "Fen ", "Meng ", "Bang ", "Chou ", "Mie ", "Chu ", "Jie ", "Xian ", "Lan ", "Gan ", "Ping ", "Nian ", "Qian ", "Bing ", "Bing ", "Xing ", "Gan ", "Yao ", "Huan ", "You ", "You ", "Ji ", "Yan ", "Pi ", "Ting ", "Ze ", "Guang ", "Zhuang ", "Mo ", "Qing ", "Bi ", "Qin ", "Dun ", "Chuang ", "Gui ", "Ya ", "Bai ", "Jie ", "Xu ", "Lu ", "Wu ", "[?] ", "Ku ", "Ying ", "Di ", "Pao ", "Dian ", "Ya ", "Miao ", "Geng ", "Ci ", "Fu ", "Tong ", "Pang ", "Fei ", "Xiang ", "Yi ", "Zhi ", "Tiao ", "Zhi ", "Xiu ", "Du ", "Zuo ", "Xiao ", "Tu ", "Gui ", "Ku ", "Pang ", "Ting ", "You ", "Bu ", "Ding ", "Cheng ", "Lai ", "Bei ", "Ji ", "An ", "Shu ", "Kang ", "Yong ", "Tuo ", "Song ", "Shu ", "Qing ", "Yu ", "Yu ", "Miao ", "Sou ", "Ce ", "Xiang ", "Fei ", "Jiu ", "He ", "Hui ", "Liu ", "Sha ", "Lian ", "Lang ", "Sou ", "Jian ", "Pou ", "Qing ", "Jiu ", "Jiu ", "Qin ", "Ao ", "Kuo ", "Lou ", "Yin ", "Liao ", "Dai ", "Lu ", "Yi ", "Chu ", "Chan ", "Tu ", "Si ", "Xin ", "Miao ", "Chang ", "Wu ", "Fei ", "Guang ", "Koc ", "Kuai ", "Bi ", "Qiang ", "Xie ", "Lin ", "Lin ", "Liao ", "Lu ", "[?] ", "Ying ", "Xian ", "Ting ", "Yong ", "Li ", "Ting ", "Yin ", "Xun ", "Yan ", "Ting ", "Di ", "Po ", "Jian ", "Hui ", "Nai ", "Hui ", "Gong ", "Nian "];
  }
});

// node_modules/unidecode/data/x5f.js
var require_x5f = __commonJS({
  "node_modules/unidecode/data/x5f.js"(exports, module2) {
    module2.exports = ["Kai ", "Bian ", "Yi ", "Qi ", "Nong ", "Fen ", "Ju ", "Yan ", "Yi ", "Zang ", "Bi ", "Yi ", "Yi ", "Er ", "San ", "Shi ", "Er ", "Shi ", "Shi ", "Gong ", "Diao ", "Yin ", "Hu ", "Fu ", "Hong ", "Wu ", "Tui ", "Chi ", "Jiang ", "Ba ", "Shen ", "Di ", "Zhang ", "Jue ", "Tao ", "Fu ", "Di ", "Mi ", "Xian ", "Hu ", "Chao ", "Nu ", "Jing ", "Zhen ", "Yi ", "Mi ", "Quan ", "Wan ", "Shao ", "Ruo ", "Xuan ", "Jing ", "Dun ", "Zhang ", "Jiang ", "Qiang ", "Peng ", "Dan ", "Qiang ", "Bi ", "Bi ", "She ", "Dan ", "Jian ", "Gou ", "Sei ", "Fa ", "Bi ", "Kou ", "Nagi ", "Bie ", "Xiao ", "Dan ", "Kuo ", "Qiang ", "Hong ", "Mi ", "Kuo ", "Wan ", "Jue ", "Ji ", "Ji ", "Gui ", "Dang ", "Lu ", "Lu ", "Tuan ", "Hui ", "Zhi ", "Hui ", "Hui ", "Yi ", "Yi ", "Yi ", "Yi ", "Huo ", "Huo ", "Shan ", "Xing ", "Wen ", "Tong ", "Yan ", "Yan ", "Yu ", "Chi ", "Cai ", "Biao ", "Diao ", "Bin ", "Peng ", "Yong ", "Piao ", "Zhang ", "Ying ", "Chi ", "Chi ", "Zhuo ", "Tuo ", "Ji ", "Pang ", "Zhong ", "Yi ", "Wang ", "Che ", "Bi ", "Chi ", "Ling ", "Fu ", "Wang ", "Zheng ", "Cu ", "Wang ", "Jing ", "Dai ", "Xi ", "Xun ", "Hen ", "Yang ", "Huai ", "Lu ", "Hou ", "Wa ", "Cheng ", "Zhi ", "Xu ", "Jing ", "Tu ", "Cong ", "[?] ", "Lai ", "Cong ", "De ", "Pai ", "Xi ", "[?] ", "Qi ", "Chang ", "Zhi ", "Cong ", "Zhou ", "Lai ", "Yu ", "Xie ", "Jie ", "Jian ", "Chi ", "Jia ", "Bian ", "Huang ", "Fu ", "Xun ", "Wei ", "Pang ", "Yao ", "Wei ", "Xi ", "Zheng ", "Piao ", "Chi ", "De ", "Zheng ", "Zheng ", "Bie ", "De ", "Chong ", "Che ", "Jiao ", "Wei ", "Jiao ", "Hui ", "Mei ", "Long ", "Xiang ", "Bao ", "Qu ", "Xin ", "Shu ", "Bi ", "Yi ", "Le ", "Ren ", "Dao ", "Ding ", "Gai ", "Ji ", "Ren ", "Ren ", "Chan ", "Tan ", "Te ", "Te ", "Gan ", "Qi ", "Shi ", "Cun ", "Zhi ", "Wang ", "Mang ", "Xi ", "Fan ", "Ying ", "Tian ", "Min ", "Min ", "Zhong ", "Chong ", "Wu ", "Ji ", "Wu ", "Xi ", "Ye ", "You ", "Wan ", "Cong ", "Zhong ", "Kuai ", "Yu ", "Bian ", "Zhi ", "Qi ", "Cui ", "Chen ", "Tai ", "Tun ", "Qian ", "Nian ", "Hun ", "Xiong ", "Niu ", "Wang ", "Xian ", "Xin ", "Kang ", "Hu ", "Kai ", "Fen "];
  }
});

// node_modules/unidecode/data/x60.js
var require_x60 = __commonJS({
  "node_modules/unidecode/data/x60.js"(exports, module2) {
    module2.exports = ["Huai ", "Tai ", "Song ", "Wu ", "Ou ", "Chang ", "Chuang ", "Ju ", "Yi ", "Bao ", "Chao ", "Min ", "Pei ", "Zuo ", "Zen ", "Yang ", "Kou ", "Ban ", "Nu ", "Nao ", "Zheng ", "Pa ", "Bu ", "Tie ", "Gu ", "Hu ", "Ju ", "Da ", "Lian ", "Si ", "Chou ", "Di ", "Dai ", "Yi ", "Tu ", "You ", "Fu ", "Ji ", "Peng ", "Xing ", "Yuan ", "Ni ", "Guai ", "Fu ", "Xi ", "Bi ", "You ", "Qie ", "Xuan ", "Cong ", "Bing ", "Huang ", "Xu ", "Chu ", "Pi ", "Xi ", "Xi ", "Tan ", "Koraeru ", "Zong ", "Dui ", "[?] ", "Ki ", "Yi ", "Chi ", "Ren ", "Xun ", "Shi ", "Xi ", "Lao ", "Heng ", "Kuang ", "Mu ", "Zhi ", "Xie ", "Lian ", "Tiao ", "Huang ", "Die ", "Hao ", "Kong ", "Gui ", "Heng ", "Xi ", "Xiao ", "Shu ", "S ", "Kua ", "Qiu ", "Yang ", "Hui ", "Hui ", "Chi ", "Jia ", "Yi ", "Xiong ", "Guai ", "Lin ", "Hui ", "Zi ", "Xu ", "Chi ", "Xiang ", "Nu ", "Hen ", "En ", "Ke ", "Tong ", "Tian ", "Gong ", "Quan ", "Xi ", "Qia ", "Yue ", "Peng ", "Ken ", "De ", "Hui ", "E ", "Kyuu ", "Tong ", "Yan ", "Kai ", "Ce ", "Nao ", "Yun ", "Mang ", "Yong ", "Yong ", "Yuan ", "Pi ", "Kun ", "Qiao ", "Yue ", "Yu ", "Yu ", "Jie ", "Xi ", "Zhe ", "Lin ", "Ti ", "Han ", "Hao ", "Qie ", "Ti ", "Bu ", "Yi ", "Qian ", "Hui ", "Xi ", "Bei ", "Man ", "Yi ", "Heng ", "Song ", "Quan ", "Cheng ", "Hui ", "Wu ", "Wu ", "You ", "Li ", "Liang ", "Huan ", "Cong ", "Yi ", "Yue ", "Li ", "Nin ", "Nao ", "E ", "Que ", "Xuan ", "Qian ", "Wu ", "Min ", "Cong ", "Fei ", "Bei ", "Duo ", "Cui ", "Chang ", "Men ", "Li ", "Ji ", "Guan ", "Guan ", "Xing ", "Dao ", "Qi ", "Kong ", "Tian ", "Lun ", "Xi ", "Kan ", "Kun ", "Ni ", "Qing ", "Chou ", "Dun ", "Guo ", "Chan ", "Liang ", "Wan ", "Yuan ", "Jin ", "Ji ", "Lin ", "Yu ", "Huo ", "He ", "Quan ", "Tan ", "Ti ", "Ti ", "Nie ", "Wang ", "Chuo ", "Bu ", "Hun ", "Xi ", "Tang ", "Xin ", "Wei ", "Hui ", "E ", "Rui ", "Zong ", "Jian ", "Yong ", "Dian ", "Ju ", "Can ", "Cheng ", "De ", "Bei ", "Qie ", "Can ", "Dan ", "Guan ", "Duo ", "Nao ", "Yun ", "Xiang ", "Zhui ", "Die ", "Huang ", "Chun ", "Qiong ", "Re ", "Xing ", "Ce ", "Bian ", "Hun ", "Zong ", "Ti "];
  }
});

// node_modules/unidecode/data/x61.js
var require_x61 = __commonJS({
  "node_modules/unidecode/data/x61.js"(exports, module2) {
    module2.exports = ["Qiao ", "Chou ", "Bei ", "Xuan ", "Wei ", "Ge ", "Qian ", "Wei ", "Yu ", "Yu ", "Bi ", "Xuan ", "Huan ", "Min ", "Bi ", "Yi ", "Mian ", "Yong ", "Kai ", "Dang ", "Yin ", "E ", "Chen ", "Mou ", "Ke ", "Ke ", "Yu ", "Ai ", "Qie ", "Yan ", "Nuo ", "Gan ", "Yun ", "Zong ", "Sai ", "Leng ", "Fen ", "[?] ", "Kui ", "Kui ", "Que ", "Gong ", "Yun ", "Su ", "Su ", "Qi ", "Yao ", "Song ", "Huang ", "Ji ", "Gu ", "Ju ", "Chuang ", "Ni ", "Xie ", "Kai ", "Zheng ", "Yong ", "Cao ", "Sun ", "Shen ", "Bo ", "Kai ", "Yuan ", "Xie ", "Hun ", "Yong ", "Yang ", "Li ", "Sao ", "Tao ", "Yin ", "Ci ", "Xu ", "Qian ", "Tai ", "Huang ", "Yun ", "Shen ", "Ming ", "[?] ", "She ", "Cong ", "Piao ", "Mo ", "Mu ", "Guo ", "Chi ", "Can ", "Can ", "Can ", "Cui ", "Min ", "Te ", "Zhang ", "Tong ", "Ao ", "Shuang ", "Man ", "Guan ", "Que ", "Zao ", "Jiu ", "Hui ", "Kai ", "Lian ", "Ou ", "Song ", "Jin ", "Yin ", "Lu ", "Shang ", "Wei ", "Tuan ", "Man ", "Qian ", "She ", "Yong ", "Qing ", "Kang ", "Di ", "Zhi ", "Lou ", "Juan ", "Qi ", "Qi ", "Yu ", "Ping ", "Liao ", "Cong ", "You ", "Chong ", "Zhi ", "Tong ", "Cheng ", "Qi ", "Qu ", "Peng ", "Bei ", "Bie ", "Chun ", "Jiao ", "Zeng ", "Chi ", "Lian ", "Ping ", "Kui ", "Hui ", "Qiao ", "Cheng ", "Yin ", "Yin ", "Xi ", "Xi ", "Dan ", "Tan ", "Duo ", "Dui ", "Dui ", "Su ", "Jue ", "Ce ", "Xiao ", "Fan ", "Fen ", "Lao ", "Lao ", "Chong ", "Han ", "Qi ", "Xian ", "Min ", "Jing ", "Liao ", "Wu ", "Can ", "Jue ", "Cu ", "Xian ", "Tan ", "Sheng ", "Pi ", "Yi ", "Chu ", "Xian ", "Nao ", "Dan ", "Tan ", "Jing ", "Song ", "Han ", "Jiao ", "Wai ", "Huan ", "Dong ", "Qin ", "Qin ", "Qu ", "Cao ", "Ken ", "Xie ", "Ying ", "Ao ", "Mao ", "Yi ", "Lin ", "Se ", "Jun ", "Huai ", "Men ", "Lan ", "Ai ", "Lin ", "Yan ", "Gua ", "Xia ", "Chi ", "Yu ", "Yin ", "Dai ", "Meng ", "Ai ", "Meng ", "Dui ", "Qi ", "Mo ", "Lan ", "Men ", "Chou ", "Zhi ", "Nuo ", "Nuo ", "Yan ", "Yang ", "Bo ", "Zhi ", "Kuang ", "Kuang ", "You ", "Fu ", "Liu ", "Mie ", "Cheng ", "[?] ", "Chan ", "Meng ", "Lan ", "Huai ", "Xuan ", "Rang ", "Chan ", "Ji ", "Ju ", "Huan ", "She ", "Yi "];
  }
});

// node_modules/unidecode/data/x62.js
var require_x62 = __commonJS({
  "node_modules/unidecode/data/x62.js"(exports, module2) {
    module2.exports = ["Lian ", "Nan ", "Mi ", "Tang ", "Jue ", "Gang ", "Gang ", "Gang ", "Ge ", "Yue ", "Wu ", "Jian ", "Xu ", "Shu ", "Rong ", "Xi ", "Cheng ", "Wo ", "Jie ", "Ge ", "Jian ", "Qiang ", "Huo ", "Qiang ", "Zhan ", "Dong ", "Qi ", "Jia ", "Die ", "Zei ", "Jia ", "Ji ", "Shi ", "Kan ", "Ji ", "Kui ", "Gai ", "Deng ", "Zhan ", "Chuang ", "Ge ", "Jian ", "Jie ", "Yu ", "Jian ", "Yan ", "Lu ", "Xi ", "Zhan ", "Xi ", "Xi ", "Chuo ", "Dai ", "Qu ", "Hu ", "Hu ", "Hu ", "E ", "Shi ", "Li ", "Mao ", "Hu ", "Li ", "Fang ", "Suo ", "Bian ", "Dian ", "Jiong ", "Shang ", "Yi ", "Yi ", "Shan ", "Hu ", "Fei ", "Yan ", "Shou ", "T ", "Cai ", "Zha ", "Qiu ", "Le ", "Bu ", "Ba ", "Da ", "Reng ", "Fu ", "Hameru ", "Zai ", "Tuo ", "Zhang ", "Diao ", "Kang ", "Yu ", "Ku ", "Han ", "Shen ", "Cha ", "Yi ", "Gu ", "Kou ", "Wu ", "Tuo ", "Qian ", "Zhi ", "Ren ", "Kuo ", "Men ", "Sao ", "Yang ", "Niu ", "Ban ", "Che ", "Rao ", "Xi ", "Qian ", "Ban ", "Jia ", "Yu ", "Fu ", "Ao ", "Xi ", "Pi ", "Zhi ", "Zi ", "E ", "Dun ", "Zhao ", "Cheng ", "Ji ", "Yan ", "Kuang ", "Bian ", "Chao ", "Ju ", "Wen ", "Hu ", "Yue ", "Jue ", "Ba ", "Qin ", "Zhen ", "Zheng ", "Yun ", "Wan ", "Nu ", "Yi ", "Shu ", "Zhua ", "Pou ", "Tou ", "Dou ", "Kang ", "Zhe ", "Pou ", "Fu ", "Pao ", "Ba ", "Ao ", "Ze ", "Tuan ", "Kou ", "Lun ", "Qiang ", "[?] ", "Hu ", "Bao ", "Bing ", "Zhi ", "Peng ", "Tan ", "Pu ", "Pi ", "Tai ", "Yao ", "Zhen ", "Zha ", "Yang ", "Bao ", "He ", "Ni ", "Yi ", "Di ", "Chi ", "Pi ", "Za ", "Mo ", "Mo ", "Shen ", "Ya ", "Chou ", "Qu ", "Min ", "Chu ", "Jia ", "Fu ", "Zhan ", "Zhu ", "Dan ", "Chai ", "Mu ", "Nian ", "La ", "Fu ", "Pao ", "Ban ", "Pai ", "Ling ", "Na ", "Guai ", "Qian ", "Ju ", "Tuo ", "Ba ", "Tuo ", "Tuo ", "Ao ", "Ju ", "Zhuo ", "Pan ", "Zhao ", "Bai ", "Bai ", "Di ", "Ni ", "Ju ", "Kuo ", "Long ", "Jian ", "[?] ", "Yong ", "Lan ", "Ning ", "Bo ", "Ze ", "Qian ", "Hen ", "Gua ", "Shi ", "Jie ", "Zheng ", "Nin ", "Gong ", "Gong ", "Quan ", "Shuan ", "Cun ", "Zan ", "Kao ", "Chi ", "Xie ", "Ce ", "Hui ", "Pin ", "Zhuai ", "Shi ", "Na "];
  }
});

// node_modules/unidecode/data/x63.js
var require_x63 = __commonJS({
  "node_modules/unidecode/data/x63.js"(exports, module2) {
    module2.exports = ["Bo ", "Chi ", "Gua ", "Zhi ", "Kuo ", "Duo ", "Duo ", "Zhi ", "Qie ", "An ", "Nong ", "Zhen ", "Ge ", "Jiao ", "Ku ", "Dong ", "Ru ", "Tiao ", "Lie ", "Zha ", "Lu ", "Die ", "Wa ", "Jue ", "Mushiru ", "Ju ", "Zhi ", "Luan ", "Ya ", "Zhua ", "Ta ", "Xie ", "Nao ", "Dang ", "Jiao ", "Zheng ", "Ji ", "Hui ", "Xun ", "Ku ", "Ai ", "Tuo ", "Nuo ", "Cuo ", "Bo ", "Geng ", "Ti ", "Zhen ", "Cheng ", "Suo ", "Suo ", "Keng ", "Mei ", "Long ", "Ju ", "Peng ", "Jian ", "Yi ", "Ting ", "Shan ", "Nuo ", "Wan ", "Xie ", "Cha ", "Feng ", "Jiao ", "Wu ", "Jun ", "Jiu ", "Tong ", "Kun ", "Huo ", "Tu ", "Zhuo ", "Pou ", "Le ", "Ba ", "Han ", "Shao ", "Nie ", "Juan ", "Ze ", "Song ", "Ye ", "Jue ", "Bu ", "Huan ", "Bu ", "Zun ", "Yi ", "Zhai ", "Lu ", "Sou ", "Tuo ", "Lao ", "Sun ", "Bang ", "Jian ", "Huan ", "Dao ", "[?] ", "Wan ", "Qin ", "Peng ", "She ", "Lie ", "Min ", "Men ", "Fu ", "Bai ", "Ju ", "Dao ", "Wo ", "Ai ", "Juan ", "Yue ", "Zong ", "Chen ", "Chui ", "Jie ", "Tu ", "Ben ", "Na ", "Nian ", "Nuo ", "Zu ", "Wo ", "Xi ", "Xian ", "Cheng ", "Dian ", "Sao ", "Lun ", "Qing ", "Gang ", "Duo ", "Shou ", "Diao ", "Pou ", "Di ", "Zhang ", "Gun ", "Ji ", "Tao ", "Qia ", "Qi ", "Pai ", "Shu ", "Qian ", "Ling ", "Yi ", "Ya ", "Jue ", "Zheng ", "Liang ", "Gua ", "Yi ", "Huo ", "Shan ", "Zheng ", "Lue ", "Cai ", "Tan ", "Che ", "Bing ", "Jie ", "Ti ", "Kong ", "Tui ", "Yan ", "Cuo ", "Zou ", "Ju ", "Tian ", "Qian ", "Ken ", "Bai ", "Shou ", "Jie ", "Lu ", "Guo ", "Haba ", "[?] ", "Zhi ", "Dan ", "Mang ", "Xian ", "Sao ", "Guan ", "Peng ", "Yuan ", "Nuo ", "Jian ", "Zhen ", "Jiu ", "Jian ", "Yu ", "Yan ", "Kui ", "Nan ", "Hong ", "Rou ", "Pi ", "Wei ", "Sai ", "Zou ", "Xuan ", "Miao ", "Ti ", "Nie ", "Cha ", "Shi ", "Zong ", "Zhen ", "Yi ", "Shun ", "Heng ", "Bian ", "Yang ", "Huan ", "Yan ", "Zuan ", "An ", "Xu ", "Ya ", "Wo ", "Ke ", "Chuai ", "Ji ", "Ti ", "La ", "La ", "Cheng ", "Kai ", "Jiu ", "Jiu ", "Tu ", "Jie ", "Hui ", "Geng ", "Chong ", "Shuo ", "She ", "Xie ", "Yuan ", "Qian ", "Ye ", "Cha ", "Zha ", "Bei ", "Yao ", "[?] ", "[?] ", "Lan ", "Wen ", "Qin "];
  }
});

// node_modules/unidecode/data/x64.js
var require_x64 = __commonJS({
  "node_modules/unidecode/data/x64.js"(exports, module2) {
    module2.exports = ["Chan ", "Ge ", "Lou ", "Zong ", "Geng ", "Jiao ", "Gou ", "Qin ", "Yong ", "Que ", "Chou ", "Chi ", "Zhan ", "Sun ", "Sun ", "Bo ", "Chu ", "Rong ", "Beng ", "Cuo ", "Sao ", "Ke ", "Yao ", "Dao ", "Zhi ", "Nu ", "Xie ", "Jian ", "Sou ", "Qiu ", "Gao ", "Xian ", "Shuo ", "Sang ", "Jin ", "Mie ", "E ", "Chui ", "Nuo ", "Shan ", "Ta ", "Jie ", "Tang ", "Pan ", "Ban ", "Da ", "Li ", "Tao ", "Hu ", "Zhi ", "Wa ", "Xia ", "Qian ", "Wen ", "Qiang ", "Tian ", "Zhen ", "E ", "Xi ", "Nuo ", "Quan ", "Cha ", "Zha ", "Ge ", "Wu ", "En ", "She ", "Kang ", "She ", "Shu ", "Bai ", "Yao ", "Bin ", "Sou ", "Tan ", "Sa ", "Chan ", "Suo ", "Liao ", "Chong ", "Chuang ", "Guo ", "Bing ", "Feng ", "Shuai ", "Di ", "Qi ", "Sou ", "Zhai ", "Lian ", "Tang ", "Chi ", "Guan ", "Lu ", "Luo ", "Lou ", "Zong ", "Gai ", "Hu ", "Zha ", "Chuang ", "Tang ", "Hua ", "Cui ", "Nai ", "Mo ", "Jiang ", "Gui ", "Ying ", "Zhi ", "Ao ", "Zhi ", "Nie ", "Man ", "Shan ", "Kou ", "Shu ", "Suo ", "Tuan ", "Jiao ", "Mo ", "Mo ", "Zhe ", "Xian ", "Keng ", "Piao ", "Jiang ", "Yin ", "Gou ", "Qian ", "Lue ", "Ji ", "Ying ", "Jue ", "Pie ", "Pie ", "Lao ", "Dun ", "Xian ", "Ruan ", "Kui ", "Zan ", "Yi ", "Xun ", "Cheng ", "Cheng ", "Sa ", "Nao ", "Heng ", "Si ", "Qian ", "Huang ", "Da ", "Zun ", "Nian ", "Lin ", "Zheng ", "Hui ", "Zhuang ", "Jiao ", "Ji ", "Cao ", "Dan ", "Dan ", "Che ", "Bo ", "Che ", "Jue ", "Xiao ", "Liao ", "Ben ", "Fu ", "Qiao ", "Bo ", "Cuo ", "Zhuo ", "Zhuan ", "Tuo ", "Pu ", "Qin ", "Dun ", "Nian ", "[?] ", "Xie ", "Lu ", "Jiao ", "Cuan ", "Ta ", "Han ", "Qiao ", "Zhua ", "Jian ", "Gan ", "Yong ", "Lei ", "Kuo ", "Lu ", "Shan ", "Zhuo ", "Ze ", "Pu ", "Chuo ", "Ji ", "Dang ", "Suo ", "Cao ", "Qing ", "Jing ", "Huan ", "Jie ", "Qin ", "Kuai ", "Dan ", "Xi ", "Ge ", "Pi ", "Bo ", "Ao ", "Ju ", "Ye ", "[?] ", "Mang ", "Sou ", "Mi ", "Ji ", "Tai ", "Zhuo ", "Dao ", "Xing ", "Lan ", "Ca ", "Ju ", "Ye ", "Ru ", "Ye ", "Ye ", "Ni ", "Hu ", "Ji ", "Bin ", "Ning ", "Ge ", "Zhi ", "Jie ", "Kuo ", "Mo ", "Jian ", "Xie ", "Lie ", "Tan ", "Bai ", "Sou ", "Lu ", "Lue ", "Rao ", "Zhi "];
  }
});

// node_modules/unidecode/data/x65.js
var require_x65 = __commonJS({
  "node_modules/unidecode/data/x65.js"(exports, module2) {
    module2.exports = ["Pan ", "Yang ", "Lei ", "Sa ", "Shu ", "Zan ", "Nian ", "Xian ", "Jun ", "Huo ", "Li ", "La ", "Han ", "Ying ", "Lu ", "Long ", "Qian ", "Qian ", "Zan ", "Qian ", "Lan ", "San ", "Ying ", "Mei ", "Rang ", "Chan ", "[?] ", "Cuan ", "Xi ", "She ", "Luo ", "Jun ", "Mi ", "Li ", "Zan ", "Luan ", "Tan ", "Zuan ", "Li ", "Dian ", "Wa ", "Dang ", "Jiao ", "Jue ", "Lan ", "Li ", "Nang ", "Zhi ", "Gui ", "Gui ", "Qi ", "Xin ", "Pu ", "Sui ", "Shou ", "Kao ", "You ", "Gai ", "Yi ", "Gong ", "Gan ", "Ban ", "Fang ", "Zheng ", "Bo ", "Dian ", "Kou ", "Min ", "Wu ", "Gu ", "He ", "Ce ", "Xiao ", "Mi ", "Chu ", "Ge ", "Di ", "Xu ", "Jiao ", "Min ", "Chen ", "Jiu ", "Zhen ", "Duo ", "Yu ", "Chi ", "Ao ", "Bai ", "Xu ", "Jiao ", "Duo ", "Lian ", "Nie ", "Bi ", "Chang ", "Dian ", "Duo ", "Yi ", "Gan ", "San ", "Ke ", "Yan ", "Dun ", "Qi ", "Dou ", "Xiao ", "Duo ", "Jiao ", "Jing ", "Yang ", "Xia ", "Min ", "Shu ", "Ai ", "Qiao ", "Ai ", "Zheng ", "Di ", "Zhen ", "Fu ", "Shu ", "Liao ", "Qu ", "Xiong ", "Xi ", "Jiao ", "Sen ", "Jiao ", "Zhuo ", "Yi ", "Lian ", "Bi ", "Li ", "Xiao ", "Xiao ", "Wen ", "Xue ", "Qi ", "Qi ", "Zhai ", "Bin ", "Jue ", "Zhai ", "[?] ", "Fei ", "Ban ", "Ban ", "Lan ", "Yu ", "Lan ", "Wei ", "Dou ", "Sheng ", "Liao ", "Jia ", "Hu ", "Xie ", "Jia ", "Yu ", "Zhen ", "Jiao ", "Wo ", "Tou ", "Chu ", "Jin ", "Chi ", "Yin ", "Fu ", "Qiang ", "Zhan ", "Qu ", "Zhuo ", "Zhan ", "Duan ", "Zhuo ", "Si ", "Xin ", "Zhuo ", "Zhuo ", "Qin ", "Lin ", "Zhuo ", "Chu ", "Duan ", "Zhu ", "Fang ", "Xie ", "Hang ", "Yu ", "Shi ", "Pei ", "You ", "Mye ", "Pang ", "Qi ", "Zhan ", "Mao ", "Lu ", "Pei ", "Pi ", "Liu ", "Fu ", "Fang ", "Xuan ", "Jing ", "Jing ", "Ni ", "Zu ", "Zhao ", "Yi ", "Liu ", "Shao ", "Jian ", "Es ", "Yi ", "Qi ", "Zhi ", "Fan ", "Piao ", "Fan ", "Zhan ", "Guai ", "Sui ", "Yu ", "Wu ", "Ji ", "Ji ", "Ji ", "Huo ", "Ri ", "Dan ", "Jiu ", "Zhi ", "Zao ", "Xie ", "Tiao ", "Xun ", "Xu ", "Xu ", "Xu ", "Gan ", "Han ", "Tai ", "Di ", "Xu ", "Chan ", "Shi ", "Kuang ", "Yang ", "Shi ", "Wang ", "Min ", "Min ", "Tun ", "Chun ", "Wu "];
  }
});

// node_modules/unidecode/data/x66.js
var require_x66 = __commonJS({
  "node_modules/unidecode/data/x66.js"(exports, module2) {
    module2.exports = ["Yun ", "Bei ", "Ang ", "Ze ", "Ban ", "Jie ", "Kun ", "Sheng ", "Hu ", "Fang ", "Hao ", "Gui ", "Chang ", "Xuan ", "Ming ", "Hun ", "Fen ", "Qin ", "Hu ", "Yi ", "Xi ", "Xin ", "Yan ", "Ze ", "Fang ", "Tan ", "Shen ", "Ju ", "Yang ", "Zan ", "Bing ", "Xing ", "Ying ", "Xuan ", "Pei ", "Zhen ", "Ling ", "Chun ", "Hao ", "Mei ", "Zuo ", "Mo ", "Bian ", "Xu ", "Hun ", "Zhao ", "Zong ", "Shi ", "Shi ", "Yu ", "Fei ", "Die ", "Mao ", "Ni ", "Chang ", "Wen ", "Dong ", "Ai ", "Bing ", "Ang ", "Zhou ", "Long ", "Xian ", "Kuang ", "Tiao ", "Chao ", "Shi ", "Huang ", "Huang ", "Xuan ", "Kui ", "Xu ", "Jiao ", "Jin ", "Zhi ", "Jin ", "Shang ", "Tong ", "Hong ", "Yan ", "Gai ", "Xiang ", "Shai ", "Xiao ", "Ye ", "Yun ", "Hui ", "Han ", "Han ", "Jun ", "Wan ", "Xian ", "Kun ", "Zhou ", "Xi ", "Cheng ", "Sheng ", "Bu ", "Zhe ", "Zhe ", "Wu ", "Han ", "Hui ", "Hao ", "Chen ", "Wan ", "Tian ", "Zhuo ", "Zui ", "Zhou ", "Pu ", "Jing ", "Xi ", "Shan ", "Yi ", "Xi ", "Qing ", "Qi ", "Jing ", "Gui ", "Zhen ", "Yi ", "Zhi ", "An ", "Wan ", "Lin ", "Liang ", "Chang ", "Wang ", "Xiao ", "Zan ", "Hi ", "Xuan ", "Xuan ", "Yi ", "Xia ", "Yun ", "Hui ", "Fu ", "Min ", "Kui ", "He ", "Ying ", "Du ", "Wei ", "Shu ", "Qing ", "Mao ", "Nan ", "Jian ", "Nuan ", "An ", "Yang ", "Chun ", "Yao ", "Suo ", "Jin ", "Ming ", "Jiao ", "Kai ", "Gao ", "Weng ", "Chang ", "Qi ", "Hao ", "Yan ", "Li ", "Ai ", "Ji ", "Gui ", "Men ", "Zan ", "Xie ", "Hao ", "Mu ", "Mo ", "Cong ", "Ni ", "Zhang ", "Hui ", "Bao ", "Han ", "Xuan ", "Chuan ", "Liao ", "Xian ", "Dan ", "Jing ", "Pie ", "Lin ", "Tun ", "Xi ", "Yi ", "Ji ", "Huang ", "Tai ", "Ye ", "Ye ", "Li ", "Tan ", "Tong ", "Xiao ", "Fei ", "Qin ", "Zhao ", "Hao ", "Yi ", "Xiang ", "Xing ", "Sen ", "Jiao ", "Bao ", "Jing ", "Yian ", "Ai ", "Ye ", "Ru ", "Shu ", "Meng ", "Xun ", "Yao ", "Pu ", "Li ", "Chen ", "Kuang ", "Die ", "[?] ", "Yan ", "Huo ", "Lu ", "Xi ", "Rong ", "Long ", "Nang ", "Luo ", "Luan ", "Shai ", "Tang ", "Yan ", "Chu ", "Yue ", "Yue ", "Qu ", "Yi ", "Geng ", "Ye ", "Hu ", "He ", "Shu ", "Cao ", "Cao ", "Noboru ", "Man ", "Ceng ", "Ceng ", "Ti "];
  }
});

// node_modules/unidecode/data/x67.js
var require_x67 = __commonJS({
  "node_modules/unidecode/data/x67.js"(exports, module2) {
    module2.exports = ["Zui ", "Can ", "Xu ", "Hui ", "Yin ", "Qie ", "Fen ", "Pi ", "Yue ", "You ", "Ruan ", "Peng ", "Ban ", "Fu ", "Ling ", "Fei ", "Qu ", "[?] ", "Nu ", "Tiao ", "Shuo ", "Zhen ", "Lang ", "Lang ", "Juan ", "Ming ", "Huang ", "Wang ", "Tun ", "Zhao ", "Ji ", "Qi ", "Ying ", "Zong ", "Wang ", "Tong ", "Lang ", "[?] ", "Meng ", "Long ", "Mu ", "Deng ", "Wei ", "Mo ", "Ben ", "Zha ", "Zhu ", "Zhu ", "[?] ", "Zhu ", "Ren ", "Ba ", "Po ", "Duo ", "Duo ", "Dao ", "Li ", "Qiu ", "Ji ", "Jiu ", "Bi ", "Xiu ", "Ting ", "Ci ", "Sha ", "Eburi ", "Za ", "Quan ", "Qian ", "Yu ", "Gan ", "Wu ", "Cha ", "Shan ", "Xun ", "Fan ", "Wu ", "Zi ", "Li ", "Xing ", "Cai ", "Cun ", "Ren ", "Shao ", "Tuo ", "Di ", "Zhang ", "Mang ", "Chi ", "Yi ", "Gu ", "Gong ", "Du ", "Yi ", "Qi ", "Shu ", "Gang ", "Tiao ", "Moku ", "Soma ", "Tochi ", "Lai ", "Sugi ", "Mang ", "Yang ", "Ma ", "Miao ", "Si ", "Yuan ", "Hang ", "Fei ", "Bei ", "Jie ", "Dong ", "Gao ", "Yao ", "Xian ", "Chu ", "Qun ", "Pa ", "Shu ", "Hua ", "Xin ", "Chou ", "Zhu ", "Chou ", "Song ", "Ban ", "Song ", "Ji ", "Yue ", "Jin ", "Gou ", "Ji ", "Mao ", "Pi ", "Bi ", "Wang ", "Ang ", "Fang ", "Fen ", "Yi ", "Fu ", "Nan ", "Xi ", "Hu ", "Ya ", "Dou ", "Xun ", "Zhen ", "Yao ", "Lin ", "Rui ", "E ", "Mei ", "Zhao ", "Guo ", "Zhi ", "Cong ", "Yun ", "Waku ", "Dou ", "Shu ", "Zao ", "[?] ", "Li ", "Haze ", "Jian ", "Cheng ", "Matsu ", "Qiang ", "Feng ", "Nan ", "Xiao ", "Xian ", "Ku ", "Ping ", "Yi ", "Xi ", "Zhi ", "Guai ", "Xiao ", "Jia ", "Jia ", "Gou ", "Fu ", "Mo ", "Yi ", "Ye ", "Ye ", "Shi ", "Nie ", "Bi ", "Duo ", "Yi ", "Ling ", "Bing ", "Ni ", "La ", "He ", "Pan ", "Fan ", "Zhong ", "Dai ", "Ci ", "Yang ", "Fu ", "Bo ", "Mou ", "Gan ", "Qi ", "Ran ", "Rou ", "Mao ", "Zhao ", "Song ", "Zhe ", "Xia ", "You ", "Shen ", "Ju ", "Tuo ", "Zuo ", "Nan ", "Ning ", "Yong ", "Di ", "Zhi ", "Zha ", "Cha ", "Dan ", "Gu ", "Pu ", "Jiu ", "Ao ", "Fu ", "Jian ", "Bo ", "Duo ", "Ke ", "Nai ", "Zhu ", "Bi ", "Liu ", "Chai ", "Zha ", "Si ", "Zhu ", "Pei ", "Shi ", "Guai ", "Cha ", "Yao ", "Jue ", "Jiu ", "Shi "];
  }
});

// node_modules/unidecode/data/x68.js
var require_x68 = __commonJS({
  "node_modules/unidecode/data/x68.js"(exports, module2) {
    module2.exports = ["Zhi ", "Liu ", "Mei ", "Hoy ", "Rong ", "Zha ", "[?] ", "Biao ", "Zhan ", "Jie ", "Long ", "Dong ", "Lu ", "Sayng ", "Li ", "Lan ", "Yong ", "Shu ", "Xun ", "Shuan ", "Qi ", "Zhen ", "Qi ", "Li ", "Yi ", "Xiang ", "Zhen ", "Li ", "Su ", "Gua ", "Kan ", "Bing ", "Ren ", "Xiao ", "Bo ", "Ren ", "Bing ", "Zi ", "Chou ", "Yi ", "Jie ", "Xu ", "Zhu ", "Jian ", "Zui ", "Er ", "Er ", "You ", "Fa ", "Gong ", "Kao ", "Lao ", "Zhan ", "Li ", "Yin ", "Yang ", "He ", "Gen ", "Zhi ", "Chi ", "Ge ", "Zai ", "Luan ", "Fu ", "Jie ", "Hang ", "Gui ", "Tao ", "Guang ", "Wei ", "Kuang ", "Ru ", "An ", "An ", "Juan ", "Yi ", "Zhuo ", "Ku ", "Zhi ", "Qiong ", "Tong ", "Sang ", "Sang ", "Huan ", "Jie ", "Jiu ", "Xue ", "Duo ", "Zhui ", "Yu ", "Zan ", "Kasei ", "Ying ", "Masu ", "[?] ", "Zhan ", "Ya ", "Nao ", "Zhen ", "Dang ", "Qi ", "Qiao ", "Hua ", "Kuai ", "Jiang ", "Zhuang ", "Xun ", "Suo ", "Sha ", "Zhen ", "Bei ", "Ting ", "Gua ", "Jing ", "Bo ", "Ben ", "Fu ", "Rui ", "Tong ", "Jue ", "Xi ", "Lang ", "Liu ", "Feng ", "Qi ", "Wen ", "Jun ", "Gan ", "Cu ", "Liang ", "Qiu ", "Ting ", "You ", "Mei ", "Bang ", "Long ", "Peng ", "Zhuang ", "Di ", "Xuan ", "Tu ", "Zao ", "Ao ", "Gu ", "Bi ", "Di ", "Han ", "Zi ", "Zhi ", "Ren ", "Bei ", "Geng ", "Jian ", "Huan ", "Wan ", "Nuo ", "Jia ", "Tiao ", "Ji ", "Xiao ", "Lu ", "Huan ", "Shao ", "Cen ", "Fen ", "Song ", "Meng ", "Wu ", "Li ", "Li ", "Dou ", "Cen ", "Ying ", "Suo ", "Ju ", "Ti ", "Jie ", "Kun ", "Zhuo ", "Shu ", "Chan ", "Fan ", "Wei ", "Jing ", "Li ", "Bing ", "Fumoto ", "Shikimi ", "Tao ", "Zhi ", "Lai ", "Lian ", "Jian ", "Zhuo ", "Ling ", "Li ", "Qi ", "Bing ", "Zhun ", "Cong ", "Qian ", "Mian ", "Qi ", "Qi ", "Cai ", "Gun ", "Chan ", "Te ", "Fei ", "Pai ", "Bang ", "Pou ", "Hun ", "Zong ", "Cheng ", "Zao ", "Ji ", "Li ", "Peng ", "Yu ", "Yu ", "Gu ", "Hun ", "Dong ", "Tang ", "Gang ", "Wang ", "Di ", "Xi ", "Fan ", "Cheng ", "Zhan ", "Qi ", "Yuan ", "Yan ", "Yu ", "Quan ", "Yi ", "Sen ", "Ren ", "Chui ", "Leng ", "Qi ", "Zhuo ", "Fu ", "Ke ", "Lai ", "Zou ", "Zou ", "Zhuo ", "Guan ", "Fen ", "Fen ", "Chen ", "Qiong ", "Nie "];
  }
});

// node_modules/unidecode/data/x69.js
var require_x69 = __commonJS({
  "node_modules/unidecode/data/x69.js"(exports, module2) {
    module2.exports = ["Wan ", "Guo ", "Lu ", "Hao ", "Jie ", "Yi ", "Chou ", "Ju ", "Ju ", "Cheng ", "Zuo ", "Liang ", "Qiang ", "Zhi ", "Zhui ", "Ya ", "Ju ", "Bei ", "Jiao ", "Zhuo ", "Zi ", "Bin ", "Peng ", "Ding ", "Chu ", "Chang ", "Kunugi ", "Momiji ", "Jian ", "Gui ", "Xi ", "Du ", "Qian ", "Kunugi ", "Soko ", "Shide ", "Luo ", "Zhi ", "Ken ", "Myeng ", "Tafu ", "[?] ", "Peng ", "Zhan ", "[?] ", "Tuo ", "Sen ", "Duo ", "Ye ", "Fou ", "Wei ", "Wei ", "Duan ", "Jia ", "Zong ", "Jian ", "Yi ", "Shen ", "Xi ", "Yan ", "Yan ", "Chuan ", "Zhan ", "Chun ", "Yu ", "He ", "Zha ", "Wo ", "Pian ", "Bi ", "Yao ", "Huo ", "Xu ", "Ruo ", "Yang ", "La ", "Yan ", "Ben ", "Hun ", "Kui ", "Jie ", "Kui ", "Si ", "Feng ", "Xie ", "Tuo ", "Zhi ", "Jian ", "Mu ", "Mao ", "Chu ", "Hu ", "Hu ", "Lian ", "Leng ", "Ting ", "Nan ", "Yu ", "You ", "Mei ", "Song ", "Xuan ", "Xuan ", "Ying ", "Zhen ", "Pian ", "Ye ", "Ji ", "Jie ", "Ye ", "Chu ", "Shun ", "Yu ", "Cou ", "Wei ", "Mei ", "Di ", "Ji ", "Jie ", "Kai ", "Qiu ", "Ying ", "Rou ", "Heng ", "Lou ", "Le ", "Hazou ", "Katsura ", "Pin ", "Muro ", "Gai ", "Tan ", "Lan ", "Yun ", "Yu ", "Chen ", "Lu ", "Ju ", "Sakaki ", "[?] ", "Pi ", "Xie ", "Jia ", "Yi ", "Zhan ", "Fu ", "Nai ", "Mi ", "Lang ", "Rong ", "Gu ", "Jian ", "Ju ", "Ta ", "Yao ", "Zhen ", "Bang ", "Sha ", "Yuan ", "Zi ", "Ming ", "Su ", "Jia ", "Yao ", "Jie ", "Huang ", "Gan ", "Fei ", "Zha ", "Qian ", "Ma ", "Sun ", "Yuan ", "Xie ", "Rong ", "Shi ", "Zhi ", "Cui ", "Yun ", "Ting ", "Liu ", "Rong ", "Tang ", "Que ", "Zhai ", "Si ", "Sheng ", "Ta ", "Ke ", "Xi ", "Gu ", "Qi ", "Kao ", "Gao ", "Sun ", "Pan ", "Tao ", "Ge ", "Xun ", "Dian ", "Nou ", "Ji ", "Shuo ", "Gou ", "Chui ", "Qiang ", "Cha ", "Qian ", "Huai ", "Mei ", "Xu ", "Gang ", "Gao ", "Zhuo ", "Tuo ", "Hashi ", "Yang ", "Dian ", "Jia ", "Jian ", "Zui ", "Kashi ", "Ori ", "Bin ", "Zhu ", "[?] ", "Xi ", "Qi ", "Lian ", "Hui ", "Yong ", "Qian ", "Guo ", "Gai ", "Gai ", "Tuan ", "Hua ", "Cu ", "Sen ", "Cui ", "Beng ", "You ", "Hu ", "Jiang ", "Hu ", "Huan ", "Kui ", "Yi ", "Nie ", "Gao ", "Kang ", "Gui ", "Gui ", "Cao ", "Man ", "Jin "];
  }
});

// node_modules/unidecode/data/x6a.js
var require_x6a = __commonJS({
  "node_modules/unidecode/data/x6a.js"(exports, module2) {
    module2.exports = ["Di ", "Zhuang ", "Le ", "Lang ", "Chen ", "Cong ", "Li ", "Xiu ", "Qing ", "Shuang ", "Fan ", "Tong ", "Guan ", "Ji ", "Suo ", "Lei ", "Lu ", "Liang ", "Mi ", "Lou ", "Chao ", "Su ", "Ke ", "Shu ", "Tang ", "Biao ", "Lu ", "Jiu ", "Shu ", "Zha ", "Shu ", "Zhang ", "Men ", "Mo ", "Niao ", "Yang ", "Tiao ", "Peng ", "Zhu ", "Sha ", "Xi ", "Quan ", "Heng ", "Jian ", "Cong ", "[?] ", "Hokuso ", "Qiang ", "Tara ", "Ying ", "Er ", "Xin ", "Zhi ", "Qiao ", "Zui ", "Cong ", "Pu ", "Shu ", "Hua ", "Kui ", "Zhen ", "Zun ", "Yue ", "Zhan ", "Xi ", "Xun ", "Dian ", "Fa ", "Gan ", "Mo ", "Wu ", "Qiao ", "Nao ", "Lin ", "Liu ", "Qiao ", "Xian ", "Run ", "Fan ", "Zhan ", "Tuo ", "Lao ", "Yun ", "Shun ", "Tui ", "Cheng ", "Tang ", "Meng ", "Ju ", "Cheng ", "Su ", "Jue ", "Jue ", "Tan ", "Hui ", "Ji ", "Nuo ", "Xiang ", "Tuo ", "Ning ", "Rui ", "Zhu ", "Chuang ", "Zeng ", "Fen ", "Qiong ", "Ran ", "Heng ", "Cen ", "Gu ", "Liu ", "Lao ", "Gao ", "Chu ", "Zusa ", "Nude ", "Ca ", "San ", "Ji ", "Dou ", "Shou ", "Lu ", "[?] ", "[?] ", "Yuan ", "Ta ", "Shu ", "Jiang ", "Tan ", "Lin ", "Nong ", "Yin ", "Xi ", "Sui ", "Shan ", "Zui ", "Xuan ", "Cheng ", "Gan ", "Ju ", "Zui ", "Yi ", "Qin ", "Pu ", "Yan ", "Lei ", "Feng ", "Hui ", "Dang ", "Ji ", "Sui ", "Bo ", "Bi ", "Ding ", "Chu ", "Zhua ", "Kuai ", "Ji ", "Jie ", "Jia ", "Qing ", "Zhe ", "Jian ", "Qiang ", "Dao ", "Yi ", "Biao ", "Song ", "She ", "Lin ", "Kunugi ", "Cha ", "Meng ", "Yin ", "Tao ", "Tai ", "Mian ", "Qi ", "Toan ", "Bin ", "Huo ", "Ji ", "Qian ", "Mi ", "Ning ", "Yi ", "Gao ", "Jian ", "Yin ", "Er ", "Qing ", "Yan ", "Qi ", "Mi ", "Zhao ", "Gui ", "Chun ", "Ji ", "Kui ", "Po ", "Deng ", "Chu ", "[?] ", "Mian ", "You ", "Zhi ", "Guang ", "Qian ", "Lei ", "Lei ", "Sa ", "Lu ", "Li ", "Cuan ", "Lu ", "Mie ", "Hui ", "Ou ", "Lu ", "Jie ", "Gao ", "Du ", "Yuan ", "Li ", "Fei ", "Zhuo ", "Sou ", "Lian ", "Tamo ", "Chu ", "[?] ", "Zhu ", "Lu ", "Yan ", "Li ", "Zhu ", "Chen ", "Jie ", "E ", "Su ", "Huai ", "Nie ", "Yu ", "Long ", "Lai ", "[?] ", "Xian ", "Kwi ", "Ju ", "Xiao ", "Ling ", "Ying ", "Jian ", "Yin ", "You ", "Ying "];
  }
});

// node_modules/unidecode/data/x6b.js
var require_x6b = __commonJS({
  "node_modules/unidecode/data/x6b.js"(exports, module2) {
    module2.exports = ["Xiang ", "Nong ", "Bo ", "Chan ", "Lan ", "Ju ", "Shuang ", "She ", "Wei ", "Cong ", "Quan ", "Qu ", "Cang ", "[?] ", "Yu ", "Luo ", "Li ", "Zan ", "Luan ", "Dang ", "Jue ", "Em ", "Lan ", "Lan ", "Zhu ", "Lei ", "Li ", "Ba ", "Nang ", "Yu ", "Ling ", "Tsuki ", "Qian ", "Ci ", "Huan ", "Xin ", "Yu ", "Yu ", "Qian ", "Ou ", "Xu ", "Chao ", "Chu ", "Chi ", "Kai ", "Yi ", "Jue ", "Xi ", "Xu ", "Xia ", "Yu ", "Kuai ", "Lang ", "Kuan ", "Shuo ", "Xi ", "Ai ", "Yi ", "Qi ", "Hu ", "Chi ", "Qin ", "Kuan ", "Kan ", "Kuan ", "Kan ", "Chuan ", "Sha ", "Gua ", "Yin ", "Xin ", "Xie ", "Yu ", "Qian ", "Xiao ", "Yi ", "Ge ", "Wu ", "Tan ", "Jin ", "Ou ", "Hu ", "Ti ", "Huan ", "Xu ", "Pen ", "Xi ", "Xiao ", "Xu ", "Xi ", "Sen ", "Lian ", "Chu ", "Yi ", "Kan ", "Yu ", "Chuo ", "Huan ", "Zhi ", "Zheng ", "Ci ", "Bu ", "Wu ", "Qi ", "Bu ", "Bu ", "Wai ", "Ju ", "Qian ", "Chi ", "Se ", "Chi ", "Se ", "Zhong ", "Sui ", "Sui ", "Li ", "Cuo ", "Yu ", "Li ", "Gui ", "Dai ", "Dai ", "Si ", "Jian ", "Zhe ", "Mo ", "Mo ", "Yao ", "Mo ", "Cu ", "Yang ", "Tian ", "Sheng ", "Dai ", "Shang ", "Xu ", "Xun ", "Shu ", "Can ", "Jue ", "Piao ", "Qia ", "Qiu ", "Su ", "Qing ", "Yun ", "Lian ", "Yi ", "Fou ", "Zhi ", "Ye ", "Can ", "Hun ", "Dan ", "Ji ", "Ye ", "Zhen ", "Yun ", "Wen ", "Chou ", "Bin ", "Ti ", "Jin ", "Shang ", "Yin ", "Diao ", "Cu ", "Hui ", "Cuan ", "Yi ", "Dan ", "Du ", "Jiang ", "Lian ", "Bin ", "Du ", "Tsukusu ", "Jian ", "Shu ", "Ou ", "Duan ", "Zhu ", "Yin ", "Qing ", "Yi ", "Sha ", "Que ", "Ke ", "Yao ", "Jun ", "Dian ", "Hui ", "Hui ", "Gu ", "Que ", "Ji ", "Yi ", "Ou ", "Hui ", "Duan ", "Yi ", "Xiao ", "Wu ", "Guan ", "Mu ", "Mei ", "Mei ", "Ai ", "Zuo ", "Du ", "Yu ", "Bi ", "Bi ", "Bi ", "Pi ", "Pi ", "Bi ", "Chan ", "Mao ", "[?] ", "[?] ", "Pu ", "Mushiru ", "Jia ", "Zhan ", "Sai ", "Mu ", "Tuo ", "Xun ", "Er ", "Rong ", "Xian ", "Ju ", "Mu ", "Hao ", "Qiu ", "Dou ", "Mushiru ", "Tan ", "Pei ", "Ju ", "Duo ", "Cui ", "Bi ", "San ", "[?] ", "Mao ", "Sui ", "Yu ", "Yu ", "Tuo ", "He ", "Jian ", "Ta ", "San "];
  }
});

// node_modules/unidecode/data/x6c.js
var require_x6c = __commonJS({
  "node_modules/unidecode/data/x6c.js"(exports, module2) {
    module2.exports = ["Lu ", "Mu ", "Li ", "Tong ", "Rong ", "Chang ", "Pu ", "Luo ", "Zhan ", "Sao ", "Zhan ", "Meng ", "Luo ", "Qu ", "Die ", "Shi ", "Di ", "Min ", "Jue ", "Mang ", "Qi ", "Pie ", "Nai ", "Qi ", "Dao ", "Xian ", "Chuan ", "Fen ", "Ri ", "Nei ", "[?] ", "Fu ", "Shen ", "Dong ", "Qing ", "Qi ", "Yin ", "Xi ", "Hai ", "Yang ", "An ", "Ya ", "Ke ", "Qing ", "Ya ", "Dong ", "Dan ", "Lu ", "Qing ", "Yang ", "Yun ", "Yun ", "Shui ", "San ", "Zheng ", "Bing ", "Yong ", "Dang ", "Shitamizu ", "Le ", "Ni ", "Tun ", "Fan ", "Gui ", "Ting ", "Zhi ", "Qiu ", "Bin ", "Ze ", "Mian ", "Cuan ", "Hui ", "Diao ", "Yi ", "Cha ", "Zhuo ", "Chuan ", "Wan ", "Fan ", "Dai ", "Xi ", "Tuo ", "Mang ", "Qiu ", "Qi ", "Shan ", "Pai ", "Han ", "Qian ", "Wu ", "Wu ", "Xun ", "Si ", "Ru ", "Gong ", "Jiang ", "Chi ", "Wu ", "Tsuchi ", "[?] ", "Tang ", "Zhi ", "Chi ", "Qian ", "Mi ", "Yu ", "Wang ", "Qing ", "Jing ", "Rui ", "Jun ", "Hong ", "Tai ", "Quan ", "Ji ", "Bian ", "Bian ", "Gan ", "Wen ", "Zhong ", "Fang ", "Xiong ", "Jue ", "Hang ", "Niou ", "Qi ", "Fen ", "Xu ", "Xu ", "Qin ", "Yi ", "Wo ", "Yun ", "Yuan ", "Hang ", "Yan ", "Chen ", "Chen ", "Dan ", "You ", "Dun ", "Hu ", "Huo ", "Qie ", "Mu ", "Rou ", "Mei ", "Ta ", "Mian ", "Wu ", "Chong ", "Tian ", "Bi ", "Sha ", "Zhi ", "Pei ", "Pan ", "Zhui ", "Za ", "Gou ", "Liu ", "Mei ", "Ze ", "Feng ", "Ou ", "Li ", "Lun ", "Cang ", "Feng ", "Wei ", "Hu ", "Mo ", "Mei ", "Shu ", "Ju ", "Zan ", "Tuo ", "Tuo ", "Tuo ", "He ", "Li ", "Mi ", "Yi ", "Fa ", "Fei ", "You ", "Tian ", "Zhi ", "Zhao ", "Gu ", "Zhan ", "Yan ", "Si ", "Kuang ", "Jiong ", "Ju ", "Xie ", "Qiu ", "Yi ", "Jia ", "Zhong ", "Quan ", "Bo ", "Hui ", "Mi ", "Ben ", "Zhuo ", "Chu ", "Le ", "You ", "Gu ", "Hong ", "Gan ", "Fa ", "Mao ", "Si ", "Hu ", "Ping ", "Ci ", "Fan ", "Chi ", "Su ", "Ning ", "Cheng ", "Ling ", "Pao ", "Bo ", "Qi ", "Si ", "Ni ", "Ju ", "Yue ", "Zhu ", "Sheng ", "Lei ", "Xuan ", "Xue ", "Fu ", "Pan ", "Min ", "Tai ", "Yang ", "Ji ", "Yong ", "Guan ", "Beng ", "Xue ", "Long ", "Lu ", "[?] ", "Bo ", "Xie ", "Po ", "Ze ", "Jing ", "Yin "];
  }
});

// node_modules/unidecode/data/x6d.js
var require_x6d = __commonJS({
  "node_modules/unidecode/data/x6d.js"(exports, module2) {
    module2.exports = ["Zhou ", "Ji ", "Yi ", "Hui ", "Hui ", "Zui ", "Cheng ", "Yin ", "Wei ", "Hou ", "Jian ", "Yang ", "Lie ", "Si ", "Ji ", "Er ", "Xing ", "Fu ", "Sa ", "Suo ", "Zhi ", "Yin ", "Wu ", "Xi ", "Kao ", "Zhu ", "Jiang ", "Luo ", "[?] ", "An ", "Dong ", "Yi ", "Mou ", "Lei ", "Yi ", "Mi ", "Quan ", "Jin ", "Mo ", "Wei ", "Xiao ", "Xie ", "Hong ", "Xu ", "Shuo ", "Kuang ", "Tao ", "Qie ", "Ju ", "Er ", "Zhou ", "Ru ", "Ping ", "Xun ", "Xiong ", "Zhi ", "Guang ", "Huan ", "Ming ", "Huo ", "Wa ", "Qia ", "Pai ", "Wu ", "Qu ", "Liu ", "Yi ", "Jia ", "Jing ", "Qian ", "Jiang ", "Jiao ", "Cheng ", "Shi ", "Zhuo ", "Ce ", "Pal ", "Kuai ", "Ji ", "Liu ", "Chan ", "Hun ", "Hu ", "Nong ", "Xun ", "Jin ", "Lie ", "Qiu ", "Wei ", "Zhe ", "Jun ", "Han ", "Bang ", "Mang ", "Zhuo ", "You ", "Xi ", "Bo ", "Dou ", "Wan ", "Hong ", "Yi ", "Pu ", "Ying ", "Lan ", "Hao ", "Lang ", "Han ", "Li ", "Geng ", "Fu ", "Wu ", "Lian ", "Chun ", "Feng ", "Yi ", "Yu ", "Tong ", "Lao ", "Hai ", "Jin ", "Jia ", "Chong ", "Weng ", "Mei ", "Sui ", "Cheng ", "Pei ", "Xian ", "Shen ", "Tu ", "Kun ", "Pin ", "Nie ", "Han ", "Jing ", "Xiao ", "She ", "Nian ", "Tu ", "Yong ", "Xiao ", "Xian ", "Ting ", "E ", "Su ", "Tun ", "Juan ", "Cen ", "Ti ", "Li ", "Shui ", "Si ", "Lei ", "Shui ", "Tao ", "Du ", "Lao ", "Lai ", "Lian ", "Wei ", "Wo ", "Yun ", "Huan ", "Di ", "[?] ", "Run ", "Jian ", "Zhang ", "Se ", "Fu ", "Guan ", "Xing ", "Shou ", "Shuan ", "Ya ", "Chuo ", "Zhang ", "Ye ", "Kong ", "Wo ", "Han ", "Tuo ", "Dong ", "He ", "Wo ", "Ju ", "Gan ", "Liang ", "Hun ", "Ta ", "Zhuo ", "Dian ", "Qie ", "De ", "Juan ", "Zi ", "Xi ", "Yao ", "Qi ", "Gu ", "Guo ", "Han ", "Lin ", "Tang ", "Zhou ", "Peng ", "Hao ", "Chang ", "Shu ", "Qi ", "Fang ", "Chi ", "Lu ", "Nao ", "Ju ", "Tao ", "Cong ", "Lei ", "Zhi ", "Peng ", "Fei ", "Song ", "Tian ", "Pi ", "Dan ", "Yu ", "Ni ", "Yu ", "Lu ", "Gan ", "Mi ", "Jing ", "Ling ", "Lun ", "Yin ", "Cui ", "Qu ", "Huai ", "Yu ", "Nian ", "Shen ", "Piao ", "Chun ", "Wa ", "Yuan ", "Lai ", "Hun ", "Qing ", "Yan ", "Qian ", "Tian ", "Miao ", "Zhi ", "Yin ", "Mi "];
  }
});

// node_modules/unidecode/data/x6e.js
var require_x6e = __commonJS({
  "node_modules/unidecode/data/x6e.js"(exports, module2) {
    module2.exports = ["Ben ", "Yuan ", "Wen ", "Re ", "Fei ", "Qing ", "Yuan ", "Ke ", "Ji ", "She ", "Yuan ", "Shibui ", "Lu ", "Zi ", "Du ", "[?] ", "Jian ", "Min ", "Pi ", "Tani ", "Yu ", "Yuan ", "Shen ", "Shen ", "Rou ", "Huan ", "Zhu ", "Jian ", "Nuan ", "Yu ", "Qiu ", "Ting ", "Qu ", "Du ", "Feng ", "Zha ", "Bo ", "Wo ", "Wo ", "Di ", "Wei ", "Wen ", "Ru ", "Xie ", "Ce ", "Wei ", "Ge ", "Gang ", "Yan ", "Hong ", "Xuan ", "Mi ", "Ke ", "Mao ", "Ying ", "Yan ", "You ", "Hong ", "Miao ", "Xing ", "Mei ", "Zai ", "Hun ", "Nai ", "Kui ", "Shi ", "E ", "Pai ", "Mei ", "Lian ", "Qi ", "Qi ", "Mei ", "Tian ", "Cou ", "Wei ", "Can ", "Tuan ", "Mian ", "Hui ", "Mo ", "Xu ", "Ji ", "Pen ", "Jian ", "Jian ", "Hu ", "Feng ", "Xiang ", "Yi ", "Yin ", "Zhan ", "Shi ", "Jie ", "Cheng ", "Huang ", "Tan ", "Yu ", "Bi ", "Min ", "Shi ", "Tu ", "Sheng ", "Yong ", "Qu ", "Zhong ", "Suei ", "Jiu ", "Jiao ", "Qiou ", "Yin ", "Tang ", "Long ", "Huo ", "Yuan ", "Nan ", "Ban ", "You ", "Quan ", "Chui ", "Liang ", "Chan ", "Yan ", "Chun ", "Nie ", "Zi ", "Wan ", "Shi ", "Man ", "Ying ", "Ratsu ", "Kui ", "[?] ", "Jian ", "Xu ", "Lu ", "Gui ", "Gai ", "[?] ", "[?] ", "Po ", "Jin ", "Gui ", "Tang ", "Yuan ", "Suo ", "Yuan ", "Lian ", "Yao ", "Meng ", "Zhun ", "Sheng ", "Ke ", "Tai ", "Da ", "Wa ", "Liu ", "Gou ", "Sao ", "Ming ", "Zha ", "Shi ", "Yi ", "Lun ", "Ma ", "Pu ", "Wei ", "Li ", "Cai ", "Wu ", "Xi ", "Wen ", "Qiang ", "Ze ", "Shi ", "Su ", "Yi ", "Zhen ", "Sou ", "Yun ", "Xiu ", "Yin ", "Rong ", "Hun ", "Su ", "Su ", "Ni ", "Ta ", "Shi ", "Ru ", "Wei ", "Pan ", "Chu ", "Chu ", "Pang ", "Weng ", "Cang ", "Mie ", "He ", "Dian ", "Hao ", "Huang ", "Xi ", "Zi ", "Di ", "Zhi ", "Ying ", "Fu ", "Jie ", "Hua ", "Ge ", "Zi ", "Tao ", "Teng ", "Sui ", "Bi ", "Jiao ", "Hui ", "Gun ", "Yin ", "Gao ", "Long ", "Zhi ", "Yan ", "She ", "Man ", "Ying ", "Chun ", "Lu ", "Lan ", "Luan ", "[?] ", "Bin ", "Tan ", "Yu ", "Sou ", "Hu ", "Bi ", "Biao ", "Zhi ", "Jiang ", "Kou ", "Shen ", "Shang ", "Di ", "Mi ", "Ao ", "Lu ", "Hu ", "Hu ", "You ", "Chan ", "Fan ", "Yong ", "Gun ", "Man "];
  }
});

// node_modules/unidecode/data/x6f.js
var require_x6f = __commonJS({
  "node_modules/unidecode/data/x6f.js"(exports, module2) {
    module2.exports = ["Qing ", "Yu ", "Piao ", "Ji ", "Ya ", "Jiao ", "Qi ", "Xi ", "Ji ", "Lu ", "Lu ", "Long ", "Jin ", "Guo ", "Cong ", "Lou ", "Zhi ", "Gai ", "Qiang ", "Li ", "Yan ", "Cao ", "Jiao ", "Cong ", "Qun ", "Tuan ", "Ou ", "Teng ", "Ye ", "Xi ", "Mi ", "Tang ", "Mo ", "Shang ", "Han ", "Lian ", "Lan ", "Wa ", "Li ", "Qian ", "Feng ", "Xuan ", "Yi ", "Man ", "Zi ", "Mang ", "Kang ", "Lei ", "Peng ", "Shu ", "Zhang ", "Zhang ", "Chong ", "Xu ", "Huan ", "Kuo ", "Jian ", "Yan ", "Chuang ", "Liao ", "Cui ", "Ti ", "Yang ", "Jiang ", "Cong ", "Ying ", "Hong ", "Xun ", "Shu ", "Guan ", "Ying ", "Xiao ", "[?] ", "[?] ", "Xu ", "Lian ", "Zhi ", "Wei ", "Pi ", "Jue ", "Jiao ", "Po ", "Dang ", "Hui ", "Jie ", "Wu ", "Pa ", "Ji ", "Pan ", "Gui ", "Xiao ", "Qian ", "Qian ", "Xi ", "Lu ", "Xi ", "Xuan ", "Dun ", "Huang ", "Min ", "Run ", "Su ", "Liao ", "Zhen ", "Zhong ", "Yi ", "Di ", "Wan ", "Dan ", "Tan ", "Chao ", "Xun ", "Kui ", "Yie ", "Shao ", "Tu ", "Zhu ", "San ", "Hei ", "Bi ", "Shan ", "Chan ", "Chan ", "Shu ", "Tong ", "Pu ", "Lin ", "Wei ", "Se ", "Se ", "Cheng ", "Jiong ", "Cheng ", "Hua ", "Jiao ", "Lao ", "Che ", "Gan ", "Cun ", "Heng ", "Si ", "Shu ", "Peng ", "Han ", "Yun ", "Liu ", "Hong ", "Fu ", "Hao ", "He ", "Xian ", "Jian ", "Shan ", "Xi ", "Oki ", "[?] ", "Lan ", "[?] ", "Yu ", "Lin ", "Min ", "Zao ", "Dang ", "Wan ", "Ze ", "Xie ", "Yu ", "Li ", "Shi ", "Xue ", "Ling ", "Man ", "Zi ", "Yong ", "Kuai ", "Can ", "Lian ", "Dian ", "Ye ", "Ao ", "Huan ", "Zhen ", "Chan ", "Man ", "Dan ", "Dan ", "Yi ", "Sui ", "Pi ", "Ju ", "Ta ", "Qin ", "Ji ", "Zhuo ", "Lian ", "Nong ", "Guo ", "Jin ", "Fen ", "Se ", "Ji ", "Sui ", "Hui ", "Chu ", "Ta ", "Song ", "Ding ", "[?] ", "Zhu ", "Lai ", "Bin ", "Lian ", "Mi ", "Shi ", "Shu ", "Mi ", "Ning ", "Ying ", "Ying ", "Meng ", "Jin ", "Qi ", "Pi ", "Ji ", "Hao ", "Ru ", "Zui ", "Wo ", "Tao ", "Yin ", "Yin ", "Dui ", "Ci ", "Huo ", "Jing ", "Lan ", "Jun ", "Ai ", "Pu ", "Zhuo ", "Wei ", "Bin ", "Gu ", "Qian ", "Xing ", "Hama ", "Kuo ", "Fei ", "[?] ", "Boku ", "Jian ", "Wei ", "Luo ", "Zan ", "Lu ", "Li "];
  }
});

// node_modules/unidecode/data/x70.js
var require_x70 = __commonJS({
  "node_modules/unidecode/data/x70.js"(exports, module2) {
    module2.exports = ["You ", "Yang ", "Lu ", "Si ", "Jie ", "Ying ", "Du ", "Wang ", "Hui ", "Xie ", "Pan ", "Shen ", "Biao ", "Chan ", "Mo ", "Liu ", "Jian ", "Pu ", "Se ", "Cheng ", "Gu ", "Bin ", "Huo ", "Xian ", "Lu ", "Qin ", "Han ", "Ying ", "Yong ", "Li ", "Jing ", "Xiao ", "Ying ", "Sui ", "Wei ", "Xie ", "Huai ", "Hao ", "Zhu ", "Long ", "Lai ", "Dui ", "Fan ", "Hu ", "Lai ", "[?] ", "[?] ", "Ying ", "Mi ", "Ji ", "Lian ", "Jian ", "Ying ", "Fen ", "Lin ", "Yi ", "Jian ", "Yue ", "Chan ", "Dai ", "Rang ", "Jian ", "Lan ", "Fan ", "Shuang ", "Yuan ", "Zhuo ", "Feng ", "She ", "Lei ", "Lan ", "Cong ", "Qu ", "Yong ", "Qian ", "Fa ", "Guan ", "Que ", "Yan ", "Hao ", "Hyeng ", "Sa ", "Zan ", "Luan ", "Yan ", "Li ", "Mi ", "Shan ", "Tan ", "Dang ", "Jiao ", "Chan ", "[?] ", "Hao ", "Ba ", "Zhu ", "Lan ", "Lan ", "Nang ", "Wan ", "Luan ", "Xun ", "Xian ", "Yan ", "Gan ", "Yan ", "Yu ", "Huo ", "Si ", "Mie ", "Guang ", "Deng ", "Hui ", "Xiao ", "Xiao ", "Hu ", "Hong ", "Ling ", "Zao ", "Zhuan ", "Jiu ", "Zha ", "Xie ", "Chi ", "Zhuo ", "Zai ", "Zai ", "Can ", "Yang ", "Qi ", "Zhong ", "Fen ", "Niu ", "Jiong ", "Wen ", "Po ", "Yi ", "Lu ", "Chui ", "Pi ", "Kai ", "Pan ", "Yan ", "Kai ", "Pang ", "Mu ", "Chao ", "Liao ", "Gui ", "Kang ", "Tun ", "Guang ", "Xin ", "Zhi ", "Guang ", "Guang ", "Wei ", "Qiang ", "[?] ", "Da ", "Xia ", "Zheng ", "Zhu ", "Ke ", "Zhao ", "Fu ", "Ba ", "Duo ", "Duo ", "Ling ", "Zhuo ", "Xuan ", "Ju ", "Tan ", "Pao ", "Jiong ", "Pao ", "Tai ", "Tai ", "Bing ", "Yang ", "Tong ", "Han ", "Zhu ", "Zha ", "Dian ", "Wei ", "Shi ", "Lian ", "Chi ", "Huang ", "[?] ", "Hu ", "Shuo ", "Lan ", "Jing ", "Jiao ", "Xu ", "Xing ", "Quan ", "Lie ", "Huan ", "Yang ", "Xiao ", "Xiu ", "Xian ", "Yin ", "Wu ", "Zhou ", "Yao ", "Shi ", "Wei ", "Tong ", "Xue ", "Zai ", "Kai ", "Hong ", "Luo ", "Xia ", "Zhu ", "Xuan ", "Zheng ", "Po ", "Yan ", "Hui ", "Guang ", "Zhe ", "Hui ", "Kao ", "[?] ", "Fan ", "Shao ", "Ye ", "Hui ", "[?] ", "Tang ", "Jin ", "Re ", "[?] ", "Xi ", "Fu ", "Jiong ", "Che ", "Pu ", "Jing ", "Zhuo ", "Ting ", "Wan ", "Hai ", "Peng ", "Lang ", "Shan ", "Hu ", "Feng ", "Chi ", "Rong "];
  }
});

// node_modules/unidecode/data/x71.js
var require_x71 = __commonJS({
  "node_modules/unidecode/data/x71.js"(exports, module2) {
    module2.exports = ["Hu ", "Xi ", "Shu ", "He ", "Xun ", "Ku ", "Jue ", "Xiao ", "Xi ", "Yan ", "Han ", "Zhuang ", "Jun ", "Di ", "Xie ", "Ji ", "Wu ", "[?] ", "[?] ", "Han ", "Yan ", "Huan ", "Men ", "Ju ", "Chou ", "Bei ", "Fen ", "Lin ", "Kun ", "Hun ", "Tun ", "Xi ", "Cui ", "Wu ", "Hong ", "Ju ", "Fu ", "Wo ", "Jiao ", "Cong ", "Feng ", "Ping ", "Qiong ", "Ruo ", "Xi ", "Qiong ", "Xin ", "Zhuo ", "Yan ", "Yan ", "Yi ", "Jue ", "Yu ", "Gang ", "Ran ", "Pi ", "Gu ", "[?] ", "Sheng ", "Chang ", "Shao ", "[?] ", "[?] ", "[?] ", "[?] ", "Chen ", "He ", "Kui ", "Zhong ", "Duan ", "Xia ", "Hui ", "Feng ", "Lian ", "Xuan ", "Xing ", "Huang ", "Jiao ", "Jian ", "Bi ", "Ying ", "Zhu ", "Wei ", "Tuan ", "Tian ", "Xi ", "Nuan ", "Nuan ", "Chan ", "Yan ", "Jiong ", "Jiong ", "Yu ", "Mei ", "Sha ", "Wei ", "Ye ", "Xin ", "Qiong ", "Rou ", "Mei ", "Huan ", "Xu ", "Zhao ", "Wei ", "Fan ", "Qiu ", "Sui ", "Yang ", "Lie ", "Zhu ", "Jie ", "Gao ", "Gua ", "Bao ", "Hu ", "Yun ", "Xia ", "[?] ", "[?] ", "Bian ", "Gou ", "Tui ", "Tang ", "Chao ", "Shan ", "N ", "Bo ", "Huang ", "Xie ", "Xi ", "Wu ", "Xi ", "Yun ", "He ", "He ", "Xi ", "Yun ", "Xiong ", "Nai ", "Shan ", "Qiong ", "Yao ", "Xun ", "Mi ", "Lian ", "Ying ", "Wen ", "Rong ", "Oozutsu ", "[?] ", "Qiang ", "Liu ", "Xi ", "Bi ", "Biao ", "Zong ", "Lu ", "Jian ", "Shou ", "Yi ", "Lou ", "Feng ", "Sui ", "Yi ", "Tong ", "Jue ", "Zong ", "Yun ", "Hu ", "Yi ", "Zhi ", "Ao ", "Wei ", "Liao ", "Han ", "Ou ", "Re ", "Jiong ", "Man ", "[?] ", "Shang ", "Cuan ", "Zeng ", "Jian ", "Xi ", "Xi ", "Xi ", "Yi ", "Xiao ", "Chi ", "Huang ", "Chan ", "Ye ", "Qian ", "Ran ", "Yan ", "Xian ", "Qiao ", "Zun ", "Deng ", "Dun ", "Shen ", "Jiao ", "Fen ", "Si ", "Liao ", "Yu ", "Lin ", "Tong ", "Shao ", "Fen ", "Fan ", "Yan ", "Xun ", "Lan ", "Mei ", "Tang ", "Yi ", "Jing ", "Men ", "[?] ", "[?] ", "Ying ", "Yu ", "Yi ", "Xue ", "Lan ", "Tai ", "Zao ", "Can ", "Sui ", "Xi ", "Que ", "Cong ", "Lian ", "Hui ", "Zhu ", "Xie ", "Ling ", "Wei ", "Yi ", "Xie ", "Zhao ", "Hui ", "Tatsu ", "Nung ", "Lan ", "Ru ", "Xian ", "Kao ", "Xun ", "Jin ", "Chou ", "Chou ", "Yao "];
  }
});

// node_modules/unidecode/data/x72.js
var require_x72 = __commonJS({
  "node_modules/unidecode/data/x72.js"(exports, module2) {
    module2.exports = ["He ", "Lan ", "Biao ", "Rong ", "Li ", "Mo ", "Bao ", "Ruo ", "Lu ", "La ", "Ao ", "Xun ", "Kuang ", "Shuo ", "[?] ", "Li ", "Lu ", "Jue ", "Liao ", "Yan ", "Xi ", "Xie ", "Long ", "Ye ", "[?] ", "Rang ", "Yue ", "Lan ", "Cong ", "Jue ", "Tong ", "Guan ", "[?] ", "Che ", "Mi ", "Tang ", "Lan ", "Zhu ", "[?] ", "Ling ", "Cuan ", "Yu ", "Zhua ", "Tsumekanmuri ", "Pa ", "Zheng ", "Pao ", "Cheng ", "Yuan ", "Ai ", "Wei ", "[?] ", "Jue ", "Jue ", "Fu ", "Ye ", "Ba ", "Die ", "Ye ", "Yao ", "Zu ", "Shuang ", "Er ", "Qiang ", "Chuang ", "Ge ", "Zang ", "Die ", "Qiang ", "Yong ", "Qiang ", "Pian ", "Ban ", "Pan ", "Shao ", "Jian ", "Pai ", "Du ", "Chuang ", "Tou ", "Zha ", "Bian ", "Die ", "Bang ", "Bo ", "Chuang ", "You ", "[?] ", "Du ", "Ya ", "Cheng ", "Niu ", "Ushihen ", "Pin ", "Jiu ", "Mou ", "Tuo ", "Mu ", "Lao ", "Ren ", "Mang ", "Fang ", "Mao ", "Mu ", "Gang ", "Wu ", "Yan ", "Ge ", "Bei ", "Si ", "Jian ", "Gu ", "You ", "Ge ", "Sheng ", "Mu ", "Di ", "Qian ", "Quan ", "Quan ", "Zi ", "Te ", "Xi ", "Mang ", "Keng ", "Qian ", "Wu ", "Gu ", "Xi ", "Li ", "Li ", "Pou ", "Ji ", "Gang ", "Zhi ", "Ben ", "Quan ", "Run ", "Du ", "Ju ", "Jia ", "Jian ", "Feng ", "Pian ", "Ke ", "Ju ", "Kao ", "Chu ", "Xi ", "Bei ", "Luo ", "Jie ", "Ma ", "San ", "Wei ", "Li ", "Dun ", "Tong ", "[?] ", "Jiang ", "Ikenie ", "Li ", "Du ", "Lie ", "Pi ", "Piao ", "Bao ", "Xi ", "Chou ", "Wei ", "Kui ", "Chou ", "Quan ", "Fan ", "Ba ", "Fan ", "Qiu ", "Ji ", "Cai ", "Chuo ", "An ", "Jie ", "Zhuang ", "Guang ", "Ma ", "You ", "Kang ", "Bo ", "Hou ", "Ya ", "Yin ", "Huan ", "Zhuang ", "Yun ", "Kuang ", "Niu ", "Di ", "Qing ", "Zhong ", "Mu ", "Bei ", "Pi ", "Ju ", "Ni ", "Sheng ", "Pao ", "Xia ", "Tuo ", "Hu ", "Ling ", "Fei ", "Pi ", "Ni ", "Ao ", "You ", "Gou ", "Yue ", "Ju ", "Dan ", "Po ", "Gu ", "Xian ", "Ning ", "Huan ", "Hen ", "Jiao ", "He ", "Zhao ", "Ji ", "Xun ", "Shan ", "Ta ", "Rong ", "Shou ", "Tong ", "Lao ", "Du ", "Xia ", "Shi ", "Hua ", "Zheng ", "Yu ", "Sun ", "Yu ", "Bi ", "Mang ", "Xi ", "Juan ", "Li ", "Xia ", "Yin ", "Suan ", "Lang ", "Bei ", "Zhi ", "Yan "];
  }
});

// node_modules/unidecode/data/x73.js
var require_x73 = __commonJS({
  "node_modules/unidecode/data/x73.js"(exports, module2) {
    module2.exports = ["Sha ", "Li ", "Han ", "Xian ", "Jing ", "Pai ", "Fei ", "Yao ", "Ba ", "Qi ", "Ni ", "Biao ", "Yin ", "Lai ", "Xi ", "Jian ", "Qiang ", "Kun ", "Yan ", "Guo ", "Zong ", "Mi ", "Chang ", "Yi ", "Zhi ", "Zheng ", "Ya ", "Meng ", "Cai ", "Cu ", "She ", "Kari ", "Cen ", "Luo ", "Hu ", "Zong ", "Ji ", "Wei ", "Feng ", "Wo ", "Yuan ", "Xing ", "Zhu ", "Mao ", "Wei ", "Yuan ", "Xian ", "Tuan ", "Ya ", "Nao ", "Xie ", "Jia ", "Hou ", "Bian ", "You ", "You ", "Mei ", "Zha ", "Yao ", "Sun ", "Bo ", "Ming ", "Hua ", "Yuan ", "Sou ", "Ma ", "Yuan ", "Dai ", "Yu ", "Shi ", "Hao ", "[?] ", "Yi ", "Zhen ", "Chuang ", "Hao ", "Man ", "Jing ", "Jiang ", "Mu ", "Zhang ", "Chan ", "Ao ", "Ao ", "Hao ", "Cui ", "Fen ", "Jue ", "Bi ", "Bi ", "Huang ", "Pu ", "Lin ", "Yu ", "Tong ", "Yao ", "Liao ", "Shuo ", "Xiao ", "Swu ", "Ton ", "Xi ", "Ge ", "Juan ", "Du ", "Hui ", "Kuai ", "Xian ", "Xie ", "Ta ", "Xian ", "Xun ", "Ning ", "Pin ", "Huo ", "Nou ", "Meng ", "Lie ", "Nao ", "Guang ", "Shou ", "Lu ", "Ta ", "Xian ", "Mi ", "Rang ", "Huan ", "Nao ", "Luo ", "Xian ", "Qi ", "Jue ", "Xuan ", "Miao ", "Zi ", "Lu ", "Lu ", "Yu ", "Su ", "Wang ", "Qiu ", "Ga ", "Ding ", "Le ", "Ba ", "Ji ", "Hong ", "Di ", "Quan ", "Gan ", "Jiu ", "Yu ", "Ji ", "Yu ", "Yang ", "Ma ", "Gong ", "Wu ", "Fu ", "Wen ", "Jie ", "Ya ", "Fen ", "Bian ", "Beng ", "Yue ", "Jue ", "Yun ", "Jue ", "Wan ", "Jian ", "Mei ", "Dan ", "Pi ", "Wei ", "Huan ", "Xian ", "Qiang ", "Ling ", "Dai ", "Yi ", "An ", "Ping ", "Dian ", "Fu ", "Xuan ", "Xi ", "Bo ", "Ci ", "Gou ", "Jia ", "Shao ", "Po ", "Ci ", "Ke ", "Ran ", "Sheng ", "Shen ", "Yi ", "Zu ", "Jia ", "Min ", "Shan ", "Liu ", "Bi ", "Zhen ", "Zhen ", "Jue ", "Fa ", "Long ", "Jin ", "Jiao ", "Jian ", "Li ", "Guang ", "Xian ", "Zhou ", "Gong ", "Yan ", "Xiu ", "Yang ", "Xu ", "Luo ", "Su ", "Zhu ", "Qin ", "Ken ", "Xun ", "Bao ", "Er ", "Xiang ", "Yao ", "Xia ", "Heng ", "Gui ", "Chong ", "Xu ", "Ban ", "Pei ", "[?] ", "Dang ", "Ei ", "Hun ", "Wen ", "E ", "Cheng ", "Ti ", "Wu ", "Wu ", "Cheng ", "Jun ", "Mei ", "Bei ", "Ting ", "Xian ", "Chuo "];
  }
});

// node_modules/unidecode/data/x74.js
var require_x74 = __commonJS({
  "node_modules/unidecode/data/x74.js"(exports, module2) {
    module2.exports = ["Han ", "Xuan ", "Yan ", "Qiu ", "Quan ", "Lang ", "Li ", "Xiu ", "Fu ", "Liu ", "Ye ", "Xi ", "Ling ", "Li ", "Jin ", "Lian ", "Suo ", "Chiisai ", "[?] ", "Wan ", "Dian ", "Pin ", "Zhan ", "Cui ", "Min ", "Yu ", "Ju ", "Chen ", "Lai ", "Wen ", "Sheng ", "Wei ", "Dian ", "Chu ", "Zhuo ", "Pei ", "Cheng ", "Hu ", "Qi ", "E ", "Kun ", "Chang ", "Qi ", "Beng ", "Wan ", "Lu ", "Cong ", "Guan ", "Yan ", "Diao ", "Bei ", "Lin ", "Qin ", "Pi ", "Pa ", "Que ", "Zhuo ", "Qin ", "Fa ", "[?] ", "Qiong ", "Du ", "Jie ", "Hun ", "Yu ", "Mao ", "Mei ", "Chun ", "Xuan ", "Ti ", "Xing ", "Dai ", "Rou ", "Min ", "Zhen ", "Wei ", "Ruan ", "Huan ", "Jie ", "Chuan ", "Jian ", "Zhuan ", "Yang ", "Lian ", "Quan ", "Xia ", "Duan ", "Yuan ", "Ye ", "Nao ", "Hu ", "Ying ", "Yu ", "Huang ", "Rui ", "Se ", "Liu ", "Shi ", "Rong ", "Suo ", "Yao ", "Wen ", "Wu ", "Jin ", "Jin ", "Ying ", "Ma ", "Tao ", "Liu ", "Tang ", "Li ", "Lang ", "Gui ", "Zhen ", "Qiang ", "Cuo ", "Jue ", "Zhao ", "Yao ", "Ai ", "Bin ", "Tu ", "Chang ", "Kun ", "Zhuan ", "Cong ", "Jin ", "Yi ", "Cui ", "Cong ", "Qi ", "Li ", "Ying ", "Suo ", "Qiu ", "Xuan ", "Ao ", "Lian ", "Man ", "Zhang ", "Yin ", "[?] ", "Ying ", "Zhi ", "Lu ", "Wu ", "Deng ", "Xiou ", "Zeng ", "Xun ", "Qu ", "Dang ", "Lin ", "Liao ", "Qiong ", "Su ", "Huang ", "Gui ", "Pu ", "Jing ", "Fan ", "Jin ", "Liu ", "Ji ", "[?] ", "Jing ", "Ai ", "Bi ", "Can ", "Qu ", "Zao ", "Dang ", "Jiao ", "Gun ", "Tan ", "Hui ", "Huan ", "Se ", "Sui ", "Tian ", "[?] ", "Yu ", "Jin ", "Lu ", "Bin ", "Shou ", "Wen ", "Zui ", "Lan ", "Xi ", "Ji ", "Xuan ", "Ruan ", "Huo ", "Gai ", "Lei ", "Du ", "Li ", "Zhi ", "Rou ", "Li ", "Zan ", "Qiong ", "Zhe ", "Gui ", "Sui ", "La ", "Long ", "Lu ", "Li ", "Zan ", "Lan ", "Ying ", "Mi ", "Xiang ", "Xi ", "Guan ", "Dao ", "Zan ", "Huan ", "Gua ", "Bo ", "Die ", "Bao ", "Hu ", "Zhi ", "Piao ", "Ban ", "Rang ", "Li ", "Wa ", "Dekaguramu ", "Jiang ", "Qian ", "Fan ", "Pen ", "Fang ", "Dan ", "Weng ", "Ou ", "Deshiguramu ", "Miriguramu ", "Thon ", "Hu ", "Ling ", "Yi ", "Ping ", "Ci ", "Hekutogura ", "Juan ", "Chang ", "Chi ", "Sarake ", "Dang ", "Meng ", "Pou "];
  }
});

// node_modules/unidecode/data/x75.js
var require_x75 = __commonJS({
  "node_modules/unidecode/data/x75.js"(exports, module2) {
    module2.exports = ["Zhui ", "Ping ", "Bian ", "Zhou ", "Zhen ", "Senchigura ", "Ci ", "Ying ", "Qi ", "Xian ", "Lou ", "Di ", "Ou ", "Meng ", "Zhuan ", "Peng ", "Lin ", "Zeng ", "Wu ", "Pi ", "Dan ", "Weng ", "Ying ", "Yan ", "Gan ", "Dai ", "Shen ", "Tian ", "Tian ", "Han ", "Chang ", "Sheng ", "Qing ", "Sheng ", "Chan ", "Chan ", "Rui ", "Sheng ", "Su ", "Sen ", "Yong ", "Shuai ", "Lu ", "Fu ", "Yong ", "Beng ", "Feng ", "Ning ", "Tian ", "You ", "Jia ", "Shen ", "Zha ", "Dian ", "Fu ", "Nan ", "Dian ", "Ping ", "Ting ", "Hua ", "Ting ", "Quan ", "Zi ", "Meng ", "Bi ", "Qi ", "Liu ", "Xun ", "Liu ", "Chang ", "Mu ", "Yun ", "Fan ", "Fu ", "Geng ", "Tian ", "Jie ", "Jie ", "Quan ", "Wei ", "Fu ", "Tian ", "Mu ", "Tap ", "Pan ", "Jiang ", "Wa ", "Da ", "Nan ", "Liu ", "Ben ", "Zhen ", "Chu ", "Mu ", "Mu ", "Ce ", "Cen ", "Gai ", "Bi ", "Da ", "Zhi ", "Lue ", "Qi ", "Lue ", "Pan ", "Kesa ", "Fan ", "Hua ", "Yu ", "Yu ", "Mu ", "Jun ", "Yi ", "Liu ", "Yu ", "Die ", "Chou ", "Hua ", "Dang ", "Chuo ", "Ji ", "Wan ", "Jiang ", "Sheng ", "Chang ", "Tuan ", "Lei ", "Ji ", "Cha ", "Liu ", "Tatamu ", "Tuan ", "Lin ", "Jiang ", "Jiang ", "Chou ", "Bo ", "Die ", "Die ", "Pi ", "Nie ", "Dan ", "Shu ", "Shu ", "Zhi ", "Yi ", "Chuang ", "Nai ", "Ding ", "Bi ", "Jie ", "Liao ", "Gong ", "Ge ", "Jiu ", "Zhou ", "Xia ", "Shan ", "Xu ", "Nue ", "Li ", "Yang ", "Chen ", "You ", "Ba ", "Jie ", "Jue ", "Zhi ", "Xia ", "Cui ", "Bi ", "Yi ", "Li ", "Zong ", "Chuang ", "Feng ", "Zhu ", "Pao ", "Pi ", "Gan ", "Ke ", "Ci ", "Xie ", "Qi ", "Dan ", "Zhen ", "Fa ", "Zhi ", "Teng ", "Ju ", "Ji ", "Fei ", "Qu ", "Dian ", "Jia ", "Xian ", "Cha ", "Bing ", "Ni ", "Zheng ", "Yong ", "Jing ", "Quan ", "Chong ", "Tong ", "Yi ", "Kai ", "Wei ", "Hui ", "Duo ", "Yang ", "Chi ", "Zhi ", "Hen ", "Ya ", "Mei ", "Dou ", "Jing ", "Xiao ", "Tong ", "Tu ", "Mang ", "Pi ", "Xiao ", "Suan ", "Pu ", "Li ", "Zhi ", "Cuo ", "Duo ", "Wu ", "Sha ", "Lao ", "Shou ", "Huan ", "Xian ", "Yi ", "Peng ", "Zhang ", "Guan ", "Tan ", "Fei ", "Ma ", "Lin ", "Chi ", "Ji ", "Dian ", "An ", "Chi ", "Bi ", "Bei ", "Min ", "Gu ", "Dui ", "E ", "Wei "];
  }
});

// node_modules/unidecode/data/x76.js
var require_x76 = __commonJS({
  "node_modules/unidecode/data/x76.js"(exports, module2) {
    module2.exports = ["Yu ", "Cui ", "Ya ", "Zhu ", "Cu ", "Dan ", "Shen ", "Zhung ", "Ji ", "Yu ", "Hou ", "Feng ", "La ", "Yang ", "Shen ", "Tu ", "Yu ", "Gua ", "Wen ", "Huan ", "Ku ", "Jia ", "Yin ", "Yi ", "Lu ", "Sao ", "Jue ", "Chi ", "Xi ", "Guan ", "Yi ", "Wen ", "Ji ", "Chuang ", "Ban ", "Lei ", "Liu ", "Chai ", "Shou ", "Nue ", "Dian ", "Da ", "Pie ", "Tan ", "Zhang ", "Biao ", "Shen ", "Cu ", "Luo ", "Yi ", "Zong ", "Chou ", "Zhang ", "Zhai ", "Sou ", "Suo ", "Que ", "Diao ", "Lou ", "Lu ", "Mo ", "Jin ", "Yin ", "Ying ", "Huang ", "Fu ", "Liao ", "Long ", "Qiao ", "Liu ", "Lao ", "Xian ", "Fei ", "Dan ", "Yin ", "He ", "Yan ", "Ban ", "Xian ", "Guan ", "Guai ", "Nong ", "Yu ", "Wei ", "Yi ", "Yong ", "Pi ", "Lei ", "Li ", "Shu ", "Dan ", "Lin ", "Dian ", "Lin ", "Lai ", "Pie ", "Ji ", "Chi ", "Yang ", "Xian ", "Jie ", "Zheng ", "[?] ", "Li ", "Huo ", "Lai ", "Shaku ", "Dian ", "Xian ", "Ying ", "Yin ", "Qu ", "Yong ", "Tan ", "Dian ", "Luo ", "Luan ", "Luan ", "Bo ", "[?] ", "Gui ", "Po ", "Fa ", "Deng ", "Fa ", "Bai ", "Bai ", "Qie ", "Bi ", "Zao ", "Zao ", "Mao ", "De ", "Pa ", "Jie ", "Huang ", "Gui ", "Ci ", "Ling ", "Gao ", "Mo ", "Ji ", "Jiao ", "Peng ", "Gao ", "Ai ", "E ", "Hao ", "Han ", "Bi ", "Wan ", "Chou ", "Qian ", "Xi ", "Ai ", "Jiong ", "Hao ", "Huang ", "Hao ", "Ze ", "Cui ", "Hao ", "Xiao ", "Ye ", "Po ", "Hao ", "Jiao ", "Ai ", "Xing ", "Huang ", "Li ", "Piao ", "He ", "Jiao ", "Pi ", "Gan ", "Pao ", "Zhou ", "Jun ", "Qiu ", "Cun ", "Que ", "Zha ", "Gu ", "Jun ", "Jun ", "Zhou ", "Zha ", "Gu ", "Zhan ", "Du ", "Min ", "Qi ", "Ying ", "Yu ", "Bei ", "Zhao ", "Zhong ", "Pen ", "He ", "Ying ", "He ", "Yi ", "Bo ", "Wan ", "He ", "Ang ", "Zhan ", "Yan ", "Jian ", "He ", "Yu ", "Kui ", "Fan ", "Gai ", "Dao ", "Pan ", "Fu ", "Qiu ", "Sheng ", "Dao ", "Lu ", "Zhan ", "Meng ", "Li ", "Jin ", "Xu ", "Jian ", "Pan ", "Guan ", "An ", "Lu ", "Shu ", "Zhou ", "Dang ", "An ", "Gu ", "Li ", "Mu ", "Cheng ", "Gan ", "Xu ", "Mang ", "Mang ", "Zhi ", "Qi ", "Ruan ", "Tian ", "Xiang ", "Dun ", "Xin ", "Xi ", "Pan ", "Feng ", "Dun ", "Min "];
  }
});

// node_modules/unidecode/data/x77.js
var require_x77 = __commonJS({
  "node_modules/unidecode/data/x77.js"(exports, module2) {
    module2.exports = ["Ming ", "Sheng ", "Shi ", "Yun ", "Mian ", "Pan ", "Fang ", "Miao ", "Dan ", "Mei ", "Mao ", "Kan ", "Xian ", "Ou ", "Shi ", "Yang ", "Zheng ", "Yao ", "Shen ", "Huo ", "Da ", "Zhen ", "Kuang ", "Ju ", "Shen ", "Chi ", "Sheng ", "Mei ", "Mo ", "Zhu ", "Zhen ", "Zhen ", "Mian ", "Di ", "Yuan ", "Die ", "Yi ", "Zi ", "Zi ", "Chao ", "Zha ", "Xuan ", "Bing ", "Mi ", "Long ", "Sui ", "Dong ", "Mi ", "Die ", "Yi ", "Er ", "Ming ", "Xuan ", "Chi ", "Kuang ", "Juan ", "Mou ", "Zhen ", "Tiao ", "Yang ", "Yan ", "Mo ", "Zhong ", "Mai ", "Zhao ", "Zheng ", "Mei ", "Jun ", "Shao ", "Han ", "Huan ", "Di ", "Cheng ", "Cuo ", "Juan ", "E ", "Wan ", "Xian ", "Xi ", "Kun ", "Lai ", "Jian ", "Shan ", "Tian ", "Hun ", "Wan ", "Ling ", "Shi ", "Qiong ", "Lie ", "Yai ", "Jing ", "Zheng ", "Li ", "Lai ", "Sui ", "Juan ", "Shui ", "Sui ", "Du ", "Bi ", "Bi ", "Mu ", "Hun ", "Ni ", "Lu ", "Yi ", "Jie ", "Cai ", "Zhou ", "Yu ", "Hun ", "Ma ", "Xia ", "Xing ", "Xi ", "Gun ", "Cai ", "Chun ", "Jian ", "Mei ", "Du ", "Hou ", "Xuan ", "Ti ", "Kui ", "Gao ", "Rui ", "Mou ", "Xu ", "Fa ", "Wen ", "Miao ", "Chou ", "Kui ", "Mi ", "Weng ", "Kou ", "Dang ", "Chen ", "Ke ", "Sou ", "Xia ", "Qiong ", "Mao ", "Ming ", "Man ", "Shui ", "Ze ", "Zhang ", "Yi ", "Diao ", "Ou ", "Mo ", "Shun ", "Cong ", "Lou ", "Chi ", "Man ", "Piao ", "Cheng ", "Ji ", "Meng ", "[?] ", "Run ", "Pie ", "Xi ", "Qiao ", "Pu ", "Zhu ", "Deng ", "Shen ", "Shun ", "Liao ", "Che ", "Xian ", "Kan ", "Ye ", "Xu ", "Tong ", "Mou ", "Lin ", "Kui ", "Xian ", "Ye ", "Ai ", "Hui ", "Zhan ", "Jian ", "Gu ", "Zhao ", "Qu ", "Wei ", "Chou ", "Sao ", "Ning ", "Xun ", "Yao ", "Huo ", "Meng ", "Mian ", "Bin ", "Mian ", "Li ", "Kuang ", "Jue ", "Xuan ", "Mian ", "Huo ", "Lu ", "Meng ", "Long ", "Guan ", "Man ", "Xi ", "Chu ", "Tang ", "Kan ", "Zhu ", "Mao ", "Jin ", "Lin ", "Yu ", "Shuo ", "Ce ", "Jue ", "Shi ", "Yi ", "Shen ", "Zhi ", "Hou ", "Shen ", "Ying ", "Ju ", "Zhou ", "Jiao ", "Cuo ", "Duan ", "Ai ", "Jiao ", "Zeng ", "Huo ", "Bai ", "Shi ", "Ding ", "Qi ", "Ji ", "Zi ", "Gan ", "Wu ", "Tuo ", "Ku ", "Qiang ", "Xi ", "Fan ", "Kuang "];
  }
});

// node_modules/unidecode/data/x78.js
var require_x78 = __commonJS({
  "node_modules/unidecode/data/x78.js"(exports, module2) {
    module2.exports = ["Dang ", "Ma ", "Sha ", "Dan ", "Jue ", "Li ", "Fu ", "Min ", "Nuo ", "Huo ", "Kang ", "Zhi ", "Qi ", "Kan ", "Jie ", "Fen ", "E ", "Ya ", "Pi ", "Zhe ", "Yan ", "Sui ", "Zhuan ", "Che ", "Dun ", "Pan ", "Yan ", "[?] ", "Feng ", "Fa ", "Mo ", "Zha ", "Qu ", "Yu ", "Luo ", "Tuo ", "Tuo ", "Di ", "Zhai ", "Zhen ", "Ai ", "Fei ", "Mu ", "Zhu ", "Li ", "Bian ", "Nu ", "Ping ", "Peng ", "Ling ", "Pao ", "Le ", "Po ", "Bo ", "Po ", "Shen ", "Za ", "Nuo ", "Li ", "Long ", "Tong ", "[?] ", "Li ", "Aragane ", "Chu ", "Keng ", "Quan ", "Zhu ", "Kuang ", "Huo ", "E ", "Nao ", "Jia ", "Lu ", "Wei ", "Ai ", "Luo ", "Ken ", "Xing ", "Yan ", "Tong ", "Peng ", "Xi ", "[?] ", "Hong ", "Shuo ", "Xia ", "Qiao ", "[?] ", "Wei ", "Qiao ", "[?] ", "Keng ", "Xiao ", "Que ", "Chan ", "Lang ", "Hong ", "Yu ", "Xiao ", "Xia ", "Mang ", "Long ", "Iong ", "Che ", "Che ", "E ", "Liu ", "Ying ", "Mang ", "Que ", "Yan ", "Sha ", "Kun ", "Yu ", "[?] ", "Kaki ", "Lu ", "Chen ", "Jian ", "Nue ", "Song ", "Zhuo ", "Keng ", "Peng ", "Yan ", "Zhui ", "Kong ", "Ceng ", "Qi ", "Zong ", "Qing ", "Lin ", "Jun ", "Bo ", "Ding ", "Min ", "Diao ", "Jian ", "He ", "Lu ", "Ai ", "Sui ", "Que ", "Ling ", "Bei ", "Yin ", "Dui ", "Wu ", "Qi ", "Lun ", "Wan ", "Dian ", "Gang ", "Pei ", "Qi ", "Chen ", "Ruan ", "Yan ", "Die ", "Ding ", "Du ", "Tuo ", "Jie ", "Ying ", "Bian ", "Ke ", "Bi ", "Wei ", "Shuo ", "Zhen ", "Duan ", "Xia ", "Dang ", "Ti ", "Nao ", "Peng ", "Jian ", "Di ", "Tan ", "Cha ", "Seki ", "Qi ", "[?] ", "Feng ", "Xuan ", "Que ", "Que ", "Ma ", "Gong ", "Nian ", "Su ", "E ", "Ci ", "Liu ", "Si ", "Tang ", "Bang ", "Hua ", "Pi ", "Wei ", "Sang ", "Lei ", "Cuo ", "Zhen ", "Xia ", "Qi ", "Lian ", "Pan ", "Wei ", "Yun ", "Dui ", "Zhe ", "Ke ", "La ", "[?] ", "Qing ", "Gun ", "Zhuan ", "Chan ", "Qi ", "Ao ", "Peng ", "Lu ", "Lu ", "Kan ", "Qiang ", "Chen ", "Yin ", "Lei ", "Biao ", "Qi ", "Mo ", "Qi ", "Cui ", "Zong ", "Qing ", "Chuo ", "[?] ", "Ji ", "Shan ", "Lao ", "Qu ", "Zeng ", "Deng ", "Jian ", "Xi ", "Lin ", "Ding ", "Dian ", "Huang ", "Pan ", "Za ", "Qiao ", "Di ", "Li "];
  }
});

// node_modules/unidecode/data/x79.js
var require_x79 = __commonJS({
  "node_modules/unidecode/data/x79.js"(exports, module2) {
    module2.exports = ["Tani ", "Jiao ", "[?] ", "Zhang ", "Qiao ", "Dun ", "Xian ", "Yu ", "Zhui ", "He ", "Huo ", "Zhai ", "Lei ", "Ke ", "Chu ", "Ji ", "Que ", "Dang ", "Yi ", "Jiang ", "Pi ", "Pi ", "Yu ", "Pin ", "Qi ", "Ai ", "Kai ", "Jian ", "Yu ", "Ruan ", "Meng ", "Pao ", "Ci ", "[?] ", "[?] ", "Mie ", "Ca ", "Xian ", "Kuang ", "Lei ", "Lei ", "Zhi ", "Li ", "Li ", "Fan ", "Que ", "Pao ", "Ying ", "Li ", "Long ", "Long ", "Mo ", "Bo ", "Shuang ", "Guan ", "Lan ", "Zan ", "Yan ", "Shi ", "Shi ", "Li ", "Reng ", "She ", "Yue ", "Si ", "Qi ", "Ta ", "Ma ", "Xie ", "Xian ", "Xian ", "Zhi ", "Qi ", "Zhi ", "Beng ", "Dui ", "Zhong ", "[?] ", "Yi ", "Shi ", "You ", "Zhi ", "Tiao ", "Fu ", "Fu ", "Mi ", "Zu ", "Zhi ", "Suan ", "Mei ", "Zuo ", "Qu ", "Hu ", "Zhu ", "Shen ", "Sui ", "Ci ", "Chai ", "Mi ", "Lu ", "Yu ", "Xiang ", "Wu ", "Tiao ", "Piao ", "Zhu ", "Gui ", "Xia ", "Zhi ", "Ji ", "Gao ", "Zhen ", "Gao ", "Shui ", "Jin ", "Chen ", "Gai ", "Kun ", "Di ", "Dao ", "Huo ", "Tao ", "Qi ", "Gu ", "Guan ", "Zui ", "Ling ", "Lu ", "Bing ", "Jin ", "Dao ", "Zhi ", "Lu ", "Shan ", "Bei ", "Zhe ", "Hui ", "You ", "Xi ", "Yin ", "Zi ", "Huo ", "Zhen ", "Fu ", "Yuan ", "Wu ", "Xian ", "Yang ", "Ti ", "Yi ", "Mei ", "Si ", "Di ", "[?] ", "Zhuo ", "Zhen ", "Yong ", "Ji ", "Gao ", "Tang ", "Si ", "Ma ", "Ta ", "[?] ", "Xuan ", "Qi ", "Yu ", "Xi ", "Ji ", "Si ", "Chan ", "Tan ", "Kuai ", "Sui ", "Li ", "Nong ", "Ni ", "Dao ", "Li ", "Rang ", "Yue ", "Ti ", "Zan ", "Lei ", "Rou ", "Yu ", "Yu ", "Chi ", "Xie ", "Qin ", "He ", "Tu ", "Xiu ", "Si ", "Ren ", "Tu ", "Zi ", "Cha ", "Gan ", "Yi ", "Xian ", "Bing ", "Nian ", "Qiu ", "Qiu ", "Chong ", "Fen ", "Hao ", "Yun ", "Ke ", "Miao ", "Zhi ", "Geng ", "Bi ", "Zhi ", "Yu ", "Mi ", "Ku ", "Ban ", "Pi ", "Ni ", "Li ", "You ", "Zu ", "Pi ", "Ba ", "Ling ", "Mo ", "Cheng ", "Nian ", "Qin ", "Yang ", "Zuo ", "Zhi ", "Zhi ", "Shu ", "Ju ", "Zi ", "Huo ", "Ji ", "Cheng ", "Tong ", "Zhi ", "Huo ", "He ", "Yin ", "Zi ", "Zhi ", "Jie ", "Ren ", "Du ", "Yi ", "Zhu ", "Hui ", "Nong ", "Fu "];
  }
});

// node_modules/unidecode/data/x7a.js
var require_x7a = __commonJS({
  "node_modules/unidecode/data/x7a.js"(exports, module2) {
    module2.exports = ["Xi ", "Kao ", "Lang ", "Fu ", "Ze ", "Shui ", "Lu ", "Kun ", "Gan ", "Geng ", "Ti ", "Cheng ", "Tu ", "Shao ", "Shui ", "Ya ", "Lun ", "Lu ", "Gu ", "Zuo ", "Ren ", "Zhun ", "Bang ", "Bai ", "Ji ", "Zhi ", "Zhi ", "Kun ", "Leng ", "Peng ", "Ke ", "Bing ", "Chou ", "Zu ", "Yu ", "Su ", "Lue ", "[?] ", "Yi ", "Xi ", "Bian ", "Ji ", "Fu ", "Bi ", "Nuo ", "Jie ", "Zhong ", "Zong ", "Xu ", "Cheng ", "Dao ", "Wen ", "Lian ", "Zi ", "Yu ", "Ji ", "Xu ", "Zhen ", "Zhi ", "Dao ", "Jia ", "Ji ", "Gao ", "Gao ", "Gu ", "Rong ", "Sui ", "You ", "Ji ", "Kang ", "Mu ", "Shan ", "Men ", "Zhi ", "Ji ", "Lu ", "Su ", "Ji ", "Ying ", "Wen ", "Qiu ", "Se ", "[?] ", "Yi ", "Huang ", "Qie ", "Ji ", "Sui ", "Xiao ", "Pu ", "Jiao ", "Zhuo ", "Tong ", "Sai ", "Lu ", "Sui ", "Nong ", "Se ", "Hui ", "Rang ", "Nuo ", "Yu ", "Bin ", "Ji ", "Tui ", "Wen ", "Cheng ", "Huo ", "Gong ", "Lu ", "Biao ", "[?] ", "Rang ", "Zhuo ", "Li ", "Zan ", "Xue ", "Wa ", "Jiu ", "Qiong ", "Xi ", "Qiong ", "Kong ", "Yu ", "Sen ", "Jing ", "Yao ", "Chuan ", "Zhun ", "Tu ", "Lao ", "Qie ", "Zhai ", "Yao ", "Bian ", "Bao ", "Yao ", "Bing ", "Wa ", "Zhu ", "Jiao ", "Qiao ", "Diao ", "Wu ", "Gui ", "Yao ", "Zhi ", "Chuang ", "Yao ", "Tiao ", "Jiao ", "Chuang ", "Jiong ", "Xiao ", "Cheng ", "Kou ", "Cuan ", "Wo ", "Dan ", "Ku ", "Ke ", "Zhui ", "Xu ", "Su ", "Guan ", "Kui ", "Dou ", "[?] ", "Yin ", "Wo ", "Wa ", "Ya ", "Yu ", "Ju ", "Qiong ", "Yao ", "Yao ", "Tiao ", "Chao ", "Yu ", "Tian ", "Diao ", "Ju ", "Liao ", "Xi ", "Wu ", "Kui ", "Chuang ", "Zhao ", "[?] ", "Kuan ", "Long ", "Cheng ", "Cui ", "Piao ", "Zao ", "Cuan ", "Qiao ", "Qiong ", "Dou ", "Zao ", "Long ", "Qie ", "Li ", "Chu ", "Shi ", "Fou ", "Qian ", "Chu ", "Hong ", "Qi ", "Qian ", "Gong ", "Shi ", "Shu ", "Miao ", "Ju ", "Zhan ", "Zhu ", "Ling ", "Long ", "Bing ", "Jing ", "Jing ", "Zhang ", "Yi ", "Si ", "Jun ", "Hong ", "Tong ", "Song ", "Jing ", "Diao ", "Yi ", "Shu ", "Jing ", "Qu ", "Jie ", "Ping ", "Duan ", "Shao ", "Zhuan ", "Ceng ", "Deng ", "Cui ", "Huai ", "Jing ", "Kan ", "Jing ", "Zhu ", "Zhu ", "Le ", "Peng ", "Yu ", "Chi ", "Gan "];
  }
});

// node_modules/unidecode/data/x7b.js
var require_x7b = __commonJS({
  "node_modules/unidecode/data/x7b.js"(exports, module2) {
    module2.exports = ["Mang ", "Zhu ", "Utsubo ", "Du ", "Ji ", "Xiao ", "Ba ", "Suan ", "Ji ", "Zhen ", "Zhao ", "Sun ", "Ya ", "Zhui ", "Yuan ", "Hu ", "Gang ", "Xiao ", "Cen ", "Pi ", "Bi ", "Jian ", "Yi ", "Dong ", "Shan ", "Sheng ", "Xia ", "Di ", "Zhu ", "Na ", "Chi ", "Gu ", "Li ", "Qie ", "Min ", "Bao ", "Tiao ", "Si ", "Fu ", "Ce ", "Ben ", "Pei ", "Da ", "Zi ", "Di ", "Ling ", "Ze ", "Nu ", "Fu ", "Gou ", "Fan ", "Jia ", "Ge ", "Fan ", "Shi ", "Mao ", "Po ", "Sey ", "Jian ", "Qiong ", "Long ", "Souke ", "Bian ", "Luo ", "Gui ", "Qu ", "Chi ", "Yin ", "Yao ", "Xian ", "Bi ", "Qiong ", "Gua ", "Deng ", "Jiao ", "Jin ", "Quan ", "Sun ", "Ru ", "Fa ", "Kuang ", "Zhu ", "Tong ", "Ji ", "Da ", "Xing ", "Ce ", "Zhong ", "Kou ", "Lai ", "Bi ", "Shai ", "Dang ", "Zheng ", "Ce ", "Fu ", "Yun ", "Tu ", "Pa ", "Li ", "Lang ", "Ju ", "Guan ", "Jian ", "Han ", "Tong ", "Xia ", "Zhi ", "Cheng ", "Suan ", "Shi ", "Zhu ", "Zuo ", "Xiao ", "Shao ", "Ting ", "Ce ", "Yan ", "Gao ", "Kuai ", "Gan ", "Chou ", "Kago ", "Gang ", "Yun ", "O ", "Qian ", "Xiao ", "Jian ", "Pu ", "Lai ", "Zou ", "Bi ", "Bi ", "Bi ", "Ge ", "Chi ", "Guai ", "Yu ", "Jian ", "Zhao ", "Gu ", "Chi ", "Zheng ", "Jing ", "Sha ", "Zhou ", "Lu ", "Bo ", "Ji ", "Lin ", "Suan ", "Jun ", "Fu ", "Zha ", "Gu ", "Kong ", "Qian ", "Quan ", "Jun ", "Chui ", "Guan ", "Yuan ", "Ce ", "Ju ", "Bo ", "Ze ", "Qie ", "Tuo ", "Luo ", "Dan ", "Xiao ", "Ruo ", "Jian ", "Xuan ", "Bian ", "Sun ", "Xiang ", "Xian ", "Ping ", "Zhen ", "Sheng ", "Hu ", "Shi ", "Zhu ", "Yue ", "Chun ", "Lu ", "Wu ", "Dong ", "Xiao ", "Ji ", "Jie ", "Huang ", "Xing ", "Mei ", "Fan ", "Chui ", "Zhuan ", "Pian ", "Feng ", "Zhu ", "Hong ", "Qie ", "Hou ", "Qiu ", "Miao ", "Qian ", "[?] ", "Kui ", "Sik ", "Lou ", "Yun ", "He ", "Tang ", "Yue ", "Chou ", "Gao ", "Fei ", "Ruo ", "Zheng ", "Gou ", "Nie ", "Qian ", "Xiao ", "Cuan ", "Gong ", "Pang ", "Du ", "Li ", "Bi ", "Zhuo ", "Chu ", "Shai ", "Chi ", "Zhu ", "Qiang ", "Long ", "Lan ", "Jian ", "Bu ", "Li ", "Hui ", "Bi ", "Di ", "Cong ", "Yan ", "Peng ", "Sen ", "Zhuan ", "Pai ", "Piao ", "Dou ", "Yu ", "Mie ", "Zhuan "];
  }
});

// node_modules/unidecode/data/x7c.js
var require_x7c = __commonJS({
  "node_modules/unidecode/data/x7c.js"(exports, module2) {
    module2.exports = ["Ze ", "Xi ", "Guo ", "Yi ", "Hu ", "Chan ", "Kou ", "Cu ", "Ping ", "Chou ", "Ji ", "Gui ", "Su ", "Lou ", "Zha ", "Lu ", "Nian ", "Suo ", "Cuan ", "Sasara ", "Suo ", "Le ", "Duan ", "Yana ", "Xiao ", "Bo ", "Mi ", "Si ", "Dang ", "Liao ", "Dan ", "Dian ", "Fu ", "Jian ", "Min ", "Kui ", "Dai ", "Qiao ", "Deng ", "Huang ", "Sun ", "Lao ", "Zan ", "Xiao ", "Du ", "Shi ", "Zan ", "[?] ", "Pai ", "Hata ", "Pai ", "Gan ", "Ju ", "Du ", "Lu ", "Yan ", "Bo ", "Dang ", "Sai ", "Ke ", "Long ", "Qian ", "Lian ", "Bo ", "Zhou ", "Lai ", "[?] ", "Lan ", "Kui ", "Yu ", "Yue ", "Hao ", "Zhen ", "Tai ", "Ti ", "Mi ", "Chou ", "Ji ", "[?] ", "Hata ", "Teng ", "Zhuan ", "Zhou ", "Fan ", "Sou ", "Zhou ", "Kuji ", "Zhuo ", "Teng ", "Lu ", "Lu ", "Jian ", "Tuo ", "Ying ", "Yu ", "Lai ", "Long ", "Shinshi ", "Lian ", "Lan ", "Qian ", "Yue ", "Zhong ", "Qu ", "Lian ", "Bian ", "Duan ", "Zuan ", "Li ", "Si ", "Luo ", "Ying ", "Yue ", "Zhuo ", "Xu ", "Mi ", "Di ", "Fan ", "Shen ", "Zhe ", "Shen ", "Nu ", "Xie ", "Lei ", "Xian ", "Zi ", "Ni ", "Cun ", "[?] ", "Qian ", "Kume ", "Bi ", "Ban ", "Wu ", "Sha ", "Kang ", "Rou ", "Fen ", "Bi ", "Cui ", "[?] ", "Li ", "Chi ", "Nukamiso ", "Ro ", "Ba ", "Li ", "Gan ", "Ju ", "Po ", "Mo ", "Cu ", "Nian ", "Zhou ", "Li ", "Su ", "Tiao ", "Li ", "Qi ", "Su ", "Hong ", "Tong ", "Zi ", "Ce ", "Yue ", "Zhou ", "Lin ", "Zhuang ", "Bai ", "[?] ", "Fen ", "Ji ", "[?] ", "Sukumo ", "Liang ", "Xian ", "Fu ", "Liang ", "Can ", "Geng ", "Li ", "Yue ", "Lu ", "Ju ", "Qi ", "Cui ", "Bai ", "Zhang ", "Lin ", "Zong ", "Jing ", "Guo ", "Kouji ", "San ", "San ", "Tang ", "Bian ", "Rou ", "Mian ", "Hou ", "Xu ", "Zong ", "Hu ", "Jian ", "Zan ", "Ci ", "Li ", "Xie ", "Fu ", "Ni ", "Bei ", "Gu ", "Xiu ", "Gao ", "Tang ", "Qiu ", "Sukumo ", "Cao ", "Zhuang ", "Tang ", "Mi ", "San ", "Fen ", "Zao ", "Kang ", "Jiang ", "Mo ", "San ", "San ", "Nuo ", "Xi ", "Liang ", "Jiang ", "Kuai ", "Bo ", "Huan ", "[?] ", "Zong ", "Xian ", "Nuo ", "Tuan ", "Nie ", "Li ", "Zuo ", "Di ", "Nie ", "Tiao ", "Lan ", "Mi ", "Jiao ", "Jiu ", "Xi ", "Gong ", "Zheng ", "Jiu ", "You "];
  }
});

// node_modules/unidecode/data/x7d.js
var require_x7d = __commonJS({
  "node_modules/unidecode/data/x7d.js"(exports, module2) {
    module2.exports = ["Ji ", "Cha ", "Zhou ", "Xun ", "Yue ", "Hong ", "Yu ", "He ", "Wan ", "Ren ", "Wen ", "Wen ", "Qiu ", "Na ", "Zi ", "Tou ", "Niu ", "Fou ", "Jie ", "Shu ", "Chun ", "Pi ", "Yin ", "Sha ", "Hong ", "Zhi ", "Ji ", "Fen ", "Yun ", "Ren ", "Dan ", "Jin ", "Su ", "Fang ", "Suo ", "Cui ", "Jiu ", "Zha ", "Kinu ", "Jin ", "Fu ", "Zhi ", "Ci ", "Zi ", "Chou ", "Hong ", "Zha ", "Lei ", "Xi ", "Fu ", "Xie ", "Shen ", "Bei ", "Zhu ", "Qu ", "Ling ", "Zhu ", "Shao ", "Gan ", "Yang ", "Fu ", "Tuo ", "Zhen ", "Dai ", "Zhuo ", "Shi ", "Zhong ", "Xian ", "Zu ", "Jiong ", "Ban ", "Ju ", "Mo ", "Shu ", "Zui ", "Wata ", "Jing ", "Ren ", "Heng ", "Xie ", "Jie ", "Zhu ", "Chou ", "Gua ", "Bai ", "Jue ", "Kuang ", "Hu ", "Ci ", "Geng ", "Geng ", "Tao ", "Xie ", "Ku ", "Jiao ", "Quan ", "Gai ", "Luo ", "Xuan ", "Bing ", "Xian ", "Fu ", "Gei ", "Tong ", "Rong ", "Tiao ", "Yin ", "Lei ", "Xie ", "Quan ", "Xu ", "Lun ", "Die ", "Tong ", "Si ", "Jiang ", "Xiang ", "Hui ", "Jue ", "Zhi ", "Jian ", "Juan ", "Chi ", "Mian ", "Zhen ", "Lu ", "Cheng ", "Qiu ", "Shu ", "Bang ", "Tong ", "Xiao ", "Wan ", "Qin ", "Geng ", "Xiu ", "Ti ", "Xiu ", "Xie ", "Hong ", "Xi ", "Fu ", "Ting ", "Sui ", "Dui ", "Kun ", "Fu ", "Jing ", "Hu ", "Zhi ", "Yan ", "Jiong ", "Feng ", "Ji ", "Sok ", "Kase ", "Zong ", "Lin ", "Duo ", "Li ", "Lu ", "Liang ", "Chou ", "Quan ", "Shao ", "Qi ", "Qi ", "Zhun ", "Qi ", "Wan ", "Qian ", "Xian ", "Shou ", "Wei ", "Qi ", "Tao ", "Wan ", "Gang ", "Wang ", "Beng ", "Zhui ", "Cai ", "Guo ", "Cui ", "Lun ", "Liu ", "Qi ", "Zhan ", "Bei ", "Chuo ", "Ling ", "Mian ", "Qi ", "Qie ", "Tan ", "Zong ", "Gun ", "Zou ", "Yi ", "Zi ", "Xing ", "Liang ", "Jin ", "Fei ", "Rui ", "Min ", "Yu ", "Zong ", "Fan ", "Lu ", "Xu ", "Yingl ", "Zhang ", "Kasuri ", "Xu ", "Xiang ", "Jian ", "Ke ", "Xian ", "Ruan ", "Mian ", "Qi ", "Duan ", "Zhong ", "Di ", "Min ", "Miao ", "Yuan ", "Xie ", "Bao ", "Si ", "Qiu ", "Bian ", "Huan ", "Geng ", "Cong ", "Mian ", "Wei ", "Fu ", "Wei ", "Yu ", "Gou ", "Miao ", "Xie ", "Lian ", "Zong ", "Bian ", "Yun ", "Yin ", "Ti ", "Gua ", "Zhi ", "Yun ", "Cheng ", "Chan ", "Dai "];
  }
});

// node_modules/unidecode/data/x7e.js
var require_x7e = __commonJS({
  "node_modules/unidecode/data/x7e.js"(exports, module2) {
    module2.exports = ["Xia ", "Yuan ", "Zong ", "Xu ", "Nawa ", "Odoshi ", "Geng ", "Sen ", "Ying ", "Jin ", "Yi ", "Zhui ", "Ni ", "Bang ", "Gu ", "Pan ", "Zhou ", "Jian ", "Cuo ", "Quan ", "Shuang ", "Yun ", "Xia ", "Shuai ", "Xi ", "Rong ", "Tao ", "Fu ", "Yun ", "Zhen ", "Gao ", "Ru ", "Hu ", "Zai ", "Teng ", "Xian ", "Su ", "Zhen ", "Zong ", "Tao ", "Horo ", "Cai ", "Bi ", "Feng ", "Cu ", "Li ", "Suo ", "Yin ", "Xi ", "Zong ", "Lei ", "Zhuan ", "Qian ", "Man ", "Zhi ", "Lu ", "Mo ", "Piao ", "Lian ", "Mi ", "Xuan ", "Zong ", "Ji ", "Shan ", "Sui ", "Fan ", "Shuai ", "Beng ", "Yi ", "Sao ", "Mou ", "Zhou ", "Qiang ", "Hun ", "Sem ", "Xi ", "Jung ", "Xiu ", "Ran ", "Xuan ", "Hui ", "Qiao ", "Zeng ", "Zuo ", "Zhi ", "Shan ", "San ", "Lin ", "Yu ", "Fan ", "Liao ", "Chuo ", "Zun ", "Jian ", "Rao ", "Chan ", "Rui ", "Xiu ", "Hui ", "Hua ", "Zuan ", "Xi ", "Qiang ", "Un ", "Da ", "Sheng ", "Hui ", "Xi ", "Se ", "Jian ", "Jiang ", "Huan ", "Zao ", "Cong ", "Jie ", "Jiao ", "Bo ", "Chan ", "Yi ", "Nao ", "Sui ", "Yi ", "Shai ", "Xu ", "Ji ", "Bin ", "Qian ", "Lan ", "Pu ", "Xun ", "Zuan ", "Qi ", "Peng ", "Li ", "Mo ", "Lei ", "Xie ", "Zuan ", "Kuang ", "You ", "Xu ", "Lei ", "Xian ", "Chan ", "Kou ", "Lu ", "Chan ", "Ying ", "Cai ", "Xiang ", "Xian ", "Zui ", "Zuan ", "Luo ", "Xi ", "Dao ", "Lan ", "Lei ", "Lian ", "Si ", "Jiu ", "Yu ", "Hong ", "Zhou ", "Xian ", "He ", "Yue ", "Ji ", "Wan ", "Kuang ", "Ji ", "Ren ", "Wei ", "Yun ", "Hong ", "Chun ", "Pi ", "Sha ", "Gang ", "Na ", "Ren ", "Zong ", "Lun ", "Fen ", "Zhi ", "Wen ", "Fang ", "Zhu ", "Yin ", "Niu ", "Shu ", "Xian ", "Gan ", "Xie ", "Fu ", "Lian ", "Zu ", "Shen ", "Xi ", "Zhi ", "Zhong ", "Zhou ", "Ban ", "Fu ", "Zhuo ", "Shao ", "Yi ", "Jing ", "Dai ", "Bang ", "Rong ", "Jie ", "Ku ", "Rao ", "Die ", "Heng ", "Hui ", "Gei ", "Xuan ", "Jiang ", "Luo ", "Jue ", "Jiao ", "Tong ", "Geng ", "Xiao ", "Juan ", "Xiu ", "Xi ", "Sui ", "Tao ", "Ji ", "Ti ", "Ji ", "Xu ", "Ling ", "[?] ", "Xu ", "Qi ", "Fei ", "Chuo ", "Zhang ", "Gun ", "Sheng ", "Wei ", "Mian ", "Shou ", "Beng ", "Chou ", "Tao ", "Liu ", "Quan ", "Zong ", "Zhan ", "Wan ", "Lu "];
  }
});

// node_modules/unidecode/data/x7f.js
var require_x7f = __commonJS({
  "node_modules/unidecode/data/x7f.js"(exports, module2) {
    module2.exports = ["Zhui ", "Zi ", "Ke ", "Xiang ", "Jian ", "Mian ", "Lan ", "Ti ", "Miao ", "Qi ", "Yun ", "Hui ", "Si ", "Duo ", "Duan ", "Bian ", "Xian ", "Gou ", "Zhui ", "Huan ", "Di ", "Lu ", "Bian ", "Min ", "Yuan ", "Jin ", "Fu ", "Ru ", "Zhen ", "Feng ", "Shuai ", "Gao ", "Chan ", "Li ", "Yi ", "Jian ", "Bin ", "Piao ", "Man ", "Lei ", "Ying ", "Suo ", "Mou ", "Sao ", "Xie ", "Liao ", "Shan ", "Zeng ", "Jiang ", "Qian ", "Zao ", "Huan ", "Jiao ", "Zuan ", "Fou ", "Xie ", "Gang ", "Fou ", "Que ", "Fou ", "Kaakeru ", "Bo ", "Ping ", "Hou ", "[?] ", "Gang ", "Ying ", "Ying ", "Qing ", "Xia ", "Guan ", "Zun ", "Tan ", "Chang ", "Qi ", "Weng ", "Ying ", "Lei ", "Tan ", "Lu ", "Guan ", "Wang ", "Wang ", "Gang ", "Wang ", "Han ", "[?] ", "Luo ", "Fu ", "Mi ", "Fa ", "Gu ", "Zhu ", "Ju ", "Mao ", "Gu ", "Min ", "Gang ", "Ba ", "Gua ", "Ti ", "Juan ", "Fu ", "Lin ", "Yan ", "Zhao ", "Zui ", "Gua ", "Zhuo ", "Yu ", "Zhi ", "An ", "Fa ", "Nan ", "Shu ", "Si ", "Pi ", "Ma ", "Liu ", "Ba ", "Fa ", "Li ", "Chao ", "Wei ", "Bi ", "Ji ", "Zeng ", "Tong ", "Liu ", "Ji ", "Juan ", "Mi ", "Zhao ", "Luo ", "Pi ", "Ji ", "Ji ", "Luan ", "Yang ", "Mie ", "Qiang ", "Ta ", "Mei ", "Yang ", "You ", "You ", "Fen ", "Ba ", "Gao ", "Yang ", "Gu ", "Qiang ", "Zang ", "Gao ", "Ling ", "Yi ", "Zhu ", "Di ", "Xiu ", "Qian ", "Yi ", "Xian ", "Rong ", "Qun ", "Qun ", "Qian ", "Huan ", "Zui ", "Xian ", "Yi ", "Yashinau ", "Qiang ", "Xian ", "Yu ", "Geng ", "Jie ", "Tang ", "Yuan ", "Xi ", "Fan ", "Shan ", "Fen ", "Shan ", "Lian ", "Lei ", "Geng ", "Nou ", "Qiang ", "Chan ", "Yu ", "Gong ", "Yi ", "Chong ", "Weng ", "Fen ", "Hong ", "Chi ", "Chi ", "Cui ", "Fu ", "Xia ", "Pen ", "Yi ", "La ", "Yi ", "Pi ", "Ling ", "Liu ", "Zhi ", "Qu ", "Xi ", "Xie ", "Xiang ", "Xi ", "Xi ", "Qi ", "Qiao ", "Hui ", "Hui ", "Xiao ", "Se ", "Hong ", "Jiang ", "Di ", "Cui ", "Fei ", "Tao ", "Sha ", "Chi ", "Zhu ", "Jian ", "Xuan ", "Shi ", "Pian ", "Zong ", "Wan ", "Hui ", "Hou ", "He ", "He ", "Han ", "Ao ", "Piao ", "Yi ", "Lian ", "Qu ", "[?] ", "Lin ", "Pen ", "Qiao ", "Ao ", "Fan ", "Yi ", "Hui ", "Xuan ", "Dao "];
  }
});

// node_modules/unidecode/data/x80.js
var require_x80 = __commonJS({
  "node_modules/unidecode/data/x80.js"(exports, module2) {
    module2.exports = ["Yao ", "Lao ", "[?] ", "Kao ", "Mao ", "Zhe ", "Qi ", "Gou ", "Gou ", "Gou ", "Die ", "Die ", "Er ", "Shua ", "Ruan ", "Er ", "Nai ", "Zhuan ", "Lei ", "Ting ", "Zi ", "Geng ", "Chao ", "Hao ", "Yun ", "Pa ", "Pi ", "Chi ", "Si ", "Chu ", "Jia ", "Ju ", "He ", "Chu ", "Lao ", "Lun ", "Ji ", "Tang ", "Ou ", "Lou ", "Nou ", "Gou ", "Pang ", "Ze ", "Lou ", "Ji ", "Lao ", "Huo ", "You ", "Mo ", "Huai ", "Er ", "Zhe ", "Ting ", "Ye ", "Da ", "Song ", "Qin ", "Yun ", "Chi ", "Dan ", "Dan ", "Hong ", "Geng ", "Zhi ", "[?] ", "Nie ", "Dan ", "Zhen ", "Che ", "Ling ", "Zheng ", "You ", "Wa ", "Liao ", "Long ", "Zhi ", "Ning ", "Tiao ", "Er ", "Ya ", "Die ", "Gua ", "[?] ", "Lian ", "Hao ", "Sheng ", "Lie ", "Pin ", "Jing ", "Ju ", "Bi ", "Di ", "Guo ", "Wen ", "Xu ", "Ping ", "Cong ", "Shikato ", "[?] ", "Ting ", "Yu ", "Cong ", "Kui ", "Tsuraneru ", "Kui ", "Cong ", "Lian ", "Weng ", "Kui ", "Lian ", "Lian ", "Cong ", "Ao ", "Sheng ", "Song ", "Ting ", "Kui ", "Nie ", "Zhi ", "Dan ", "Ning ", "Qie ", "Ji ", "Ting ", "Ting ", "Long ", "Yu ", "Yu ", "Zhao ", "Si ", "Su ", "Yi ", "Su ", "Si ", "Zhao ", "Zhao ", "Rou ", "Yi ", "Le ", "Ji ", "Qiu ", "Ken ", "Cao ", "Ge ", "Di ", "Huan ", "Huang ", "Yi ", "Ren ", "Xiao ", "Ru ", "Zhou ", "Yuan ", "Du ", "Gang ", "Rong ", "Gan ", "Cha ", "Wo ", "Chang ", "Gu ", "Zhi ", "Han ", "Fu ", "Fei ", "Fen ", "Pei ", "Pang ", "Jian ", "Fang ", "Zhun ", "You ", "Na ", "Hang ", "Ken ", "Ran ", "Gong ", "Yu ", "Wen ", "Yao ", "Jin ", "Pi ", "Qian ", "Xi ", "Xi ", "Fei ", "Ken ", "Jing ", "Tai ", "Shen ", "Zhong ", "Zhang ", "Xie ", "Shen ", "Wei ", "Zhou ", "Die ", "Dan ", "Fei ", "Ba ", "Bo ", "Qu ", "Tian ", "Bei ", "Gua ", "Tai ", "Zi ", "Ku ", "Zhi ", "Ni ", "Ping ", "Zi ", "Fu ", "Pang ", "Zhen ", "Xian ", "Zuo ", "Pei ", "Jia ", "Sheng ", "Zhi ", "Bao ", "Mu ", "Qu ", "Hu ", "Ke ", "Yi ", "Yin ", "Xu ", "Yang ", "Long ", "Dong ", "Ka ", "Lu ", "Jing ", "Nu ", "Yan ", "Pang ", "Kua ", "Yi ", "Guang ", "Gai ", "Ge ", "Dong ", "Zhi ", "Xiao ", "Xiong ", "Xiong ", "Er ", "E ", "Xing ", "Pian ", "Neng ", "Zi ", "Gui "];
  }
});

// node_modules/unidecode/data/x81.js
var require_x81 = __commonJS({
  "node_modules/unidecode/data/x81.js"(exports, module2) {
    module2.exports = ["Cheng ", "Tiao ", "Zhi ", "Cui ", "Mei ", "Xie ", "Cui ", "Xie ", "Mo ", "Mai ", "Ji ", "Obiyaakasu ", "[?] ", "Kuai ", "Sa ", "Zang ", "Qi ", "Nao ", "Mi ", "Nong ", "Luan ", "Wan ", "Bo ", "Wen ", "Guan ", "Qiu ", "Jiao ", "Jing ", "Rou ", "Heng ", "Cuo ", "Lie ", "Shan ", "Ting ", "Mei ", "Chun ", "Shen ", "Xie ", "De ", "Zui ", "Cu ", "Xiu ", "Xin ", "Tuo ", "Pao ", "Cheng ", "Nei ", "Fu ", "Dou ", "Tuo ", "Niao ", "Noy ", "Pi ", "Gu ", "Gua ", "Li ", "Lian ", "Zhang ", "Cui ", "Jie ", "Liang ", "Zhou ", "Pi ", "Biao ", "Lun ", "Pian ", "Guo ", "Kui ", "Chui ", "Dan ", "Tian ", "Nei ", "Jing ", "Jie ", "La ", "Yi ", "An ", "Ren ", "Shen ", "Chuo ", "Fu ", "Fu ", "Ju ", "Fei ", "Qiang ", "Wan ", "Dong ", "Pi ", "Guo ", "Zong ", "Ding ", "Wu ", "Mei ", "Ruan ", "Zhuan ", "Zhi ", "Cou ", "Gua ", "Ou ", "Di ", "An ", "Xing ", "Nao ", "Yu ", "Chuan ", "Nan ", "Yun ", "Zhong ", "Rou ", "E ", "Sai ", "Tu ", "Yao ", "Jian ", "Wei ", "Jiao ", "Yu ", "Jia ", "Duan ", "Bi ", "Chang ", "Fu ", "Xian ", "Ni ", "Mian ", "Wa ", "Teng ", "Tui ", "Bang ", "Qian ", "Lu ", "Wa ", "Sou ", "Tang ", "Su ", "Zhui ", "Ge ", "Yi ", "Bo ", "Liao ", "Ji ", "Pi ", "Xie ", "Gao ", "Lu ", "Bin ", "Ou ", "Chang ", "Lu ", "Guo ", "Pang ", "Chuai ", "Piao ", "Jiang ", "Fu ", "Tang ", "Mo ", "Xi ", "Zhuan ", "Lu ", "Jiao ", "Ying ", "Lu ", "Zhi ", "Tara ", "Chun ", "Lian ", "Tong ", "Peng ", "Ni ", "Zha ", "Liao ", "Cui ", "Gui ", "Xiao ", "Teng ", "Fan ", "Zhi ", "Jiao ", "Shan ", "Wu ", "Cui ", "Run ", "Xiang ", "Sui ", "Fen ", "Ying ", "Tan ", "Zhua ", "Dan ", "Kuai ", "Nong ", "Tun ", "Lian ", "Bi ", "Yong ", "Jue ", "Chu ", "Yi ", "Juan ", "La ", "Lian ", "Sao ", "Tun ", "Gu ", "Qi ", "Cui ", "Bin ", "Xun ", "Ru ", "Huo ", "Zang ", "Xian ", "Biao ", "Xing ", "Kuan ", "La ", "Yan ", "Lu ", "Huo ", "Zang ", "Luo ", "Qu ", "Zang ", "Luan ", "Ni ", "Zang ", "Chen ", "Qian ", "Wo ", "Guang ", "Zang ", "Lin ", "Guang ", "Zi ", "Jiao ", "Nie ", "Chou ", "Ji ", "Gao ", "Chou ", "Mian ", "Nie ", "Zhi ", "Zhi ", "Ge ", "Jian ", "Die ", "Zhi ", "Xiu ", "Tai ", "Zhen ", "Jiu ", "Xian ", "Yu ", "Cha "];
  }
});

// node_modules/unidecode/data/x82.js
var require_x82 = __commonJS({
  "node_modules/unidecode/data/x82.js"(exports, module2) {
    module2.exports = ["Yao ", "Yu ", "Chong ", "Xi ", "Xi ", "Jiu ", "Yu ", "Yu ", "Xing ", "Ju ", "Jiu ", "Xin ", "She ", "She ", "Yadoru ", "Jiu ", "Shi ", "Tan ", "Shu ", "Shi ", "Tian ", "Dan ", "Pu ", "Pu ", "Guan ", "Hua ", "Tan ", "Chuan ", "Shun ", "Xia ", "Wu ", "Zhou ", "Dao ", "Gang ", "Shan ", "Yi ", "[?] ", "Pa ", "Tai ", "Fan ", "Ban ", "Chuan ", "Hang ", "Fang ", "Ban ", "Que ", "Hesaki ", "Zhong ", "Jian ", "Cang ", "Ling ", "Zhu ", "Ze ", "Duo ", "Bo ", "Xian ", "Ge ", "Chuan ", "Jia ", "Lu ", "Hong ", "Pang ", "Xi ", "[?] ", "Fu ", "Zao ", "Feng ", "Li ", "Shao ", "Yu ", "Lang ", "Ting ", "[?] ", "Wei ", "Bo ", "Meng ", "Nian ", "Ju ", "Huang ", "Shou ", "Zong ", "Bian ", "Mao ", "Die ", "[?] ", "Bang ", "Cha ", "Yi ", "Sao ", "Cang ", "Cao ", "Lou ", "Dai ", "Sori ", "Yao ", "Tong ", "Yofune ", "Dang ", "Tan ", "Lu ", "Yi ", "Jie ", "Jian ", "Huo ", "Meng ", "Qi ", "Lu ", "Lu ", "Chan ", "Shuang ", "Gen ", "Liang ", "Jian ", "Jian ", "Se ", "Yan ", "Fu ", "Ping ", "Yan ", "Yan ", "Cao ", "Cao ", "Yi ", "Le ", "Ting ", "Qiu ", "Ai ", "Nai ", "Tiao ", "Jiao ", "Jie ", "Peng ", "Wan ", "Yi ", "Chai ", "Mian ", "Mie ", "Gan ", "Qian ", "Yu ", "Yu ", "Shuo ", "Qiong ", "Tu ", "Xia ", "Qi ", "Mang ", "Zi ", "Hui ", "Sui ", "Zhi ", "Xiang ", "Bi ", "Fu ", "Tun ", "Wei ", "Wu ", "Zhi ", "Qi ", "Shan ", "Wen ", "Qian ", "Ren ", "Fou ", "Kou ", "Jie ", "Lu ", "Xu ", "Ji ", "Qin ", "Qi ", "Yuan ", "Fen ", "Ba ", "Rui ", "Xin ", "Ji ", "Hua ", "Hua ", "Fang ", "Wu ", "Jue ", "Gou ", "Zhi ", "Yun ", "Qin ", "Ao ", "Chu ", "Mao ", "Ya ", "Fei ", "Reng ", "Hang ", "Cong ", "Yin ", "You ", "Bian ", "Yi ", "Susa ", "Wei ", "Li ", "Pi ", "E ", "Xian ", "Chang ", "Cang ", "Meng ", "Su ", "Yi ", "Yuan ", "Ran ", "Ling ", "Tai ", "Tiao ", "Di ", "Miao ", "Qiong ", "Li ", "Yong ", "Ke ", "Mu ", "Pei ", "Bao ", "Gou ", "Min ", "Yi ", "Yi ", "Ju ", "Pi ", "Ruo ", "Ku ", "Zhu ", "Ni ", "Bo ", "Bing ", "Shan ", "Qiu ", "Yao ", "Xian ", "Ben ", "Hong ", "Ying ", "Zha ", "Dong ", "Ju ", "Die ", "Nie ", "Gan ", "Hu ", "Ping ", "Mei ", "Fu ", "Sheng ", "Gu ", "Bi ", "Wei "];
  }
});

// node_modules/unidecode/data/x83.js
var require_x83 = __commonJS({
  "node_modules/unidecode/data/x83.js"(exports, module2) {
    module2.exports = ["Fu ", "Zhuo ", "Mao ", "Fan ", "Qie ", "Mao ", "Mao ", "Ba ", "Zi ", "Mo ", "Zi ", "Di ", "Chi ", "Ji ", "Jing ", "Long ", "[?] ", "Niao ", "[?] ", "Xue ", "Ying ", "Qiong ", "Ge ", "Ming ", "Li ", "Rong ", "Yin ", "Gen ", "Qian ", "Chai ", "Chen ", "Yu ", "Xiu ", "Zi ", "Lie ", "Wu ", "Ji ", "Kui ", "Ce ", "Chong ", "Ci ", "Gou ", "Guang ", "Mang ", "Chi ", "Jiao ", "Jiao ", "Fu ", "Yu ", "Zhu ", "Zi ", "Jiang ", "Hui ", "Yin ", "Cha ", "Fa ", "Rong ", "Ru ", "Chong ", "Mang ", "Tong ", "Zhong ", "[?] ", "Zhu ", "Xun ", "Huan ", "Kua ", "Quan ", "Gai ", "Da ", "Jing ", "Xing ", "Quan ", "Cao ", "Jing ", "Er ", "An ", "Shou ", "Chi ", "Ren ", "Jian ", "Ti ", "Huang ", "Ping ", "Li ", "Jin ", "Lao ", "Shu ", "Zhuang ", "Da ", "Jia ", "Rao ", "Bi ", "Ze ", "Qiao ", "Hui ", "Qi ", "Dang ", "[?] ", "Rong ", "Hun ", "Ying ", "Luo ", "Ying ", "Xun ", "Jin ", "Sun ", "Yin ", "Mai ", "Hong ", "Zhou ", "Yao ", "Du ", "Wei ", "Chu ", "Dou ", "Fu ", "Ren ", "Yin ", "He ", "Bi ", "Bu ", "Yun ", "Di ", "Tu ", "Sui ", "Sui ", "Cheng ", "Chen ", "Wu ", "Bie ", "Xi ", "Geng ", "Li ", "Fu ", "Zhu ", "Mo ", "Li ", "Zhuang ", "Ji ", "Duo ", "Qiu ", "Sha ", "Suo ", "Chen ", "Feng ", "Ju ", "Mei ", "Meng ", "Xing ", "Jing ", "Che ", "Xin ", "Jun ", "Yan ", "Ting ", "Diao ", "Cuo ", "Wan ", "Han ", "You ", "Cuo ", "Jia ", "Wang ", "You ", "Niu ", "Shao ", "Xian ", "Lang ", "Fu ", "E ", "Mo ", "Wen ", "Jie ", "Nan ", "Mu ", "Kan ", "Lai ", "Lian ", "Shi ", "Wo ", "Usagi ", "Lian ", "Huo ", "You ", "Ying ", "Ying ", "Nuc ", "Chun ", "Mang ", "Mang ", "Ci ", "Wan ", "Jing ", "Di ", "Qu ", "Dong ", "Jian ", "Zou ", "Gu ", "La ", "Lu ", "Ju ", "Wei ", "Jun ", "Nie ", "Kun ", "He ", "Pu ", "Zi ", "Gao ", "Guo ", "Fu ", "Lun ", "Chang ", "Chou ", "Song ", "Chui ", "Zhan ", "Men ", "Cai ", "Ba ", "Li ", "Tu ", "Bo ", "Han ", "Bao ", "Qin ", "Juan ", "Xi ", "Qin ", "Di ", "Jie ", "Pu ", "Dang ", "Jin ", "Zhao ", "Tai ", "Geng ", "Hua ", "Gu ", "Ling ", "Fei ", "Jin ", "An ", "Wang ", "Beng ", "Zhou ", "Yan ", "Ju ", "Jian ", "Lin ", "Tan ", "Shu ", "Tian ", "Dao "];
  }
});

// node_modules/unidecode/data/x84.js
var require_x84 = __commonJS({
  "node_modules/unidecode/data/x84.js"(exports, module2) {
    module2.exports = ["Hu ", "Qi ", "He ", "Cui ", "Tao ", "Chun ", "Bei ", "Chang ", "Huan ", "Fei ", "Lai ", "Qi ", "Meng ", "Ping ", "Wei ", "Dan ", "Sha ", "Huan ", "Yan ", "Yi ", "Tiao ", "Qi ", "Wan ", "Ce ", "Nai ", "Kutabireru ", "Tuo ", "Jiu ", "Tie ", "Luo ", "[?] ", "[?] ", "Meng ", "[?] ", "Yaji ", "[?] ", "Ying ", "Ying ", "Ying ", "Xiao ", "Sa ", "Qiu ", "Ke ", "Xiang ", "Wan ", "Yu ", "Yu ", "Fu ", "Lian ", "Xuan ", "Yuan ", "Nan ", "Ze ", "Wo ", "Chun ", "Xiao ", "Yu ", "Pian ", "Mao ", "An ", "E ", "Luo ", "Ying ", "Huo ", "Gua ", "Jiang ", "Mian ", "Zuo ", "Zuo ", "Ju ", "Bao ", "Rou ", "Xi ", "Xie ", "An ", "Qu ", "Jian ", "Fu ", "Lu ", "Jing ", "Pen ", "Feng ", "Hong ", "Hong ", "Hou ", "Yan ", "Tu ", "Zhu ", "Zi ", "Xiang ", "Shen ", "Ge ", "Jie ", "Jing ", "Mi ", "Huang ", "Shen ", "Pu ", "Gai ", "Dong ", "Zhou ", "Qian ", "Wei ", "Bo ", "Wei ", "Pa ", "Ji ", "Hu ", "Zang ", "Jia ", "Duan ", "Yao ", "Jun ", "Cong ", "Quan ", "Wei ", "Xian ", "Kui ", "Ting ", "Hun ", "Xi ", "Shi ", "Qi ", "Lan ", "Zong ", "Yao ", "Yuan ", "Mei ", "Yun ", "Shu ", "Di ", "Zhuan ", "Guan ", "Sukumo ", "Xue ", "Chan ", "Kai ", "Kui ", "[?] ", "Jiang ", "Lou ", "Wei ", "Pai ", "[?] ", "Sou ", "Yin ", "Shi ", "Chun ", "Shi ", "Yun ", "Zhen ", "Lang ", "Nu ", "Meng ", "He ", "Que ", "Suan ", "Yuan ", "Li ", "Ju ", "Xi ", "Pang ", "Chu ", "Xu ", "Tu ", "Liu ", "Wo ", "Zhen ", "Qian ", "Zu ", "Po ", "Cuo ", "Yuan ", "Chu ", "Yu ", "Kuai ", "Pan ", "Pu ", "Pu ", "Na ", "Shuo ", "Xi ", "Fen ", "Yun ", "Zheng ", "Jian ", "Ji ", "Ruo ", "Cang ", "En ", "Mi ", "Hao ", "Sun ", "Zhen ", "Ming ", "Sou ", "Xu ", "Liu ", "Xi ", "Gu ", "Lang ", "Rong ", "Weng ", "Gai ", "Cuo ", "Shi ", "Tang ", "Luo ", "Ru ", "Suo ", "Xian ", "Bei ", "Yao ", "Gui ", "Bi ", "Zong ", "Gun ", "Za ", "Xiu ", "Ce ", "Hai ", "Lan ", "[?] ", "Ji ", "Li ", "Can ", "Lang ", "Yu ", "[?] ", "Ying ", "Mo ", "Diao ", "Tiao ", "Mao ", "Tong ", "Zhu ", "Peng ", "An ", "Lian ", "Cong ", "Xi ", "Ping ", "Qiu ", "Jin ", "Chun ", "Jie ", "Wei ", "Tui ", "Cao ", "Yu ", "Yi ", "Ji ", "Liao ", "Bi ", "Lu ", "Su "];
  }
});

// node_modules/unidecode/data/x85.js
var require_x85 = __commonJS({
  "node_modules/unidecode/data/x85.js"(exports, module2) {
    module2.exports = ["Bu ", "Zhang ", "Luo ", "Jiang ", "Man ", "Yan ", "Ling ", "Ji ", "Piao ", "Gun ", "Han ", "Di ", "Su ", "Lu ", "She ", "Shang ", "Di ", "Mie ", "Xun ", "Man ", "Bo ", "Di ", "Cuo ", "Zhe ", "Sen ", "Xuan ", "Wei ", "Hu ", "Ao ", "Mi ", "Lou ", "Cu ", "Zhong ", "Cai ", "Po ", "Jiang ", "Mi ", "Cong ", "Niao ", "Hui ", "Jun ", "Yin ", "Jian ", "Yan ", "Shu ", "Yin ", "Kui ", "Chen ", "Hu ", "Sha ", "Kou ", "Qian ", "Ma ", "Zang ", "Sonoko ", "Qiang ", "Dou ", "Lian ", "Lin ", "Kou ", "Ai ", "Bi ", "Li ", "Wei ", "Ji ", "Xun ", "Sheng ", "Fan ", "Meng ", "Ou ", "Chan ", "Dian ", "Xun ", "Jiao ", "Rui ", "Rui ", "Lei ", "Yu ", "Qiao ", "Chu ", "Hua ", "Jian ", "Mai ", "Yun ", "Bao ", "You ", "Qu ", "Lu ", "Rao ", "Hui ", "E ", "Teng ", "Fei ", "Jue ", "Zui ", "Fa ", "Ru ", "Fen ", "Kui ", "Shun ", "Rui ", "Ya ", "Xu ", "Fu ", "Jue ", "Dang ", "Wu ", "Tong ", "Si ", "Xiao ", "Xi ", "Long ", "Yun ", "[?] ", "Qi ", "Jian ", "Yun ", "Sun ", "Ling ", "Yu ", "Xia ", "Yong ", "Ji ", "Hong ", "Si ", "Nong ", "Lei ", "Xuan ", "Yun ", "Yu ", "Xi ", "Hao ", "Bo ", "Hao ", "Ai ", "Wei ", "Hui ", "Wei ", "Ji ", "Ci ", "Xiang ", "Luan ", "Mie ", "Yi ", "Leng ", "Jiang ", "Can ", "Shen ", "Qiang ", "Lian ", "Ke ", "Yuan ", "Da ", "Ti ", "Tang ", "Xie ", "Bi ", "Zhan ", "Sun ", "Lian ", "Fan ", "Ding ", "Jie ", "Gu ", "Xie ", "Shu ", "Jian ", "Kao ", "Hong ", "Sa ", "Xin ", "Xun ", "Yao ", "Hie ", "Sou ", "Shu ", "Xun ", "Dui ", "Pin ", "Wei ", "Neng ", "Chou ", "Mai ", "Ru ", "Piao ", "Tai ", "Qi ", "Zao ", "Chen ", "Zhen ", "Er ", "Ni ", "Ying ", "Gao ", "Cong ", "Xiao ", "Qi ", "Fa ", "Jian ", "Xu ", "Kui ", "Jie ", "Bian ", "Diao ", "Mi ", "Lan ", "Jin ", "Cang ", "Miao ", "Qiong ", "Qie ", "Xian ", "[?] ", "Ou ", "Xian ", "Su ", "Lu ", "Yi ", "Xu ", "Xie ", "Li ", "Yi ", "La ", "Lei ", "Xiao ", "Di ", "Zhi ", "Bei ", "Teng ", "Yao ", "Mo ", "Huan ", "Piao ", "Fan ", "Sou ", "Tan ", "Tui ", "Qiong ", "Qiao ", "Wei ", "Liu ", "Hui ", "[?] ", "Gao ", "Yun ", "[?] ", "Li ", "Shu ", "Chu ", "Ai ", "Lin ", "Zao ", "Xuan ", "Chen ", "Lai ", "Huo "];
  }
});

// node_modules/unidecode/data/x86.js
var require_x86 = __commonJS({
  "node_modules/unidecode/data/x86.js"(exports, module2) {
    module2.exports = ["Tuo ", "Wu ", "Rui ", "Rui ", "Qi ", "Heng ", "Lu ", "Su ", "Tui ", "Mang ", "Yun ", "Pin ", "Yu ", "Xun ", "Ji ", "Jiong ", "Xian ", "Mo ", "Hagi ", "Su ", "Jiong ", "[?] ", "Nie ", "Bo ", "Rang ", "Yi ", "Xian ", "Yu ", "Ju ", "Lian ", "Lian ", "Yin ", "Qiang ", "Ying ", "Long ", "Tong ", "Wei ", "Yue ", "Ling ", "Qu ", "Yao ", "Fan ", "Mi ", "Lan ", "Kui ", "Lan ", "Ji ", "Dang ", "Katsura ", "Lei ", "Lei ", "Hua ", "Feng ", "Zhi ", "Wei ", "Kui ", "Zhan ", "Huai ", "Li ", "Ji ", "Mi ", "Lei ", "Huai ", "Luo ", "Ji ", "Kui ", "Lu ", "Jian ", "San ", "[?] ", "Lei ", "Quan ", "Xiao ", "Yi ", "Luan ", "Men ", "Bie ", "Hu ", "Hu ", "Lu ", "Nue ", "Lu ", "Si ", "Xiao ", "Qian ", "Chu ", "Hu ", "Xu ", "Cuo ", "Fu ", "Xu ", "Xu ", "Lu ", "Hu ", "Yu ", "Hao ", "Jiao ", "Ju ", "Guo ", "Bao ", "Yan ", "Zhan ", "Zhan ", "Kui ", "Ban ", "Xi ", "Shu ", "Chong ", "Qiu ", "Diao ", "Ji ", "Qiu ", "Cheng ", "Shi ", "[?] ", "Di ", "Zhe ", "She ", "Yu ", "Gan ", "Zi ", "Hong ", "Hui ", "Meng ", "Ge ", "Sui ", "Xia ", "Chai ", "Shi ", "Yi ", "Ma ", "Xiang ", "Fang ", "E ", "Pa ", "Chi ", "Qian ", "Wen ", "Wen ", "Rui ", "Bang ", "Bi ", "Yue ", "Yue ", "Jun ", "Qi ", "Ran ", "Yin ", "Qi ", "Tian ", "Yuan ", "Jue ", "Hui ", "Qin ", "Qi ", "Zhong ", "Ya ", "Ci ", "Mu ", "Wang ", "Fen ", "Fen ", "Hang ", "Gong ", "Zao ", "Fu ", "Ran ", "Jie ", "Fu ", "Chi ", "Dou ", "Piao ", "Xian ", "Ni ", "Te ", "Qiu ", "You ", "Zha ", "Ping ", "Chi ", "You ", "He ", "Han ", "Ju ", "Li ", "Fu ", "Ran ", "Zha ", "Gou ", "Pi ", "Bo ", "Xian ", "Zhu ", "Diao ", "Bie ", "Bing ", "Gu ", "Ran ", "Qu ", "She ", "Tie ", "Ling ", "Gu ", "Dan ", "Gu ", "Ying ", "Li ", "Cheng ", "Qu ", "Mou ", "Ge ", "Ci ", "Hui ", "Hui ", "Mang ", "Fu ", "Yang ", "Wa ", "Lie ", "Zhu ", "Yi ", "Xian ", "Kuo ", "Jiao ", "Li ", "Yi ", "Ping ", "Ji ", "Ha ", "She ", "Yi ", "Wang ", "Mo ", "Qiong ", "Qie ", "Gui ", "Gong ", "Zhi ", "Man ", "Ebi ", "Zhi ", "Jia ", "Rao ", "Si ", "Qi ", "Xing ", "Lie ", "Qiu ", "Shao ", "Yong ", "Jia ", "Shui ", "Che ", "Bai ", "E ", "Han "];
  }
});

// node_modules/unidecode/data/x87.js
var require_x87 = __commonJS({
  "node_modules/unidecode/data/x87.js"(exports, module2) {
    module2.exports = ["Shu ", "Xuan ", "Feng ", "Shen ", "Zhen ", "Fu ", "Xian ", "Zhe ", "Wu ", "Fu ", "Li ", "Lang ", "Bi ", "Chu ", "Yuan ", "You ", "Jie ", "Dan ", "Yan ", "Ting ", "Dian ", "Shui ", "Hui ", "Gua ", "Zhi ", "Song ", "Fei ", "Ju ", "Mi ", "Qi ", "Qi ", "Yu ", "Jun ", "Zha ", "Meng ", "Qiang ", "Si ", "Xi ", "Lun ", "Li ", "Die ", "Tiao ", "Tao ", "Kun ", "Gan ", "Han ", "Yu ", "Bang ", "Fei ", "Pi ", "Wei ", "Dun ", "Yi ", "Yuan ", "Su ", "Quan ", "Qian ", "Rui ", "Ni ", "Qing ", "Wei ", "Liang ", "Guo ", "Wan ", "Dong ", "E ", "Ban ", "Di ", "Wang ", "Can ", "Yang ", "Ying ", "Guo ", "Chan ", "[?] ", "La ", "Ke ", "Ji ", "He ", "Ting ", "Mai ", "Xu ", "Mian ", "Yu ", "Jie ", "Shi ", "Xuan ", "Huang ", "Yan ", "Bian ", "Rou ", "Wei ", "Fu ", "Yuan ", "Mei ", "Wei ", "Fu ", "Ruan ", "Xie ", "You ", "Qiu ", "Mao ", "Xia ", "Ying ", "Shi ", "Chong ", "Tang ", "Zhu ", "Zong ", "Ti ", "Fu ", "Yuan ", "Hui ", "Meng ", "La ", "Du ", "Hu ", "Qiu ", "Die ", "Li ", "Gua ", "Yun ", "Ju ", "Nan ", "Lou ", "Qun ", "Rong ", "Ying ", "Jiang ", "[?] ", "Lang ", "Pang ", "Si ", "Xi ", "Ci ", "Xi ", "Yuan ", "Weng ", "Lian ", "Sou ", "Ban ", "Rong ", "Rong ", "Ji ", "Wu ", "Qiu ", "Han ", "Qin ", "Yi ", "Bi ", "Hua ", "Tang ", "Yi ", "Du ", "Nai ", "He ", "Hu ", "Hui ", "Ma ", "Ming ", "Yi ", "Wen ", "Ying ", "Teng ", "Yu ", "Cang ", "So ", "Ebi ", "Man ", "[?] ", "Shang ", "Zhe ", "Cao ", "Chi ", "Di ", "Ao ", "Lu ", "Wei ", "Zhi ", "Tang ", "Chen ", "Piao ", "Qu ", "Pi ", "Yu ", "Jian ", "Luo ", "Lou ", "Qin ", "Zhong ", "Yin ", "Jiang ", "Shuai ", "Wen ", "Jiao ", "Wan ", "Zhi ", "Zhe ", "Ma ", "Ma ", "Guo ", "Liu ", "Mao ", "Xi ", "Cong ", "Li ", "Man ", "Xiao ", "Kamakiri ", "Zhang ", "Mang ", "Xiang ", "Mo ", "Zui ", "Si ", "Qiu ", "Te ", "Zhi ", "Peng ", "Peng ", "Jiao ", "Qu ", "Bie ", "Liao ", "Pan ", "Gui ", "Xi ", "Ji ", "Zhuan ", "Huang ", "Fei ", "Lao ", "Jue ", "Jue ", "Hui ", "Yin ", "Chan ", "Jiao ", "Shan ", "Rao ", "Xiao ", "Mou ", "Chong ", "Xun ", "Si ", "[?] ", "Cheng ", "Dang ", "Li ", "Xie ", "Shan ", "Yi ", "Jing ", "Da ", "Chan ", "Qi "];
  }
});

// node_modules/unidecode/data/x88.js
var require_x88 = __commonJS({
  "node_modules/unidecode/data/x88.js"(exports, module2) {
    module2.exports = ["Ci ", "Xiang ", "She ", "Luo ", "Qin ", "Ying ", "Chai ", "Li ", "Ze ", "Xuan ", "Lian ", "Zhu ", "Ze ", "Xie ", "Mang ", "Xie ", "Qi ", "Rong ", "Jian ", "Meng ", "Hao ", "Ruan ", "Huo ", "Zhuo ", "Jie ", "Bin ", "He ", "Mie ", "Fan ", "Lei ", "Jie ", "La ", "Mi ", "Li ", "Chun ", "Li ", "Qiu ", "Nie ", "Lu ", "Du ", "Xiao ", "Zhu ", "Long ", "Li ", "Long ", "Feng ", "Ye ", "Beng ", "Shang ", "Gu ", "Juan ", "Ying ", "[?] ", "Xi ", "Can ", "Qu ", "Quan ", "Du ", "Can ", "Man ", "Jue ", "Jie ", "Zhu ", "Zha ", "Xie ", "Huang ", "Niu ", "Pei ", "Nu ", "Xin ", "Zhong ", "Mo ", "Er ", "Ke ", "Mie ", "Xi ", "Xing ", "Yan ", "Kan ", "Yuan ", "[?] ", "Ling ", "Xuan ", "Shu ", "Xian ", "Tong ", "Long ", "Jie ", "Xian ", "Ya ", "Hu ", "Wei ", "Dao ", "Chong ", "Wei ", "Dao ", "Zhun ", "Heng ", "Qu ", "Yi ", "Yi ", "Bu ", "Gan ", "Yu ", "Biao ", "Cha ", "Yi ", "Shan ", "Chen ", "Fu ", "Gun ", "Fen ", "Shuai ", "Jie ", "Na ", "Zhong ", "Dan ", "Ri ", "Zhong ", "Zhong ", "Xie ", "Qi ", "Xie ", "Ran ", "Zhi ", "Ren ", "Qin ", "Jin ", "Jun ", "Yuan ", "Mei ", "Chai ", "Ao ", "Niao ", "Hui ", "Ran ", "Jia ", "Tuo ", "Ling ", "Dai ", "Bao ", "Pao ", "Yao ", "Zuo ", "Bi ", "Shao ", "Tan ", "Ju ", "He ", "Shu ", "Xiu ", "Zhen ", "Yi ", "Pa ", "Bo ", "Di ", "Wa ", "Fu ", "Gun ", "Zhi ", "Zhi ", "Ran ", "Pan ", "Yi ", "Mao ", "Tuo ", "Na ", "Kou ", "Xian ", "Chan ", "Qu ", "Bei ", "Gun ", "Xi ", "Ne ", "Bo ", "Horo ", "Fu ", "Yi ", "Chi ", "Ku ", "Ren ", "Jiang ", "Jia ", "Cun ", "Mo ", "Jie ", "Er ", "Luo ", "Ru ", "Zhu ", "Gui ", "Yin ", "Cai ", "Lie ", "Kamishimo ", "Yuki ", "Zhuang ", "Dang ", "[?] ", "Kun ", "Ken ", "Niao ", "Shu ", "Jia ", "Kun ", "Cheng ", "Li ", "Juan ", "Shen ", "Pou ", "Ge ", "Yi ", "Yu ", "Zhen ", "Liu ", "Qiu ", "Qun ", "Ji ", "Yi ", "Bu ", "Zhuang ", "Shui ", "Sha ", "Qun ", "Li ", "Lian ", "Lian ", "Ku ", "Jian ", "Fou ", "Chan ", "Bi ", "Gun ", "Tao ", "Yuan ", "Ling ", "Chi ", "Chang ", "Chou ", "Duo ", "Biao ", "Liang ", "Chang ", "Pei ", "Pei ", "Fei ", "Yuan ", "Luo ", "Guo ", "Yan ", "Du ", "Xi ", "Zhi ", "Ju ", "Qi "];
  }
});

// node_modules/unidecode/data/x89.js
var require_x89 = __commonJS({
  "node_modules/unidecode/data/x89.js"(exports, module2) {
    module2.exports = ["Ji ", "Zhi ", "Gua ", "Ken ", "Che ", "Ti ", "Ti ", "Fu ", "Chong ", "Xie ", "Bian ", "Die ", "Kun ", "Duan ", "Xiu ", "Xiu ", "He ", "Yuan ", "Bao ", "Bao ", "Fu ", "Yu ", "Tuan ", "Yan ", "Hui ", "Bei ", "Chu ", "Lu ", "Ena ", "Hitoe ", "Yun ", "Da ", "Gou ", "Da ", "Huai ", "Rong ", "Yuan ", "Ru ", "Nai ", "Jiong ", "Suo ", "Ban ", "Tun ", "Chi ", "Sang ", "Niao ", "Ying ", "Jie ", "Qian ", "Huai ", "Ku ", "Lian ", "Bao ", "Li ", "Zhe ", "Shi ", "Lu ", "Yi ", "Die ", "Xie ", "Xian ", "Wei ", "Biao ", "Cao ", "Ji ", "Jiang ", "Sen ", "Bao ", "Xiang ", "Chihaya ", "Pu ", "Jian ", "Zhuan ", "Jian ", "Zui ", "Ji ", "Dan ", "Za ", "Fan ", "Bo ", "Xiang ", "Xin ", "Bie ", "Rao ", "Man ", "Lan ", "Ao ", "Duo ", "Gui ", "Cao ", "Sui ", "Nong ", "Chan ", "Lian ", "Bi ", "Jin ", "Dang ", "Shu ", "Tan ", "Bi ", "Lan ", "Pu ", "Ru ", "Zhi ", "[?] ", "Shu ", "Wa ", "Shi ", "Bai ", "Xie ", "Bo ", "Chen ", "Lai ", "Long ", "Xi ", "Xian ", "Lan ", "Zhe ", "Dai ", "Tasuki ", "Zan ", "Shi ", "Jian ", "Pan ", "Yi ", "Ran ", "Ya ", "Xi ", "Xi ", "Yao ", "Feng ", "Tan ", "[?] ", "Biao ", "Fu ", "Ba ", "He ", "Ji ", "Ji ", "Jian ", "Guan ", "Bian ", "Yan ", "Gui ", "Jue ", "Pian ", "Mao ", "Mi ", "Mi ", "Mie ", "Shi ", "Si ", "Zhan ", "Luo ", "Jue ", "Mi ", "Tiao ", "Lian ", "Yao ", "Zhi ", "Jun ", "Xi ", "Shan ", "Wei ", "Xi ", "Tian ", "Yu ", "Lan ", "E ", "Du ", "Qin ", "Pang ", "Ji ", "Ming ", "Ying ", "Gou ", "Qu ", "Zhan ", "Jin ", "Guan ", "Deng ", "Jian ", "Luo ", "Qu ", "Jian ", "Wei ", "Jue ", "Qu ", "Luo ", "Lan ", "Shen ", "Di ", "Guan ", "Jian ", "Guan ", "Yan ", "Gui ", "Mi ", "Shi ", "Zhan ", "Lan ", "Jue ", "Ji ", "Xi ", "Di ", "Tian ", "Yu ", "Gou ", "Jin ", "Qu ", "Jiao ", "Jiu ", "Jin ", "Cu ", "Jue ", "Zhi ", "Chao ", "Ji ", "Gu ", "Dan ", "Zui ", "Di ", "Shang ", "Hua ", "Quan ", "Ge ", "Chi ", "Jie ", "Gui ", "Gong ", "Hong ", "Jie ", "Hun ", "Qiu ", "Xing ", "Su ", "Ni ", "Ji ", "Lu ", "Zhi ", "Zha ", "Bi ", "Xing ", "Hu ", "Shang ", "Gong ", "Zhi ", "Xue ", "Chu ", "Xi ", "Yi ", "Lu ", "Jue ", "Xi ", "Yan ", "Xi "];
  }
});

// node_modules/unidecode/data/x8a.js
var require_x8a = __commonJS({
  "node_modules/unidecode/data/x8a.js"(exports, module2) {
    module2.exports = ["Yan ", "Yan ", "Ding ", "Fu ", "Qiu ", "Qiu ", "Jiao ", "Hong ", "Ji ", "Fan ", "Xun ", "Diao ", "Hong ", "Cha ", "Tao ", "Xu ", "Jie ", "Yi ", "Ren ", "Xun ", "Yin ", "Shan ", "Qi ", "Tuo ", "Ji ", "Xun ", "Yin ", "E ", "Fen ", "Ya ", "Yao ", "Song ", "Shen ", "Yin ", "Xin ", "Jue ", "Xiao ", "Ne ", "Chen ", "You ", "Zhi ", "Xiong ", "Fang ", "Xin ", "Chao ", "She ", "Xian ", "Sha ", "Tun ", "Xu ", "Yi ", "Yi ", "Su ", "Chi ", "He ", "Shen ", "He ", "Xu ", "Zhen ", "Zhu ", "Zheng ", "Gou ", "Zi ", "Zi ", "Zhan ", "Gu ", "Fu ", "Quan ", "Die ", "Ling ", "Di ", "Yang ", "Li ", "Nao ", "Pan ", "Zhou ", "Gan ", "Yi ", "Ju ", "Ao ", "Zha ", "Tuo ", "Yi ", "Qu ", "Zhao ", "Ping ", "Bi ", "Xiong ", "Qu ", "Ba ", "Da ", "Zu ", "Tao ", "Zhu ", "Ci ", "Zhe ", "Yong ", "Xu ", "Xun ", "Yi ", "Huang ", "He ", "Shi ", "Cha ", "Jiao ", "Shi ", "Hen ", "Cha ", "Gou ", "Gui ", "Quan ", "Hui ", "Jie ", "Hua ", "Gai ", "Xiang ", "Wei ", "Shen ", "Chou ", "Tong ", "Mi ", "Zhan ", "Ming ", "E ", "Hui ", "Yan ", "Xiong ", "Gua ", "Er ", "Beng ", "Tiao ", "Chi ", "Lei ", "Zhu ", "Kuang ", "Kua ", "Wu ", "Yu ", "Teng ", "Ji ", "Zhi ", "Ren ", "Su ", "Lang ", "E ", "Kuang ", "E ", "Shi ", "Ting ", "Dan ", "Bo ", "Chan ", "You ", "Heng ", "Qiao ", "Qin ", "Shua ", "An ", "Yu ", "Xiao ", "Cheng ", "Jie ", "Xian ", "Wu ", "Wu ", "Gao ", "Song ", "Pu ", "Hui ", "Jing ", "Shuo ", "Zhen ", "Shuo ", "Du ", "Yasashi ", "Chang ", "Shui ", "Jie ", "Ke ", "Qu ", "Cong ", "Xiao ", "Sui ", "Wang ", "Xuan ", "Fei ", "Chi ", "Ta ", "Yi ", "Na ", "Yin ", "Diao ", "Pi ", "Chuo ", "Chan ", "Chen ", "Zhun ", "Ji ", "Qi ", "Tan ", "Zhui ", "Wei ", "Ju ", "Qing ", "Jian ", "Zheng ", "Ze ", "Zou ", "Qian ", "Zhuo ", "Liang ", "Jian ", "Zhu ", "Hao ", "Lun ", "Shen ", "Biao ", "Huai ", "Pian ", "Yu ", "Die ", "Xu ", "Pian ", "Shi ", "Xuan ", "Shi ", "Hun ", "Hua ", "E ", "Zhong ", "Di ", "Xie ", "Fu ", "Pu ", "Ting ", "Jian ", "Qi ", "Yu ", "Zi ", "Chuan ", "Xi ", "Hui ", "Yin ", "An ", "Xian ", "Nan ", "Chen ", "Feng ", "Zhu ", "Yang ", "Yan ", "Heng ", "Xuan ", "Ge ", "Nuo ", "Qi "];
  }
});

// node_modules/unidecode/data/x8b.js
var require_x8b = __commonJS({
  "node_modules/unidecode/data/x8b.js"(exports, module2) {
    module2.exports = ["Mou ", "Ye ", "Wei ", "[?] ", "Teng ", "Zou ", "Shan ", "Jian ", "Bo ", "Ku ", "Huang ", "Huo ", "Ge ", "Ying ", "Mi ", "Xiao ", "Mi ", "Xi ", "Qiang ", "Chen ", "Nue ", "Ti ", "Su ", "Bang ", "Chi ", "Qian ", "Shi ", "Jiang ", "Yuan ", "Xie ", "Xue ", "Tao ", "Yao ", "Yao ", "[?] ", "Yu ", "Biao ", "Cong ", "Qing ", "Li ", "Mo ", "Mo ", "Shang ", "Zhe ", "Miu ", "Jian ", "Ze ", "Jie ", "Lian ", "Lou ", "Can ", "Ou ", "Guan ", "Xi ", "Zhuo ", "Ao ", "Ao ", "Jin ", "Zhe ", "Yi ", "Hu ", "Jiang ", "Man ", "Chao ", "Han ", "Hua ", "Chan ", "Xu ", "Zeng ", "Se ", "Xi ", "She ", "Dui ", "Zheng ", "Nao ", "Lan ", "E ", "Ying ", "Jue ", "Ji ", "Zun ", "Jiao ", "Bo ", "Hui ", "Zhuan ", "Mu ", "Zen ", "Zha ", "Shi ", "Qiao ", "Tan ", "Zen ", "Pu ", "Sheng ", "Xuan ", "Zao ", "Tan ", "Dang ", "Sui ", "Qian ", "Ji ", "Jiao ", "Jing ", "Lian ", "Nou ", "Yi ", "Ai ", "Zhan ", "Pi ", "Hui ", "Hua ", "Yi ", "Yi ", "Shan ", "Rang ", "Nou ", "Qian ", "Zhui ", "Ta ", "Hu ", "Zhou ", "Hao ", "Ye ", "Ying ", "Jian ", "Yu ", "Jian ", "Hui ", "Du ", "Zhe ", "Xuan ", "Zan ", "Lei ", "Shen ", "Wei ", "Chan ", "Li ", "Yi ", "Bian ", "Zhe ", "Yan ", "E ", "Chou ", "Wei ", "Chou ", "Yao ", "Chan ", "Rang ", "Yin ", "Lan ", "Chen ", "Huo ", "Zhe ", "Huan ", "Zan ", "Yi ", "Dang ", "Zhan ", "Yan ", "Du ", "Yan ", "Ji ", "Ding ", "Fu ", "Ren ", "Ji ", "Jie ", "Hong ", "Tao ", "Rang ", "Shan ", "Qi ", "Tuo ", "Xun ", "Yi ", "Xun ", "Ji ", "Ren ", "Jiang ", "Hui ", "Ou ", "Ju ", "Ya ", "Ne ", "Xu ", "E ", "Lun ", "Xiong ", "Song ", "Feng ", "She ", "Fang ", "Jue ", "Zheng ", "Gu ", "He ", "Ping ", "Zu ", "Shi ", "Xiong ", "Zha ", "Su ", "Zhen ", "Di ", "Zou ", "Ci ", "Qu ", "Zhao ", "Bi ", "Yi ", "Yi ", "Kuang ", "Lei ", "Shi ", "Gua ", "Shi ", "Jie ", "Hui ", "Cheng ", "Zhu ", "Shen ", "Hua ", "Dan ", "Gou ", "Quan ", "Gui ", "Xun ", "Yi ", "Zheng ", "Gai ", "Xiang ", "Cha ", "Hun ", "Xu ", "Zhou ", "Jie ", "Wu ", "Yu ", "Qiao ", "Wu ", "Gao ", "You ", "Hui ", "Kuang ", "Shuo ", "Song ", "Ai ", "Qing ", "Zhu ", "Zou ", "Nuo ", "Du ", "Zhuo ", "Fei ", "Ke ", "Wei "];
  }
});

// node_modules/unidecode/data/x8c.js
var require_x8c = __commonJS({
  "node_modules/unidecode/data/x8c.js"(exports, module2) {
    module2.exports = ["Yu ", "Shui ", "Shen ", "Diao ", "Chan ", "Liang ", "Zhun ", "Sui ", "Tan ", "Shen ", "Yi ", "Mou ", "Chen ", "Die ", "Huang ", "Jian ", "Xie ", "Nue ", "Ye ", "Wei ", "E ", "Yu ", "Xuan ", "Chan ", "Zi ", "An ", "Yan ", "Di ", "Mi ", "Pian ", "Xu ", "Mo ", "Dang ", "Su ", "Xie ", "Yao ", "Bang ", "Shi ", "Qian ", "Mi ", "Jin ", "Man ", "Zhe ", "Jian ", "Miu ", "Tan ", "Zen ", "Qiao ", "Lan ", "Pu ", "Jue ", "Yan ", "Qian ", "Zhan ", "Chen ", "Gu ", "Qian ", "Hong ", "Xia ", "Jue ", "Hong ", "Han ", "Hong ", "Xi ", "Xi ", "Huo ", "Liao ", "Han ", "Du ", "Long ", "Dou ", "Jiang ", "Qi ", "Shi ", "Li ", "Deng ", "Wan ", "Bi ", "Shu ", "Xian ", "Feng ", "Zhi ", "Zhi ", "Yan ", "Yan ", "Shi ", "Chu ", "Hui ", "Tun ", "Yi ", "Tun ", "Yi ", "Jian ", "Ba ", "Hou ", "E ", "Cu ", "Xiang ", "Huan ", "Jian ", "Ken ", "Gai ", "Qu ", "Fu ", "Xi ", "Bin ", "Hao ", "Yu ", "Zhu ", "Jia ", "[?] ", "Xi ", "Bo ", "Wen ", "Huan ", "Bin ", "Di ", "Zong ", "Fen ", "Yi ", "Zhi ", "Bao ", "Chai ", "Han ", "Pi ", "Na ", "Pi ", "Gou ", "Na ", "You ", "Diao ", "Mo ", "Si ", "Xiu ", "Huan ", "Kun ", "He ", "He ", "Mo ", "Han ", "Mao ", "Li ", "Ni ", "Bi ", "Yu ", "Jia ", "Tuan ", "Mao ", "Pi ", "Xi ", "E ", "Ju ", "Mo ", "Chu ", "Tan ", "Huan ", "Jue ", "Bei ", "Zhen ", "Yuan ", "Fu ", "Cai ", "Gong ", "Te ", "Yi ", "Hang ", "Wan ", "Pin ", "Huo ", "Fan ", "Tan ", "Guan ", "Ze ", "Zhi ", "Er ", "Zhu ", "Shi ", "Bi ", "Zi ", "Er ", "Gui ", "Pian ", "Bian ", "Mai ", "Dai ", "Sheng ", "Kuang ", "Fei ", "Tie ", "Yi ", "Chi ", "Mao ", "He ", "Bi ", "Lu ", "Ren ", "Hui ", "Gai ", "Pian ", "Zi ", "Jia ", "Xu ", "Zei ", "Jiao ", "Gai ", "Zang ", "Jian ", "Ying ", "Xun ", "Zhen ", "She ", "Bin ", "Bin ", "Qiu ", "She ", "Chuan ", "Zang ", "Zhou ", "Lai ", "Zan ", "Si ", "Chen ", "Shang ", "Tian ", "Pei ", "Geng ", "Xian ", "Mai ", "Jian ", "Sui ", "Fu ", "Tan ", "Cong ", "Cong ", "Zhi ", "Ji ", "Zhang ", "Du ", "Jin ", "Xiong ", "Shun ", "Yun ", "Bao ", "Zai ", "Lai ", "Feng ", "Cang ", "Ji ", "Sheng ", "Ai ", "Zhuan ", "Fu ", "Gou ", "Sai ", "Ze ", "Liao "];
  }
});

// node_modules/unidecode/data/x8d.js
var require_x8d = __commonJS({
  "node_modules/unidecode/data/x8d.js"(exports, module2) {
    module2.exports = ["Wei ", "Bai ", "Chen ", "Zhuan ", "Zhi ", "Zhui ", "Biao ", "Yun ", "Zeng ", "Tan ", "Zan ", "Yan ", "[?] ", "Shan ", "Wan ", "Ying ", "Jin ", "Gan ", "Xian ", "Zang ", "Bi ", "Du ", "Shu ", "Yan ", "[?] ", "Xuan ", "Long ", "Gan ", "Zang ", "Bei ", "Zhen ", "Fu ", "Yuan ", "Gong ", "Cai ", "Ze ", "Xian ", "Bai ", "Zhang ", "Huo ", "Zhi ", "Fan ", "Tan ", "Pin ", "Bian ", "Gou ", "Zhu ", "Guan ", "Er ", "Jian ", "Bi ", "Shi ", "Tie ", "Gui ", "Kuang ", "Dai ", "Mao ", "Fei ", "He ", "Yi ", "Zei ", "Zhi ", "Jia ", "Hui ", "Zi ", "Ren ", "Lu ", "Zang ", "Zi ", "Gai ", "Jin ", "Qiu ", "Zhen ", "Lai ", "She ", "Fu ", "Du ", "Ji ", "Shu ", "Shang ", "Si ", "Bi ", "Zhou ", "Geng ", "Pei ", "Tan ", "Lai ", "Feng ", "Zhui ", "Fu ", "Zhuan ", "Sai ", "Ze ", "Yan ", "Zan ", "Yun ", "Zeng ", "Shan ", "Ying ", "Gan ", "Chi ", "Xi ", "She ", "Nan ", "Xiong ", "Xi ", "Cheng ", "He ", "Cheng ", "Zhe ", "Xia ", "Tang ", "Zou ", "Zou ", "Li ", "Jiu ", "Fu ", "Zhao ", "Gan ", "Qi ", "Shan ", "Qiong ", "Qin ", "Xian ", "Ci ", "Jue ", "Qin ", "Chi ", "Ci ", "Chen ", "Chen ", "Die ", "Ju ", "Chao ", "Di ", "Se ", "Zhan ", "Zhu ", "Yue ", "Qu ", "Jie ", "Chi ", "Chu ", "Gua ", "Xue ", "Ci ", "Tiao ", "Duo ", "Lie ", "Gan ", "Suo ", "Cu ", "Xi ", "Zhao ", "Su ", "Yin ", "Ju ", "Jian ", "Que ", "Tang ", "Chuo ", "Cui ", "Lu ", "Qu ", "Dang ", "Qiu ", "Zi ", "Ti ", "Qu ", "Chi ", "Huang ", "Qiao ", "Qiao ", "Yao ", "Zao ", "Ti ", "[?] ", "Zan ", "Zan ", "Zu ", "Pa ", "Bao ", "Ku ", "Ke ", "Dun ", "Jue ", "Fu ", "Chen ", "Jian ", "Fang ", "Zhi ", "Sa ", "Yue ", "Pa ", "Qi ", "Yue ", "Qiang ", "Tuo ", "Tai ", "Yi ", "Nian ", "Ling ", "Mei ", "Ba ", "Die ", "Ku ", "Tuo ", "Jia ", "Ci ", "Pao ", "Qia ", "Zhu ", "Ju ", "Die ", "Zhi ", "Fu ", "Pan ", "Ju ", "Shan ", "Bo ", "Ni ", "Ju ", "Li ", "Gen ", "Yi ", "Ji ", "Dai ", "Xian ", "Jiao ", "Duo ", "Zhu ", "Zhuan ", "Kua ", "Zhuai ", "Gui ", "Qiong ", "Kui ", "Xiang ", "Chi ", "Lu ", "Beng ", "Zhi ", "Jia ", "Tiao ", "Cai ", "Jian ", "Ta ", "Qiao ", "Bi ", "Xian ", "Duo ", "Ji ", "Ju ", "Ji ", "Shu ", "Tu "];
  }
});

// node_modules/unidecode/data/x8e.js
var require_x8e = __commonJS({
  "node_modules/unidecode/data/x8e.js"(exports, module2) {
    module2.exports = ["Chu ", "Jing ", "Nie ", "Xiao ", "Bo ", "Chi ", "Qun ", "Mou ", "Shu ", "Lang ", "Yong ", "Jiao ", "Chou ", "Qiao ", "[?] ", "Ta ", "Jian ", "Qi ", "Wo ", "Wei ", "Zhuo ", "Jie ", "Ji ", "Nie ", "Ju ", "Ju ", "Lun ", "Lu ", "Leng ", "Huai ", "Ju ", "Chi ", "Wan ", "Quan ", "Ti ", "Bo ", "Zu ", "Qie ", "Ji ", "Cu ", "Zong ", "Cai ", "Zong ", "Peng ", "Zhi ", "Zheng ", "Dian ", "Zhi ", "Yu ", "Duo ", "Dun ", "Chun ", "Yong ", "Zhong ", "Di ", "Zhe ", "Chen ", "Chuai ", "Jian ", "Gua ", "Tang ", "Ju ", "Fu ", "Zu ", "Die ", "Pian ", "Rou ", "Nuo ", "Ti ", "Cha ", "Tui ", "Jian ", "Dao ", "Cuo ", "Xi ", "Ta ", "Qiang ", "Zhan ", "Dian ", "Ti ", "Ji ", "Nie ", "Man ", "Liu ", "Zhan ", "Bi ", "Chong ", "Lu ", "Liao ", "Cu ", "Tang ", "Dai ", "Suo ", "Xi ", "Kui ", "Ji ", "Zhi ", "Qiang ", "Di ", "Man ", "Zong ", "Lian ", "Beng ", "Zao ", "Nian ", "Bie ", "Tui ", "Ju ", "Deng ", "Ceng ", "Xian ", "Fan ", "Chu ", "Zhong ", "Dun ", "Bo ", "Cu ", "Zu ", "Jue ", "Jue ", "Lin ", "Ta ", "Qiao ", "Qiao ", "Pu ", "Liao ", "Dun ", "Cuan ", "Kuang ", "Zao ", "Ta ", "Bi ", "Bi ", "Zhu ", "Ju ", "Chu ", "Qiao ", "Dun ", "Chou ", "Ji ", "Wu ", "Yue ", "Nian ", "Lin ", "Lie ", "Zhi ", "Li ", "Zhi ", "Chan ", "Chu ", "Duan ", "Wei ", "Long ", "Lin ", "Xian ", "Wei ", "Zuan ", "Lan ", "Xie ", "Rang ", "Xie ", "Nie ", "Ta ", "Qu ", "Jie ", "Cuan ", "Zuan ", "Xi ", "Kui ", "Jue ", "Lin ", "Shen ", "Gong ", "Dan ", "Segare ", "Qu ", "Ti ", "Duo ", "Duo ", "Gong ", "Lang ", "Nerau ", "Luo ", "Ai ", "Ji ", "Ju ", "Tang ", "Utsuke ", "[?] ", "Yan ", "Shitsuke ", "Kang ", "Qu ", "Lou ", "Lao ", "Tuo ", "Zhi ", "Yagate ", "Ti ", "Dao ", "Yagate ", "Yu ", "Che ", "Ya ", "Gui ", "Jun ", "Wei ", "Yue ", "Xin ", "Di ", "Xuan ", "Fan ", "Ren ", "Shan ", "Qiang ", "Shu ", "Tun ", "Chen ", "Dai ", "E ", "Na ", "Qi ", "Mao ", "Ruan ", "Ren ", "Fan ", "Zhuan ", "Hong ", "Hu ", "Qu ", "Huang ", "Di ", "Ling ", "Dai ", "Ao ", "Zhen ", "Fan ", "Kuang ", "Ang ", "Peng ", "Bei ", "Gu ", "Ku ", "Pao ", "Zhu ", "Rong ", "E ", "Ba ", "Zhou ", "Zhi ", "Yao ", "Ke ", "Yi ", "Qing ", "Shi ", "Ping "];
  }
});

// node_modules/unidecode/data/x8f.js
var require_x8f = __commonJS({
  "node_modules/unidecode/data/x8f.js"(exports, module2) {
    module2.exports = ["Er ", "Qiong ", "Ju ", "Jiao ", "Guang ", "Lu ", "Kai ", "Quan ", "Zhou ", "Zai ", "Zhi ", "She ", "Liang ", "Yu ", "Shao ", "You ", "Huan ", "Yun ", "Zhe ", "Wan ", "Fu ", "Qing ", "Zhou ", "Ni ", "Ling ", "Zhe ", "Zhan ", "Liang ", "Zi ", "Hui ", "Wang ", "Chuo ", "Guo ", "Kan ", "Yi ", "Peng ", "Qian ", "Gun ", "Nian ", "Pian ", "Guan ", "Bei ", "Lun ", "Pai ", "Liang ", "Ruan ", "Rou ", "Ji ", "Yang ", "Xian ", "Chuan ", "Cou ", "Qun ", "Ge ", "You ", "Hong ", "Shu ", "Fu ", "Zi ", "Fu ", "Wen ", "Ben ", "Zhan ", "Yu ", "Wen ", "Tao ", "Gu ", "Zhen ", "Xia ", "Yuan ", "Lu ", "Jiu ", "Chao ", "Zhuan ", "Wei ", "Hun ", "Sori ", "Che ", "Jiao ", "Zhan ", "Pu ", "Lao ", "Fen ", "Fan ", "Lin ", "Ge ", "Se ", "Kan ", "Huan ", "Yi ", "Ji ", "Dui ", "Er ", "Yu ", "Xian ", "Hong ", "Lei ", "Pei ", "Li ", "Li ", "Lu ", "Lin ", "Che ", "Ya ", "Gui ", "Xuan ", "Di ", "Ren ", "Zhuan ", "E ", "Lun ", "Ruan ", "Hong ", "Ku ", "Ke ", "Lu ", "Zhou ", "Zhi ", "Yi ", "Hu ", "Zhen ", "Li ", "Yao ", "Qing ", "Shi ", "Zai ", "Zhi ", "Jiao ", "Zhou ", "Quan ", "Lu ", "Jiao ", "Zhe ", "Fu ", "Liang ", "Nian ", "Bei ", "Hui ", "Gun ", "Wang ", "Liang ", "Chuo ", "Zi ", "Cou ", "Fu ", "Ji ", "Wen ", "Shu ", "Pei ", "Yuan ", "Xia ", "Zhan ", "Lu ", "Che ", "Lin ", "Xin ", "Gu ", "Ci ", "Ci ", "Pi ", "Zui ", "Bian ", "La ", "La ", "Ci ", "Xue ", "Ban ", "Bian ", "Bian ", "Bian ", "[?] ", "Bian ", "Ban ", "Ci ", "Bian ", "Bian ", "Chen ", "Ru ", "Nong ", "Nong ", "Zhen ", "Chuo ", "Chuo ", "Suberu ", "Reng ", "Bian ", "Bian ", "Sip ", "Ip ", "Liao ", "Da ", "Chan ", "Gan ", "Qian ", "Yu ", "Yu ", "Qi ", "Xun ", "Yi ", "Guo ", "Mai ", "Qi ", "Za ", "Wang ", "Jia ", "Zhun ", "Ying ", "Ti ", "Yun ", "Jin ", "Hang ", "Ya ", "Fan ", "Wu ", "Da ", "E ", "Huan ", "Zhe ", "Totemo ", "Jin ", "Yuan ", "Wei ", "Lian ", "Chi ", "Che ", "Ni ", "Tiao ", "Zhi ", "Yi ", "Jiong ", "Jia ", "Chen ", "Dai ", "Er ", "Di ", "Po ", "Wang ", "Die ", "Ze ", "Tao ", "Shu ", "Tuo ", "Kep ", "Jing ", "Hui ", "Tong ", "You ", "Mi ", "Beng ", "Ji ", "Nai ", "Yi ", "Jie ", "Zhui ", "Lie ", "Xun "];
  }
});

// node_modules/unidecode/data/x90.js
var require_x90 = __commonJS({
  "node_modules/unidecode/data/x90.js"(exports, module2) {
    module2.exports = ["Tui ", "Song ", "Gua ", "Tao ", "Pang ", "Hou ", "Ni ", "Dun ", "Jiong ", "Xuan ", "Xun ", "Bu ", "You ", "Xiao ", "Qiu ", "Tou ", "Zhu ", "Qiu ", "Di ", "Di ", "Tu ", "Jing ", "Ti ", "Dou ", "Yi ", "Zhe ", "Tong ", "Guang ", "Wu ", "Shi ", "Cheng ", "Su ", "Zao ", "Qun ", "Feng ", "Lian ", "Suo ", "Hui ", "Li ", "Sako ", "Lai ", "Ben ", "Cuo ", "Jue ", "Beng ", "Huan ", "Dai ", "Lu ", "You ", "Zhou ", "Jin ", "Yu ", "Chuo ", "Kui ", "Wei ", "Ti ", "Yi ", "Da ", "Yuan ", "Luo ", "Bi ", "Nuo ", "Yu ", "Dang ", "Sui ", "Dun ", "Sui ", "Yan ", "Chuan ", "Chi ", "Ti ", "Yu ", "Shi ", "Zhen ", "You ", "Yun ", "E ", "Bian ", "Guo ", "E ", "Xia ", "Huang ", "Qiu ", "Dao ", "Da ", "Wei ", "Appare ", "Yi ", "Gou ", "Yao ", "Chu ", "Liu ", "Xun ", "Ta ", "Di ", "Chi ", "Yuan ", "Su ", "Ta ", "Qian ", "[?] ", "Yao ", "Guan ", "Zhang ", "Ao ", "Shi ", "Ce ", "Chi ", "Su ", "Zao ", "Zhe ", "Dun ", "Di ", "Lou ", "Chi ", "Cuo ", "Lin ", "Zun ", "Rao ", "Qian ", "Xuan ", "Yu ", "Yi ", "Wu ", "Liao ", "Ju ", "Shi ", "Bi ", "Yao ", "Mai ", "Xie ", "Sui ", "Huan ", "Zhan ", "Teng ", "Er ", "Miao ", "Bian ", "Bian ", "La ", "Li ", "Yuan ", "Yao ", "Luo ", "Li ", "Yi ", "Ting ", "Deng ", "Qi ", "Yong ", "Shan ", "Han ", "Yu ", "Mang ", "Ru ", "Qiong ", "[?] ", "Kuang ", "Fu ", "Kang ", "Bin ", "Fang ", "Xing ", "Na ", "Xin ", "Shen ", "Bang ", "Yuan ", "Cun ", "Huo ", "Xie ", "Bang ", "Wu ", "Ju ", "You ", "Han ", "Tai ", "Qiu ", "Bi ", "Pei ", "Bing ", "Shao ", "Bei ", "Wa ", "Di ", "Zou ", "Ye ", "Lin ", "Kuang ", "Gui ", "Zhu ", "Shi ", "Ku ", "Yu ", "Gai ", "Ge ", "Xi ", "Zhi ", "Ji ", "Xun ", "Hou ", "Xing ", "Jiao ", "Xi ", "Gui ", "Nuo ", "Lang ", "Jia ", "Kuai ", "Zheng ", "Otoko ", "Yun ", "Yan ", "Cheng ", "Dou ", "Chi ", "Lu ", "Fu ", "Wu ", "Fu ", "Gao ", "Hao ", "Lang ", "Jia ", "Geng ", "Jun ", "Ying ", "Bo ", "Xi ", "Bei ", "Li ", "Yun ", "Bu ", "Xiao ", "Qi ", "Pi ", "Qing ", "Guo ", "Zhou ", "Tan ", "Zou ", "Ping ", "Lai ", "Ni ", "Chen ", "You ", "Bu ", "Xiang ", "Dan ", "Ju ", "Yong ", "Qiao ", "Yi ", "Du ", "Yan ", "Mei "];
  }
});

// node_modules/unidecode/data/x91.js
var require_x91 = __commonJS({
  "node_modules/unidecode/data/x91.js"(exports, module2) {
    module2.exports = ["Ruo ", "Bei ", "E ", "Yu ", "Juan ", "Yu ", "Yun ", "Hou ", "Kui ", "Xiang ", "Xiang ", "Sou ", "Tang ", "Ming ", "Xi ", "Ru ", "Chu ", "Zi ", "Zou ", "Ju ", "Wu ", "Xiang ", "Yun ", "Hao ", "Yong ", "Bi ", "Mo ", "Chao ", "Fu ", "Liao ", "Yin ", "Zhuan ", "Hu ", "Qiao ", "Yan ", "Zhang ", "Fan ", "Qiao ", "Xu ", "Deng ", "Bi ", "Xin ", "Bi ", "Ceng ", "Wei ", "Zheng ", "Mao ", "Shan ", "Lin ", "Po ", "Dan ", "Meng ", "Ye ", "Cao ", "Kuai ", "Feng ", "Meng ", "Zou ", "Kuang ", "Lian ", "Zan ", "Chan ", "You ", "Qi ", "Yan ", "Chan ", "Zan ", "Ling ", "Huan ", "Xi ", "Feng ", "Zan ", "Li ", "You ", "Ding ", "Qiu ", "Zhuo ", "Pei ", "Zhou ", "Yi ", "Hang ", "Yu ", "Jiu ", "Yan ", "Zui ", "Mao ", "Dan ", "Xu ", "Tou ", "Zhen ", "Fen ", "Sakenomoto ", "[?] ", "Yun ", "Tai ", "Tian ", "Qia ", "Tuo ", "Zuo ", "Han ", "Gu ", "Su ", "Po ", "Chou ", "Zai ", "Ming ", "Luo ", "Chuo ", "Chou ", "You ", "Tong ", "Zhi ", "Xian ", "Jiang ", "Cheng ", "Yin ", "Tu ", "Xiao ", "Mei ", "Ku ", "Suan ", "Lei ", "Pu ", "Zui ", "Hai ", "Yan ", "Xi ", "Niang ", "Wei ", "Lu ", "Lan ", "Yan ", "Tao ", "Pei ", "Zhan ", "Chun ", "Tan ", "Zui ", "Chuo ", "Cu ", "Kun ", "Ti ", "Mian ", "Du ", "Hu ", "Xu ", "Xing ", "Tan ", "Jiu ", "Chun ", "Yun ", "Po ", "Ke ", "Sou ", "Mi ", "Quan ", "Chou ", "Cuo ", "Yun ", "Yong ", "Ang ", "Zha ", "Hai ", "Tang ", "Jiang ", "Piao ", "Shan ", "Yu ", "Li ", "Zao ", "Lao ", "Yi ", "Jiang ", "Pu ", "Jiao ", "Xi ", "Tan ", "Po ", "Nong ", "Yi ", "Li ", "Ju ", "Jiao ", "Yi ", "Niang ", "Ru ", "Xun ", "Chou ", "Yan ", "Ling ", "Mi ", "Mi ", "Niang ", "Xin ", "Jiao ", "Xi ", "Mi ", "Yan ", "Bian ", "Cai ", "Shi ", "You ", "Shi ", "Shi ", "Li ", "Zhong ", "Ye ", "Liang ", "Li ", "Jin ", "Jin ", "Qiu ", "Yi ", "Diao ", "Dao ", "Zhao ", "Ding ", "Po ", "Qiu ", "He ", "Fu ", "Zhen ", "Zhi ", "Ba ", "Luan ", "Fu ", "Nai ", "Diao ", "Shan ", "Qiao ", "Kou ", "Chuan ", "Zi ", "Fan ", "Yu ", "Hua ", "Han ", "Gong ", "Qi ", "Mang ", "Ri ", "Di ", "Si ", "Xi ", "Yi ", "Chai ", "Shi ", "Tu ", "Xi ", "Nu ", "Qian ", "Ishiyumi ", "Jian ", "Pi ", "Ye ", "Yin "];
  }
});

// node_modules/unidecode/data/x92.js
var require_x92 = __commonJS({
  "node_modules/unidecode/data/x92.js"(exports, module2) {
    module2.exports = ["Ba ", "Fang ", "Chen ", "Xing ", "Tou ", "Yue ", "Yan ", "Fu ", "Pi ", "Na ", "Xin ", "E ", "Jue ", "Dun ", "Gou ", "Yin ", "Qian ", "Ban ", "Ji ", "Ren ", "Chao ", "Niu ", "Fen ", "Yun ", "Ji ", "Qin ", "Pi ", "Guo ", "Hong ", "Yin ", "Jun ", "Shi ", "Yi ", "Zhong ", "Nie ", "Gai ", "Ri ", "Huo ", "Tai ", "Kang ", "Habaki ", "Irori ", "Ngaak ", "[?] ", "Duo ", "Zi ", "Ni ", "Tu ", "Shi ", "Min ", "Gu ", "E ", "Ling ", "Bing ", "Yi ", "Gu ", "Ba ", "Pi ", "Yu ", "Si ", "Zuo ", "Bu ", "You ", "Dian ", "Jia ", "Zhen ", "Shi ", "Shi ", "Tie ", "Ju ", "Zhan ", "Shi ", "She ", "Xuan ", "Zhao ", "Bao ", "He ", "Bi ", "Sheng ", "Chu ", "Shi ", "Bo ", "Zhu ", "Chi ", "Za ", "Po ", "Tong ", "Qian ", "Fu ", "Zhai ", "Liu ", "Qian ", "Fu ", "Li ", "Yue ", "Pi ", "Yang ", "Ban ", "Bo ", "Jie ", "Gou ", "Shu ", "Zheng ", "Mu ", "Ni ", "Nie ", "Di ", "Jia ", "Mu ", "Dan ", "Shen ", "Yi ", "Si ", "Kuang ", "Ka ", "Bei ", "Jian ", "Tong ", "Xing ", "Hong ", "Jiao ", "Chi ", "Er ", "Ge ", "Bing ", "Shi ", "Mou ", "Jia ", "Yin ", "Jun ", "Zhou ", "Chong ", "Shang ", "Tong ", "Mo ", "Lei ", "Ji ", "Yu ", "Xu ", "Ren ", "Zun ", "Zhi ", "Qiong ", "Shan ", "Chi ", "Xian ", "Xing ", "Quan ", "Pi ", "Tie ", "Zhu ", "Hou ", "Ming ", "Kua ", "Yao ", "Xian ", "Xian ", "Xiu ", "Jun ", "Cha ", "Lao ", "Ji ", "Pi ", "Ru ", "Mi ", "Yi ", "Yin ", "Guang ", "An ", "Diou ", "You ", "Se ", "Kao ", "Qian ", "Luan ", "Kasugai ", "Ai ", "Diao ", "Han ", "Rui ", "Shi ", "Keng ", "Qiu ", "Xiao ", "Zhe ", "Xiu ", "Zang ", "Ti ", "Cuo ", "Gua ", "Gong ", "Zhong ", "Dou ", "Lu ", "Mei ", "Lang ", "Wan ", "Xin ", "Yun ", "Bei ", "Wu ", "Su ", "Yu ", "Chan ", "Ting ", "Bo ", "Han ", "Jia ", "Hong ", "Cuan ", "Feng ", "Chan ", "Wan ", "Zhi ", "Si ", "Xuan ", "Wu ", "Wu ", "Tiao ", "Gong ", "Zhuo ", "Lue ", "Xing ", "Qian ", "Shen ", "Han ", "Lue ", "Xie ", "Chu ", "Zheng ", "Ju ", "Xian ", "Tie ", "Mang ", "Pu ", "Li ", "Pan ", "Rui ", "Cheng ", "Gao ", "Li ", "Te ", "Pyeng ", "Zhu ", "[?] ", "Tu ", "Liu ", "Zui ", "Ju ", "Chang ", "Yuan ", "Jian ", "Gang ", "Diao ", "Tao ", "Chang "];
  }
});

// node_modules/unidecode/data/x93.js
var require_x93 = __commonJS({
  "node_modules/unidecode/data/x93.js"(exports, module2) {
    module2.exports = ["Lun ", "Kua ", "Ling ", "Bei ", "Lu ", "Li ", "Qiang ", "Pou ", "Juan ", "Min ", "Zui ", "Peng ", "An ", "Pi ", "Xian ", "Ya ", "Zhui ", "Lei ", "A ", "Kong ", "Ta ", "Kun ", "Du ", "Wei ", "Chui ", "Zi ", "Zheng ", "Ben ", "Nie ", "Cong ", "Qun ", "Tan ", "Ding ", "Qi ", "Qian ", "Zhuo ", "Qi ", "Yu ", "Jin ", "Guan ", "Mao ", "Chang ", "Tian ", "Xi ", "Lian ", "Tao ", "Gu ", "Cuo ", "Shu ", "Zhen ", "Lu ", "Meng ", "Lu ", "Hua ", "Biao ", "Ga ", "Lai ", "Ken ", "Kazari ", "Bu ", "Nai ", "Wan ", "Zan ", "[?] ", "De ", "Xian ", "[?] ", "Huo ", "Liang ", "[?] ", "Men ", "Kai ", "Ying ", "Di ", "Lian ", "Guo ", "Xian ", "Du ", "Tu ", "Wei ", "Cong ", "Fu ", "Rou ", "Ji ", "E ", "Rou ", "Chen ", "Ti ", "Zha ", "Hong ", "Yang ", "Duan ", "Xia ", "Yu ", "Keng ", "Xing ", "Huang ", "Wei ", "Fu ", "Zhao ", "Cha ", "Qie ", "She ", "Hong ", "Kui ", "Tian ", "Mou ", "Qiao ", "Qiao ", "Hou ", "Tou ", "Cong ", "Huan ", "Ye ", "Min ", "Jian ", "Duan ", "Jian ", "Song ", "Kui ", "Hu ", "Xuan ", "Duo ", "Jie ", "Zhen ", "Bian ", "Zhong ", "Zi ", "Xiu ", "Ye ", "Mei ", "Pai ", "Ai ", "Jie ", "[?] ", "Mei ", "Chuo ", "Ta ", "Bang ", "Xia ", "Lian ", "Suo ", "Xi ", "Liu ", "Zu ", "Ye ", "Nou ", "Weng ", "Rong ", "Tang ", "Suo ", "Qiang ", "Ge ", "Shuo ", "Chui ", "Bo ", "Pan ", "Sa ", "Bi ", "Sang ", "Gang ", "Zi ", "Wu ", "Ying ", "Huang ", "Tiao ", "Liu ", "Kai ", "Sun ", "Sha ", "Sou ", "Wan ", "Hao ", "Zhen ", "Zhen ", "Luo ", "Yi ", "Yuan ", "Tang ", "Nie ", "Xi ", "Jia ", "Ge ", "Ma ", "Juan ", "Kasugai ", "Habaki ", "Suo ", "[?] ", "[?] ", "[?] ", "Na ", "Lu ", "Suo ", "Ou ", "Zu ", "Tuan ", "Xiu ", "Guan ", "Xuan ", "Lian ", "Shou ", "Ao ", "Man ", "Mo ", "Luo ", "Bi ", "Wei ", "Liu ", "Di ", "Qiao ", "Cong ", "Yi ", "Lu ", "Ao ", "Keng ", "Qiang ", "Cui ", "Qi ", "Chang ", "Tang ", "Man ", "Yong ", "Chan ", "Feng ", "Jing ", "Biao ", "Shu ", "Lou ", "Xiu ", "Cong ", "Long ", "Zan ", "Jian ", "Cao ", "Li ", "Xia ", "Xi ", "Kang ", "[?] ", "Beng ", "[?] ", "[?] ", "Zheng ", "Lu ", "Hua ", "Ji ", "Pu ", "Hui ", "Qiang ", "Po ", "Lin ", "Suo ", "Xiu ", "San ", "Cheng "];
  }
});

// node_modules/unidecode/data/x94.js
var require_x94 = __commonJS({
  "node_modules/unidecode/data/x94.js"(exports, module2) {
    module2.exports = ["Kui ", "Si ", "Liu ", "Nao ", "Heng ", "Pie ", "Sui ", "Fan ", "Qiao ", "Quan ", "Yang ", "Tang ", "Xiang ", "Jue ", "Jiao ", "Zun ", "Liao ", "Jie ", "Lao ", "Dui ", "Tan ", "Zan ", "Ji ", "Jian ", "Zhong ", "Deng ", "Ya ", "Ying ", "Dui ", "Jue ", "Nou ", "Ti ", "Pu ", "Tie ", "[?] ", "[?] ", "Ding ", "Shan ", "Kai ", "Jian ", "Fei ", "Sui ", "Lu ", "Juan ", "Hui ", "Yu ", "Lian ", "Zhuo ", "Qiao ", "Qian ", "Zhuo ", "Lei ", "Bi ", "Tie ", "Huan ", "Ye ", "Duo ", "Guo ", "Dang ", "Ju ", "Fen ", "Da ", "Bei ", "Yi ", "Ai ", "Zong ", "Xun ", "Diao ", "Zhu ", "Heng ", "Zhui ", "Ji ", "Nie ", "Ta ", "Huo ", "Qing ", "Bin ", "Ying ", "Kui ", "Ning ", "Xu ", "Jian ", "Jian ", "Yari ", "Cha ", "Zhi ", "Mie ", "Li ", "Lei ", "Ji ", "Zuan ", "Kuang ", "Shang ", "Peng ", "La ", "Du ", "Shuo ", "Chuo ", "Lu ", "Biao ", "Bao ", "Lu ", "[?] ", "[?] ", "Long ", "E ", "Lu ", "Xin ", "Jian ", "Lan ", "Bo ", "Jian ", "Yao ", "Chan ", "Xiang ", "Jian ", "Xi ", "Guan ", "Cang ", "Nie ", "Lei ", "Cuan ", "Qu ", "Pan ", "Luo ", "Zuan ", "Luan ", "Zao ", "Nie ", "Jue ", "Tang ", "Shu ", "Lan ", "Jin ", "Qiu ", "Yi ", "Zhen ", "Ding ", "Zhao ", "Po ", "Diao ", "Tu ", "Qian ", "Chuan ", "Shan ", "Ji ", "Fan ", "Diao ", "Men ", "Nu ", "Xi ", "Chai ", "Xing ", "Gai ", "Bu ", "Tai ", "Ju ", "Dun ", "Chao ", "Zhong ", "Na ", "Bei ", "Gang ", "Ban ", "Qian ", "Yao ", "Qin ", "Jun ", "Wu ", "Gou ", "Kang ", "Fang ", "Huo ", "Tou ", "Niu ", "Ba ", "Yu ", "Qian ", "Zheng ", "Qian ", "Gu ", "Bo ", "E ", "Po ", "Bu ", "Ba ", "Yue ", "Zuan ", "Mu ", "Dan ", "Jia ", "Dian ", "You ", "Tie ", "Bo ", "Ling ", "Shuo ", "Qian ", "Liu ", "Bao ", "Shi ", "Xuan ", "She ", "Bi ", "Ni ", "Pi ", "Duo ", "Xing ", "Kao ", "Lao ", "Er ", "Mang ", "Ya ", "You ", "Cheng ", "Jia ", "Ye ", "Nao ", "Zhi ", "Dang ", "Tong ", "Lu ", "Diao ", "Yin ", "Kai ", "Zha ", "Zhu ", "Xian ", "Ting ", "Diu ", "Xian ", "Hua ", "Quan ", "Sha ", "Jia ", "Yao ", "Ge ", "Ming ", "Zheng ", "Se ", "Jiao ", "Yi ", "Chan ", "Chong ", "Tang ", "An ", "Yin ", "Ru ", "Zhu ", "Lao ", "Pu ", "Wu ", "Lai ", "Te ", "Lian ", "Keng "];
  }
});

// node_modules/unidecode/data/x95.js
var require_x95 = __commonJS({
  "node_modules/unidecode/data/x95.js"(exports, module2) {
    module2.exports = ["Xiao ", "Suo ", "Li ", "Zheng ", "Chu ", "Guo ", "Gao ", "Tie ", "Xiu ", "Cuo ", "Lue ", "Feng ", "Xin ", "Liu ", "Kai ", "Jian ", "Rui ", "Ti ", "Lang ", "Qian ", "Ju ", "A ", "Qiang ", "Duo ", "Tian ", "Cuo ", "Mao ", "Ben ", "Qi ", "De ", "Kua ", "Kun ", "Chang ", "Xi ", "Gu ", "Luo ", "Chui ", "Zhui ", "Jin ", "Zhi ", "Xian ", "Juan ", "Huo ", "Pou ", "Tan ", "Ding ", "Jian ", "Ju ", "Meng ", "Zi ", "Qie ", "Ying ", "Kai ", "Qiang ", "Song ", "E ", "Cha ", "Qiao ", "Zhong ", "Duan ", "Sou ", "Huang ", "Huan ", "Ai ", "Du ", "Mei ", "Lou ", "Zi ", "Fei ", "Mei ", "Mo ", "Zhen ", "Bo ", "Ge ", "Nie ", "Tang ", "Juan ", "Nie ", "Na ", "Liu ", "Hao ", "Bang ", "Yi ", "Jia ", "Bin ", "Rong ", "Biao ", "Tang ", "Man ", "Luo ", "Beng ", "Yong ", "Jing ", "Di ", "Zu ", "Xuan ", "Liu ", "Tan ", "Jue ", "Liao ", "Pu ", "Lu ", "Dui ", "Lan ", "Pu ", "Cuan ", "Qiang ", "Deng ", "Huo ", "Lei ", "Huan ", "Zhuo ", "Lian ", "Yi ", "Cha ", "Biao ", "La ", "Chan ", "Xiang ", "Chang ", "Chang ", "Jiu ", "Ao ", "Die ", "Qu ", "Liao ", "Mi ", "Chang ", "Men ", "Ma ", "Shuan ", "Shan ", "Huo ", "Men ", "Yan ", "Bi ", "Han ", "Bi ", "San ", "Kai ", "Kang ", "Beng ", "Hong ", "Run ", "San ", "Xian ", "Xian ", "Jian ", "Min ", "Xia ", "Yuru ", "Dou ", "Zha ", "Nao ", "Jian ", "Peng ", "Xia ", "Ling ", "Bian ", "Bi ", "Run ", "He ", "Guan ", "Ge ", "Ge ", "Fa ", "Chu ", "Hong ", "Gui ", "Min ", "Se ", "Kun ", "Lang ", "Lu ", "Ting ", "Sha ", "Ju ", "Yue ", "Yue ", "Chan ", "Qu ", "Lin ", "Chang ", "Shai ", "Kun ", "Yan ", "Min ", "Yan ", "E ", "Hun ", "Yu ", "Wen ", "Xiang ", "Bao ", "Xiang ", "Qu ", "Yao ", "Wen ", "Ban ", "An ", "Wei ", "Yin ", "Kuo ", "Que ", "Lan ", "Du ", "[?] ", "Phwung ", "Tian ", "Nie ", "Ta ", "Kai ", "He ", "Que ", "Chuang ", "Guan ", "Dou ", "Qi ", "Kui ", "Tang ", "Guan ", "Piao ", "Kan ", "Xi ", "Hui ", "Chan ", "Pi ", "Dang ", "Huan ", "Ta ", "Wen ", "[?] ", "Men ", "Shuan ", "Shan ", "Yan ", "Han ", "Bi ", "Wen ", "Chuang ", "Run ", "Wei ", "Xian ", "Hong ", "Jian ", "Min ", "Kang ", "Men ", "Zha ", "Nao ", "Gui ", "Wen ", "Ta ", "Min ", "Lu ", "Kai "];
  }
});

// node_modules/unidecode/data/x96.js
var require_x96 = __commonJS({
  "node_modules/unidecode/data/x96.js"(exports, module2) {
    module2.exports = ["Fa ", "Ge ", "He ", "Kun ", "Jiu ", "Yue ", "Lang ", "Du ", "Yu ", "Yan ", "Chang ", "Xi ", "Wen ", "Hun ", "Yan ", "E ", "Chan ", "Lan ", "Qu ", "Hui ", "Kuo ", "Que ", "Ge ", "Tian ", "Ta ", "Que ", "Kan ", "Huan ", "Fu ", "Fu ", "Le ", "Dui ", "Xin ", "Qian ", "Wu ", "Yi ", "Tuo ", "Yin ", "Yang ", "Dou ", "E ", "Sheng ", "Ban ", "Pei ", "Keng ", "Yun ", "Ruan ", "Zhi ", "Pi ", "Jing ", "Fang ", "Yang ", "Yin ", "Zhen ", "Jie ", "Cheng ", "E ", "Qu ", "Di ", "Zu ", "Zuo ", "Dian ", "Ling ", "A ", "Tuo ", "Tuo ", "Po ", "Bing ", "Fu ", "Ji ", "Lu ", "Long ", "Chen ", "Xing ", "Duo ", "Lou ", "Mo ", "Jiang ", "Shu ", "Duo ", "Xian ", "Er ", "Gui ", "Yu ", "Gai ", "Shan ", "Xun ", "Qiao ", "Xing ", "Chun ", "Fu ", "Bi ", "Xia ", "Shan ", "Sheng ", "Zhi ", "Pu ", "Dou ", "Yuan ", "Zhen ", "Chu ", "Xian ", "Tou ", "Nie ", "Yun ", "Xian ", "Pei ", "Pei ", "Zou ", "Yi ", "Dui ", "Lun ", "Yin ", "Ju ", "Chui ", "Chen ", "Pi ", "Ling ", "Tao ", "Xian ", "Lu ", "Sheng ", "Xian ", "Yin ", "Zhu ", "Yang ", "Reng ", "Shan ", "Chong ", "Yan ", "Yin ", "Yu ", "Ti ", "Yu ", "Long ", "Wei ", "Wei ", "Nie ", "Dui ", "Sui ", "An ", "Huang ", "Jie ", "Sui ", "Yin ", "Gai ", "Yan ", "Hui ", "Ge ", "Yun ", "Wu ", "Wei ", "Ai ", "Xi ", "Tang ", "Ji ", "Zhang ", "Dao ", "Ao ", "Xi ", "Yin ", "[?] ", "Rao ", "Lin ", "Tui ", "Deng ", "Pi ", "Sui ", "Sui ", "Yu ", "Xian ", "Fen ", "Ni ", "Er ", "Ji ", "Dao ", "Xi ", "Yin ", "E ", "Hui ", "Long ", "Xi ", "Li ", "Li ", "Li ", "Zhui ", "He ", "Zhi ", "Zhun ", "Jun ", "Nan ", "Yi ", "Que ", "Yan ", "Qian ", "Ya ", "Xiong ", "Ya ", "Ji ", "Gu ", "Huan ", "Zhi ", "Gou ", "Jun ", "Ci ", "Yong ", "Ju ", "Chu ", "Hu ", "Za ", "Luo ", "Yu ", "Chou ", "Diao ", "Sui ", "Han ", "Huo ", "Shuang ", "Guan ", "Chu ", "Za ", "Yong ", "Ji ", "Xi ", "Chou ", "Liu ", "Li ", "Nan ", "Xue ", "Za ", "Ji ", "Ji ", "Yu ", "Yu ", "Xue ", "Na ", "Fou ", "Se ", "Mu ", "Wen ", "Fen ", "Pang ", "Yun ", "Li ", "Li ", "Ang ", "Ling ", "Lei ", "An ", "Bao ", "Meng ", "Dian ", "Dang ", "Xing ", "Wu ", "Zhao "];
  }
});

// node_modules/unidecode/data/x97.js
var require_x97 = __commonJS({
  "node_modules/unidecode/data/x97.js"(exports, module2) {
    module2.exports = ["Xu ", "Ji ", "Mu ", "Chen ", "Xiao ", "Zha ", "Ting ", "Zhen ", "Pei ", "Mei ", "Ling ", "Qi ", "Chou ", "Huo ", "Sha ", "Fei ", "Weng ", "Zhan ", "Yin ", "Ni ", "Chou ", "Tun ", "Lin ", "[?] ", "Dong ", "Ying ", "Wu ", "Ling ", "Shuang ", "Ling ", "Xia ", "Hong ", "Yin ", "Mo ", "Mai ", "Yun ", "Liu ", "Meng ", "Bin ", "Wu ", "Wei ", "Huo ", "Yin ", "Xi ", "Yi ", "Ai ", "Dan ", "Deng ", "Xian ", "Yu ", "Lu ", "Long ", "Dai ", "Ji ", "Pang ", "Yang ", "Ba ", "Pi ", "Wei ", "[?] ", "Xi ", "Ji ", "Mai ", "Meng ", "Meng ", "Lei ", "Li ", "Huo ", "Ai ", "Fei ", "Dai ", "Long ", "Ling ", "Ai ", "Feng ", "Li ", "Bao ", "[?] ", "He ", "He ", "Bing ", "Qing ", "Qing ", "Jing ", "Tian ", "Zhen ", "Jing ", "Cheng ", "Qing ", "Jing ", "Jing ", "Dian ", "Jing ", "Tian ", "Fei ", "Fei ", "Kao ", "Mi ", "Mian ", "Mian ", "Pao ", "Ye ", "Tian ", "Hui ", "Ye ", "Ge ", "Ding ", "Cha ", "Jian ", "Ren ", "Di ", "Du ", "Wu ", "Ren ", "Qin ", "Jin ", "Xue ", "Niu ", "Ba ", "Yin ", "Sa ", "Na ", "Mo ", "Zu ", "Da ", "Ban ", "Yi ", "Yao ", "Tao ", "Tuo ", "Jia ", "Hong ", "Pao ", "Yang ", "Tomo ", "Yin ", "Jia ", "Tao ", "Ji ", "Xie ", "An ", "An ", "Hen ", "Gong ", "Kohaze ", "Da ", "Qiao ", "Ting ", "Wan ", "Ying ", "Sui ", "Tiao ", "Qiao ", "Xuan ", "Kong ", "Beng ", "Ta ", "Zhang ", "Bing ", "Kuo ", "Ju ", "La ", "Xie ", "Rou ", "Bang ", "Yi ", "Qiu ", "Qiu ", "He ", "Xiao ", "Mu ", "Ju ", "Jian ", "Bian ", "Di ", "Jian ", "On ", "Tao ", "Gou ", "Ta ", "Bei ", "Xie ", "Pan ", "Ge ", "Bi ", "Kuo ", "Tang ", "Lou ", "Gui ", "Qiao ", "Xue ", "Ji ", "Jian ", "Jiang ", "Chan ", "Da ", "Huo ", "Xian ", "Qian ", "Du ", "Wa ", "Jian ", "Lan ", "Wei ", "Ren ", "Fu ", "Mei ", "Juan ", "Ge ", "Wei ", "Qiao ", "Han ", "Chang ", "[?] ", "Rou ", "Xun ", "She ", "Wei ", "Ge ", "Bei ", "Tao ", "Gou ", "Yun ", "[?] ", "Bi ", "Wei ", "Hui ", "Du ", "Wa ", "Du ", "Wei ", "Ren ", "Fu ", "Han ", "Wei ", "Yun ", "Tao ", "Jiu ", "Jiu ", "Xian ", "Xie ", "Xian ", "Ji ", "Yin ", "Za ", "Yun ", "Shao ", "Le ", "Peng ", "Heng ", "Ying ", "Yun ", "Peng ", "Yin ", "Yin ", "Xiang "];
  }
});

// node_modules/unidecode/data/x98.js
var require_x98 = __commonJS({
  "node_modules/unidecode/data/x98.js"(exports, module2) {
    module2.exports = ["Hu ", "Ye ", "Ding ", "Qing ", "Pan ", "Xiang ", "Shun ", "Han ", "Xu ", "Yi ", "Xu ", "Gu ", "Song ", "Kui ", "Qi ", "Hang ", "Yu ", "Wan ", "Ban ", "Dun ", "Di ", "Dan ", "Pan ", "Po ", "Ling ", "Ce ", "Jing ", "Lei ", "He ", "Qiao ", "E ", "E ", "Wei ", "Jie ", "Gua ", "Shen ", "Yi ", "Shen ", "Hai ", "Dui ", "Pian ", "Ping ", "Lei ", "Fu ", "Jia ", "Tou ", "Hui ", "Kui ", "Jia ", "Le ", "Tian ", "Cheng ", "Ying ", "Jun ", "Hu ", "Han ", "Jing ", "Tui ", "Tui ", "Pin ", "Lai ", "Tui ", "Zi ", "Zi ", "Chui ", "Ding ", "Lai ", "Yan ", "Han ", "Jian ", "Ke ", "Cui ", "Jiong ", "Qin ", "Yi ", "Sai ", "Ti ", "E ", "E ", "Yan ", "Hun ", "Kan ", "Yong ", "Zhuan ", "Yan ", "Xian ", "Xin ", "Yi ", "Yuan ", "Sang ", "Dian ", "Dian ", "Jiang ", "Ku ", "Lei ", "Liao ", "Piao ", "Yi ", "Man ", "Qi ", "Rao ", "Hao ", "Qiao ", "Gu ", "Xun ", "Qian ", "Hui ", "Zhan ", "Ru ", "Hong ", "Bin ", "Xian ", "Pin ", "Lu ", "Lan ", "Nie ", "Quan ", "Ye ", "Ding ", "Qing ", "Han ", "Xiang ", "Shun ", "Xu ", "Xu ", "Wan ", "Gu ", "Dun ", "Qi ", "Ban ", "Song ", "Hang ", "Yu ", "Lu ", "Ling ", "Po ", "Jing ", "Jie ", "Jia ", "Tian ", "Han ", "Ying ", "Jiong ", "Hai ", "Yi ", "Pin ", "Hui ", "Tui ", "Han ", "Ying ", "Ying ", "Ke ", "Ti ", "Yong ", "E ", "Zhuan ", "Yan ", "E ", "Nie ", "Man ", "Dian ", "Sang ", "Hao ", "Lei ", "Zhan ", "Ru ", "Pin ", "Quan ", "Feng ", "Biao ", "Oroshi ", "Fu ", "Xia ", "Zhan ", "Biao ", "Sa ", "Ba ", "Tai ", "Lie ", "Gua ", "Xuan ", "Shao ", "Ju ", "Bi ", "Si ", "Wei ", "Yang ", "Yao ", "Sou ", "Kai ", "Sao ", "Fan ", "Liu ", "Xi ", "Liao ", "Piao ", "Piao ", "Liu ", "Biao ", "Biao ", "Biao ", "Liao ", "[?] ", "Se ", "Feng ", "Biao ", "Feng ", "Yang ", "Zhan ", "Biao ", "Sa ", "Ju ", "Si ", "Sou ", "Yao ", "Liu ", "Piao ", "Biao ", "Biao ", "Fei ", "Fan ", "Fei ", "Fei ", "Shi ", "Shi ", "Can ", "Ji ", "Ding ", "Si ", "Tuo ", "Zhan ", "Sun ", "Xiang ", "Tun ", "Ren ", "Yu ", "Juan ", "Chi ", "Yin ", "Fan ", "Fan ", "Sun ", "Yin ", "Zhu ", "Yi ", "Zhai ", "Bi ", "Jie ", "Tao ", "Liu ", "Ci ", "Tie ", "Si ", "Bao ", "Shi ", "Duo "];
  }
});

// node_modules/unidecode/data/x99.js
var require_x99 = __commonJS({
  "node_modules/unidecode/data/x99.js"(exports, module2) {
    module2.exports = ["Hai ", "Ren ", "Tian ", "Jiao ", "Jia ", "Bing ", "Yao ", "Tong ", "Ci ", "Xiang ", "Yang ", "Yang ", "Er ", "Yan ", "Le ", "Yi ", "Can ", "Bo ", "Nei ", "E ", "Bu ", "Jun ", "Dou ", "Su ", "Yu ", "Shi ", "Yao ", "Hun ", "Guo ", "Shi ", "Jian ", "Zhui ", "Bing ", "Xian ", "Bu ", "Ye ", "Tan ", "Fei ", "Zhang ", "Wei ", "Guan ", "E ", "Nuan ", "Hun ", "Hu ", "Huang ", "Tie ", "Hui ", "Jian ", "Hou ", "He ", "Xing ", "Fen ", "Wei ", "Gu ", "Cha ", "Song ", "Tang ", "Bo ", "Gao ", "Xi ", "Kui ", "Liu ", "Sou ", "Tao ", "Ye ", "Yun ", "Mo ", "Tang ", "Man ", "Bi ", "Yu ", "Xiu ", "Jin ", "San ", "Kui ", "Zhuan ", "Shan ", "Chi ", "Dan ", "Yi ", "Ji ", "Rao ", "Cheng ", "Yong ", "Tao ", "Hui ", "Xiang ", "Zhan ", "Fen ", "Hai ", "Meng ", "Yan ", "Mo ", "Chan ", "Xiang ", "Luo ", "Zuan ", "Nang ", "Shi ", "Ding ", "Ji ", "Tuo ", "Xing ", "Tun ", "Xi ", "Ren ", "Yu ", "Chi ", "Fan ", "Yin ", "Jian ", "Shi ", "Bao ", "Si ", "Duo ", "Yi ", "Er ", "Rao ", "Xiang ", "Jia ", "Le ", "Jiao ", "Yi ", "Bing ", "Bo ", "Dou ", "E ", "Yu ", "Nei ", "Jun ", "Guo ", "Hun ", "Xian ", "Guan ", "Cha ", "Kui ", "Gu ", "Sou ", "Chan ", "Ye ", "Mo ", "Bo ", "Liu ", "Xiu ", "Jin ", "Man ", "San ", "Zhuan ", "Nang ", "Shou ", "Kui ", "Guo ", "Xiang ", "Fen ", "Ba ", "Ni ", "Bi ", "Bo ", "Tu ", "Han ", "Fei ", "Jian ", "An ", "Ai ", "Fu ", "Xian ", "Wen ", "Xin ", "Fen ", "Bin ", "Xing ", "Ma ", "Yu ", "Feng ", "Han ", "Di ", "Tuo ", "Tuo ", "Chi ", "Xun ", "Zhu ", "Zhi ", "Pei ", "Xin ", "Ri ", "Sa ", "Yin ", "Wen ", "Zhi ", "Dan ", "Lu ", "You ", "Bo ", "Bao ", "Kuai ", "Tuo ", "Yi ", "Qu ", "[?] ", "Qu ", "Jiong ", "Bo ", "Zhao ", "Yuan ", "Peng ", "Zhou ", "Ju ", "Zhu ", "Nu ", "Ju ", "Pi ", "Zang ", "Jia ", "Ling ", "Zhen ", "Tai ", "Fu ", "Yang ", "Shi ", "Bi ", "Tuo ", "Tuo ", "Si ", "Liu ", "Ma ", "Pian ", "Tao ", "Zhi ", "Rong ", "Teng ", "Dong ", "Xun ", "Quan ", "Shen ", "Jiong ", "Er ", "Hai ", "Bo ", "Zhu ", "Yin ", "Luo ", "Shuu ", "Dan ", "Xie ", "Liu ", "Ju ", "Song ", "Qin ", "Mang ", "Liang ", "Han ", "Tu ", "Xuan ", "Tui ", "Jun "];
  }
});

// node_modules/unidecode/data/x9a.js
var require_x9a = __commonJS({
  "node_modules/unidecode/data/x9a.js"(exports, module2) {
    module2.exports = ["E ", "Cheng ", "Xin ", "Ai ", "Lu ", "Zhui ", "Zhou ", "She ", "Pian ", "Kun ", "Tao ", "Lai ", "Zong ", "Ke ", "Qi ", "Qi ", "Yan ", "Fei ", "Sao ", "Yan ", "Jie ", "Yao ", "Wu ", "Pian ", "Cong ", "Pian ", "Qian ", "Fei ", "Huang ", "Jian ", "Huo ", "Yu ", "Ti ", "Quan ", "Xia ", "Zong ", "Kui ", "Rou ", "Si ", "Gua ", "Tuo ", "Kui ", "Sou ", "Qian ", "Cheng ", "Zhi ", "Liu ", "Pang ", "Teng ", "Xi ", "Cao ", "Du ", "Yan ", "Yuan ", "Zou ", "Sao ", "Shan ", "Li ", "Zhi ", "Shuang ", "Lu ", "Xi ", "Luo ", "Zhang ", "Mo ", "Ao ", "Can ", "Piao ", "Cong ", "Qu ", "Bi ", "Zhi ", "Yu ", "Xu ", "Hua ", "Bo ", "Su ", "Xiao ", "Lin ", "Chan ", "Dun ", "Liu ", "Tuo ", "Zeng ", "Tan ", "Jiao ", "Tie ", "Yan ", "Luo ", "Zhan ", "Jing ", "Yi ", "Ye ", "Tuo ", "Bin ", "Zou ", "Yan ", "Peng ", "Lu ", "Teng ", "Xiang ", "Ji ", "Shuang ", "Ju ", "Xi ", "Huan ", "Li ", "Biao ", "Ma ", "Yu ", "Tuo ", "Xun ", "Chi ", "Qu ", "Ri ", "Bo ", "Lu ", "Zang ", "Shi ", "Si ", "Fu ", "Ju ", "Zou ", "Zhu ", "Tuo ", "Nu ", "Jia ", "Yi ", "Tai ", "Xiao ", "Ma ", "Yin ", "Jiao ", "Hua ", "Luo ", "Hai ", "Pian ", "Biao ", "Li ", "Cheng ", "Yan ", "Xin ", "Qin ", "Jun ", "Qi ", "Qi ", "Ke ", "Zhui ", "Zong ", "Su ", "Can ", "Pian ", "Zhi ", "Kui ", "Sao ", "Wu ", "Ao ", "Liu ", "Qian ", "Shan ", "Piao ", "Luo ", "Cong ", "Chan ", "Zou ", "Ji ", "Shuang ", "Xiang ", "Gu ", "Wei ", "Wei ", "Wei ", "Yu ", "Gan ", "Yi ", "Ang ", "Tou ", "Xie ", "Bao ", "Bi ", "Chi ", "Ti ", "Di ", "Ku ", "Hai ", "Qiao ", "Gou ", "Kua ", "Ge ", "Tui ", "Geng ", "Pian ", "Bi ", "Ke ", "Ka ", "Yu ", "Sui ", "Lou ", "Bo ", "Xiao ", "Pang ", "Bo ", "Ci ", "Kuan ", "Bin ", "Mo ", "Liao ", "Lou ", "Nao ", "Du ", "Zang ", "Sui ", "Ti ", "Bin ", "Kuan ", "Lu ", "Gao ", "Gao ", "Qiao ", "Kao ", "Qiao ", "Lao ", "Zao ", "Biao ", "Kun ", "Kun ", "Ti ", "Fang ", "Xiu ", "Ran ", "Mao ", "Dan ", "Kun ", "Bin ", "Fa ", "Tiao ", "Peng ", "Zi ", "Fa ", "Ran ", "Ti ", "Pao ", "Pi ", "Mao ", "Fu ", "Er ", "Rong ", "Qu ", "Gong ", "Xiu ", "Gua ", "Ji ", "Peng ", "Zhua ", "Shao ", "Sha "];
  }
});

// node_modules/unidecode/data/x9b.js
var require_x9b = __commonJS({
  "node_modules/unidecode/data/x9b.js"(exports, module2) {
    module2.exports = ["Ti ", "Li ", "Bin ", "Zong ", "Ti ", "Peng ", "Song ", "Zheng ", "Quan ", "Zong ", "Shun ", "Jian ", "Duo ", "Hu ", "La ", "Jiu ", "Qi ", "Lian ", "Zhen ", "Bin ", "Peng ", "Mo ", "San ", "Man ", "Man ", "Seng ", "Xu ", "Lie ", "Qian ", "Qian ", "Nong ", "Huan ", "Kuai ", "Ning ", "Bin ", "Lie ", "Rang ", "Dou ", "Dou ", "Nao ", "Hong ", "Xi ", "Dou ", "Han ", "Dou ", "Dou ", "Jiu ", "Chang ", "Yu ", "Yu ", "Li ", "Juan ", "Fu ", "Qian ", "Gui ", "Zong ", "Liu ", "Gui ", "Shang ", "Yu ", "Gui ", "Mei ", "Ji ", "Qi ", "Jie ", "Kui ", "Hun ", "Ba ", "Po ", "Mei ", "Xu ", "Yan ", "Xiao ", "Liang ", "Yu ", "Tui ", "Qi ", "Wang ", "Liang ", "Wei ", "Jian ", "Chi ", "Piao ", "Bi ", "Mo ", "Ji ", "Xu ", "Chou ", "Yan ", "Zhan ", "Yu ", "Dao ", "Ren ", "Ji ", "Eri ", "Gong ", "Tuo ", "Diao ", "Ji ", "Xu ", "E ", "E ", "Sha ", "Hang ", "Tun ", "Mo ", "Jie ", "Shen ", "Fan ", "Yuan ", "Bi ", "Lu ", "Wen ", "Hu ", "Lu ", "Za ", "Fang ", "Fen ", "Na ", "You ", "Namazu ", "Todo ", "He ", "Xia ", "Qu ", "Han ", "Pi ", "Ling ", "Tuo ", "Bo ", "Qiu ", "Ping ", "Fu ", "Bi ", "Ji ", "Wei ", "Ju ", "Diao ", "Bo ", "You ", "Gun ", "Pi ", "Nian ", "Xing ", "Tai ", "Bao ", "Fu ", "Zha ", "Ju ", "Gu ", "Kajika ", "Tong ", "[?] ", "Ta ", "Jie ", "Shu ", "Hou ", "Xiang ", "Er ", "An ", "Wei ", "Tiao ", "Zhu ", "Yin ", "Lie ", "Luo ", "Tong ", "Yi ", "Qi ", "Bing ", "Wei ", "Jiao ", "Bu ", "Gui ", "Xian ", "Ge ", "Hui ", "Bora ", "Mate ", "Kao ", "Gori ", "Duo ", "Jun ", "Ti ", "Man ", "Xiao ", "Za ", "Sha ", "Qin ", "Yu ", "Nei ", "Zhe ", "Gun ", "Geng ", "Su ", "Wu ", "Qiu ", "Ting ", "Fu ", "Wan ", "You ", "Li ", "Sha ", "Sha ", "Gao ", "Meng ", "Ugui ", "Asari ", "Subashiri ", "Kazunoko ", "Yong ", "Ni ", "Zi ", "Qi ", "Qing ", "Xiang ", "Nei ", "Chun ", "Ji ", "Diao ", "Qie ", "Gu ", "Zhou ", "Dong ", "Lai ", "Fei ", "Ni ", "Yi ", "Kun ", "Lu ", "Jiu ", "Chang ", "Jing ", "Lun ", "Ling ", "Zou ", "Li ", "Meng ", "Zong ", "Zhi ", "Nian ", "Shachi ", "Dojou ", "Sukesou ", "Shi ", "Shen ", "Hun ", "Shi ", "Hou ", "Xing ", "Zhu ", "La ", "Zong ", "Ji ", "Bian ", "Bian "];
  }
});

// node_modules/unidecode/data/x9c.js
var require_x9c = __commonJS({
  "node_modules/unidecode/data/x9c.js"(exports, module2) {
    module2.exports = ["Huan ", "Quan ", "Ze ", "Wei ", "Wei ", "Yu ", "Qun ", "Rou ", "Die ", "Huang ", "Lian ", "Yan ", "Qiu ", "Qiu ", "Jian ", "Bi ", "E ", "Yang ", "Fu ", "Sai ", "Jian ", "Xia ", "Tuo ", "Hu ", "Muroaji ", "Ruo ", "Haraka ", "Wen ", "Jian ", "Hao ", "Wu ", "Fang ", "Sao ", "Liu ", "Ma ", "Shi ", "Shi ", "Yin ", "Z ", "Teng ", "Ta ", "Yao ", "Ge ", "Rong ", "Qian ", "Qi ", "Wen ", "Ruo ", "Hatahata ", "Lian ", "Ao ", "Le ", "Hui ", "Min ", "Ji ", "Tiao ", "Qu ", "Jian ", "Sao ", "Man ", "Xi ", "Qiu ", "Biao ", "Ji ", "Ji ", "Zhu ", "Jiang ", "Qiu ", "Zhuan ", "Yong ", "Zhang ", "Kang ", "Xue ", "Bie ", "Jue ", "Qu ", "Xiang ", "Bo ", "Jiao ", "Xun ", "Su ", "Huang ", "Zun ", "Shan ", "Shan ", "Fan ", "Jue ", "Lin ", "Xun ", "Miao ", "Xi ", "Eso ", "Kyou ", "Fen ", "Guan ", "Hou ", "Kuai ", "Zei ", "Sao ", "Zhan ", "Gan ", "Gui ", "Sheng ", "Li ", "Chang ", "Hatahata ", "Shiira ", "Mutsu ", "Ru ", "Ji ", "Xu ", "Huo ", "Shiira ", "Li ", "Lie ", "Li ", "Mie ", "Zhen ", "Xiang ", "E ", "Lu ", "Guan ", "Li ", "Xian ", "Yu ", "Dao ", "Ji ", "You ", "Tun ", "Lu ", "Fang ", "Ba ", "He ", "Bo ", "Ping ", "Nian ", "Lu ", "You ", "Zha ", "Fu ", "Bo ", "Bao ", "Hou ", "Pi ", "Tai ", "Gui ", "Jie ", "Kao ", "Wei ", "Er ", "Tong ", "Ze ", "Hou ", "Kuai ", "Ji ", "Jiao ", "Xian ", "Za ", "Xiang ", "Xun ", "Geng ", "Li ", "Lian ", "Jian ", "Li ", "Shi ", "Tiao ", "Gun ", "Sha ", "Wan ", "Jun ", "Ji ", "Yong ", "Qing ", "Ling ", "Qi ", "Zou ", "Fei ", "Kun ", "Chang ", "Gu ", "Ni ", "Nian ", "Diao ", "Jing ", "Shen ", "Shi ", "Zi ", "Fen ", "Die ", "Bi ", "Chang ", "Shi ", "Wen ", "Wei ", "Sai ", "E ", "Qiu ", "Fu ", "Huang ", "Quan ", "Jiang ", "Bian ", "Sao ", "Ao ", "Qi ", "Ta ", "Yin ", "Yao ", "Fang ", "Jian ", "Le ", "Biao ", "Xue ", "Bie ", "Man ", "Min ", "Yong ", "Wei ", "Xi ", "Jue ", "Shan ", "Lin ", "Zun ", "Huo ", "Gan ", "Li ", "Zhan ", "Guan ", "Niao ", "Yi ", "Fu ", "Li ", "Jiu ", "Bu ", "Yan ", "Fu ", "Diao ", "Ji ", "Feng ", "Nio ", "Gan ", "Shi ", "Feng ", "Ming ", "Bao ", "Yuan ", "Zhi ", "Hu ", "Qin ", "Fu ", "Fen ", "Wen ", "Jian ", "Shi ", "Yu "];
  }
});

// node_modules/unidecode/data/x9d.js
var require_x9d = __commonJS({
  "node_modules/unidecode/data/x9d.js"(exports, module2) {
    module2.exports = ["Fou ", "Yiao ", "Jue ", "Jue ", "Pi ", "Huan ", "Zhen ", "Bao ", "Yan ", "Ya ", "Zheng ", "Fang ", "Feng ", "Wen ", "Ou ", "Te ", "Jia ", "Nu ", "Ling ", "Mie ", "Fu ", "Tuo ", "Wen ", "Li ", "Bian ", "Zhi ", "Ge ", "Yuan ", "Zi ", "Qu ", "Xiao ", "Zhi ", "Dan ", "Ju ", "You ", "Gu ", "Zhong ", "Yu ", "Yang ", "Rong ", "Ya ", "Tie ", "Yu ", "Shigi ", "Ying ", "Zhui ", "Wu ", "Er ", "Gua ", "Ai ", "Zhi ", "Yan ", "Heng ", "Jiao ", "Ji ", "Lie ", "Zhu ", "Ren ", "Yi ", "Hong ", "Luo ", "Ru ", "Mou ", "Ge ", "Ren ", "Jiao ", "Xiu ", "Zhou ", "Zhi ", "Luo ", "Chidori ", "Toki ", "Ten ", "Luan ", "Jia ", "Ji ", "Yu ", "Huan ", "Tuo ", "Bu ", "Wu ", "Juan ", "Yu ", "Bo ", "Xun ", "Xun ", "Bi ", "Xi ", "Jun ", "Ju ", "Tu ", "Jing ", "Ti ", "E ", "E ", "Kuang ", "Hu ", "Wu ", "Shen ", "Lai ", "Ikaruga ", "Kakesu ", "Lu ", "Ping ", "Shu ", "Fu ", "An ", "Zhao ", "Peng ", "Qin ", "Qian ", "Bei ", "Diao ", "Lu ", "Que ", "Jian ", "Ju ", "Tu ", "Ya ", "Yuan ", "Qi ", "Li ", "Ye ", "Zhui ", "Kong ", "Zhui ", "Kun ", "Sheng ", "Qi ", "Jing ", "Yi ", "Yi ", "Jing ", "Zi ", "Lai ", "Dong ", "Qi ", "Chun ", "Geng ", "Ju ", "Qu ", "Isuka ", "Kikuitadaki ", "Ji ", "Shu ", "[?] ", "Chi ", "Miao ", "Rou ", "An ", "Qiu ", "Ti ", "Hu ", "Ti ", "E ", "Jie ", "Mao ", "Fu ", "Chun ", "Tu ", "Yan ", "He ", "Yuan ", "Pian ", "Yun ", "Mei ", "Hu ", "Ying ", "Dun ", "Mu ", "Ju ", "Tsugumi ", "Cang ", "Fang ", "Gu ", "Ying ", "Yuan ", "Xuan ", "Weng ", "Shi ", "He ", "Chu ", "Tang ", "Xia ", "Ruo ", "Liu ", "Ji ", "Gu ", "Jian ", "Zhun ", "Han ", "Zi ", "Zi ", "Ni ", "Yao ", "Yan ", "Ji ", "Li ", "Tian ", "Kou ", "Ti ", "Ti ", "Ni ", "Tu ", "Ma ", "Jiao ", "Gao ", "Tian ", "Chen ", "Li ", "Zhuan ", "Zhe ", "Ao ", "Yao ", "Yi ", "Ou ", "Chi ", "Zhi ", "Liao ", "Rong ", "Lou ", "Bi ", "Shuang ", "Zhuo ", "Yu ", "Wu ", "Jue ", "Yin ", "Quan ", "Si ", "Jiao ", "Yi ", "Hua ", "Bi ", "Ying ", "Su ", "Huang ", "Fan ", "Jiao ", "Liao ", "Yan ", "Kao ", "Jiu ", "Xian ", "Xian ", "Tu ", "Mai ", "Zun ", "Yu ", "Ying ", "Lu ", "Tuan ", "Xian ", "Xue ", "Yi ", "Pi "];
  }
});

// node_modules/unidecode/data/x9e.js
var require_x9e = __commonJS({
  "node_modules/unidecode/data/x9e.js"(exports, module2) {
    module2.exports = ["Shu ", "Luo ", "Qi ", "Yi ", "Ji ", "Zhe ", "Yu ", "Zhan ", "Ye ", "Yang ", "Pi ", "Ning ", "Huo ", "Mi ", "Ying ", "Meng ", "Di ", "Yue ", "Yu ", "Lei ", "Bao ", "Lu ", "He ", "Long ", "Shuang ", "Yue ", "Ying ", "Guan ", "Qu ", "Li ", "Luan ", "Niao ", "Jiu ", "Ji ", "Yuan ", "Ming ", "Shi ", "Ou ", "Ya ", "Cang ", "Bao ", "Zhen ", "Gu ", "Dong ", "Lu ", "Ya ", "Xiao ", "Yang ", "Ling ", "Zhi ", "Qu ", "Yuan ", "Xue ", "Tuo ", "Si ", "Zhi ", "Er ", "Gua ", "Xiu ", "Heng ", "Zhou ", "Ge ", "Luan ", "Hong ", "Wu ", "Bo ", "Li ", "Juan ", "Hu ", "E ", "Yu ", "Xian ", "Ti ", "Wu ", "Que ", "Miao ", "An ", "Kun ", "Bei ", "Peng ", "Qian ", "Chun ", "Geng ", "Yuan ", "Su ", "Hu ", "He ", "E ", "Gu ", "Qiu ", "Zi ", "Mei ", "Mu ", "Ni ", "Yao ", "Weng ", "Liu ", "Ji ", "Ni ", "Jian ", "He ", "Yi ", "Ying ", "Zhe ", "Liao ", "Liao ", "Jiao ", "Jiu ", "Yu ", "Lu ", "Xuan ", "Zhan ", "Ying ", "Huo ", "Meng ", "Guan ", "Shuang ", "Lu ", "Jin ", "Ling ", "Jian ", "Xian ", "Cuo ", "Jian ", "Jian ", "Yan ", "Cuo ", "Lu ", "You ", "Cu ", "Ji ", "Biao ", "Cu ", "Biao ", "Zhu ", "Jun ", "Zhu ", "Jian ", "Mi ", "Mi ", "Wu ", "Liu ", "Chen ", "Jun ", "Lin ", "Ni ", "Qi ", "Lu ", "Jiu ", "Jun ", "Jing ", "Li ", "Xiang ", "Yan ", "Jia ", "Mi ", "Li ", "She ", "Zhang ", "Lin ", "Jing ", "Ji ", "Ling ", "Yan ", "Cu ", "Mai ", "Mai ", "Ge ", "Chao ", "Fu ", "Mian ", "Mian ", "Fu ", "Pao ", "Qu ", "Qu ", "Mou ", "Fu ", "Xian ", "Lai ", "Qu ", "Mian ", "[?] ", "Feng ", "Fu ", "Qu ", "Mian ", "Ma ", "Mo ", "Mo ", "Hui ", "Ma ", "Zou ", "Nen ", "Fen ", "Huang ", "Huang ", "Jin ", "Guang ", "Tian ", "Tou ", "Heng ", "Xi ", "Kuang ", "Heng ", "Shu ", "Li ", "Nian ", "Chi ", "Hei ", "Hei ", "Yi ", "Qian ", "Dan ", "Xi ", "Tuan ", "Mo ", "Mo ", "Qian ", "Dai ", "Chu ", "You ", "Dian ", "Yi ", "Xia ", "Yan ", "Qu ", "Mei ", "Yan ", "Jing ", "Yu ", "Li ", "Dang ", "Du ", "Can ", "Yin ", "An ", "Yan ", "Tan ", "An ", "Zhen ", "Dai ", "Can ", "Yi ", "Mei ", "Dan ", "Yan ", "Du ", "Lu ", "Zhi ", "Fen ", "Fu ", "Fu ", "Min ", "Min ", "Yuan "];
  }
});

// node_modules/unidecode/data/x9f.js
var require_x9f = __commonJS({
  "node_modules/unidecode/data/x9f.js"(exports, module2) {
    module2.exports = ["Cu ", "Qu ", "Chao ", "Wa ", "Zhu ", "Zhi ", "Mang ", "Ao ", "Bie ", "Tuo ", "Bi ", "Yuan ", "Chao ", "Tuo ", "Ding ", "Mi ", "Nai ", "Ding ", "Zi ", "Gu ", "Gu ", "Dong ", "Fen ", "Tao ", "Yuan ", "Pi ", "Chang ", "Gao ", "Qi ", "Yuan ", "Tang ", "Teng ", "Shu ", "Shu ", "Fen ", "Fei ", "Wen ", "Ba ", "Diao ", "Tuo ", "Tong ", "Qu ", "Sheng ", "Shi ", "You ", "Shi ", "Ting ", "Wu ", "Nian ", "Jing ", "Hun ", "Ju ", "Yan ", "Tu ", "Ti ", "Xi ", "Xian ", "Yan ", "Lei ", "Bi ", "Yao ", "Qiu ", "Han ", "Wu ", "Wu ", "Hou ", "Xi ", "Ge ", "Zha ", "Xiu ", "Weng ", "Zha ", "Nong ", "Nang ", "Qi ", "Zhai ", "Ji ", "Zi ", "Ji ", "Ji ", "Qi ", "Ji ", "Chi ", "Chen ", "Chen ", "He ", "Ya ", "Ken ", "Xie ", "Pao ", "Cuo ", "Shi ", "Zi ", "Chi ", "Nian ", "Ju ", "Tiao ", "Ling ", "Ling ", "Chu ", "Quan ", "Xie ", "Ken ", "Nie ", "Jiu ", "Yao ", "Chuo ", "Kun ", "Yu ", "Chu ", "Yi ", "Ni ", "Cuo ", "Zou ", "Qu ", "Nen ", "Xian ", "Ou ", "E ", "Wo ", "Yi ", "Chuo ", "Zou ", "Dian ", "Chu ", "Jin ", "Ya ", "Chi ", "Chen ", "He ", "Ken ", "Ju ", "Ling ", "Pao ", "Tiao ", "Zi ", "Ken ", "Yu ", "Chuo ", "Qu ", "Wo ", "Long ", "Pang ", "Gong ", "Pang ", "Yan ", "Long ", "Long ", "Gong ", "Kan ", "Ta ", "Ling ", "Ta ", "Long ", "Gong ", "Kan ", "Gui ", "Qiu ", "Bie ", "Gui ", "Yue ", "Chui ", "He ", "Jue ", "Xie ", "Yu ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/xa0.js
var require_xa0 = __commonJS({
  "node_modules/unidecode/data/xa0.js"(exports, module2) {
    module2.exports = ["it", "ix", "i", "ip", "iet", "iex", "ie", "iep", "at", "ax", "a", "ap", "uox", "uo", "uop", "ot", "ox", "o", "op", "ex", "e", "wu", "bit", "bix", "bi", "bip", "biet", "biex", "bie", "biep", "bat", "bax", "ba", "bap", "buox", "buo", "buop", "bot", "box", "bo", "bop", "bex", "be", "bep", "but", "bux", "bu", "bup", "burx", "bur", "byt", "byx", "by", "byp", "byrx", "byr", "pit", "pix", "pi", "pip", "piex", "pie", "piep", "pat", "pax", "pa", "pap", "puox", "puo", "puop", "pot", "pox", "po", "pop", "put", "pux", "pu", "pup", "purx", "pur", "pyt", "pyx", "py", "pyp", "pyrx", "pyr", "bbit", "bbix", "bbi", "bbip", "bbiet", "bbiex", "bbie", "bbiep", "bbat", "bbax", "bba", "bbap", "bbuox", "bbuo", "bbuop", "bbot", "bbox", "bbo", "bbop", "bbex", "bbe", "bbep", "bbut", "bbux", "bbu", "bbup", "bburx", "bbur", "bbyt", "bbyx", "bby", "bbyp", "nbit", "nbix", "nbi", "nbip", "nbiex", "nbie", "nbiep", "nbat", "nbax", "nba", "nbap", "nbot", "nbox", "nbo", "nbop", "nbut", "nbux", "nbu", "nbup", "nburx", "nbur", "nbyt", "nbyx", "nby", "nbyp", "nbyrx", "nbyr", "hmit", "hmix", "hmi", "hmip", "hmiex", "hmie", "hmiep", "hmat", "hmax", "hma", "hmap", "hmuox", "hmuo", "hmuop", "hmot", "hmox", "hmo", "hmop", "hmut", "hmux", "hmu", "hmup", "hmurx", "hmur", "hmyx", "hmy", "hmyp", "hmyrx", "hmyr", "mit", "mix", "mi", "mip", "miex", "mie", "miep", "mat", "max", "ma", "map", "muot", "muox", "muo", "muop", "mot", "mox", "mo", "mop", "mex", "me", "mut", "mux", "mu", "mup", "murx", "mur", "myt", "myx", "my", "myp", "fit", "fix", "fi", "fip", "fat", "fax", "fa", "fap", "fox", "fo", "fop", "fut", "fux", "fu", "fup", "furx", "fur", "fyt", "fyx", "fy", "fyp", "vit", "vix", "vi", "vip", "viet", "viex", "vie", "viep", "vat", "vax", "va", "vap", "vot", "vox", "vo", "vop", "vex", "vep", "vut", "vux", "vu", "vup", "vurx", "vur", "vyt", "vyx", "vy", "vyp", "vyrx", "vyr"];
  }
});

// node_modules/unidecode/data/xa1.js
var require_xa1 = __commonJS({
  "node_modules/unidecode/data/xa1.js"(exports, module2) {
    module2.exports = ["dit", "dix", "di", "dip", "diex", "die", "diep", "dat", "dax", "da", "dap", "duox", "duo", "dot", "dox", "do", "dop", "dex", "de", "dep", "dut", "dux", "du", "dup", "durx", "dur", "tit", "tix", "ti", "tip", "tiex", "tie", "tiep", "tat", "tax", "ta", "tap", "tuot", "tuox", "tuo", "tuop", "tot", "tox", "to", "top", "tex", "te", "tep", "tut", "tux", "tu", "tup", "turx", "tur", "ddit", "ddix", "ddi", "ddip", "ddiex", "ddie", "ddiep", "ddat", "ddax", "dda", "ddap", "dduox", "dduo", "dduop", "ddot", "ddox", "ddo", "ddop", "ddex", "dde", "ddep", "ddut", "ddux", "ddu", "ddup", "ddurx", "ddur", "ndit", "ndix", "ndi", "ndip", "ndiex", "ndie", "ndat", "ndax", "nda", "ndap", "ndot", "ndox", "ndo", "ndop", "ndex", "nde", "ndep", "ndut", "ndux", "ndu", "ndup", "ndurx", "ndur", "hnit", "hnix", "hni", "hnip", "hniet", "hniex", "hnie", "hniep", "hnat", "hnax", "hna", "hnap", "hnuox", "hnuo", "hnot", "hnox", "hnop", "hnex", "hne", "hnep", "hnut", "nit", "nix", "ni", "nip", "niex", "nie", "niep", "nax", "na", "nap", "nuox", "nuo", "nuop", "not", "nox", "no", "nop", "nex", "ne", "nep", "nut", "nux", "nu", "nup", "nurx", "nur", "hlit", "hlix", "hli", "hlip", "hliex", "hlie", "hliep", "hlat", "hlax", "hla", "hlap", "hluox", "hluo", "hluop", "hlox", "hlo", "hlop", "hlex", "hle", "hlep", "hlut", "hlux", "hlu", "hlup", "hlurx", "hlur", "hlyt", "hlyx", "hly", "hlyp", "hlyrx", "hlyr", "lit", "lix", "li", "lip", "liet", "liex", "lie", "liep", "lat", "lax", "la", "lap", "luot", "luox", "luo", "luop", "lot", "lox", "lo", "lop", "lex", "le", "lep", "lut", "lux", "lu", "lup", "lurx", "lur", "lyt", "lyx", "ly", "lyp", "lyrx", "lyr", "git", "gix", "gi", "gip", "giet", "giex", "gie", "giep", "gat", "gax", "ga", "gap", "guot", "guox", "guo", "guop", "got", "gox", "go", "gop", "get", "gex", "ge", "gep", "gut", "gux", "gu", "gup", "gurx", "gur", "kit", "kix", "ki", "kip", "kiex", "kie", "kiep", "kat"];
  }
});

// node_modules/unidecode/data/xa2.js
var require_xa2 = __commonJS({
  "node_modules/unidecode/data/xa2.js"(exports, module2) {
    module2.exports = ["kax", "ka", "kap", "kuox", "kuo", "kuop", "kot", "kox", "ko", "kop", "ket", "kex", "ke", "kep", "kut", "kux", "ku", "kup", "kurx", "kur", "ggit", "ggix", "ggi", "ggiex", "ggie", "ggiep", "ggat", "ggax", "gga", "ggap", "gguot", "gguox", "gguo", "gguop", "ggot", "ggox", "ggo", "ggop", "gget", "ggex", "gge", "ggep", "ggut", "ggux", "ggu", "ggup", "ggurx", "ggur", "mgiex", "mgie", "mgat", "mgax", "mga", "mgap", "mguox", "mguo", "mguop", "mgot", "mgox", "mgo", "mgop", "mgex", "mge", "mgep", "mgut", "mgux", "mgu", "mgup", "mgurx", "mgur", "hxit", "hxix", "hxi", "hxip", "hxiet", "hxiex", "hxie", "hxiep", "hxat", "hxax", "hxa", "hxap", "hxuot", "hxuox", "hxuo", "hxuop", "hxot", "hxox", "hxo", "hxop", "hxex", "hxe", "hxep", "ngiex", "ngie", "ngiep", "ngat", "ngax", "nga", "ngap", "nguot", "nguox", "nguo", "ngot", "ngox", "ngo", "ngop", "ngex", "nge", "ngep", "hit", "hiex", "hie", "hat", "hax", "ha", "hap", "huot", "huox", "huo", "huop", "hot", "hox", "ho", "hop", "hex", "he", "hep", "wat", "wax", "wa", "wap", "wuox", "wuo", "wuop", "wox", "wo", "wop", "wex", "we", "wep", "zit", "zix", "zi", "zip", "ziex", "zie", "ziep", "zat", "zax", "za", "zap", "zuox", "zuo", "zuop", "zot", "zox", "zo", "zop", "zex", "ze", "zep", "zut", "zux", "zu", "zup", "zurx", "zur", "zyt", "zyx", "zy", "zyp", "zyrx", "zyr", "cit", "cix", "ci", "cip", "ciet", "ciex", "cie", "ciep", "cat", "cax", "ca", "cap", "cuox", "cuo", "cuop", "cot", "cox", "co", "cop", "cex", "ce", "cep", "cut", "cux", "cu", "cup", "curx", "cur", "cyt", "cyx", "cy", "cyp", "cyrx", "cyr", "zzit", "zzix", "zzi", "zzip", "zziet", "zziex", "zzie", "zziep", "zzat", "zzax", "zza", "zzap", "zzox", "zzo", "zzop", "zzex", "zze", "zzep", "zzux", "zzu", "zzup", "zzurx", "zzur", "zzyt", "zzyx", "zzy", "zzyp", "zzyrx", "zzyr", "nzit", "nzix", "nzi", "nzip", "nziex", "nzie", "nziep", "nzat", "nzax", "nza", "nzap", "nzuox", "nzuo", "nzox", "nzop", "nzex", "nze", "nzux", "nzu"];
  }
});

// node_modules/unidecode/data/xa3.js
var require_xa3 = __commonJS({
  "node_modules/unidecode/data/xa3.js"(exports, module2) {
    module2.exports = ["nzup", "nzurx", "nzur", "nzyt", "nzyx", "nzy", "nzyp", "nzyrx", "nzyr", "sit", "six", "si", "sip", "siex", "sie", "siep", "sat", "sax", "sa", "sap", "suox", "suo", "suop", "sot", "sox", "so", "sop", "sex", "se", "sep", "sut", "sux", "su", "sup", "surx", "sur", "syt", "syx", "sy", "syp", "syrx", "syr", "ssit", "ssix", "ssi", "ssip", "ssiex", "ssie", "ssiep", "ssat", "ssax", "ssa", "ssap", "ssot", "ssox", "sso", "ssop", "ssex", "sse", "ssep", "ssut", "ssux", "ssu", "ssup", "ssyt", "ssyx", "ssy", "ssyp", "ssyrx", "ssyr", "zhat", "zhax", "zha", "zhap", "zhuox", "zhuo", "zhuop", "zhot", "zhox", "zho", "zhop", "zhet", "zhex", "zhe", "zhep", "zhut", "zhux", "zhu", "zhup", "zhurx", "zhur", "zhyt", "zhyx", "zhy", "zhyp", "zhyrx", "zhyr", "chat", "chax", "cha", "chap", "chuot", "chuox", "chuo", "chuop", "chot", "chox", "cho", "chop", "chet", "chex", "che", "chep", "chux", "chu", "chup", "churx", "chur", "chyt", "chyx", "chy", "chyp", "chyrx", "chyr", "rrax", "rra", "rruox", "rruo", "rrot", "rrox", "rro", "rrop", "rret", "rrex", "rre", "rrep", "rrut", "rrux", "rru", "rrup", "rrurx", "rrur", "rryt", "rryx", "rry", "rryp", "rryrx", "rryr", "nrat", "nrax", "nra", "nrap", "nrox", "nro", "nrop", "nret", "nrex", "nre", "nrep", "nrut", "nrux", "nru", "nrup", "nrurx", "nrur", "nryt", "nryx", "nry", "nryp", "nryrx", "nryr", "shat", "shax", "sha", "shap", "shuox", "shuo", "shuop", "shot", "shox", "sho", "shop", "shet", "shex", "she", "shep", "shut", "shux", "shu", "shup", "shurx", "shur", "shyt", "shyx", "shy", "shyp", "shyrx", "shyr", "rat", "rax", "ra", "rap", "ruox", "ruo", "ruop", "rot", "rox", "ro", "rop", "rex", "re", "rep", "rut", "rux", "ru", "rup", "rurx", "rur", "ryt", "ryx", "ry", "ryp", "ryrx", "ryr", "jit", "jix", "ji", "jip", "jiet", "jiex", "jie", "jiep", "juot", "juox", "juo", "juop", "jot", "jox", "jo", "jop", "jut", "jux", "ju", "jup", "jurx", "jur", "jyt", "jyx", "jy", "jyp", "jyrx", "jyr", "qit", "qix", "qi", "qip"];
  }
});

// node_modules/unidecode/data/xa4.js
var require_xa4 = __commonJS({
  "node_modules/unidecode/data/xa4.js"(exports, module2) {
    module2.exports = ["qiet", "qiex", "qie", "qiep", "quot", "quox", "quo", "quop", "qot", "qox", "qo", "qop", "qut", "qux", "qu", "qup", "qurx", "qur", "qyt", "qyx", "qy", "qyp", "qyrx", "qyr", "jjit", "jjix", "jji", "jjip", "jjiet", "jjiex", "jjie", "jjiep", "jjuox", "jjuo", "jjuop", "jjot", "jjox", "jjo", "jjop", "jjut", "jjux", "jju", "jjup", "jjurx", "jjur", "jjyt", "jjyx", "jjy", "jjyp", "njit", "njix", "nji", "njip", "njiet", "njiex", "njie", "njiep", "njuox", "njuo", "njot", "njox", "njo", "njop", "njux", "nju", "njup", "njurx", "njur", "njyt", "njyx", "njy", "njyp", "njyrx", "njyr", "nyit", "nyix", "nyi", "nyip", "nyiet", "nyiex", "nyie", "nyiep", "nyuox", "nyuo", "nyuop", "nyot", "nyox", "nyo", "nyop", "nyut", "nyux", "nyu", "nyup", "xit", "xix", "xi", "xip", "xiet", "xiex", "xie", "xiep", "xuox", "xuo", "xot", "xox", "xo", "xop", "xyt", "xyx", "xy", "xyp", "xyrx", "xyr", "yit", "yix", "yi", "yip", "yiet", "yiex", "yie", "yiep", "yuot", "yuox", "yuo", "yuop", "yot", "yox", "yo", "yop", "yut", "yux", "yu", "yup", "yurx", "yur", "yyt", "yyx", "yy", "yyp", "yyrx", "yyr", "[?]", "[?]", "[?]", "Qot", "Li", "Kit", "Nyip", "Cyp", "Ssi", "Ggop", "Gep", "Mi", "Hxit", "Lyr", "Bbut", "Mop", "Yo", "Put", "Hxuo", "Tat", "Ga", "[?]", "[?]", "Ddur", "Bur", "Gguo", "Nyop", "Tu", "Op", "Jjut", "Zot", "Pyt", "Hmo", "Yit", "Vur", "Shy", "Vep", "Za", "Jo", "[?]", "Jjy", "Got", "Jjie", "Wo", "Du", "Shur", "Lie", "Cy", "Cuop", "Cip", "Hxop", "Shat", "[?]", "Shop", "Che", "Zziet", "[?]", "Ke", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/xac.js
var require_xac = __commonJS({
  "node_modules/unidecode/data/xac.js"(exports, module2) {
    module2.exports = ["ga", "gag", "gagg", "gags", "gan", "ganj", "ganh", "gad", "gal", "galg", "galm", "galb", "gals", "galt", "galp", "galh", "gam", "gab", "gabs", "gas", "gass", "gang", "gaj", "gac", "gak", "gat", "gap", "gah", "gae", "gaeg", "gaegg", "gaegs", "gaen", "gaenj", "gaenh", "gaed", "gael", "gaelg", "gaelm", "gaelb", "gaels", "gaelt", "gaelp", "gaelh", "gaem", "gaeb", "gaebs", "gaes", "gaess", "gaeng", "gaej", "gaec", "gaek", "gaet", "gaep", "gaeh", "gya", "gyag", "gyagg", "gyags", "gyan", "gyanj", "gyanh", "gyad", "gyal", "gyalg", "gyalm", "gyalb", "gyals", "gyalt", "gyalp", "gyalh", "gyam", "gyab", "gyabs", "gyas", "gyass", "gyang", "gyaj", "gyac", "gyak", "gyat", "gyap", "gyah", "gyae", "gyaeg", "gyaegg", "gyaegs", "gyaen", "gyaenj", "gyaenh", "gyaed", "gyael", "gyaelg", "gyaelm", "gyaelb", "gyaels", "gyaelt", "gyaelp", "gyaelh", "gyaem", "gyaeb", "gyaebs", "gyaes", "gyaess", "gyaeng", "gyaej", "gyaec", "gyaek", "gyaet", "gyaep", "gyaeh", "geo", "geog", "geogg", "geogs", "geon", "geonj", "geonh", "geod", "geol", "geolg", "geolm", "geolb", "geols", "geolt", "geolp", "geolh", "geom", "geob", "geobs", "geos", "geoss", "geong", "geoj", "geoc", "geok", "geot", "geop", "geoh", "ge", "geg", "gegg", "gegs", "gen", "genj", "genh", "ged", "gel", "gelg", "gelm", "gelb", "gels", "gelt", "gelp", "gelh", "gem", "geb", "gebs", "ges", "gess", "geng", "gej", "gec", "gek", "get", "gep", "geh", "gyeo", "gyeog", "gyeogg", "gyeogs", "gyeon", "gyeonj", "gyeonh", "gyeod", "gyeol", "gyeolg", "gyeolm", "gyeolb", "gyeols", "gyeolt", "gyeolp", "gyeolh", "gyeom", "gyeob", "gyeobs", "gyeos", "gyeoss", "gyeong", "gyeoj", "gyeoc", "gyeok", "gyeot", "gyeop", "gyeoh", "gye", "gyeg", "gyegg", "gyegs", "gyen", "gyenj", "gyenh", "gyed", "gyel", "gyelg", "gyelm", "gyelb", "gyels", "gyelt", "gyelp", "gyelh", "gyem", "gyeb", "gyebs", "gyes", "gyess", "gyeng", "gyej", "gyec", "gyek", "gyet", "gyep", "gyeh", "go", "gog", "gogg", "gogs", "gon", "gonj", "gonh", "god", "gol", "golg", "golm", "golb", "gols", "golt", "golp", "golh", "gom", "gob", "gobs", "gos", "goss", "gong", "goj", "goc", "gok", "got", "gop", "goh", "gwa", "gwag", "gwagg", "gwags"];
  }
});

// node_modules/unidecode/data/xad.js
var require_xad = __commonJS({
  "node_modules/unidecode/data/xad.js"(exports, module2) {
    module2.exports = ["gwan", "gwanj", "gwanh", "gwad", "gwal", "gwalg", "gwalm", "gwalb", "gwals", "gwalt", "gwalp", "gwalh", "gwam", "gwab", "gwabs", "gwas", "gwass", "gwang", "gwaj", "gwac", "gwak", "gwat", "gwap", "gwah", "gwae", "gwaeg", "gwaegg", "gwaegs", "gwaen", "gwaenj", "gwaenh", "gwaed", "gwael", "gwaelg", "gwaelm", "gwaelb", "gwaels", "gwaelt", "gwaelp", "gwaelh", "gwaem", "gwaeb", "gwaebs", "gwaes", "gwaess", "gwaeng", "gwaej", "gwaec", "gwaek", "gwaet", "gwaep", "gwaeh", "goe", "goeg", "goegg", "goegs", "goen", "goenj", "goenh", "goed", "goel", "goelg", "goelm", "goelb", "goels", "goelt", "goelp", "goelh", "goem", "goeb", "goebs", "goes", "goess", "goeng", "goej", "goec", "goek", "goet", "goep", "goeh", "gyo", "gyog", "gyogg", "gyogs", "gyon", "gyonj", "gyonh", "gyod", "gyol", "gyolg", "gyolm", "gyolb", "gyols", "gyolt", "gyolp", "gyolh", "gyom", "gyob", "gyobs", "gyos", "gyoss", "gyong", "gyoj", "gyoc", "gyok", "gyot", "gyop", "gyoh", "gu", "gug", "gugg", "gugs", "gun", "gunj", "gunh", "gud", "gul", "gulg", "gulm", "gulb", "guls", "gult", "gulp", "gulh", "gum", "gub", "gubs", "gus", "guss", "gung", "guj", "guc", "guk", "gut", "gup", "guh", "gweo", "gweog", "gweogg", "gweogs", "gweon", "gweonj", "gweonh", "gweod", "gweol", "gweolg", "gweolm", "gweolb", "gweols", "gweolt", "gweolp", "gweolh", "gweom", "gweob", "gweobs", "gweos", "gweoss", "gweong", "gweoj", "gweoc", "gweok", "gweot", "gweop", "gweoh", "gwe", "gweg", "gwegg", "gwegs", "gwen", "gwenj", "gwenh", "gwed", "gwel", "gwelg", "gwelm", "gwelb", "gwels", "gwelt", "gwelp", "gwelh", "gwem", "gweb", "gwebs", "gwes", "gwess", "gweng", "gwej", "gwec", "gwek", "gwet", "gwep", "gweh", "gwi", "gwig", "gwigg", "gwigs", "gwin", "gwinj", "gwinh", "gwid", "gwil", "gwilg", "gwilm", "gwilb", "gwils", "gwilt", "gwilp", "gwilh", "gwim", "gwib", "gwibs", "gwis", "gwiss", "gwing", "gwij", "gwic", "gwik", "gwit", "gwip", "gwih", "gyu", "gyug", "gyugg", "gyugs", "gyun", "gyunj", "gyunh", "gyud", "gyul", "gyulg", "gyulm", "gyulb", "gyuls", "gyult", "gyulp", "gyulh", "gyum", "gyub", "gyubs", "gyus", "gyuss", "gyung", "gyuj", "gyuc", "gyuk", "gyut", "gyup", "gyuh", "geu", "geug", "geugg", "geugs", "geun", "geunj", "geunh", "geud"];
  }
});

// node_modules/unidecode/data/xae.js
var require_xae = __commonJS({
  "node_modules/unidecode/data/xae.js"(exports, module2) {
    module2.exports = ["geul", "geulg", "geulm", "geulb", "geuls", "geult", "geulp", "geulh", "geum", "geub", "geubs", "geus", "geuss", "geung", "geuj", "geuc", "geuk", "geut", "geup", "geuh", "gyi", "gyig", "gyigg", "gyigs", "gyin", "gyinj", "gyinh", "gyid", "gyil", "gyilg", "gyilm", "gyilb", "gyils", "gyilt", "gyilp", "gyilh", "gyim", "gyib", "gyibs", "gyis", "gyiss", "gying", "gyij", "gyic", "gyik", "gyit", "gyip", "gyih", "gi", "gig", "gigg", "gigs", "gin", "ginj", "ginh", "gid", "gil", "gilg", "gilm", "gilb", "gils", "gilt", "gilp", "gilh", "gim", "gib", "gibs", "gis", "giss", "ging", "gij", "gic", "gik", "git", "gip", "gih", "gga", "ggag", "ggagg", "ggags", "ggan", "gganj", "gganh", "ggad", "ggal", "ggalg", "ggalm", "ggalb", "ggals", "ggalt", "ggalp", "ggalh", "ggam", "ggab", "ggabs", "ggas", "ggass", "ggang", "ggaj", "ggac", "ggak", "ggat", "ggap", "ggah", "ggae", "ggaeg", "ggaegg", "ggaegs", "ggaen", "ggaenj", "ggaenh", "ggaed", "ggael", "ggaelg", "ggaelm", "ggaelb", "ggaels", "ggaelt", "ggaelp", "ggaelh", "ggaem", "ggaeb", "ggaebs", "ggaes", "ggaess", "ggaeng", "ggaej", "ggaec", "ggaek", "ggaet", "ggaep", "ggaeh", "ggya", "ggyag", "ggyagg", "ggyags", "ggyan", "ggyanj", "ggyanh", "ggyad", "ggyal", "ggyalg", "ggyalm", "ggyalb", "ggyals", "ggyalt", "ggyalp", "ggyalh", "ggyam", "ggyab", "ggyabs", "ggyas", "ggyass", "ggyang", "ggyaj", "ggyac", "ggyak", "ggyat", "ggyap", "ggyah", "ggyae", "ggyaeg", "ggyaegg", "ggyaegs", "ggyaen", "ggyaenj", "ggyaenh", "ggyaed", "ggyael", "ggyaelg", "ggyaelm", "ggyaelb", "ggyaels", "ggyaelt", "ggyaelp", "ggyaelh", "ggyaem", "ggyaeb", "ggyaebs", "ggyaes", "ggyaess", "ggyaeng", "ggyaej", "ggyaec", "ggyaek", "ggyaet", "ggyaep", "ggyaeh", "ggeo", "ggeog", "ggeogg", "ggeogs", "ggeon", "ggeonj", "ggeonh", "ggeod", "ggeol", "ggeolg", "ggeolm", "ggeolb", "ggeols", "ggeolt", "ggeolp", "ggeolh", "ggeom", "ggeob", "ggeobs", "ggeos", "ggeoss", "ggeong", "ggeoj", "ggeoc", "ggeok", "ggeot", "ggeop", "ggeoh", "gge", "ggeg", "ggegg", "ggegs", "ggen", "ggenj", "ggenh", "gged", "ggel", "ggelg", "ggelm", "ggelb", "ggels", "ggelt", "ggelp", "ggelh", "ggem", "ggeb", "ggebs", "gges", "ggess", "ggeng", "ggej", "ggec", "ggek", "gget", "ggep", "ggeh", "ggyeo", "ggyeog", "ggyeogg", "ggyeogs", "ggyeon", "ggyeonj", "ggyeonh", "ggyeod", "ggyeol", "ggyeolg", "ggyeolm", "ggyeolb"];
  }
});

// node_modules/unidecode/data/xaf.js
var require_xaf = __commonJS({
  "node_modules/unidecode/data/xaf.js"(exports, module2) {
    module2.exports = ["ggyeols", "ggyeolt", "ggyeolp", "ggyeolh", "ggyeom", "ggyeob", "ggyeobs", "ggyeos", "ggyeoss", "ggyeong", "ggyeoj", "ggyeoc", "ggyeok", "ggyeot", "ggyeop", "ggyeoh", "ggye", "ggyeg", "ggyegg", "ggyegs", "ggyen", "ggyenj", "ggyenh", "ggyed", "ggyel", "ggyelg", "ggyelm", "ggyelb", "ggyels", "ggyelt", "ggyelp", "ggyelh", "ggyem", "ggyeb", "ggyebs", "ggyes", "ggyess", "ggyeng", "ggyej", "ggyec", "ggyek", "ggyet", "ggyep", "ggyeh", "ggo", "ggog", "ggogg", "ggogs", "ggon", "ggonj", "ggonh", "ggod", "ggol", "ggolg", "ggolm", "ggolb", "ggols", "ggolt", "ggolp", "ggolh", "ggom", "ggob", "ggobs", "ggos", "ggoss", "ggong", "ggoj", "ggoc", "ggok", "ggot", "ggop", "ggoh", "ggwa", "ggwag", "ggwagg", "ggwags", "ggwan", "ggwanj", "ggwanh", "ggwad", "ggwal", "ggwalg", "ggwalm", "ggwalb", "ggwals", "ggwalt", "ggwalp", "ggwalh", "ggwam", "ggwab", "ggwabs", "ggwas", "ggwass", "ggwang", "ggwaj", "ggwac", "ggwak", "ggwat", "ggwap", "ggwah", "ggwae", "ggwaeg", "ggwaegg", "ggwaegs", "ggwaen", "ggwaenj", "ggwaenh", "ggwaed", "ggwael", "ggwaelg", "ggwaelm", "ggwaelb", "ggwaels", "ggwaelt", "ggwaelp", "ggwaelh", "ggwaem", "ggwaeb", "ggwaebs", "ggwaes", "ggwaess", "ggwaeng", "ggwaej", "ggwaec", "ggwaek", "ggwaet", "ggwaep", "ggwaeh", "ggoe", "ggoeg", "ggoegg", "ggoegs", "ggoen", "ggoenj", "ggoenh", "ggoed", "ggoel", "ggoelg", "ggoelm", "ggoelb", "ggoels", "ggoelt", "ggoelp", "ggoelh", "ggoem", "ggoeb", "ggoebs", "ggoes", "ggoess", "ggoeng", "ggoej", "ggoec", "ggoek", "ggoet", "ggoep", "ggoeh", "ggyo", "ggyog", "ggyogg", "ggyogs", "ggyon", "ggyonj", "ggyonh", "ggyod", "ggyol", "ggyolg", "ggyolm", "ggyolb", "ggyols", "ggyolt", "ggyolp", "ggyolh", "ggyom", "ggyob", "ggyobs", "ggyos", "ggyoss", "ggyong", "ggyoj", "ggyoc", "ggyok", "ggyot", "ggyop", "ggyoh", "ggu", "ggug", "ggugg", "ggugs", "ggun", "ggunj", "ggunh", "ggud", "ggul", "ggulg", "ggulm", "ggulb", "gguls", "ggult", "ggulp", "ggulh", "ggum", "ggub", "ggubs", "ggus", "gguss", "ggung", "gguj", "gguc", "gguk", "ggut", "ggup", "gguh", "ggweo", "ggweog", "ggweogg", "ggweogs", "ggweon", "ggweonj", "ggweonh", "ggweod", "ggweol", "ggweolg", "ggweolm", "ggweolb", "ggweols", "ggweolt", "ggweolp", "ggweolh", "ggweom", "ggweob", "ggweobs", "ggweos", "ggweoss", "ggweong", "ggweoj", "ggweoc", "ggweok", "ggweot", "ggweop", "ggweoh", "ggwe", "ggweg", "ggwegg", "ggwegs", "ggwen", "ggwenj", "ggwenh", "ggwed", "ggwel", "ggwelg", "ggwelm", "ggwelb", "ggwels", "ggwelt", "ggwelp", "ggwelh"];
  }
});

// node_modules/unidecode/data/xb0.js
var require_xb0 = __commonJS({
  "node_modules/unidecode/data/xb0.js"(exports, module2) {
    module2.exports = ["ggwem", "ggweb", "ggwebs", "ggwes", "ggwess", "ggweng", "ggwej", "ggwec", "ggwek", "ggwet", "ggwep", "ggweh", "ggwi", "ggwig", "ggwigg", "ggwigs", "ggwin", "ggwinj", "ggwinh", "ggwid", "ggwil", "ggwilg", "ggwilm", "ggwilb", "ggwils", "ggwilt", "ggwilp", "ggwilh", "ggwim", "ggwib", "ggwibs", "ggwis", "ggwiss", "ggwing", "ggwij", "ggwic", "ggwik", "ggwit", "ggwip", "ggwih", "ggyu", "ggyug", "ggyugg", "ggyugs", "ggyun", "ggyunj", "ggyunh", "ggyud", "ggyul", "ggyulg", "ggyulm", "ggyulb", "ggyuls", "ggyult", "ggyulp", "ggyulh", "ggyum", "ggyub", "ggyubs", "ggyus", "ggyuss", "ggyung", "ggyuj", "ggyuc", "ggyuk", "ggyut", "ggyup", "ggyuh", "ggeu", "ggeug", "ggeugg", "ggeugs", "ggeun", "ggeunj", "ggeunh", "ggeud", "ggeul", "ggeulg", "ggeulm", "ggeulb", "ggeuls", "ggeult", "ggeulp", "ggeulh", "ggeum", "ggeub", "ggeubs", "ggeus", "ggeuss", "ggeung", "ggeuj", "ggeuc", "ggeuk", "ggeut", "ggeup", "ggeuh", "ggyi", "ggyig", "ggyigg", "ggyigs", "ggyin", "ggyinj", "ggyinh", "ggyid", "ggyil", "ggyilg", "ggyilm", "ggyilb", "ggyils", "ggyilt", "ggyilp", "ggyilh", "ggyim", "ggyib", "ggyibs", "ggyis", "ggyiss", "ggying", "ggyij", "ggyic", "ggyik", "ggyit", "ggyip", "ggyih", "ggi", "ggig", "ggigg", "ggigs", "ggin", "gginj", "gginh", "ggid", "ggil", "ggilg", "ggilm", "ggilb", "ggils", "ggilt", "ggilp", "ggilh", "ggim", "ggib", "ggibs", "ggis", "ggiss", "gging", "ggij", "ggic", "ggik", "ggit", "ggip", "ggih", "na", "nag", "nagg", "nags", "nan", "nanj", "nanh", "nad", "nal", "nalg", "nalm", "nalb", "nals", "nalt", "nalp", "nalh", "nam", "nab", "nabs", "nas", "nass", "nang", "naj", "nac", "nak", "nat", "nap", "nah", "nae", "naeg", "naegg", "naegs", "naen", "naenj", "naenh", "naed", "nael", "naelg", "naelm", "naelb", "naels", "naelt", "naelp", "naelh", "naem", "naeb", "naebs", "naes", "naess", "naeng", "naej", "naec", "naek", "naet", "naep", "naeh", "nya", "nyag", "nyagg", "nyags", "nyan", "nyanj", "nyanh", "nyad", "nyal", "nyalg", "nyalm", "nyalb", "nyals", "nyalt", "nyalp", "nyalh", "nyam", "nyab", "nyabs", "nyas", "nyass", "nyang", "nyaj", "nyac", "nyak", "nyat", "nyap", "nyah", "nyae", "nyaeg", "nyaegg", "nyaegs", "nyaen", "nyaenj", "nyaenh", "nyaed", "nyael", "nyaelg", "nyaelm", "nyaelb", "nyaels", "nyaelt", "nyaelp", "nyaelh", "nyaem", "nyaeb", "nyaebs", "nyaes"];
  }
});

// node_modules/unidecode/data/xb1.js
var require_xb1 = __commonJS({
  "node_modules/unidecode/data/xb1.js"(exports, module2) {
    module2.exports = ["nyaess", "nyaeng", "nyaej", "nyaec", "nyaek", "nyaet", "nyaep", "nyaeh", "neo", "neog", "neogg", "neogs", "neon", "neonj", "neonh", "neod", "neol", "neolg", "neolm", "neolb", "neols", "neolt", "neolp", "neolh", "neom", "neob", "neobs", "neos", "neoss", "neong", "neoj", "neoc", "neok", "neot", "neop", "neoh", "ne", "neg", "negg", "negs", "nen", "nenj", "nenh", "ned", "nel", "nelg", "nelm", "nelb", "nels", "nelt", "nelp", "nelh", "nem", "neb", "nebs", "nes", "ness", "neng", "nej", "nec", "nek", "net", "nep", "neh", "nyeo", "nyeog", "nyeogg", "nyeogs", "nyeon", "nyeonj", "nyeonh", "nyeod", "nyeol", "nyeolg", "nyeolm", "nyeolb", "nyeols", "nyeolt", "nyeolp", "nyeolh", "nyeom", "nyeob", "nyeobs", "nyeos", "nyeoss", "nyeong", "nyeoj", "nyeoc", "nyeok", "nyeot", "nyeop", "nyeoh", "nye", "nyeg", "nyegg", "nyegs", "nyen", "nyenj", "nyenh", "nyed", "nyel", "nyelg", "nyelm", "nyelb", "nyels", "nyelt", "nyelp", "nyelh", "nyem", "nyeb", "nyebs", "nyes", "nyess", "nyeng", "nyej", "nyec", "nyek", "nyet", "nyep", "nyeh", "no", "nog", "nogg", "nogs", "non", "nonj", "nonh", "nod", "nol", "nolg", "nolm", "nolb", "nols", "nolt", "nolp", "nolh", "nom", "nob", "nobs", "nos", "noss", "nong", "noj", "noc", "nok", "not", "nop", "noh", "nwa", "nwag", "nwagg", "nwags", "nwan", "nwanj", "nwanh", "nwad", "nwal", "nwalg", "nwalm", "nwalb", "nwals", "nwalt", "nwalp", "nwalh", "nwam", "nwab", "nwabs", "nwas", "nwass", "nwang", "nwaj", "nwac", "nwak", "nwat", "nwap", "nwah", "nwae", "nwaeg", "nwaegg", "nwaegs", "nwaen", "nwaenj", "nwaenh", "nwaed", "nwael", "nwaelg", "nwaelm", "nwaelb", "nwaels", "nwaelt", "nwaelp", "nwaelh", "nwaem", "nwaeb", "nwaebs", "nwaes", "nwaess", "nwaeng", "nwaej", "nwaec", "nwaek", "nwaet", "nwaep", "nwaeh", "noe", "noeg", "noegg", "noegs", "noen", "noenj", "noenh", "noed", "noel", "noelg", "noelm", "noelb", "noels", "noelt", "noelp", "noelh", "noem", "noeb", "noebs", "noes", "noess", "noeng", "noej", "noec", "noek", "noet", "noep", "noeh", "nyo", "nyog", "nyogg", "nyogs", "nyon", "nyonj", "nyonh", "nyod", "nyol", "nyolg", "nyolm", "nyolb", "nyols", "nyolt", "nyolp", "nyolh", "nyom", "nyob", "nyobs", "nyos", "nyoss", "nyong", "nyoj", "nyoc"];
  }
});

// node_modules/unidecode/data/xb2.js
var require_xb2 = __commonJS({
  "node_modules/unidecode/data/xb2.js"(exports, module2) {
    module2.exports = ["nyok", "nyot", "nyop", "nyoh", "nu", "nug", "nugg", "nugs", "nun", "nunj", "nunh", "nud", "nul", "nulg", "nulm", "nulb", "nuls", "nult", "nulp", "nulh", "num", "nub", "nubs", "nus", "nuss", "nung", "nuj", "nuc", "nuk", "nut", "nup", "nuh", "nweo", "nweog", "nweogg", "nweogs", "nweon", "nweonj", "nweonh", "nweod", "nweol", "nweolg", "nweolm", "nweolb", "nweols", "nweolt", "nweolp", "nweolh", "nweom", "nweob", "nweobs", "nweos", "nweoss", "nweong", "nweoj", "nweoc", "nweok", "nweot", "nweop", "nweoh", "nwe", "nweg", "nwegg", "nwegs", "nwen", "nwenj", "nwenh", "nwed", "nwel", "nwelg", "nwelm", "nwelb", "nwels", "nwelt", "nwelp", "nwelh", "nwem", "nweb", "nwebs", "nwes", "nwess", "nweng", "nwej", "nwec", "nwek", "nwet", "nwep", "nweh", "nwi", "nwig", "nwigg", "nwigs", "nwin", "nwinj", "nwinh", "nwid", "nwil", "nwilg", "nwilm", "nwilb", "nwils", "nwilt", "nwilp", "nwilh", "nwim", "nwib", "nwibs", "nwis", "nwiss", "nwing", "nwij", "nwic", "nwik", "nwit", "nwip", "nwih", "nyu", "nyug", "nyugg", "nyugs", "nyun", "nyunj", "nyunh", "nyud", "nyul", "nyulg", "nyulm", "nyulb", "nyuls", "nyult", "nyulp", "nyulh", "nyum", "nyub", "nyubs", "nyus", "nyuss", "nyung", "nyuj", "nyuc", "nyuk", "nyut", "nyup", "nyuh", "neu", "neug", "neugg", "neugs", "neun", "neunj", "neunh", "neud", "neul", "neulg", "neulm", "neulb", "neuls", "neult", "neulp", "neulh", "neum", "neub", "neubs", "neus", "neuss", "neung", "neuj", "neuc", "neuk", "neut", "neup", "neuh", "nyi", "nyig", "nyigg", "nyigs", "nyin", "nyinj", "nyinh", "nyid", "nyil", "nyilg", "nyilm", "nyilb", "nyils", "nyilt", "nyilp", "nyilh", "nyim", "nyib", "nyibs", "nyis", "nyiss", "nying", "nyij", "nyic", "nyik", "nyit", "nyip", "nyih", "ni", "nig", "nigg", "nigs", "nin", "ninj", "ninh", "nid", "nil", "nilg", "nilm", "nilb", "nils", "nilt", "nilp", "nilh", "nim", "nib", "nibs", "nis", "niss", "ning", "nij", "nic", "nik", "nit", "nip", "nih", "da", "dag", "dagg", "dags", "dan", "danj", "danh", "dad", "dal", "dalg", "dalm", "dalb", "dals", "dalt", "dalp", "dalh", "dam", "dab", "dabs", "das", "dass", "dang", "daj", "dac", "dak", "dat", "dap", "dah"];
  }
});

// node_modules/unidecode/data/xb3.js
var require_xb3 = __commonJS({
  "node_modules/unidecode/data/xb3.js"(exports, module2) {
    module2.exports = ["dae", "daeg", "daegg", "daegs", "daen", "daenj", "daenh", "daed", "dael", "daelg", "daelm", "daelb", "daels", "daelt", "daelp", "daelh", "daem", "daeb", "daebs", "daes", "daess", "daeng", "daej", "daec", "daek", "daet", "daep", "daeh", "dya", "dyag", "dyagg", "dyags", "dyan", "dyanj", "dyanh", "dyad", "dyal", "dyalg", "dyalm", "dyalb", "dyals", "dyalt", "dyalp", "dyalh", "dyam", "dyab", "dyabs", "dyas", "dyass", "dyang", "dyaj", "dyac", "dyak", "dyat", "dyap", "dyah", "dyae", "dyaeg", "dyaegg", "dyaegs", "dyaen", "dyaenj", "dyaenh", "dyaed", "dyael", "dyaelg", "dyaelm", "dyaelb", "dyaels", "dyaelt", "dyaelp", "dyaelh", "dyaem", "dyaeb", "dyaebs", "dyaes", "dyaess", "dyaeng", "dyaej", "dyaec", "dyaek", "dyaet", "dyaep", "dyaeh", "deo", "deog", "deogg", "deogs", "deon", "deonj", "deonh", "deod", "deol", "deolg", "deolm", "deolb", "deols", "deolt", "deolp", "deolh", "deom", "deob", "deobs", "deos", "deoss", "deong", "deoj", "deoc", "deok", "deot", "deop", "deoh", "de", "deg", "degg", "degs", "den", "denj", "denh", "ded", "del", "delg", "delm", "delb", "dels", "delt", "delp", "delh", "dem", "deb", "debs", "des", "dess", "deng", "dej", "dec", "dek", "det", "dep", "deh", "dyeo", "dyeog", "dyeogg", "dyeogs", "dyeon", "dyeonj", "dyeonh", "dyeod", "dyeol", "dyeolg", "dyeolm", "dyeolb", "dyeols", "dyeolt", "dyeolp", "dyeolh", "dyeom", "dyeob", "dyeobs", "dyeos", "dyeoss", "dyeong", "dyeoj", "dyeoc", "dyeok", "dyeot", "dyeop", "dyeoh", "dye", "dyeg", "dyegg", "dyegs", "dyen", "dyenj", "dyenh", "dyed", "dyel", "dyelg", "dyelm", "dyelb", "dyels", "dyelt", "dyelp", "dyelh", "dyem", "dyeb", "dyebs", "dyes", "dyess", "dyeng", "dyej", "dyec", "dyek", "dyet", "dyep", "dyeh", "do", "dog", "dogg", "dogs", "don", "donj", "donh", "dod", "dol", "dolg", "dolm", "dolb", "dols", "dolt", "dolp", "dolh", "dom", "dob", "dobs", "dos", "doss", "dong", "doj", "doc", "dok", "dot", "dop", "doh", "dwa", "dwag", "dwagg", "dwags", "dwan", "dwanj", "dwanh", "dwad", "dwal", "dwalg", "dwalm", "dwalb", "dwals", "dwalt", "dwalp", "dwalh", "dwam", "dwab", "dwabs", "dwas", "dwass", "dwang", "dwaj", "dwac", "dwak", "dwat", "dwap", "dwah", "dwae", "dwaeg", "dwaegg", "dwaegs"];
  }
});

// node_modules/unidecode/data/xb4.js
var require_xb4 = __commonJS({
  "node_modules/unidecode/data/xb4.js"(exports, module2) {
    module2.exports = ["dwaen", "dwaenj", "dwaenh", "dwaed", "dwael", "dwaelg", "dwaelm", "dwaelb", "dwaels", "dwaelt", "dwaelp", "dwaelh", "dwaem", "dwaeb", "dwaebs", "dwaes", "dwaess", "dwaeng", "dwaej", "dwaec", "dwaek", "dwaet", "dwaep", "dwaeh", "doe", "doeg", "doegg", "doegs", "doen", "doenj", "doenh", "doed", "doel", "doelg", "doelm", "doelb", "doels", "doelt", "doelp", "doelh", "doem", "doeb", "doebs", "does", "doess", "doeng", "doej", "doec", "doek", "doet", "doep", "doeh", "dyo", "dyog", "dyogg", "dyogs", "dyon", "dyonj", "dyonh", "dyod", "dyol", "dyolg", "dyolm", "dyolb", "dyols", "dyolt", "dyolp", "dyolh", "dyom", "dyob", "dyobs", "dyos", "dyoss", "dyong", "dyoj", "dyoc", "dyok", "dyot", "dyop", "dyoh", "du", "dug", "dugg", "dugs", "dun", "dunj", "dunh", "dud", "dul", "dulg", "dulm", "dulb", "duls", "dult", "dulp", "dulh", "dum", "dub", "dubs", "dus", "duss", "dung", "duj", "duc", "duk", "dut", "dup", "duh", "dweo", "dweog", "dweogg", "dweogs", "dweon", "dweonj", "dweonh", "dweod", "dweol", "dweolg", "dweolm", "dweolb", "dweols", "dweolt", "dweolp", "dweolh", "dweom", "dweob", "dweobs", "dweos", "dweoss", "dweong", "dweoj", "dweoc", "dweok", "dweot", "dweop", "dweoh", "dwe", "dweg", "dwegg", "dwegs", "dwen", "dwenj", "dwenh", "dwed", "dwel", "dwelg", "dwelm", "dwelb", "dwels", "dwelt", "dwelp", "dwelh", "dwem", "dweb", "dwebs", "dwes", "dwess", "dweng", "dwej", "dwec", "dwek", "dwet", "dwep", "dweh", "dwi", "dwig", "dwigg", "dwigs", "dwin", "dwinj", "dwinh", "dwid", "dwil", "dwilg", "dwilm", "dwilb", "dwils", "dwilt", "dwilp", "dwilh", "dwim", "dwib", "dwibs", "dwis", "dwiss", "dwing", "dwij", "dwic", "dwik", "dwit", "dwip", "dwih", "dyu", "dyug", "dyugg", "dyugs", "dyun", "dyunj", "dyunh", "dyud", "dyul", "dyulg", "dyulm", "dyulb", "dyuls", "dyult", "dyulp", "dyulh", "dyum", "dyub", "dyubs", "dyus", "dyuss", "dyung", "dyuj", "dyuc", "dyuk", "dyut", "dyup", "dyuh", "deu", "deug", "deugg", "deugs", "deun", "deunj", "deunh", "deud", "deul", "deulg", "deulm", "deulb", "deuls", "deult", "deulp", "deulh", "deum", "deub", "deubs", "deus", "deuss", "deung", "deuj", "deuc", "deuk", "deut", "deup", "deuh", "dyi", "dyig", "dyigg", "dyigs", "dyin", "dyinj", "dyinh", "dyid"];
  }
});

// node_modules/unidecode/data/xb5.js
var require_xb5 = __commonJS({
  "node_modules/unidecode/data/xb5.js"(exports, module2) {
    module2.exports = ["dyil", "dyilg", "dyilm", "dyilb", "dyils", "dyilt", "dyilp", "dyilh", "dyim", "dyib", "dyibs", "dyis", "dyiss", "dying", "dyij", "dyic", "dyik", "dyit", "dyip", "dyih", "di", "dig", "digg", "digs", "din", "dinj", "dinh", "did", "dil", "dilg", "dilm", "dilb", "dils", "dilt", "dilp", "dilh", "dim", "dib", "dibs", "dis", "diss", "ding", "dij", "dic", "dik", "dit", "dip", "dih", "dda", "ddag", "ddagg", "ddags", "ddan", "ddanj", "ddanh", "ddad", "ddal", "ddalg", "ddalm", "ddalb", "ddals", "ddalt", "ddalp", "ddalh", "ddam", "ddab", "ddabs", "ddas", "ddass", "ddang", "ddaj", "ddac", "ddak", "ddat", "ddap", "ddah", "ddae", "ddaeg", "ddaegg", "ddaegs", "ddaen", "ddaenj", "ddaenh", "ddaed", "ddael", "ddaelg", "ddaelm", "ddaelb", "ddaels", "ddaelt", "ddaelp", "ddaelh", "ddaem", "ddaeb", "ddaebs", "ddaes", "ddaess", "ddaeng", "ddaej", "ddaec", "ddaek", "ddaet", "ddaep", "ddaeh", "ddya", "ddyag", "ddyagg", "ddyags", "ddyan", "ddyanj", "ddyanh", "ddyad", "ddyal", "ddyalg", "ddyalm", "ddyalb", "ddyals", "ddyalt", "ddyalp", "ddyalh", "ddyam", "ddyab", "ddyabs", "ddyas", "ddyass", "ddyang", "ddyaj", "ddyac", "ddyak", "ddyat", "ddyap", "ddyah", "ddyae", "ddyaeg", "ddyaegg", "ddyaegs", "ddyaen", "ddyaenj", "ddyaenh", "ddyaed", "ddyael", "ddyaelg", "ddyaelm", "ddyaelb", "ddyaels", "ddyaelt", "ddyaelp", "ddyaelh", "ddyaem", "ddyaeb", "ddyaebs", "ddyaes", "ddyaess", "ddyaeng", "ddyaej", "ddyaec", "ddyaek", "ddyaet", "ddyaep", "ddyaeh", "ddeo", "ddeog", "ddeogg", "ddeogs", "ddeon", "ddeonj", "ddeonh", "ddeod", "ddeol", "ddeolg", "ddeolm", "ddeolb", "ddeols", "ddeolt", "ddeolp", "ddeolh", "ddeom", "ddeob", "ddeobs", "ddeos", "ddeoss", "ddeong", "ddeoj", "ddeoc", "ddeok", "ddeot", "ddeop", "ddeoh", "dde", "ddeg", "ddegg", "ddegs", "dden", "ddenj", "ddenh", "dded", "ddel", "ddelg", "ddelm", "ddelb", "ddels", "ddelt", "ddelp", "ddelh", "ddem", "ddeb", "ddebs", "ddes", "ddess", "ddeng", "ddej", "ddec", "ddek", "ddet", "ddep", "ddeh", "ddyeo", "ddyeog", "ddyeogg", "ddyeogs", "ddyeon", "ddyeonj", "ddyeonh", "ddyeod", "ddyeol", "ddyeolg", "ddyeolm", "ddyeolb", "ddyeols", "ddyeolt", "ddyeolp", "ddyeolh", "ddyeom", "ddyeob", "ddyeobs", "ddyeos", "ddyeoss", "ddyeong", "ddyeoj", "ddyeoc", "ddyeok", "ddyeot", "ddyeop", "ddyeoh", "ddye", "ddyeg", "ddyegg", "ddyegs", "ddyen", "ddyenj", "ddyenh", "ddyed", "ddyel", "ddyelg", "ddyelm", "ddyelb"];
  }
});

// node_modules/unidecode/data/xb6.js
var require_xb6 = __commonJS({
  "node_modules/unidecode/data/xb6.js"(exports, module2) {
    module2.exports = ["ddyels", "ddyelt", "ddyelp", "ddyelh", "ddyem", "ddyeb", "ddyebs", "ddyes", "ddyess", "ddyeng", "ddyej", "ddyec", "ddyek", "ddyet", "ddyep", "ddyeh", "ddo", "ddog", "ddogg", "ddogs", "ddon", "ddonj", "ddonh", "ddod", "ddol", "ddolg", "ddolm", "ddolb", "ddols", "ddolt", "ddolp", "ddolh", "ddom", "ddob", "ddobs", "ddos", "ddoss", "ddong", "ddoj", "ddoc", "ddok", "ddot", "ddop", "ddoh", "ddwa", "ddwag", "ddwagg", "ddwags", "ddwan", "ddwanj", "ddwanh", "ddwad", "ddwal", "ddwalg", "ddwalm", "ddwalb", "ddwals", "ddwalt", "ddwalp", "ddwalh", "ddwam", "ddwab", "ddwabs", "ddwas", "ddwass", "ddwang", "ddwaj", "ddwac", "ddwak", "ddwat", "ddwap", "ddwah", "ddwae", "ddwaeg", "ddwaegg", "ddwaegs", "ddwaen", "ddwaenj", "ddwaenh", "ddwaed", "ddwael", "ddwaelg", "ddwaelm", "ddwaelb", "ddwaels", "ddwaelt", "ddwaelp", "ddwaelh", "ddwaem", "ddwaeb", "ddwaebs", "ddwaes", "ddwaess", "ddwaeng", "ddwaej", "ddwaec", "ddwaek", "ddwaet", "ddwaep", "ddwaeh", "ddoe", "ddoeg", "ddoegg", "ddoegs", "ddoen", "ddoenj", "ddoenh", "ddoed", "ddoel", "ddoelg", "ddoelm", "ddoelb", "ddoels", "ddoelt", "ddoelp", "ddoelh", "ddoem", "ddoeb", "ddoebs", "ddoes", "ddoess", "ddoeng", "ddoej", "ddoec", "ddoek", "ddoet", "ddoep", "ddoeh", "ddyo", "ddyog", "ddyogg", "ddyogs", "ddyon", "ddyonj", "ddyonh", "ddyod", "ddyol", "ddyolg", "ddyolm", "ddyolb", "ddyols", "ddyolt", "ddyolp", "ddyolh", "ddyom", "ddyob", "ddyobs", "ddyos", "ddyoss", "ddyong", "ddyoj", "ddyoc", "ddyok", "ddyot", "ddyop", "ddyoh", "ddu", "ddug", "ddugg", "ddugs", "ddun", "ddunj", "ddunh", "ddud", "ddul", "ddulg", "ddulm", "ddulb", "dduls", "ddult", "ddulp", "ddulh", "ddum", "ddub", "ddubs", "ddus", "dduss", "ddung", "dduj", "dduc", "dduk", "ddut", "ddup", "dduh", "ddweo", "ddweog", "ddweogg", "ddweogs", "ddweon", "ddweonj", "ddweonh", "ddweod", "ddweol", "ddweolg", "ddweolm", "ddweolb", "ddweols", "ddweolt", "ddweolp", "ddweolh", "ddweom", "ddweob", "ddweobs", "ddweos", "ddweoss", "ddweong", "ddweoj", "ddweoc", "ddweok", "ddweot", "ddweop", "ddweoh", "ddwe", "ddweg", "ddwegg", "ddwegs", "ddwen", "ddwenj", "ddwenh", "ddwed", "ddwel", "ddwelg", "ddwelm", "ddwelb", "ddwels", "ddwelt", "ddwelp", "ddwelh", "ddwem", "ddweb", "ddwebs", "ddwes", "ddwess", "ddweng", "ddwej", "ddwec", "ddwek", "ddwet", "ddwep", "ddweh", "ddwi", "ddwig", "ddwigg", "ddwigs", "ddwin", "ddwinj", "ddwinh", "ddwid", "ddwil", "ddwilg", "ddwilm", "ddwilb", "ddwils", "ddwilt", "ddwilp", "ddwilh"];
  }
});

// node_modules/unidecode/data/xb7.js
var require_xb7 = __commonJS({
  "node_modules/unidecode/data/xb7.js"(exports, module2) {
    module2.exports = ["ddwim", "ddwib", "ddwibs", "ddwis", "ddwiss", "ddwing", "ddwij", "ddwic", "ddwik", "ddwit", "ddwip", "ddwih", "ddyu", "ddyug", "ddyugg", "ddyugs", "ddyun", "ddyunj", "ddyunh", "ddyud", "ddyul", "ddyulg", "ddyulm", "ddyulb", "ddyuls", "ddyult", "ddyulp", "ddyulh", "ddyum", "ddyub", "ddyubs", "ddyus", "ddyuss", "ddyung", "ddyuj", "ddyuc", "ddyuk", "ddyut", "ddyup", "ddyuh", "ddeu", "ddeug", "ddeugg", "ddeugs", "ddeun", "ddeunj", "ddeunh", "ddeud", "ddeul", "ddeulg", "ddeulm", "ddeulb", "ddeuls", "ddeult", "ddeulp", "ddeulh", "ddeum", "ddeub", "ddeubs", "ddeus", "ddeuss", "ddeung", "ddeuj", "ddeuc", "ddeuk", "ddeut", "ddeup", "ddeuh", "ddyi", "ddyig", "ddyigg", "ddyigs", "ddyin", "ddyinj", "ddyinh", "ddyid", "ddyil", "ddyilg", "ddyilm", "ddyilb", "ddyils", "ddyilt", "ddyilp", "ddyilh", "ddyim", "ddyib", "ddyibs", "ddyis", "ddyiss", "ddying", "ddyij", "ddyic", "ddyik", "ddyit", "ddyip", "ddyih", "ddi", "ddig", "ddigg", "ddigs", "ddin", "ddinj", "ddinh", "ddid", "ddil", "ddilg", "ddilm", "ddilb", "ddils", "ddilt", "ddilp", "ddilh", "ddim", "ddib", "ddibs", "ddis", "ddiss", "dding", "ddij", "ddic", "ddik", "ddit", "ddip", "ddih", "ra", "rag", "ragg", "rags", "ran", "ranj", "ranh", "rad", "ral", "ralg", "ralm", "ralb", "rals", "ralt", "ralp", "ralh", "ram", "rab", "rabs", "ras", "rass", "rang", "raj", "rac", "rak", "rat", "rap", "rah", "rae", "raeg", "raegg", "raegs", "raen", "raenj", "raenh", "raed", "rael", "raelg", "raelm", "raelb", "raels", "raelt", "raelp", "raelh", "raem", "raeb", "raebs", "raes", "raess", "raeng", "raej", "raec", "raek", "raet", "raep", "raeh", "rya", "ryag", "ryagg", "ryags", "ryan", "ryanj", "ryanh", "ryad", "ryal", "ryalg", "ryalm", "ryalb", "ryals", "ryalt", "ryalp", "ryalh", "ryam", "ryab", "ryabs", "ryas", "ryass", "ryang", "ryaj", "ryac", "ryak", "ryat", "ryap", "ryah", "ryae", "ryaeg", "ryaegg", "ryaegs", "ryaen", "ryaenj", "ryaenh", "ryaed", "ryael", "ryaelg", "ryaelm", "ryaelb", "ryaels", "ryaelt", "ryaelp", "ryaelh", "ryaem", "ryaeb", "ryaebs", "ryaes", "ryaess", "ryaeng", "ryaej", "ryaec", "ryaek", "ryaet", "ryaep", "ryaeh", "reo", "reog", "reogg", "reogs", "reon", "reonj", "reonh", "reod", "reol", "reolg", "reolm", "reolb", "reols", "reolt", "reolp", "reolh", "reom", "reob", "reobs", "reos"];
  }
});

// node_modules/unidecode/data/xb8.js
var require_xb8 = __commonJS({
  "node_modules/unidecode/data/xb8.js"(exports, module2) {
    module2.exports = ["reoss", "reong", "reoj", "reoc", "reok", "reot", "reop", "reoh", "re", "reg", "regg", "regs", "ren", "renj", "renh", "red", "rel", "relg", "relm", "relb", "rels", "relt", "relp", "relh", "rem", "reb", "rebs", "res", "ress", "reng", "rej", "rec", "rek", "ret", "rep", "reh", "ryeo", "ryeog", "ryeogg", "ryeogs", "ryeon", "ryeonj", "ryeonh", "ryeod", "ryeol", "ryeolg", "ryeolm", "ryeolb", "ryeols", "ryeolt", "ryeolp", "ryeolh", "ryeom", "ryeob", "ryeobs", "ryeos", "ryeoss", "ryeong", "ryeoj", "ryeoc", "ryeok", "ryeot", "ryeop", "ryeoh", "rye", "ryeg", "ryegg", "ryegs", "ryen", "ryenj", "ryenh", "ryed", "ryel", "ryelg", "ryelm", "ryelb", "ryels", "ryelt", "ryelp", "ryelh", "ryem", "ryeb", "ryebs", "ryes", "ryess", "ryeng", "ryej", "ryec", "ryek", "ryet", "ryep", "ryeh", "ro", "rog", "rogg", "rogs", "ron", "ronj", "ronh", "rod", "rol", "rolg", "rolm", "rolb", "rols", "rolt", "rolp", "rolh", "rom", "rob", "robs", "ros", "ross", "rong", "roj", "roc", "rok", "rot", "rop", "roh", "rwa", "rwag", "rwagg", "rwags", "rwan", "rwanj", "rwanh", "rwad", "rwal", "rwalg", "rwalm", "rwalb", "rwals", "rwalt", "rwalp", "rwalh", "rwam", "rwab", "rwabs", "rwas", "rwass", "rwang", "rwaj", "rwac", "rwak", "rwat", "rwap", "rwah", "rwae", "rwaeg", "rwaegg", "rwaegs", "rwaen", "rwaenj", "rwaenh", "rwaed", "rwael", "rwaelg", "rwaelm", "rwaelb", "rwaels", "rwaelt", "rwaelp", "rwaelh", "rwaem", "rwaeb", "rwaebs", "rwaes", "rwaess", "rwaeng", "rwaej", "rwaec", "rwaek", "rwaet", "rwaep", "rwaeh", "roe", "roeg", "roegg", "roegs", "roen", "roenj", "roenh", "roed", "roel", "roelg", "roelm", "roelb", "roels", "roelt", "roelp", "roelh", "roem", "roeb", "roebs", "roes", "roess", "roeng", "roej", "roec", "roek", "roet", "roep", "roeh", "ryo", "ryog", "ryogg", "ryogs", "ryon", "ryonj", "ryonh", "ryod", "ryol", "ryolg", "ryolm", "ryolb", "ryols", "ryolt", "ryolp", "ryolh", "ryom", "ryob", "ryobs", "ryos", "ryoss", "ryong", "ryoj", "ryoc", "ryok", "ryot", "ryop", "ryoh", "ru", "rug", "rugg", "rugs", "run", "runj", "runh", "rud", "rul", "rulg", "rulm", "rulb", "ruls", "rult", "rulp", "rulh", "rum", "rub", "rubs", "rus", "russ", "rung", "ruj", "ruc"];
  }
});

// node_modules/unidecode/data/xb9.js
var require_xb9 = __commonJS({
  "node_modules/unidecode/data/xb9.js"(exports, module2) {
    module2.exports = ["ruk", "rut", "rup", "ruh", "rweo", "rweog", "rweogg", "rweogs", "rweon", "rweonj", "rweonh", "rweod", "rweol", "rweolg", "rweolm", "rweolb", "rweols", "rweolt", "rweolp", "rweolh", "rweom", "rweob", "rweobs", "rweos", "rweoss", "rweong", "rweoj", "rweoc", "rweok", "rweot", "rweop", "rweoh", "rwe", "rweg", "rwegg", "rwegs", "rwen", "rwenj", "rwenh", "rwed", "rwel", "rwelg", "rwelm", "rwelb", "rwels", "rwelt", "rwelp", "rwelh", "rwem", "rweb", "rwebs", "rwes", "rwess", "rweng", "rwej", "rwec", "rwek", "rwet", "rwep", "rweh", "rwi", "rwig", "rwigg", "rwigs", "rwin", "rwinj", "rwinh", "rwid", "rwil", "rwilg", "rwilm", "rwilb", "rwils", "rwilt", "rwilp", "rwilh", "rwim", "rwib", "rwibs", "rwis", "rwiss", "rwing", "rwij", "rwic", "rwik", "rwit", "rwip", "rwih", "ryu", "ryug", "ryugg", "ryugs", "ryun", "ryunj", "ryunh", "ryud", "ryul", "ryulg", "ryulm", "ryulb", "ryuls", "ryult", "ryulp", "ryulh", "ryum", "ryub", "ryubs", "ryus", "ryuss", "ryung", "ryuj", "ryuc", "ryuk", "ryut", "ryup", "ryuh", "reu", "reug", "reugg", "reugs", "reun", "reunj", "reunh", "reud", "reul", "reulg", "reulm", "reulb", "reuls", "reult", "reulp", "reulh", "reum", "reub", "reubs", "reus", "reuss", "reung", "reuj", "reuc", "reuk", "reut", "reup", "reuh", "ryi", "ryig", "ryigg", "ryigs", "ryin", "ryinj", "ryinh", "ryid", "ryil", "ryilg", "ryilm", "ryilb", "ryils", "ryilt", "ryilp", "ryilh", "ryim", "ryib", "ryibs", "ryis", "ryiss", "rying", "ryij", "ryic", "ryik", "ryit", "ryip", "ryih", "ri", "rig", "rigg", "rigs", "rin", "rinj", "rinh", "rid", "ril", "rilg", "rilm", "rilb", "rils", "rilt", "rilp", "rilh", "rim", "rib", "ribs", "ris", "riss", "ring", "rij", "ric", "rik", "rit", "rip", "rih", "ma", "mag", "magg", "mags", "man", "manj", "manh", "mad", "mal", "malg", "malm", "malb", "mals", "malt", "malp", "malh", "mam", "mab", "mabs", "mas", "mass", "mang", "maj", "mac", "mak", "mat", "map", "mah", "mae", "maeg", "maegg", "maegs", "maen", "maenj", "maenh", "maed", "mael", "maelg", "maelm", "maelb", "maels", "maelt", "maelp", "maelh", "maem", "maeb", "maebs", "maes", "maess", "maeng", "maej", "maec", "maek", "maet", "maep", "maeh"];
  }
});

// node_modules/unidecode/data/xba.js
var require_xba = __commonJS({
  "node_modules/unidecode/data/xba.js"(exports, module2) {
    module2.exports = ["mya", "myag", "myagg", "myags", "myan", "myanj", "myanh", "myad", "myal", "myalg", "myalm", "myalb", "myals", "myalt", "myalp", "myalh", "myam", "myab", "myabs", "myas", "myass", "myang", "myaj", "myac", "myak", "myat", "myap", "myah", "myae", "myaeg", "myaegg", "myaegs", "myaen", "myaenj", "myaenh", "myaed", "myael", "myaelg", "myaelm", "myaelb", "myaels", "myaelt", "myaelp", "myaelh", "myaem", "myaeb", "myaebs", "myaes", "myaess", "myaeng", "myaej", "myaec", "myaek", "myaet", "myaep", "myaeh", "meo", "meog", "meogg", "meogs", "meon", "meonj", "meonh", "meod", "meol", "meolg", "meolm", "meolb", "meols", "meolt", "meolp", "meolh", "meom", "meob", "meobs", "meos", "meoss", "meong", "meoj", "meoc", "meok", "meot", "meop", "meoh", "me", "meg", "megg", "megs", "men", "menj", "menh", "med", "mel", "melg", "melm", "melb", "mels", "melt", "melp", "melh", "mem", "meb", "mebs", "mes", "mess", "meng", "mej", "mec", "mek", "met", "mep", "meh", "myeo", "myeog", "myeogg", "myeogs", "myeon", "myeonj", "myeonh", "myeod", "myeol", "myeolg", "myeolm", "myeolb", "myeols", "myeolt", "myeolp", "myeolh", "myeom", "myeob", "myeobs", "myeos", "myeoss", "myeong", "myeoj", "myeoc", "myeok", "myeot", "myeop", "myeoh", "mye", "myeg", "myegg", "myegs", "myen", "myenj", "myenh", "myed", "myel", "myelg", "myelm", "myelb", "myels", "myelt", "myelp", "myelh", "myem", "myeb", "myebs", "myes", "myess", "myeng", "myej", "myec", "myek", "myet", "myep", "myeh", "mo", "mog", "mogg", "mogs", "mon", "monj", "monh", "mod", "mol", "molg", "molm", "molb", "mols", "molt", "molp", "molh", "mom", "mob", "mobs", "mos", "moss", "mong", "moj", "moc", "mok", "mot", "mop", "moh", "mwa", "mwag", "mwagg", "mwags", "mwan", "mwanj", "mwanh", "mwad", "mwal", "mwalg", "mwalm", "mwalb", "mwals", "mwalt", "mwalp", "mwalh", "mwam", "mwab", "mwabs", "mwas", "mwass", "mwang", "mwaj", "mwac", "mwak", "mwat", "mwap", "mwah", "mwae", "mwaeg", "mwaegg", "mwaegs", "mwaen", "mwaenj", "mwaenh", "mwaed", "mwael", "mwaelg", "mwaelm", "mwaelb", "mwaels", "mwaelt", "mwaelp", "mwaelh", "mwaem", "mwaeb", "mwaebs", "mwaes", "mwaess", "mwaeng", "mwaej", "mwaec", "mwaek", "mwaet", "mwaep", "mwaeh", "moe", "moeg", "moegg", "moegs"];
  }
});

// node_modules/unidecode/data/xbb.js
var require_xbb = __commonJS({
  "node_modules/unidecode/data/xbb.js"(exports, module2) {
    module2.exports = ["moen", "moenj", "moenh", "moed", "moel", "moelg", "moelm", "moelb", "moels", "moelt", "moelp", "moelh", "moem", "moeb", "moebs", "moes", "moess", "moeng", "moej", "moec", "moek", "moet", "moep", "moeh", "myo", "myog", "myogg", "myogs", "myon", "myonj", "myonh", "myod", "myol", "myolg", "myolm", "myolb", "myols", "myolt", "myolp", "myolh", "myom", "myob", "myobs", "myos", "myoss", "myong", "myoj", "myoc", "myok", "myot", "myop", "myoh", "mu", "mug", "mugg", "mugs", "mun", "munj", "munh", "mud", "mul", "mulg", "mulm", "mulb", "muls", "mult", "mulp", "mulh", "mum", "mub", "mubs", "mus", "muss", "mung", "muj", "muc", "muk", "mut", "mup", "muh", "mweo", "mweog", "mweogg", "mweogs", "mweon", "mweonj", "mweonh", "mweod", "mweol", "mweolg", "mweolm", "mweolb", "mweols", "mweolt", "mweolp", "mweolh", "mweom", "mweob", "mweobs", "mweos", "mweoss", "mweong", "mweoj", "mweoc", "mweok", "mweot", "mweop", "mweoh", "mwe", "mweg", "mwegg", "mwegs", "mwen", "mwenj", "mwenh", "mwed", "mwel", "mwelg", "mwelm", "mwelb", "mwels", "mwelt", "mwelp", "mwelh", "mwem", "mweb", "mwebs", "mwes", "mwess", "mweng", "mwej", "mwec", "mwek", "mwet", "mwep", "mweh", "mwi", "mwig", "mwigg", "mwigs", "mwin", "mwinj", "mwinh", "mwid", "mwil", "mwilg", "mwilm", "mwilb", "mwils", "mwilt", "mwilp", "mwilh", "mwim", "mwib", "mwibs", "mwis", "mwiss", "mwing", "mwij", "mwic", "mwik", "mwit", "mwip", "mwih", "myu", "myug", "myugg", "myugs", "myun", "myunj", "myunh", "myud", "myul", "myulg", "myulm", "myulb", "myuls", "myult", "myulp", "myulh", "myum", "myub", "myubs", "myus", "myuss", "myung", "myuj", "myuc", "myuk", "myut", "myup", "myuh", "meu", "meug", "meugg", "meugs", "meun", "meunj", "meunh", "meud", "meul", "meulg", "meulm", "meulb", "meuls", "meult", "meulp", "meulh", "meum", "meub", "meubs", "meus", "meuss", "meung", "meuj", "meuc", "meuk", "meut", "meup", "meuh", "myi", "myig", "myigg", "myigs", "myin", "myinj", "myinh", "myid", "myil", "myilg", "myilm", "myilb", "myils", "myilt", "myilp", "myilh", "myim", "myib", "myibs", "myis", "myiss", "mying", "myij", "myic", "myik", "myit", "myip", "myih", "mi", "mig", "migg", "migs", "min", "minj", "minh", "mid"];
  }
});

// node_modules/unidecode/data/xbc.js
var require_xbc = __commonJS({
  "node_modules/unidecode/data/xbc.js"(exports, module2) {
    module2.exports = ["mil", "milg", "milm", "milb", "mils", "milt", "milp", "milh", "mim", "mib", "mibs", "mis", "miss", "ming", "mij", "mic", "mik", "mit", "mip", "mih", "ba", "bag", "bagg", "bags", "ban", "banj", "banh", "bad", "bal", "balg", "balm", "balb", "bals", "balt", "balp", "balh", "bam", "bab", "babs", "bas", "bass", "bang", "baj", "bac", "bak", "bat", "bap", "bah", "bae", "baeg", "baegg", "baegs", "baen", "baenj", "baenh", "baed", "bael", "baelg", "baelm", "baelb", "baels", "baelt", "baelp", "baelh", "baem", "baeb", "baebs", "baes", "baess", "baeng", "baej", "baec", "baek", "baet", "baep", "baeh", "bya", "byag", "byagg", "byags", "byan", "byanj", "byanh", "byad", "byal", "byalg", "byalm", "byalb", "byals", "byalt", "byalp", "byalh", "byam", "byab", "byabs", "byas", "byass", "byang", "byaj", "byac", "byak", "byat", "byap", "byah", "byae", "byaeg", "byaegg", "byaegs", "byaen", "byaenj", "byaenh", "byaed", "byael", "byaelg", "byaelm", "byaelb", "byaels", "byaelt", "byaelp", "byaelh", "byaem", "byaeb", "byaebs", "byaes", "byaess", "byaeng", "byaej", "byaec", "byaek", "byaet", "byaep", "byaeh", "beo", "beog", "beogg", "beogs", "beon", "beonj", "beonh", "beod", "beol", "beolg", "beolm", "beolb", "beols", "beolt", "beolp", "beolh", "beom", "beob", "beobs", "beos", "beoss", "beong", "beoj", "beoc", "beok", "beot", "beop", "beoh", "be", "beg", "begg", "begs", "ben", "benj", "benh", "bed", "bel", "belg", "belm", "belb", "bels", "belt", "belp", "belh", "bem", "beb", "bebs", "bes", "bess", "beng", "bej", "bec", "bek", "bet", "bep", "beh", "byeo", "byeog", "byeogg", "byeogs", "byeon", "byeonj", "byeonh", "byeod", "byeol", "byeolg", "byeolm", "byeolb", "byeols", "byeolt", "byeolp", "byeolh", "byeom", "byeob", "byeobs", "byeos", "byeoss", "byeong", "byeoj", "byeoc", "byeok", "byeot", "byeop", "byeoh", "bye", "byeg", "byegg", "byegs", "byen", "byenj", "byenh", "byed", "byel", "byelg", "byelm", "byelb", "byels", "byelt", "byelp", "byelh", "byem", "byeb", "byebs", "byes", "byess", "byeng", "byej", "byec", "byek", "byet", "byep", "byeh", "bo", "bog", "bogg", "bogs", "bon", "bonj", "bonh", "bod", "bol", "bolg", "bolm", "bolb"];
  }
});

// node_modules/unidecode/data/xbd.js
var require_xbd = __commonJS({
  "node_modules/unidecode/data/xbd.js"(exports, module2) {
    module2.exports = ["bols", "bolt", "bolp", "bolh", "bom", "bob", "bobs", "bos", "boss", "bong", "boj", "boc", "bok", "bot", "bop", "boh", "bwa", "bwag", "bwagg", "bwags", "bwan", "bwanj", "bwanh", "bwad", "bwal", "bwalg", "bwalm", "bwalb", "bwals", "bwalt", "bwalp", "bwalh", "bwam", "bwab", "bwabs", "bwas", "bwass", "bwang", "bwaj", "bwac", "bwak", "bwat", "bwap", "bwah", "bwae", "bwaeg", "bwaegg", "bwaegs", "bwaen", "bwaenj", "bwaenh", "bwaed", "bwael", "bwaelg", "bwaelm", "bwaelb", "bwaels", "bwaelt", "bwaelp", "bwaelh", "bwaem", "bwaeb", "bwaebs", "bwaes", "bwaess", "bwaeng", "bwaej", "bwaec", "bwaek", "bwaet", "bwaep", "bwaeh", "boe", "boeg", "boegg", "boegs", "boen", "boenj", "boenh", "boed", "boel", "boelg", "boelm", "boelb", "boels", "boelt", "boelp", "boelh", "boem", "boeb", "boebs", "boes", "boess", "boeng", "boej", "boec", "boek", "boet", "boep", "boeh", "byo", "byog", "byogg", "byogs", "byon", "byonj", "byonh", "byod", "byol", "byolg", "byolm", "byolb", "byols", "byolt", "byolp", "byolh", "byom", "byob", "byobs", "byos", "byoss", "byong", "byoj", "byoc", "byok", "byot", "byop", "byoh", "bu", "bug", "bugg", "bugs", "bun", "bunj", "bunh", "bud", "bul", "bulg", "bulm", "bulb", "buls", "bult", "bulp", "bulh", "bum", "bub", "bubs", "bus", "buss", "bung", "buj", "buc", "buk", "but", "bup", "buh", "bweo", "bweog", "bweogg", "bweogs", "bweon", "bweonj", "bweonh", "bweod", "bweol", "bweolg", "bweolm", "bweolb", "bweols", "bweolt", "bweolp", "bweolh", "bweom", "bweob", "bweobs", "bweos", "bweoss", "bweong", "bweoj", "bweoc", "bweok", "bweot", "bweop", "bweoh", "bwe", "bweg", "bwegg", "bwegs", "bwen", "bwenj", "bwenh", "bwed", "bwel", "bwelg", "bwelm", "bwelb", "bwels", "bwelt", "bwelp", "bwelh", "bwem", "bweb", "bwebs", "bwes", "bwess", "bweng", "bwej", "bwec", "bwek", "bwet", "bwep", "bweh", "bwi", "bwig", "bwigg", "bwigs", "bwin", "bwinj", "bwinh", "bwid", "bwil", "bwilg", "bwilm", "bwilb", "bwils", "bwilt", "bwilp", "bwilh", "bwim", "bwib", "bwibs", "bwis", "bwiss", "bwing", "bwij", "bwic", "bwik", "bwit", "bwip", "bwih", "byu", "byug", "byugg", "byugs", "byun", "byunj", "byunh", "byud", "byul", "byulg", "byulm", "byulb", "byuls", "byult", "byulp", "byulh"];
  }
});

// node_modules/unidecode/data/xbe.js
var require_xbe = __commonJS({
  "node_modules/unidecode/data/xbe.js"(exports, module2) {
    module2.exports = ["byum", "byub", "byubs", "byus", "byuss", "byung", "byuj", "byuc", "byuk", "byut", "byup", "byuh", "beu", "beug", "beugg", "beugs", "beun", "beunj", "beunh", "beud", "beul", "beulg", "beulm", "beulb", "beuls", "beult", "beulp", "beulh", "beum", "beub", "beubs", "beus", "beuss", "beung", "beuj", "beuc", "beuk", "beut", "beup", "beuh", "byi", "byig", "byigg", "byigs", "byin", "byinj", "byinh", "byid", "byil", "byilg", "byilm", "byilb", "byils", "byilt", "byilp", "byilh", "byim", "byib", "byibs", "byis", "byiss", "bying", "byij", "byic", "byik", "byit", "byip", "byih", "bi", "big", "bigg", "bigs", "bin", "binj", "binh", "bid", "bil", "bilg", "bilm", "bilb", "bils", "bilt", "bilp", "bilh", "bim", "bib", "bibs", "bis", "biss", "bing", "bij", "bic", "bik", "bit", "bip", "bih", "bba", "bbag", "bbagg", "bbags", "bban", "bbanj", "bbanh", "bbad", "bbal", "bbalg", "bbalm", "bbalb", "bbals", "bbalt", "bbalp", "bbalh", "bbam", "bbab", "bbabs", "bbas", "bbass", "bbang", "bbaj", "bbac", "bbak", "bbat", "bbap", "bbah", "bbae", "bbaeg", "bbaegg", "bbaegs", "bbaen", "bbaenj", "bbaenh", "bbaed", "bbael", "bbaelg", "bbaelm", "bbaelb", "bbaels", "bbaelt", "bbaelp", "bbaelh", "bbaem", "bbaeb", "bbaebs", "bbaes", "bbaess", "bbaeng", "bbaej", "bbaec", "bbaek", "bbaet", "bbaep", "bbaeh", "bbya", "bbyag", "bbyagg", "bbyags", "bbyan", "bbyanj", "bbyanh", "bbyad", "bbyal", "bbyalg", "bbyalm", "bbyalb", "bbyals", "bbyalt", "bbyalp", "bbyalh", "bbyam", "bbyab", "bbyabs", "bbyas", "bbyass", "bbyang", "bbyaj", "bbyac", "bbyak", "bbyat", "bbyap", "bbyah", "bbyae", "bbyaeg", "bbyaegg", "bbyaegs", "bbyaen", "bbyaenj", "bbyaenh", "bbyaed", "bbyael", "bbyaelg", "bbyaelm", "bbyaelb", "bbyaels", "bbyaelt", "bbyaelp", "bbyaelh", "bbyaem", "bbyaeb", "bbyaebs", "bbyaes", "bbyaess", "bbyaeng", "bbyaej", "bbyaec", "bbyaek", "bbyaet", "bbyaep", "bbyaeh", "bbeo", "bbeog", "bbeogg", "bbeogs", "bbeon", "bbeonj", "bbeonh", "bbeod", "bbeol", "bbeolg", "bbeolm", "bbeolb", "bbeols", "bbeolt", "bbeolp", "bbeolh", "bbeom", "bbeob", "bbeobs", "bbeos", "bbeoss", "bbeong", "bbeoj", "bbeoc", "bbeok", "bbeot", "bbeop", "bbeoh", "bbe", "bbeg", "bbegg", "bbegs", "bben", "bbenj", "bbenh", "bbed", "bbel", "bbelg", "bbelm", "bbelb", "bbels", "bbelt", "bbelp", "bbelh", "bbem", "bbeb", "bbebs", "bbes"];
  }
});

// node_modules/unidecode/data/xbf.js
var require_xbf = __commonJS({
  "node_modules/unidecode/data/xbf.js"(exports, module2) {
    module2.exports = ["bbess", "bbeng", "bbej", "bbec", "bbek", "bbet", "bbep", "bbeh", "bbyeo", "bbyeog", "bbyeogg", "bbyeogs", "bbyeon", "bbyeonj", "bbyeonh", "bbyeod", "bbyeol", "bbyeolg", "bbyeolm", "bbyeolb", "bbyeols", "bbyeolt", "bbyeolp", "bbyeolh", "bbyeom", "bbyeob", "bbyeobs", "bbyeos", "bbyeoss", "bbyeong", "bbyeoj", "bbyeoc", "bbyeok", "bbyeot", "bbyeop", "bbyeoh", "bbye", "bbyeg", "bbyegg", "bbyegs", "bbyen", "bbyenj", "bbyenh", "bbyed", "bbyel", "bbyelg", "bbyelm", "bbyelb", "bbyels", "bbyelt", "bbyelp", "bbyelh", "bbyem", "bbyeb", "bbyebs", "bbyes", "bbyess", "bbyeng", "bbyej", "bbyec", "bbyek", "bbyet", "bbyep", "bbyeh", "bbo", "bbog", "bbogg", "bbogs", "bbon", "bbonj", "bbonh", "bbod", "bbol", "bbolg", "bbolm", "bbolb", "bbols", "bbolt", "bbolp", "bbolh", "bbom", "bbob", "bbobs", "bbos", "bboss", "bbong", "bboj", "bboc", "bbok", "bbot", "bbop", "bboh", "bbwa", "bbwag", "bbwagg", "bbwags", "bbwan", "bbwanj", "bbwanh", "bbwad", "bbwal", "bbwalg", "bbwalm", "bbwalb", "bbwals", "bbwalt", "bbwalp", "bbwalh", "bbwam", "bbwab", "bbwabs", "bbwas", "bbwass", "bbwang", "bbwaj", "bbwac", "bbwak", "bbwat", "bbwap", "bbwah", "bbwae", "bbwaeg", "bbwaegg", "bbwaegs", "bbwaen", "bbwaenj", "bbwaenh", "bbwaed", "bbwael", "bbwaelg", "bbwaelm", "bbwaelb", "bbwaels", "bbwaelt", "bbwaelp", "bbwaelh", "bbwaem", "bbwaeb", "bbwaebs", "bbwaes", "bbwaess", "bbwaeng", "bbwaej", "bbwaec", "bbwaek", "bbwaet", "bbwaep", "bbwaeh", "bboe", "bboeg", "bboegg", "bboegs", "bboen", "bboenj", "bboenh", "bboed", "bboel", "bboelg", "bboelm", "bboelb", "bboels", "bboelt", "bboelp", "bboelh", "bboem", "bboeb", "bboebs", "bboes", "bboess", "bboeng", "bboej", "bboec", "bboek", "bboet", "bboep", "bboeh", "bbyo", "bbyog", "bbyogg", "bbyogs", "bbyon", "bbyonj", "bbyonh", "bbyod", "bbyol", "bbyolg", "bbyolm", "bbyolb", "bbyols", "bbyolt", "bbyolp", "bbyolh", "bbyom", "bbyob", "bbyobs", "bbyos", "bbyoss", "bbyong", "bbyoj", "bbyoc", "bbyok", "bbyot", "bbyop", "bbyoh", "bbu", "bbug", "bbugg", "bbugs", "bbun", "bbunj", "bbunh", "bbud", "bbul", "bbulg", "bbulm", "bbulb", "bbuls", "bbult", "bbulp", "bbulh", "bbum", "bbub", "bbubs", "bbus", "bbuss", "bbung", "bbuj", "bbuc", "bbuk", "bbut", "bbup", "bbuh", "bbweo", "bbweog", "bbweogg", "bbweogs", "bbweon", "bbweonj", "bbweonh", "bbweod", "bbweol", "bbweolg", "bbweolm", "bbweolb", "bbweols", "bbweolt", "bbweolp", "bbweolh", "bbweom", "bbweob", "bbweobs", "bbweos", "bbweoss", "bbweong", "bbweoj", "bbweoc"];
  }
});

// node_modules/unidecode/data/xc0.js
var require_xc0 = __commonJS({
  "node_modules/unidecode/data/xc0.js"(exports, module2) {
    module2.exports = ["bbweok", "bbweot", "bbweop", "bbweoh", "bbwe", "bbweg", "bbwegg", "bbwegs", "bbwen", "bbwenj", "bbwenh", "bbwed", "bbwel", "bbwelg", "bbwelm", "bbwelb", "bbwels", "bbwelt", "bbwelp", "bbwelh", "bbwem", "bbweb", "bbwebs", "bbwes", "bbwess", "bbweng", "bbwej", "bbwec", "bbwek", "bbwet", "bbwep", "bbweh", "bbwi", "bbwig", "bbwigg", "bbwigs", "bbwin", "bbwinj", "bbwinh", "bbwid", "bbwil", "bbwilg", "bbwilm", "bbwilb", "bbwils", "bbwilt", "bbwilp", "bbwilh", "bbwim", "bbwib", "bbwibs", "bbwis", "bbwiss", "bbwing", "bbwij", "bbwic", "bbwik", "bbwit", "bbwip", "bbwih", "bbyu", "bbyug", "bbyugg", "bbyugs", "bbyun", "bbyunj", "bbyunh", "bbyud", "bbyul", "bbyulg", "bbyulm", "bbyulb", "bbyuls", "bbyult", "bbyulp", "bbyulh", "bbyum", "bbyub", "bbyubs", "bbyus", "bbyuss", "bbyung", "bbyuj", "bbyuc", "bbyuk", "bbyut", "bbyup", "bbyuh", "bbeu", "bbeug", "bbeugg", "bbeugs", "bbeun", "bbeunj", "bbeunh", "bbeud", "bbeul", "bbeulg", "bbeulm", "bbeulb", "bbeuls", "bbeult", "bbeulp", "bbeulh", "bbeum", "bbeub", "bbeubs", "bbeus", "bbeuss", "bbeung", "bbeuj", "bbeuc", "bbeuk", "bbeut", "bbeup", "bbeuh", "bbyi", "bbyig", "bbyigg", "bbyigs", "bbyin", "bbyinj", "bbyinh", "bbyid", "bbyil", "bbyilg", "bbyilm", "bbyilb", "bbyils", "bbyilt", "bbyilp", "bbyilh", "bbyim", "bbyib", "bbyibs", "bbyis", "bbyiss", "bbying", "bbyij", "bbyic", "bbyik", "bbyit", "bbyip", "bbyih", "bbi", "bbig", "bbigg", "bbigs", "bbin", "bbinj", "bbinh", "bbid", "bbil", "bbilg", "bbilm", "bbilb", "bbils", "bbilt", "bbilp", "bbilh", "bbim", "bbib", "bbibs", "bbis", "bbiss", "bbing", "bbij", "bbic", "bbik", "bbit", "bbip", "bbih", "sa", "sag", "sagg", "sags", "san", "sanj", "sanh", "sad", "sal", "salg", "salm", "salb", "sals", "salt", "salp", "salh", "sam", "sab", "sabs", "sas", "sass", "sang", "saj", "sac", "sak", "sat", "sap", "sah", "sae", "saeg", "saegg", "saegs", "saen", "saenj", "saenh", "saed", "sael", "saelg", "saelm", "saelb", "saels", "saelt", "saelp", "saelh", "saem", "saeb", "saebs", "saes", "saess", "saeng", "saej", "saec", "saek", "saet", "saep", "saeh", "sya", "syag", "syagg", "syags", "syan", "syanj", "syanh", "syad", "syal", "syalg", "syalm", "syalb", "syals", "syalt", "syalp", "syalh", "syam", "syab", "syabs", "syas", "syass", "syang", "syaj", "syac", "syak", "syat", "syap", "syah"];
  }
});

// node_modules/unidecode/data/xc1.js
var require_xc1 = __commonJS({
  "node_modules/unidecode/data/xc1.js"(exports, module2) {
    module2.exports = ["syae", "syaeg", "syaegg", "syaegs", "syaen", "syaenj", "syaenh", "syaed", "syael", "syaelg", "syaelm", "syaelb", "syaels", "syaelt", "syaelp", "syaelh", "syaem", "syaeb", "syaebs", "syaes", "syaess", "syaeng", "syaej", "syaec", "syaek", "syaet", "syaep", "syaeh", "seo", "seog", "seogg", "seogs", "seon", "seonj", "seonh", "seod", "seol", "seolg", "seolm", "seolb", "seols", "seolt", "seolp", "seolh", "seom", "seob", "seobs", "seos", "seoss", "seong", "seoj", "seoc", "seok", "seot", "seop", "seoh", "se", "seg", "segg", "segs", "sen", "senj", "senh", "sed", "sel", "selg", "selm", "selb", "sels", "selt", "selp", "selh", "sem", "seb", "sebs", "ses", "sess", "seng", "sej", "sec", "sek", "set", "sep", "seh", "syeo", "syeog", "syeogg", "syeogs", "syeon", "syeonj", "syeonh", "syeod", "syeol", "syeolg", "syeolm", "syeolb", "syeols", "syeolt", "syeolp", "syeolh", "syeom", "syeob", "syeobs", "syeos", "syeoss", "syeong", "syeoj", "syeoc", "syeok", "syeot", "syeop", "syeoh", "sye", "syeg", "syegg", "syegs", "syen", "syenj", "syenh", "syed", "syel", "syelg", "syelm", "syelb", "syels", "syelt", "syelp", "syelh", "syem", "syeb", "syebs", "syes", "syess", "syeng", "syej", "syec", "syek", "syet", "syep", "syeh", "so", "sog", "sogg", "sogs", "son", "sonj", "sonh", "sod", "sol", "solg", "solm", "solb", "sols", "solt", "solp", "solh", "som", "sob", "sobs", "sos", "soss", "song", "soj", "soc", "sok", "sot", "sop", "soh", "swa", "swag", "swagg", "swags", "swan", "swanj", "swanh", "swad", "swal", "swalg", "swalm", "swalb", "swals", "swalt", "swalp", "swalh", "swam", "swab", "swabs", "swas", "swass", "swang", "swaj", "swac", "swak", "swat", "swap", "swah", "swae", "swaeg", "swaegg", "swaegs", "swaen", "swaenj", "swaenh", "swaed", "swael", "swaelg", "swaelm", "swaelb", "swaels", "swaelt", "swaelp", "swaelh", "swaem", "swaeb", "swaebs", "swaes", "swaess", "swaeng", "swaej", "swaec", "swaek", "swaet", "swaep", "swaeh", "soe", "soeg", "soegg", "soegs", "soen", "soenj", "soenh", "soed", "soel", "soelg", "soelm", "soelb", "soels", "soelt", "soelp", "soelh", "soem", "soeb", "soebs", "soes", "soess", "soeng", "soej", "soec", "soek", "soet", "soep", "soeh", "syo", "syog", "syogg", "syogs"];
  }
});

// node_modules/unidecode/data/xc2.js
var require_xc2 = __commonJS({
  "node_modules/unidecode/data/xc2.js"(exports, module2) {
    module2.exports = ["syon", "syonj", "syonh", "syod", "syol", "syolg", "syolm", "syolb", "syols", "syolt", "syolp", "syolh", "syom", "syob", "syobs", "syos", "syoss", "syong", "syoj", "syoc", "syok", "syot", "syop", "syoh", "su", "sug", "sugg", "sugs", "sun", "sunj", "sunh", "sud", "sul", "sulg", "sulm", "sulb", "suls", "sult", "sulp", "sulh", "sum", "sub", "subs", "sus", "suss", "sung", "suj", "suc", "suk", "sut", "sup", "suh", "sweo", "sweog", "sweogg", "sweogs", "sweon", "sweonj", "sweonh", "sweod", "sweol", "sweolg", "sweolm", "sweolb", "sweols", "sweolt", "sweolp", "sweolh", "sweom", "sweob", "sweobs", "sweos", "sweoss", "sweong", "sweoj", "sweoc", "sweok", "sweot", "sweop", "sweoh", "swe", "sweg", "swegg", "swegs", "swen", "swenj", "swenh", "swed", "swel", "swelg", "swelm", "swelb", "swels", "swelt", "swelp", "swelh", "swem", "sweb", "swebs", "swes", "swess", "sweng", "swej", "swec", "swek", "swet", "swep", "sweh", "swi", "swig", "swigg", "swigs", "swin", "swinj", "swinh", "swid", "swil", "swilg", "swilm", "swilb", "swils", "swilt", "swilp", "swilh", "swim", "swib", "swibs", "swis", "swiss", "swing", "swij", "swic", "swik", "swit", "swip", "swih", "syu", "syug", "syugg", "syugs", "syun", "syunj", "syunh", "syud", "syul", "syulg", "syulm", "syulb", "syuls", "syult", "syulp", "syulh", "syum", "syub", "syubs", "syus", "syuss", "syung", "syuj", "syuc", "syuk", "syut", "syup", "syuh", "seu", "seug", "seugg", "seugs", "seun", "seunj", "seunh", "seud", "seul", "seulg", "seulm", "seulb", "seuls", "seult", "seulp", "seulh", "seum", "seub", "seubs", "seus", "seuss", "seung", "seuj", "seuc", "seuk", "seut", "seup", "seuh", "syi", "syig", "syigg", "syigs", "syin", "syinj", "syinh", "syid", "syil", "syilg", "syilm", "syilb", "syils", "syilt", "syilp", "syilh", "syim", "syib", "syibs", "syis", "syiss", "sying", "syij", "syic", "syik", "syit", "syip", "syih", "si", "sig", "sigg", "sigs", "sin", "sinj", "sinh", "sid", "sil", "silg", "silm", "silb", "sils", "silt", "silp", "silh", "sim", "sib", "sibs", "sis", "siss", "sing", "sij", "sic", "sik", "sit", "sip", "sih", "ssa", "ssag", "ssagg", "ssags", "ssan", "ssanj", "ssanh", "ssad"];
  }
});

// node_modules/unidecode/data/xc3.js
var require_xc3 = __commonJS({
  "node_modules/unidecode/data/xc3.js"(exports, module2) {
    module2.exports = ["ssal", "ssalg", "ssalm", "ssalb", "ssals", "ssalt", "ssalp", "ssalh", "ssam", "ssab", "ssabs", "ssas", "ssass", "ssang", "ssaj", "ssac", "ssak", "ssat", "ssap", "ssah", "ssae", "ssaeg", "ssaegg", "ssaegs", "ssaen", "ssaenj", "ssaenh", "ssaed", "ssael", "ssaelg", "ssaelm", "ssaelb", "ssaels", "ssaelt", "ssaelp", "ssaelh", "ssaem", "ssaeb", "ssaebs", "ssaes", "ssaess", "ssaeng", "ssaej", "ssaec", "ssaek", "ssaet", "ssaep", "ssaeh", "ssya", "ssyag", "ssyagg", "ssyags", "ssyan", "ssyanj", "ssyanh", "ssyad", "ssyal", "ssyalg", "ssyalm", "ssyalb", "ssyals", "ssyalt", "ssyalp", "ssyalh", "ssyam", "ssyab", "ssyabs", "ssyas", "ssyass", "ssyang", "ssyaj", "ssyac", "ssyak", "ssyat", "ssyap", "ssyah", "ssyae", "ssyaeg", "ssyaegg", "ssyaegs", "ssyaen", "ssyaenj", "ssyaenh", "ssyaed", "ssyael", "ssyaelg", "ssyaelm", "ssyaelb", "ssyaels", "ssyaelt", "ssyaelp", "ssyaelh", "ssyaem", "ssyaeb", "ssyaebs", "ssyaes", "ssyaess", "ssyaeng", "ssyaej", "ssyaec", "ssyaek", "ssyaet", "ssyaep", "ssyaeh", "sseo", "sseog", "sseogg", "sseogs", "sseon", "sseonj", "sseonh", "sseod", "sseol", "sseolg", "sseolm", "sseolb", "sseols", "sseolt", "sseolp", "sseolh", "sseom", "sseob", "sseobs", "sseos", "sseoss", "sseong", "sseoj", "sseoc", "sseok", "sseot", "sseop", "sseoh", "sse", "sseg", "ssegg", "ssegs", "ssen", "ssenj", "ssenh", "ssed", "ssel", "sselg", "sselm", "sselb", "ssels", "sselt", "sselp", "sselh", "ssem", "sseb", "ssebs", "sses", "ssess", "sseng", "ssej", "ssec", "ssek", "sset", "ssep", "sseh", "ssyeo", "ssyeog", "ssyeogg", "ssyeogs", "ssyeon", "ssyeonj", "ssyeonh", "ssyeod", "ssyeol", "ssyeolg", "ssyeolm", "ssyeolb", "ssyeols", "ssyeolt", "ssyeolp", "ssyeolh", "ssyeom", "ssyeob", "ssyeobs", "ssyeos", "ssyeoss", "ssyeong", "ssyeoj", "ssyeoc", "ssyeok", "ssyeot", "ssyeop", "ssyeoh", "ssye", "ssyeg", "ssyegg", "ssyegs", "ssyen", "ssyenj", "ssyenh", "ssyed", "ssyel", "ssyelg", "ssyelm", "ssyelb", "ssyels", "ssyelt", "ssyelp", "ssyelh", "ssyem", "ssyeb", "ssyebs", "ssyes", "ssyess", "ssyeng", "ssyej", "ssyec", "ssyek", "ssyet", "ssyep", "ssyeh", "sso", "ssog", "ssogg", "ssogs", "sson", "ssonj", "ssonh", "ssod", "ssol", "ssolg", "ssolm", "ssolb", "ssols", "ssolt", "ssolp", "ssolh", "ssom", "ssob", "ssobs", "ssos", "ssoss", "ssong", "ssoj", "ssoc", "ssok", "ssot", "ssop", "ssoh", "sswa", "sswag", "sswagg", "sswags", "sswan", "sswanj", "sswanh", "sswad", "sswal", "sswalg", "sswalm", "sswalb"];
  }
});

// node_modules/unidecode/data/xc4.js
var require_xc4 = __commonJS({
  "node_modules/unidecode/data/xc4.js"(exports, module2) {
    module2.exports = ["sswals", "sswalt", "sswalp", "sswalh", "sswam", "sswab", "sswabs", "sswas", "sswass", "sswang", "sswaj", "sswac", "sswak", "sswat", "sswap", "sswah", "sswae", "sswaeg", "sswaegg", "sswaegs", "sswaen", "sswaenj", "sswaenh", "sswaed", "sswael", "sswaelg", "sswaelm", "sswaelb", "sswaels", "sswaelt", "sswaelp", "sswaelh", "sswaem", "sswaeb", "sswaebs", "sswaes", "sswaess", "sswaeng", "sswaej", "sswaec", "sswaek", "sswaet", "sswaep", "sswaeh", "ssoe", "ssoeg", "ssoegg", "ssoegs", "ssoen", "ssoenj", "ssoenh", "ssoed", "ssoel", "ssoelg", "ssoelm", "ssoelb", "ssoels", "ssoelt", "ssoelp", "ssoelh", "ssoem", "ssoeb", "ssoebs", "ssoes", "ssoess", "ssoeng", "ssoej", "ssoec", "ssoek", "ssoet", "ssoep", "ssoeh", "ssyo", "ssyog", "ssyogg", "ssyogs", "ssyon", "ssyonj", "ssyonh", "ssyod", "ssyol", "ssyolg", "ssyolm", "ssyolb", "ssyols", "ssyolt", "ssyolp", "ssyolh", "ssyom", "ssyob", "ssyobs", "ssyos", "ssyoss", "ssyong", "ssyoj", "ssyoc", "ssyok", "ssyot", "ssyop", "ssyoh", "ssu", "ssug", "ssugg", "ssugs", "ssun", "ssunj", "ssunh", "ssud", "ssul", "ssulg", "ssulm", "ssulb", "ssuls", "ssult", "ssulp", "ssulh", "ssum", "ssub", "ssubs", "ssus", "ssuss", "ssung", "ssuj", "ssuc", "ssuk", "ssut", "ssup", "ssuh", "ssweo", "ssweog", "ssweogg", "ssweogs", "ssweon", "ssweonj", "ssweonh", "ssweod", "ssweol", "ssweolg", "ssweolm", "ssweolb", "ssweols", "ssweolt", "ssweolp", "ssweolh", "ssweom", "ssweob", "ssweobs", "ssweos", "ssweoss", "ssweong", "ssweoj", "ssweoc", "ssweok", "ssweot", "ssweop", "ssweoh", "sswe", "ssweg", "sswegg", "sswegs", "sswen", "sswenj", "sswenh", "sswed", "sswel", "sswelg", "sswelm", "sswelb", "sswels", "sswelt", "sswelp", "sswelh", "sswem", "ssweb", "sswebs", "sswes", "sswess", "ssweng", "sswej", "sswec", "sswek", "sswet", "sswep", "ssweh", "sswi", "sswig", "sswigg", "sswigs", "sswin", "sswinj", "sswinh", "sswid", "sswil", "sswilg", "sswilm", "sswilb", "sswils", "sswilt", "sswilp", "sswilh", "sswim", "sswib", "sswibs", "sswis", "sswiss", "sswing", "sswij", "sswic", "sswik", "sswit", "sswip", "sswih", "ssyu", "ssyug", "ssyugg", "ssyugs", "ssyun", "ssyunj", "ssyunh", "ssyud", "ssyul", "ssyulg", "ssyulm", "ssyulb", "ssyuls", "ssyult", "ssyulp", "ssyulh", "ssyum", "ssyub", "ssyubs", "ssyus", "ssyuss", "ssyung", "ssyuj", "ssyuc", "ssyuk", "ssyut", "ssyup", "ssyuh", "sseu", "sseug", "sseugg", "sseugs", "sseun", "sseunj", "sseunh", "sseud", "sseul", "sseulg", "sseulm", "sseulb", "sseuls", "sseult", "sseulp", "sseulh"];
  }
});

// node_modules/unidecode/data/xc5.js
var require_xc5 = __commonJS({
  "node_modules/unidecode/data/xc5.js"(exports, module2) {
    module2.exports = ["sseum", "sseub", "sseubs", "sseus", "sseuss", "sseung", "sseuj", "sseuc", "sseuk", "sseut", "sseup", "sseuh", "ssyi", "ssyig", "ssyigg", "ssyigs", "ssyin", "ssyinj", "ssyinh", "ssyid", "ssyil", "ssyilg", "ssyilm", "ssyilb", "ssyils", "ssyilt", "ssyilp", "ssyilh", "ssyim", "ssyib", "ssyibs", "ssyis", "ssyiss", "ssying", "ssyij", "ssyic", "ssyik", "ssyit", "ssyip", "ssyih", "ssi", "ssig", "ssigg", "ssigs", "ssin", "ssinj", "ssinh", "ssid", "ssil", "ssilg", "ssilm", "ssilb", "ssils", "ssilt", "ssilp", "ssilh", "ssim", "ssib", "ssibs", "ssis", "ssiss", "ssing", "ssij", "ssic", "ssik", "ssit", "ssip", "ssih", "a", "ag", "agg", "ags", "an", "anj", "anh", "ad", "al", "alg", "alm", "alb", "als", "alt", "alp", "alh", "am", "ab", "abs", "as", "ass", "ang", "aj", "ac", "ak", "at", "ap", "ah", "ae", "aeg", "aegg", "aegs", "aen", "aenj", "aenh", "aed", "ael", "aelg", "aelm", "aelb", "aels", "aelt", "aelp", "aelh", "aem", "aeb", "aebs", "aes", "aess", "aeng", "aej", "aec", "aek", "aet", "aep", "aeh", "ya", "yag", "yagg", "yags", "yan", "yanj", "yanh", "yad", "yal", "yalg", "yalm", "yalb", "yals", "yalt", "yalp", "yalh", "yam", "yab", "yabs", "yas", "yass", "yang", "yaj", "yac", "yak", "yat", "yap", "yah", "yae", "yaeg", "yaegg", "yaegs", "yaen", "yaenj", "yaenh", "yaed", "yael", "yaelg", "yaelm", "yaelb", "yaels", "yaelt", "yaelp", "yaelh", "yaem", "yaeb", "yaebs", "yaes", "yaess", "yaeng", "yaej", "yaec", "yaek", "yaet", "yaep", "yaeh", "eo", "eog", "eogg", "eogs", "eon", "eonj", "eonh", "eod", "eol", "eolg", "eolm", "eolb", "eols", "eolt", "eolp", "eolh", "eom", "eob", "eobs", "eos", "eoss", "eong", "eoj", "eoc", "eok", "eot", "eop", "eoh", "e", "eg", "egg", "egs", "en", "enj", "enh", "ed", "el", "elg", "elm", "elb", "els", "elt", "elp", "elh", "em", "eb", "ebs", "es", "ess", "eng", "ej", "ec", "ek", "et", "ep", "eh", "yeo", "yeog", "yeogg", "yeogs", "yeon", "yeonj", "yeonh", "yeod", "yeol", "yeolg", "yeolm", "yeolb", "yeols", "yeolt", "yeolp", "yeolh", "yeom", "yeob", "yeobs", "yeos"];
  }
});

// node_modules/unidecode/data/xc6.js
var require_xc6 = __commonJS({
  "node_modules/unidecode/data/xc6.js"(exports, module2) {
    module2.exports = ["yeoss", "yeong", "yeoj", "yeoc", "yeok", "yeot", "yeop", "yeoh", "ye", "yeg", "yegg", "yegs", "yen", "yenj", "yenh", "yed", "yel", "yelg", "yelm", "yelb", "yels", "yelt", "yelp", "yelh", "yem", "yeb", "yebs", "yes", "yess", "yeng", "yej", "yec", "yek", "yet", "yep", "yeh", "o", "og", "ogg", "ogs", "on", "onj", "onh", "od", "ol", "olg", "olm", "olb", "ols", "olt", "olp", "olh", "om", "ob", "obs", "os", "oss", "ong", "oj", "oc", "ok", "ot", "op", "oh", "wa", "wag", "wagg", "wags", "wan", "wanj", "wanh", "wad", "wal", "walg", "walm", "walb", "wals", "walt", "walp", "walh", "wam", "wab", "wabs", "was", "wass", "wang", "waj", "wac", "wak", "wat", "wap", "wah", "wae", "waeg", "waegg", "waegs", "waen", "waenj", "waenh", "waed", "wael", "waelg", "waelm", "waelb", "waels", "waelt", "waelp", "waelh", "waem", "waeb", "waebs", "waes", "waess", "waeng", "waej", "waec", "waek", "waet", "waep", "waeh", "oe", "oeg", "oegg", "oegs", "oen", "oenj", "oenh", "oed", "oel", "oelg", "oelm", "oelb", "oels", "oelt", "oelp", "oelh", "oem", "oeb", "oebs", "oes", "oess", "oeng", "oej", "oec", "oek", "oet", "oep", "oeh", "yo", "yog", "yogg", "yogs", "yon", "yonj", "yonh", "yod", "yol", "yolg", "yolm", "yolb", "yols", "yolt", "yolp", "yolh", "yom", "yob", "yobs", "yos", "yoss", "yong", "yoj", "yoc", "yok", "yot", "yop", "yoh", "u", "ug", "ugg", "ugs", "un", "unj", "unh", "ud", "ul", "ulg", "ulm", "ulb", "uls", "ult", "ulp", "ulh", "um", "ub", "ubs", "us", "uss", "ung", "uj", "uc", "uk", "ut", "up", "uh", "weo", "weog", "weogg", "weogs", "weon", "weonj", "weonh", "weod", "weol", "weolg", "weolm", "weolb", "weols", "weolt", "weolp", "weolh", "weom", "weob", "weobs", "weos", "weoss", "weong", "weoj", "weoc", "weok", "weot", "weop", "weoh", "we", "weg", "wegg", "wegs", "wen", "wenj", "wenh", "wed", "wel", "welg", "welm", "welb", "wels", "welt", "welp", "welh", "wem", "web", "webs", "wes", "wess", "weng", "wej", "wec"];
  }
});

// node_modules/unidecode/data/xc7.js
var require_xc7 = __commonJS({
  "node_modules/unidecode/data/xc7.js"(exports, module2) {
    module2.exports = ["wek", "wet", "wep", "weh", "wi", "wig", "wigg", "wigs", "win", "winj", "winh", "wid", "wil", "wilg", "wilm", "wilb", "wils", "wilt", "wilp", "wilh", "wim", "wib", "wibs", "wis", "wiss", "wing", "wij", "wic", "wik", "wit", "wip", "wih", "yu", "yug", "yugg", "yugs", "yun", "yunj", "yunh", "yud", "yul", "yulg", "yulm", "yulb", "yuls", "yult", "yulp", "yulh", "yum", "yub", "yubs", "yus", "yuss", "yung", "yuj", "yuc", "yuk", "yut", "yup", "yuh", "eu", "eug", "eugg", "eugs", "eun", "eunj", "eunh", "eud", "eul", "eulg", "eulm", "eulb", "euls", "eult", "eulp", "eulh", "eum", "eub", "eubs", "eus", "euss", "eung", "euj", "euc", "euk", "eut", "eup", "euh", "yi", "yig", "yigg", "yigs", "yin", "yinj", "yinh", "yid", "yil", "yilg", "yilm", "yilb", "yils", "yilt", "yilp", "yilh", "yim", "yib", "yibs", "yis", "yiss", "ying", "yij", "yic", "yik", "yit", "yip", "yih", "i", "ig", "igg", "igs", "in", "inj", "inh", "id", "il", "ilg", "ilm", "ilb", "ils", "ilt", "ilp", "ilh", "im", "ib", "ibs", "is", "iss", "ing", "ij", "ic", "ik", "it", "ip", "ih", "ja", "jag", "jagg", "jags", "jan", "janj", "janh", "jad", "jal", "jalg", "jalm", "jalb", "jals", "jalt", "jalp", "jalh", "jam", "jab", "jabs", "jas", "jass", "jang", "jaj", "jac", "jak", "jat", "jap", "jah", "jae", "jaeg", "jaegg", "jaegs", "jaen", "jaenj", "jaenh", "jaed", "jael", "jaelg", "jaelm", "jaelb", "jaels", "jaelt", "jaelp", "jaelh", "jaem", "jaeb", "jaebs", "jaes", "jaess", "jaeng", "jaej", "jaec", "jaek", "jaet", "jaep", "jaeh", "jya", "jyag", "jyagg", "jyags", "jyan", "jyanj", "jyanh", "jyad", "jyal", "jyalg", "jyalm", "jyalb", "jyals", "jyalt", "jyalp", "jyalh", "jyam", "jyab", "jyabs", "jyas", "jyass", "jyang", "jyaj", "jyac", "jyak", "jyat", "jyap", "jyah", "jyae", "jyaeg", "jyaegg", "jyaegs", "jyaen", "jyaenj", "jyaenh", "jyaed", "jyael", "jyaelg", "jyaelm", "jyaelb", "jyaels", "jyaelt", "jyaelp", "jyaelh", "jyaem", "jyaeb", "jyaebs", "jyaes", "jyaess", "jyaeng", "jyaej", "jyaec", "jyaek", "jyaet", "jyaep", "jyaeh"];
  }
});

// node_modules/unidecode/data/xc8.js
var require_xc8 = __commonJS({
  "node_modules/unidecode/data/xc8.js"(exports, module2) {
    module2.exports = ["jeo", "jeog", "jeogg", "jeogs", "jeon", "jeonj", "jeonh", "jeod", "jeol", "jeolg", "jeolm", "jeolb", "jeols", "jeolt", "jeolp", "jeolh", "jeom", "jeob", "jeobs", "jeos", "jeoss", "jeong", "jeoj", "jeoc", "jeok", "jeot", "jeop", "jeoh", "je", "jeg", "jegg", "jegs", "jen", "jenj", "jenh", "jed", "jel", "jelg", "jelm", "jelb", "jels", "jelt", "jelp", "jelh", "jem", "jeb", "jebs", "jes", "jess", "jeng", "jej", "jec", "jek", "jet", "jep", "jeh", "jyeo", "jyeog", "jyeogg", "jyeogs", "jyeon", "jyeonj", "jyeonh", "jyeod", "jyeol", "jyeolg", "jyeolm", "jyeolb", "jyeols", "jyeolt", "jyeolp", "jyeolh", "jyeom", "jyeob", "jyeobs", "jyeos", "jyeoss", "jyeong", "jyeoj", "jyeoc", "jyeok", "jyeot", "jyeop", "jyeoh", "jye", "jyeg", "jyegg", "jyegs", "jyen", "jyenj", "jyenh", "jyed", "jyel", "jyelg", "jyelm", "jyelb", "jyels", "jyelt", "jyelp", "jyelh", "jyem", "jyeb", "jyebs", "jyes", "jyess", "jyeng", "jyej", "jyec", "jyek", "jyet", "jyep", "jyeh", "jo", "jog", "jogg", "jogs", "jon", "jonj", "jonh", "jod", "jol", "jolg", "jolm", "jolb", "jols", "jolt", "jolp", "jolh", "jom", "job", "jobs", "jos", "joss", "jong", "joj", "joc", "jok", "jot", "jop", "joh", "jwa", "jwag", "jwagg", "jwags", "jwan", "jwanj", "jwanh", "jwad", "jwal", "jwalg", "jwalm", "jwalb", "jwals", "jwalt", "jwalp", "jwalh", "jwam", "jwab", "jwabs", "jwas", "jwass", "jwang", "jwaj", "jwac", "jwak", "jwat", "jwap", "jwah", "jwae", "jwaeg", "jwaegg", "jwaegs", "jwaen", "jwaenj", "jwaenh", "jwaed", "jwael", "jwaelg", "jwaelm", "jwaelb", "jwaels", "jwaelt", "jwaelp", "jwaelh", "jwaem", "jwaeb", "jwaebs", "jwaes", "jwaess", "jwaeng", "jwaej", "jwaec", "jwaek", "jwaet", "jwaep", "jwaeh", "joe", "joeg", "joegg", "joegs", "joen", "joenj", "joenh", "joed", "joel", "joelg", "joelm", "joelb", "joels", "joelt", "joelp", "joelh", "joem", "joeb", "joebs", "joes", "joess", "joeng", "joej", "joec", "joek", "joet", "joep", "joeh", "jyo", "jyog", "jyogg", "jyogs", "jyon", "jyonj", "jyonh", "jyod", "jyol", "jyolg", "jyolm", "jyolb", "jyols", "jyolt", "jyolp", "jyolh", "jyom", "jyob", "jyobs", "jyos", "jyoss", "jyong", "jyoj", "jyoc", "jyok", "jyot", "jyop", "jyoh", "ju", "jug", "jugg", "jugs"];
  }
});

// node_modules/unidecode/data/xc9.js
var require_xc9 = __commonJS({
  "node_modules/unidecode/data/xc9.js"(exports, module2) {
    module2.exports = ["jun", "junj", "junh", "jud", "jul", "julg", "julm", "julb", "juls", "jult", "julp", "julh", "jum", "jub", "jubs", "jus", "juss", "jung", "juj", "juc", "juk", "jut", "jup", "juh", "jweo", "jweog", "jweogg", "jweogs", "jweon", "jweonj", "jweonh", "jweod", "jweol", "jweolg", "jweolm", "jweolb", "jweols", "jweolt", "jweolp", "jweolh", "jweom", "jweob", "jweobs", "jweos", "jweoss", "jweong", "jweoj", "jweoc", "jweok", "jweot", "jweop", "jweoh", "jwe", "jweg", "jwegg", "jwegs", "jwen", "jwenj", "jwenh", "jwed", "jwel", "jwelg", "jwelm", "jwelb", "jwels", "jwelt", "jwelp", "jwelh", "jwem", "jweb", "jwebs", "jwes", "jwess", "jweng", "jwej", "jwec", "jwek", "jwet", "jwep", "jweh", "jwi", "jwig", "jwigg", "jwigs", "jwin", "jwinj", "jwinh", "jwid", "jwil", "jwilg", "jwilm", "jwilb", "jwils", "jwilt", "jwilp", "jwilh", "jwim", "jwib", "jwibs", "jwis", "jwiss", "jwing", "jwij", "jwic", "jwik", "jwit", "jwip", "jwih", "jyu", "jyug", "jyugg", "jyugs", "jyun", "jyunj", "jyunh", "jyud", "jyul", "jyulg", "jyulm", "jyulb", "jyuls", "jyult", "jyulp", "jyulh", "jyum", "jyub", "jyubs", "jyus", "jyuss", "jyung", "jyuj", "jyuc", "jyuk", "jyut", "jyup", "jyuh", "jeu", "jeug", "jeugg", "jeugs", "jeun", "jeunj", "jeunh", "jeud", "jeul", "jeulg", "jeulm", "jeulb", "jeuls", "jeult", "jeulp", "jeulh", "jeum", "jeub", "jeubs", "jeus", "jeuss", "jeung", "jeuj", "jeuc", "jeuk", "jeut", "jeup", "jeuh", "jyi", "jyig", "jyigg", "jyigs", "jyin", "jyinj", "jyinh", "jyid", "jyil", "jyilg", "jyilm", "jyilb", "jyils", "jyilt", "jyilp", "jyilh", "jyim", "jyib", "jyibs", "jyis", "jyiss", "jying", "jyij", "jyic", "jyik", "jyit", "jyip", "jyih", "ji", "jig", "jigg", "jigs", "jin", "jinj", "jinh", "jid", "jil", "jilg", "jilm", "jilb", "jils", "jilt", "jilp", "jilh", "jim", "jib", "jibs", "jis", "jiss", "jing", "jij", "jic", "jik", "jit", "jip", "jih", "jja", "jjag", "jjagg", "jjags", "jjan", "jjanj", "jjanh", "jjad", "jjal", "jjalg", "jjalm", "jjalb", "jjals", "jjalt", "jjalp", "jjalh", "jjam", "jjab", "jjabs", "jjas", "jjass", "jjang", "jjaj", "jjac", "jjak", "jjat", "jjap", "jjah", "jjae", "jjaeg", "jjaegg", "jjaegs", "jjaen", "jjaenj", "jjaenh", "jjaed"];
  }
});

// node_modules/unidecode/data/xca.js
var require_xca = __commonJS({
  "node_modules/unidecode/data/xca.js"(exports, module2) {
    module2.exports = ["jjael", "jjaelg", "jjaelm", "jjaelb", "jjaels", "jjaelt", "jjaelp", "jjaelh", "jjaem", "jjaeb", "jjaebs", "jjaes", "jjaess", "jjaeng", "jjaej", "jjaec", "jjaek", "jjaet", "jjaep", "jjaeh", "jjya", "jjyag", "jjyagg", "jjyags", "jjyan", "jjyanj", "jjyanh", "jjyad", "jjyal", "jjyalg", "jjyalm", "jjyalb", "jjyals", "jjyalt", "jjyalp", "jjyalh", "jjyam", "jjyab", "jjyabs", "jjyas", "jjyass", "jjyang", "jjyaj", "jjyac", "jjyak", "jjyat", "jjyap", "jjyah", "jjyae", "jjyaeg", "jjyaegg", "jjyaegs", "jjyaen", "jjyaenj", "jjyaenh", "jjyaed", "jjyael", "jjyaelg", "jjyaelm", "jjyaelb", "jjyaels", "jjyaelt", "jjyaelp", "jjyaelh", "jjyaem", "jjyaeb", "jjyaebs", "jjyaes", "jjyaess", "jjyaeng", "jjyaej", "jjyaec", "jjyaek", "jjyaet", "jjyaep", "jjyaeh", "jjeo", "jjeog", "jjeogg", "jjeogs", "jjeon", "jjeonj", "jjeonh", "jjeod", "jjeol", "jjeolg", "jjeolm", "jjeolb", "jjeols", "jjeolt", "jjeolp", "jjeolh", "jjeom", "jjeob", "jjeobs", "jjeos", "jjeoss", "jjeong", "jjeoj", "jjeoc", "jjeok", "jjeot", "jjeop", "jjeoh", "jje", "jjeg", "jjegg", "jjegs", "jjen", "jjenj", "jjenh", "jjed", "jjel", "jjelg", "jjelm", "jjelb", "jjels", "jjelt", "jjelp", "jjelh", "jjem", "jjeb", "jjebs", "jjes", "jjess", "jjeng", "jjej", "jjec", "jjek", "jjet", "jjep", "jjeh", "jjyeo", "jjyeog", "jjyeogg", "jjyeogs", "jjyeon", "jjyeonj", "jjyeonh", "jjyeod", "jjyeol", "jjyeolg", "jjyeolm", "jjyeolb", "jjyeols", "jjyeolt", "jjyeolp", "jjyeolh", "jjyeom", "jjyeob", "jjyeobs", "jjyeos", "jjyeoss", "jjyeong", "jjyeoj", "jjyeoc", "jjyeok", "jjyeot", "jjyeop", "jjyeoh", "jjye", "jjyeg", "jjyegg", "jjyegs", "jjyen", "jjyenj", "jjyenh", "jjyed", "jjyel", "jjyelg", "jjyelm", "jjyelb", "jjyels", "jjyelt", "jjyelp", "jjyelh", "jjyem", "jjyeb", "jjyebs", "jjyes", "jjyess", "jjyeng", "jjyej", "jjyec", "jjyek", "jjyet", "jjyep", "jjyeh", "jjo", "jjog", "jjogg", "jjogs", "jjon", "jjonj", "jjonh", "jjod", "jjol", "jjolg", "jjolm", "jjolb", "jjols", "jjolt", "jjolp", "jjolh", "jjom", "jjob", "jjobs", "jjos", "jjoss", "jjong", "jjoj", "jjoc", "jjok", "jjot", "jjop", "jjoh", "jjwa", "jjwag", "jjwagg", "jjwags", "jjwan", "jjwanj", "jjwanh", "jjwad", "jjwal", "jjwalg", "jjwalm", "jjwalb", "jjwals", "jjwalt", "jjwalp", "jjwalh", "jjwam", "jjwab", "jjwabs", "jjwas", "jjwass", "jjwang", "jjwaj", "jjwac", "jjwak", "jjwat", "jjwap", "jjwah", "jjwae", "jjwaeg", "jjwaegg", "jjwaegs", "jjwaen", "jjwaenj", "jjwaenh", "jjwaed", "jjwael", "jjwaelg", "jjwaelm", "jjwaelb"];
  }
});

// node_modules/unidecode/data/xcb.js
var require_xcb = __commonJS({
  "node_modules/unidecode/data/xcb.js"(exports, module2) {
    module2.exports = ["jjwaels", "jjwaelt", "jjwaelp", "jjwaelh", "jjwaem", "jjwaeb", "jjwaebs", "jjwaes", "jjwaess", "jjwaeng", "jjwaej", "jjwaec", "jjwaek", "jjwaet", "jjwaep", "jjwaeh", "jjoe", "jjoeg", "jjoegg", "jjoegs", "jjoen", "jjoenj", "jjoenh", "jjoed", "jjoel", "jjoelg", "jjoelm", "jjoelb", "jjoels", "jjoelt", "jjoelp", "jjoelh", "jjoem", "jjoeb", "jjoebs", "jjoes", "jjoess", "jjoeng", "jjoej", "jjoec", "jjoek", "jjoet", "jjoep", "jjoeh", "jjyo", "jjyog", "jjyogg", "jjyogs", "jjyon", "jjyonj", "jjyonh", "jjyod", "jjyol", "jjyolg", "jjyolm", "jjyolb", "jjyols", "jjyolt", "jjyolp", "jjyolh", "jjyom", "jjyob", "jjyobs", "jjyos", "jjyoss", "jjyong", "jjyoj", "jjyoc", "jjyok", "jjyot", "jjyop", "jjyoh", "jju", "jjug", "jjugg", "jjugs", "jjun", "jjunj", "jjunh", "jjud", "jjul", "jjulg", "jjulm", "jjulb", "jjuls", "jjult", "jjulp", "jjulh", "jjum", "jjub", "jjubs", "jjus", "jjuss", "jjung", "jjuj", "jjuc", "jjuk", "jjut", "jjup", "jjuh", "jjweo", "jjweog", "jjweogg", "jjweogs", "jjweon", "jjweonj", "jjweonh", "jjweod", "jjweol", "jjweolg", "jjweolm", "jjweolb", "jjweols", "jjweolt", "jjweolp", "jjweolh", "jjweom", "jjweob", "jjweobs", "jjweos", "jjweoss", "jjweong", "jjweoj", "jjweoc", "jjweok", "jjweot", "jjweop", "jjweoh", "jjwe", "jjweg", "jjwegg", "jjwegs", "jjwen", "jjwenj", "jjwenh", "jjwed", "jjwel", "jjwelg", "jjwelm", "jjwelb", "jjwels", "jjwelt", "jjwelp", "jjwelh", "jjwem", "jjweb", "jjwebs", "jjwes", "jjwess", "jjweng", "jjwej", "jjwec", "jjwek", "jjwet", "jjwep", "jjweh", "jjwi", "jjwig", "jjwigg", "jjwigs", "jjwin", "jjwinj", "jjwinh", "jjwid", "jjwil", "jjwilg", "jjwilm", "jjwilb", "jjwils", "jjwilt", "jjwilp", "jjwilh", "jjwim", "jjwib", "jjwibs", "jjwis", "jjwiss", "jjwing", "jjwij", "jjwic", "jjwik", "jjwit", "jjwip", "jjwih", "jjyu", "jjyug", "jjyugg", "jjyugs", "jjyun", "jjyunj", "jjyunh", "jjyud", "jjyul", "jjyulg", "jjyulm", "jjyulb", "jjyuls", "jjyult", "jjyulp", "jjyulh", "jjyum", "jjyub", "jjyubs", "jjyus", "jjyuss", "jjyung", "jjyuj", "jjyuc", "jjyuk", "jjyut", "jjyup", "jjyuh", "jjeu", "jjeug", "jjeugg", "jjeugs", "jjeun", "jjeunj", "jjeunh", "jjeud", "jjeul", "jjeulg", "jjeulm", "jjeulb", "jjeuls", "jjeult", "jjeulp", "jjeulh", "jjeum", "jjeub", "jjeubs", "jjeus", "jjeuss", "jjeung", "jjeuj", "jjeuc", "jjeuk", "jjeut", "jjeup", "jjeuh", "jjyi", "jjyig", "jjyigg", "jjyigs", "jjyin", "jjyinj", "jjyinh", "jjyid", "jjyil", "jjyilg", "jjyilm", "jjyilb", "jjyils", "jjyilt", "jjyilp", "jjyilh"];
  }
});

// node_modules/unidecode/data/xcc.js
var require_xcc = __commonJS({
  "node_modules/unidecode/data/xcc.js"(exports, module2) {
    module2.exports = ["jjyim", "jjyib", "jjyibs", "jjyis", "jjyiss", "jjying", "jjyij", "jjyic", "jjyik", "jjyit", "jjyip", "jjyih", "jji", "jjig", "jjigg", "jjigs", "jjin", "jjinj", "jjinh", "jjid", "jjil", "jjilg", "jjilm", "jjilb", "jjils", "jjilt", "jjilp", "jjilh", "jjim", "jjib", "jjibs", "jjis", "jjiss", "jjing", "jjij", "jjic", "jjik", "jjit", "jjip", "jjih", "ca", "cag", "cagg", "cags", "can", "canj", "canh", "cad", "cal", "calg", "calm", "calb", "cals", "calt", "calp", "calh", "cam", "cab", "cabs", "cas", "cass", "cang", "caj", "cac", "cak", "cat", "cap", "cah", "cae", "caeg", "caegg", "caegs", "caen", "caenj", "caenh", "caed", "cael", "caelg", "caelm", "caelb", "caels", "caelt", "caelp", "caelh", "caem", "caeb", "caebs", "caes", "caess", "caeng", "caej", "caec", "caek", "caet", "caep", "caeh", "cya", "cyag", "cyagg", "cyags", "cyan", "cyanj", "cyanh", "cyad", "cyal", "cyalg", "cyalm", "cyalb", "cyals", "cyalt", "cyalp", "cyalh", "cyam", "cyab", "cyabs", "cyas", "cyass", "cyang", "cyaj", "cyac", "cyak", "cyat", "cyap", "cyah", "cyae", "cyaeg", "cyaegg", "cyaegs", "cyaen", "cyaenj", "cyaenh", "cyaed", "cyael", "cyaelg", "cyaelm", "cyaelb", "cyaels", "cyaelt", "cyaelp", "cyaelh", "cyaem", "cyaeb", "cyaebs", "cyaes", "cyaess", "cyaeng", "cyaej", "cyaec", "cyaek", "cyaet", "cyaep", "cyaeh", "ceo", "ceog", "ceogg", "ceogs", "ceon", "ceonj", "ceonh", "ceod", "ceol", "ceolg", "ceolm", "ceolb", "ceols", "ceolt", "ceolp", "ceolh", "ceom", "ceob", "ceobs", "ceos", "ceoss", "ceong", "ceoj", "ceoc", "ceok", "ceot", "ceop", "ceoh", "ce", "ceg", "cegg", "cegs", "cen", "cenj", "cenh", "ced", "cel", "celg", "celm", "celb", "cels", "celt", "celp", "celh", "cem", "ceb", "cebs", "ces", "cess", "ceng", "cej", "cec", "cek", "cet", "cep", "ceh", "cyeo", "cyeog", "cyeogg", "cyeogs", "cyeon", "cyeonj", "cyeonh", "cyeod", "cyeol", "cyeolg", "cyeolm", "cyeolb", "cyeols", "cyeolt", "cyeolp", "cyeolh", "cyeom", "cyeob", "cyeobs", "cyeos", "cyeoss", "cyeong", "cyeoj", "cyeoc", "cyeok", "cyeot", "cyeop", "cyeoh", "cye", "cyeg", "cyegg", "cyegs", "cyen", "cyenj", "cyenh", "cyed", "cyel", "cyelg", "cyelm", "cyelb", "cyels", "cyelt", "cyelp", "cyelh", "cyem", "cyeb", "cyebs", "cyes"];
  }
});

// node_modules/unidecode/data/xcd.js
var require_xcd = __commonJS({
  "node_modules/unidecode/data/xcd.js"(exports, module2) {
    module2.exports = ["cyess", "cyeng", "cyej", "cyec", "cyek", "cyet", "cyep", "cyeh", "co", "cog", "cogg", "cogs", "con", "conj", "conh", "cod", "col", "colg", "colm", "colb", "cols", "colt", "colp", "colh", "com", "cob", "cobs", "cos", "coss", "cong", "coj", "coc", "cok", "cot", "cop", "coh", "cwa", "cwag", "cwagg", "cwags", "cwan", "cwanj", "cwanh", "cwad", "cwal", "cwalg", "cwalm", "cwalb", "cwals", "cwalt", "cwalp", "cwalh", "cwam", "cwab", "cwabs", "cwas", "cwass", "cwang", "cwaj", "cwac", "cwak", "cwat", "cwap", "cwah", "cwae", "cwaeg", "cwaegg", "cwaegs", "cwaen", "cwaenj", "cwaenh", "cwaed", "cwael", "cwaelg", "cwaelm", "cwaelb", "cwaels", "cwaelt", "cwaelp", "cwaelh", "cwaem", "cwaeb", "cwaebs", "cwaes", "cwaess", "cwaeng", "cwaej", "cwaec", "cwaek", "cwaet", "cwaep", "cwaeh", "coe", "coeg", "coegg", "coegs", "coen", "coenj", "coenh", "coed", "coel", "coelg", "coelm", "coelb", "coels", "coelt", "coelp", "coelh", "coem", "coeb", "coebs", "coes", "coess", "coeng", "coej", "coec", "coek", "coet", "coep", "coeh", "cyo", "cyog", "cyogg", "cyogs", "cyon", "cyonj", "cyonh", "cyod", "cyol", "cyolg", "cyolm", "cyolb", "cyols", "cyolt", "cyolp", "cyolh", "cyom", "cyob", "cyobs", "cyos", "cyoss", "cyong", "cyoj", "cyoc", "cyok", "cyot", "cyop", "cyoh", "cu", "cug", "cugg", "cugs", "cun", "cunj", "cunh", "cud", "cul", "culg", "culm", "culb", "culs", "cult", "culp", "culh", "cum", "cub", "cubs", "cus", "cuss", "cung", "cuj", "cuc", "cuk", "cut", "cup", "cuh", "cweo", "cweog", "cweogg", "cweogs", "cweon", "cweonj", "cweonh", "cweod", "cweol", "cweolg", "cweolm", "cweolb", "cweols", "cweolt", "cweolp", "cweolh", "cweom", "cweob", "cweobs", "cweos", "cweoss", "cweong", "cweoj", "cweoc", "cweok", "cweot", "cweop", "cweoh", "cwe", "cweg", "cwegg", "cwegs", "cwen", "cwenj", "cwenh", "cwed", "cwel", "cwelg", "cwelm", "cwelb", "cwels", "cwelt", "cwelp", "cwelh", "cwem", "cweb", "cwebs", "cwes", "cwess", "cweng", "cwej", "cwec", "cwek", "cwet", "cwep", "cweh", "cwi", "cwig", "cwigg", "cwigs", "cwin", "cwinj", "cwinh", "cwid", "cwil", "cwilg", "cwilm", "cwilb", "cwils", "cwilt", "cwilp", "cwilh", "cwim", "cwib", "cwibs", "cwis", "cwiss", "cwing", "cwij", "cwic"];
  }
});

// node_modules/unidecode/data/xce.js
var require_xce = __commonJS({
  "node_modules/unidecode/data/xce.js"(exports, module2) {
    module2.exports = ["cwik", "cwit", "cwip", "cwih", "cyu", "cyug", "cyugg", "cyugs", "cyun", "cyunj", "cyunh", "cyud", "cyul", "cyulg", "cyulm", "cyulb", "cyuls", "cyult", "cyulp", "cyulh", "cyum", "cyub", "cyubs", "cyus", "cyuss", "cyung", "cyuj", "cyuc", "cyuk", "cyut", "cyup", "cyuh", "ceu", "ceug", "ceugg", "ceugs", "ceun", "ceunj", "ceunh", "ceud", "ceul", "ceulg", "ceulm", "ceulb", "ceuls", "ceult", "ceulp", "ceulh", "ceum", "ceub", "ceubs", "ceus", "ceuss", "ceung", "ceuj", "ceuc", "ceuk", "ceut", "ceup", "ceuh", "cyi", "cyig", "cyigg", "cyigs", "cyin", "cyinj", "cyinh", "cyid", "cyil", "cyilg", "cyilm", "cyilb", "cyils", "cyilt", "cyilp", "cyilh", "cyim", "cyib", "cyibs", "cyis", "cyiss", "cying", "cyij", "cyic", "cyik", "cyit", "cyip", "cyih", "ci", "cig", "cigg", "cigs", "cin", "cinj", "cinh", "cid", "cil", "cilg", "cilm", "cilb", "cils", "cilt", "cilp", "cilh", "cim", "cib", "cibs", "cis", "ciss", "cing", "cij", "cic", "cik", "cit", "cip", "cih", "ka", "kag", "kagg", "kags", "kan", "kanj", "kanh", "kad", "kal", "kalg", "kalm", "kalb", "kals", "kalt", "kalp", "kalh", "kam", "kab", "kabs", "kas", "kass", "kang", "kaj", "kac", "kak", "kat", "kap", "kah", "kae", "kaeg", "kaegg", "kaegs", "kaen", "kaenj", "kaenh", "kaed", "kael", "kaelg", "kaelm", "kaelb", "kaels", "kaelt", "kaelp", "kaelh", "kaem", "kaeb", "kaebs", "kaes", "kaess", "kaeng", "kaej", "kaec", "kaek", "kaet", "kaep", "kaeh", "kya", "kyag", "kyagg", "kyags", "kyan", "kyanj", "kyanh", "kyad", "kyal", "kyalg", "kyalm", "kyalb", "kyals", "kyalt", "kyalp", "kyalh", "kyam", "kyab", "kyabs", "kyas", "kyass", "kyang", "kyaj", "kyac", "kyak", "kyat", "kyap", "kyah", "kyae", "kyaeg", "kyaegg", "kyaegs", "kyaen", "kyaenj", "kyaenh", "kyaed", "kyael", "kyaelg", "kyaelm", "kyaelb", "kyaels", "kyaelt", "kyaelp", "kyaelh", "kyaem", "kyaeb", "kyaebs", "kyaes", "kyaess", "kyaeng", "kyaej", "kyaec", "kyaek", "kyaet", "kyaep", "kyaeh", "keo", "keog", "keogg", "keogs", "keon", "keonj", "keonh", "keod", "keol", "keolg", "keolm", "keolb", "keols", "keolt", "keolp", "keolh", "keom", "keob", "keobs", "keos", "keoss", "keong", "keoj", "keoc", "keok", "keot", "keop", "keoh"];
  }
});

// node_modules/unidecode/data/xcf.js
var require_xcf = __commonJS({
  "node_modules/unidecode/data/xcf.js"(exports, module2) {
    module2.exports = ["ke", "keg", "kegg", "kegs", "ken", "kenj", "kenh", "ked", "kel", "kelg", "kelm", "kelb", "kels", "kelt", "kelp", "kelh", "kem", "keb", "kebs", "kes", "kess", "keng", "kej", "kec", "kek", "ket", "kep", "keh", "kyeo", "kyeog", "kyeogg", "kyeogs", "kyeon", "kyeonj", "kyeonh", "kyeod", "kyeol", "kyeolg", "kyeolm", "kyeolb", "kyeols", "kyeolt", "kyeolp", "kyeolh", "kyeom", "kyeob", "kyeobs", "kyeos", "kyeoss", "kyeong", "kyeoj", "kyeoc", "kyeok", "kyeot", "kyeop", "kyeoh", "kye", "kyeg", "kyegg", "kyegs", "kyen", "kyenj", "kyenh", "kyed", "kyel", "kyelg", "kyelm", "kyelb", "kyels", "kyelt", "kyelp", "kyelh", "kyem", "kyeb", "kyebs", "kyes", "kyess", "kyeng", "kyej", "kyec", "kyek", "kyet", "kyep", "kyeh", "ko", "kog", "kogg", "kogs", "kon", "konj", "konh", "kod", "kol", "kolg", "kolm", "kolb", "kols", "kolt", "kolp", "kolh", "kom", "kob", "kobs", "kos", "koss", "kong", "koj", "koc", "kok", "kot", "kop", "koh", "kwa", "kwag", "kwagg", "kwags", "kwan", "kwanj", "kwanh", "kwad", "kwal", "kwalg", "kwalm", "kwalb", "kwals", "kwalt", "kwalp", "kwalh", "kwam", "kwab", "kwabs", "kwas", "kwass", "kwang", "kwaj", "kwac", "kwak", "kwat", "kwap", "kwah", "kwae", "kwaeg", "kwaegg", "kwaegs", "kwaen", "kwaenj", "kwaenh", "kwaed", "kwael", "kwaelg", "kwaelm", "kwaelb", "kwaels", "kwaelt", "kwaelp", "kwaelh", "kwaem", "kwaeb", "kwaebs", "kwaes", "kwaess", "kwaeng", "kwaej", "kwaec", "kwaek", "kwaet", "kwaep", "kwaeh", "koe", "koeg", "koegg", "koegs", "koen", "koenj", "koenh", "koed", "koel", "koelg", "koelm", "koelb", "koels", "koelt", "koelp", "koelh", "koem", "koeb", "koebs", "koes", "koess", "koeng", "koej", "koec", "koek", "koet", "koep", "koeh", "kyo", "kyog", "kyogg", "kyogs", "kyon", "kyonj", "kyonh", "kyod", "kyol", "kyolg", "kyolm", "kyolb", "kyols", "kyolt", "kyolp", "kyolh", "kyom", "kyob", "kyobs", "kyos", "kyoss", "kyong", "kyoj", "kyoc", "kyok", "kyot", "kyop", "kyoh", "ku", "kug", "kugg", "kugs", "kun", "kunj", "kunh", "kud", "kul", "kulg", "kulm", "kulb", "kuls", "kult", "kulp", "kulh", "kum", "kub", "kubs", "kus", "kuss", "kung", "kuj", "kuc", "kuk", "kut", "kup", "kuh", "kweo", "kweog", "kweogg", "kweogs"];
  }
});

// node_modules/unidecode/data/xd0.js
var require_xd0 = __commonJS({
  "node_modules/unidecode/data/xd0.js"(exports, module2) {
    module2.exports = ["kweon", "kweonj", "kweonh", "kweod", "kweol", "kweolg", "kweolm", "kweolb", "kweols", "kweolt", "kweolp", "kweolh", "kweom", "kweob", "kweobs", "kweos", "kweoss", "kweong", "kweoj", "kweoc", "kweok", "kweot", "kweop", "kweoh", "kwe", "kweg", "kwegg", "kwegs", "kwen", "kwenj", "kwenh", "kwed", "kwel", "kwelg", "kwelm", "kwelb", "kwels", "kwelt", "kwelp", "kwelh", "kwem", "kweb", "kwebs", "kwes", "kwess", "kweng", "kwej", "kwec", "kwek", "kwet", "kwep", "kweh", "kwi", "kwig", "kwigg", "kwigs", "kwin", "kwinj", "kwinh", "kwid", "kwil", "kwilg", "kwilm", "kwilb", "kwils", "kwilt", "kwilp", "kwilh", "kwim", "kwib", "kwibs", "kwis", "kwiss", "kwing", "kwij", "kwic", "kwik", "kwit", "kwip", "kwih", "kyu", "kyug", "kyugg", "kyugs", "kyun", "kyunj", "kyunh", "kyud", "kyul", "kyulg", "kyulm", "kyulb", "kyuls", "kyult", "kyulp", "kyulh", "kyum", "kyub", "kyubs", "kyus", "kyuss", "kyung", "kyuj", "kyuc", "kyuk", "kyut", "kyup", "kyuh", "keu", "keug", "keugg", "keugs", "keun", "keunj", "keunh", "keud", "keul", "keulg", "keulm", "keulb", "keuls", "keult", "keulp", "keulh", "keum", "keub", "keubs", "keus", "keuss", "keung", "keuj", "keuc", "keuk", "keut", "keup", "keuh", "kyi", "kyig", "kyigg", "kyigs", "kyin", "kyinj", "kyinh", "kyid", "kyil", "kyilg", "kyilm", "kyilb", "kyils", "kyilt", "kyilp", "kyilh", "kyim", "kyib", "kyibs", "kyis", "kyiss", "kying", "kyij", "kyic", "kyik", "kyit", "kyip", "kyih", "ki", "kig", "kigg", "kigs", "kin", "kinj", "kinh", "kid", "kil", "kilg", "kilm", "kilb", "kils", "kilt", "kilp", "kilh", "kim", "kib", "kibs", "kis", "kiss", "king", "kij", "kic", "kik", "kit", "kip", "kih", "ta", "tag", "tagg", "tags", "tan", "tanj", "tanh", "tad", "tal", "talg", "talm", "talb", "tals", "talt", "talp", "talh", "tam", "tab", "tabs", "tas", "tass", "tang", "taj", "tac", "tak", "tat", "tap", "tah", "tae", "taeg", "taegg", "taegs", "taen", "taenj", "taenh", "taed", "tael", "taelg", "taelm", "taelb", "taels", "taelt", "taelp", "taelh", "taem", "taeb", "taebs", "taes", "taess", "taeng", "taej", "taec", "taek", "taet", "taep", "taeh", "tya", "tyag", "tyagg", "tyags", "tyan", "tyanj", "tyanh", "tyad"];
  }
});

// node_modules/unidecode/data/xd1.js
var require_xd1 = __commonJS({
  "node_modules/unidecode/data/xd1.js"(exports, module2) {
    module2.exports = ["tyal", "tyalg", "tyalm", "tyalb", "tyals", "tyalt", "tyalp", "tyalh", "tyam", "tyab", "tyabs", "tyas", "tyass", "tyang", "tyaj", "tyac", "tyak", "tyat", "tyap", "tyah", "tyae", "tyaeg", "tyaegg", "tyaegs", "tyaen", "tyaenj", "tyaenh", "tyaed", "tyael", "tyaelg", "tyaelm", "tyaelb", "tyaels", "tyaelt", "tyaelp", "tyaelh", "tyaem", "tyaeb", "tyaebs", "tyaes", "tyaess", "tyaeng", "tyaej", "tyaec", "tyaek", "tyaet", "tyaep", "tyaeh", "teo", "teog", "teogg", "teogs", "teon", "teonj", "teonh", "teod", "teol", "teolg", "teolm", "teolb", "teols", "teolt", "teolp", "teolh", "teom", "teob", "teobs", "teos", "teoss", "teong", "teoj", "teoc", "teok", "teot", "teop", "teoh", "te", "teg", "tegg", "tegs", "ten", "tenj", "tenh", "ted", "tel", "telg", "telm", "telb", "tels", "telt", "telp", "telh", "tem", "teb", "tebs", "tes", "tess", "teng", "tej", "tec", "tek", "tet", "tep", "teh", "tyeo", "tyeog", "tyeogg", "tyeogs", "tyeon", "tyeonj", "tyeonh", "tyeod", "tyeol", "tyeolg", "tyeolm", "tyeolb", "tyeols", "tyeolt", "tyeolp", "tyeolh", "tyeom", "tyeob", "tyeobs", "tyeos", "tyeoss", "tyeong", "tyeoj", "tyeoc", "tyeok", "tyeot", "tyeop", "tyeoh", "tye", "tyeg", "tyegg", "tyegs", "tyen", "tyenj", "tyenh", "tyed", "tyel", "tyelg", "tyelm", "tyelb", "tyels", "tyelt", "tyelp", "tyelh", "tyem", "tyeb", "tyebs", "tyes", "tyess", "tyeng", "tyej", "tyec", "tyek", "tyet", "tyep", "tyeh", "to", "tog", "togg", "togs", "ton", "tonj", "tonh", "tod", "tol", "tolg", "tolm", "tolb", "tols", "tolt", "tolp", "tolh", "tom", "tob", "tobs", "tos", "toss", "tong", "toj", "toc", "tok", "tot", "top", "toh", "twa", "twag", "twagg", "twags", "twan", "twanj", "twanh", "twad", "twal", "twalg", "twalm", "twalb", "twals", "twalt", "twalp", "twalh", "twam", "twab", "twabs", "twas", "twass", "twang", "twaj", "twac", "twak", "twat", "twap", "twah", "twae", "twaeg", "twaegg", "twaegs", "twaen", "twaenj", "twaenh", "twaed", "twael", "twaelg", "twaelm", "twaelb", "twaels", "twaelt", "twaelp", "twaelh", "twaem", "twaeb", "twaebs", "twaes", "twaess", "twaeng", "twaej", "twaec", "twaek", "twaet", "twaep", "twaeh", "toe", "toeg", "toegg", "toegs", "toen", "toenj", "toenh", "toed", "toel", "toelg", "toelm", "toelb"];
  }
});

// node_modules/unidecode/data/xd2.js
var require_xd2 = __commonJS({
  "node_modules/unidecode/data/xd2.js"(exports, module2) {
    module2.exports = ["toels", "toelt", "toelp", "toelh", "toem", "toeb", "toebs", "toes", "toess", "toeng", "toej", "toec", "toek", "toet", "toep", "toeh", "tyo", "tyog", "tyogg", "tyogs", "tyon", "tyonj", "tyonh", "tyod", "tyol", "tyolg", "tyolm", "tyolb", "tyols", "tyolt", "tyolp", "tyolh", "tyom", "tyob", "tyobs", "tyos", "tyoss", "tyong", "tyoj", "tyoc", "tyok", "tyot", "tyop", "tyoh", "tu", "tug", "tugg", "tugs", "tun", "tunj", "tunh", "tud", "tul", "tulg", "tulm", "tulb", "tuls", "tult", "tulp", "tulh", "tum", "tub", "tubs", "tus", "tuss", "tung", "tuj", "tuc", "tuk", "tut", "tup", "tuh", "tweo", "tweog", "tweogg", "tweogs", "tweon", "tweonj", "tweonh", "tweod", "tweol", "tweolg", "tweolm", "tweolb", "tweols", "tweolt", "tweolp", "tweolh", "tweom", "tweob", "tweobs", "tweos", "tweoss", "tweong", "tweoj", "tweoc", "tweok", "tweot", "tweop", "tweoh", "twe", "tweg", "twegg", "twegs", "twen", "twenj", "twenh", "twed", "twel", "twelg", "twelm", "twelb", "twels", "twelt", "twelp", "twelh", "twem", "tweb", "twebs", "twes", "twess", "tweng", "twej", "twec", "twek", "twet", "twep", "tweh", "twi", "twig", "twigg", "twigs", "twin", "twinj", "twinh", "twid", "twil", "twilg", "twilm", "twilb", "twils", "twilt", "twilp", "twilh", "twim", "twib", "twibs", "twis", "twiss", "twing", "twij", "twic", "twik", "twit", "twip", "twih", "tyu", "tyug", "tyugg", "tyugs", "tyun", "tyunj", "tyunh", "tyud", "tyul", "tyulg", "tyulm", "tyulb", "tyuls", "tyult", "tyulp", "tyulh", "tyum", "tyub", "tyubs", "tyus", "tyuss", "tyung", "tyuj", "tyuc", "tyuk", "tyut", "tyup", "tyuh", "teu", "teug", "teugg", "teugs", "teun", "teunj", "teunh", "teud", "teul", "teulg", "teulm", "teulb", "teuls", "teult", "teulp", "teulh", "teum", "teub", "teubs", "teus", "teuss", "teung", "teuj", "teuc", "teuk", "teut", "teup", "teuh", "tyi", "tyig", "tyigg", "tyigs", "tyin", "tyinj", "tyinh", "tyid", "tyil", "tyilg", "tyilm", "tyilb", "tyils", "tyilt", "tyilp", "tyilh", "tyim", "tyib", "tyibs", "tyis", "tyiss", "tying", "tyij", "tyic", "tyik", "tyit", "tyip", "tyih", "ti", "tig", "tigg", "tigs", "tin", "tinj", "tinh", "tid", "til", "tilg", "tilm", "tilb", "tils", "tilt", "tilp", "tilh"];
  }
});

// node_modules/unidecode/data/xd3.js
var require_xd3 = __commonJS({
  "node_modules/unidecode/data/xd3.js"(exports, module2) {
    module2.exports = ["tim", "tib", "tibs", "tis", "tiss", "ting", "tij", "tic", "tik", "tit", "tip", "tih", "pa", "pag", "pagg", "pags", "pan", "panj", "panh", "pad", "pal", "palg", "palm", "palb", "pals", "palt", "palp", "palh", "pam", "pab", "pabs", "pas", "pass", "pang", "paj", "pac", "pak", "pat", "pap", "pah", "pae", "paeg", "paegg", "paegs", "paen", "paenj", "paenh", "paed", "pael", "paelg", "paelm", "paelb", "paels", "paelt", "paelp", "paelh", "paem", "paeb", "paebs", "paes", "paess", "paeng", "paej", "paec", "paek", "paet", "paep", "paeh", "pya", "pyag", "pyagg", "pyags", "pyan", "pyanj", "pyanh", "pyad", "pyal", "pyalg", "pyalm", "pyalb", "pyals", "pyalt", "pyalp", "pyalh", "pyam", "pyab", "pyabs", "pyas", "pyass", "pyang", "pyaj", "pyac", "pyak", "pyat", "pyap", "pyah", "pyae", "pyaeg", "pyaegg", "pyaegs", "pyaen", "pyaenj", "pyaenh", "pyaed", "pyael", "pyaelg", "pyaelm", "pyaelb", "pyaels", "pyaelt", "pyaelp", "pyaelh", "pyaem", "pyaeb", "pyaebs", "pyaes", "pyaess", "pyaeng", "pyaej", "pyaec", "pyaek", "pyaet", "pyaep", "pyaeh", "peo", "peog", "peogg", "peogs", "peon", "peonj", "peonh", "peod", "peol", "peolg", "peolm", "peolb", "peols", "peolt", "peolp", "peolh", "peom", "peob", "peobs", "peos", "peoss", "peong", "peoj", "peoc", "peok", "peot", "peop", "peoh", "pe", "peg", "pegg", "pegs", "pen", "penj", "penh", "ped", "pel", "pelg", "pelm", "pelb", "pels", "pelt", "pelp", "pelh", "pem", "peb", "pebs", "pes", "pess", "peng", "pej", "pec", "pek", "pet", "pep", "peh", "pyeo", "pyeog", "pyeogg", "pyeogs", "pyeon", "pyeonj", "pyeonh", "pyeod", "pyeol", "pyeolg", "pyeolm", "pyeolb", "pyeols", "pyeolt", "pyeolp", "pyeolh", "pyeom", "pyeob", "pyeobs", "pyeos", "pyeoss", "pyeong", "pyeoj", "pyeoc", "pyeok", "pyeot", "pyeop", "pyeoh", "pye", "pyeg", "pyegg", "pyegs", "pyen", "pyenj", "pyenh", "pyed", "pyel", "pyelg", "pyelm", "pyelb", "pyels", "pyelt", "pyelp", "pyelh", "pyem", "pyeb", "pyebs", "pyes", "pyess", "pyeng", "pyej", "pyec", "pyek", "pyet", "pyep", "pyeh", "po", "pog", "pogg", "pogs", "pon", "ponj", "ponh", "pod", "pol", "polg", "polm", "polb", "pols", "polt", "polp", "polh", "pom", "pob", "pobs", "pos"];
  }
});

// node_modules/unidecode/data/xd4.js
var require_xd4 = __commonJS({
  "node_modules/unidecode/data/xd4.js"(exports, module2) {
    module2.exports = ["poss", "pong", "poj", "poc", "pok", "pot", "pop", "poh", "pwa", "pwag", "pwagg", "pwags", "pwan", "pwanj", "pwanh", "pwad", "pwal", "pwalg", "pwalm", "pwalb", "pwals", "pwalt", "pwalp", "pwalh", "pwam", "pwab", "pwabs", "pwas", "pwass", "pwang", "pwaj", "pwac", "pwak", "pwat", "pwap", "pwah", "pwae", "pwaeg", "pwaegg", "pwaegs", "pwaen", "pwaenj", "pwaenh", "pwaed", "pwael", "pwaelg", "pwaelm", "pwaelb", "pwaels", "pwaelt", "pwaelp", "pwaelh", "pwaem", "pwaeb", "pwaebs", "pwaes", "pwaess", "pwaeng", "pwaej", "pwaec", "pwaek", "pwaet", "pwaep", "pwaeh", "poe", "poeg", "poegg", "poegs", "poen", "poenj", "poenh", "poed", "poel", "poelg", "poelm", "poelb", "poels", "poelt", "poelp", "poelh", "poem", "poeb", "poebs", "poes", "poess", "poeng", "poej", "poec", "poek", "poet", "poep", "poeh", "pyo", "pyog", "pyogg", "pyogs", "pyon", "pyonj", "pyonh", "pyod", "pyol", "pyolg", "pyolm", "pyolb", "pyols", "pyolt", "pyolp", "pyolh", "pyom", "pyob", "pyobs", "pyos", "pyoss", "pyong", "pyoj", "pyoc", "pyok", "pyot", "pyop", "pyoh", "pu", "pug", "pugg", "pugs", "pun", "punj", "punh", "pud", "pul", "pulg", "pulm", "pulb", "puls", "pult", "pulp", "pulh", "pum", "pub", "pubs", "pus", "puss", "pung", "puj", "puc", "puk", "put", "pup", "puh", "pweo", "pweog", "pweogg", "pweogs", "pweon", "pweonj", "pweonh", "pweod", "pweol", "pweolg", "pweolm", "pweolb", "pweols", "pweolt", "pweolp", "pweolh", "pweom", "pweob", "pweobs", "pweos", "pweoss", "pweong", "pweoj", "pweoc", "pweok", "pweot", "pweop", "pweoh", "pwe", "pweg", "pwegg", "pwegs", "pwen", "pwenj", "pwenh", "pwed", "pwel", "pwelg", "pwelm", "pwelb", "pwels", "pwelt", "pwelp", "pwelh", "pwem", "pweb", "pwebs", "pwes", "pwess", "pweng", "pwej", "pwec", "pwek", "pwet", "pwep", "pweh", "pwi", "pwig", "pwigg", "pwigs", "pwin", "pwinj", "pwinh", "pwid", "pwil", "pwilg", "pwilm", "pwilb", "pwils", "pwilt", "pwilp", "pwilh", "pwim", "pwib", "pwibs", "pwis", "pwiss", "pwing", "pwij", "pwic", "pwik", "pwit", "pwip", "pwih", "pyu", "pyug", "pyugg", "pyugs", "pyun", "pyunj", "pyunh", "pyud", "pyul", "pyulg", "pyulm", "pyulb", "pyuls", "pyult", "pyulp", "pyulh", "pyum", "pyub", "pyubs", "pyus", "pyuss", "pyung", "pyuj", "pyuc"];
  }
});

// node_modules/unidecode/data/xd5.js
var require_xd5 = __commonJS({
  "node_modules/unidecode/data/xd5.js"(exports, module2) {
    module2.exports = ["pyuk", "pyut", "pyup", "pyuh", "peu", "peug", "peugg", "peugs", "peun", "peunj", "peunh", "peud", "peul", "peulg", "peulm", "peulb", "peuls", "peult", "peulp", "peulh", "peum", "peub", "peubs", "peus", "peuss", "peung", "peuj", "peuc", "peuk", "peut", "peup", "peuh", "pyi", "pyig", "pyigg", "pyigs", "pyin", "pyinj", "pyinh", "pyid", "pyil", "pyilg", "pyilm", "pyilb", "pyils", "pyilt", "pyilp", "pyilh", "pyim", "pyib", "pyibs", "pyis", "pyiss", "pying", "pyij", "pyic", "pyik", "pyit", "pyip", "pyih", "pi", "pig", "pigg", "pigs", "pin", "pinj", "pinh", "pid", "pil", "pilg", "pilm", "pilb", "pils", "pilt", "pilp", "pilh", "pim", "pib", "pibs", "pis", "piss", "ping", "pij", "pic", "pik", "pit", "pip", "pih", "ha", "hag", "hagg", "hags", "han", "hanj", "hanh", "had", "hal", "halg", "halm", "halb", "hals", "halt", "halp", "halh", "ham", "hab", "habs", "has", "hass", "hang", "haj", "hac", "hak", "hat", "hap", "hah", "hae", "haeg", "haegg", "haegs", "haen", "haenj", "haenh", "haed", "hael", "haelg", "haelm", "haelb", "haels", "haelt", "haelp", "haelh", "haem", "haeb", "haebs", "haes", "haess", "haeng", "haej", "haec", "haek", "haet", "haep", "haeh", "hya", "hyag", "hyagg", "hyags", "hyan", "hyanj", "hyanh", "hyad", "hyal", "hyalg", "hyalm", "hyalb", "hyals", "hyalt", "hyalp", "hyalh", "hyam", "hyab", "hyabs", "hyas", "hyass", "hyang", "hyaj", "hyac", "hyak", "hyat", "hyap", "hyah", "hyae", "hyaeg", "hyaegg", "hyaegs", "hyaen", "hyaenj", "hyaenh", "hyaed", "hyael", "hyaelg", "hyaelm", "hyaelb", "hyaels", "hyaelt", "hyaelp", "hyaelh", "hyaem", "hyaeb", "hyaebs", "hyaes", "hyaess", "hyaeng", "hyaej", "hyaec", "hyaek", "hyaet", "hyaep", "hyaeh", "heo", "heog", "heogg", "heogs", "heon", "heonj", "heonh", "heod", "heol", "heolg", "heolm", "heolb", "heols", "heolt", "heolp", "heolh", "heom", "heob", "heobs", "heos", "heoss", "heong", "heoj", "heoc", "heok", "heot", "heop", "heoh", "he", "heg", "hegg", "hegs", "hen", "henj", "henh", "hed", "hel", "helg", "helm", "helb", "hels", "helt", "help", "helh", "hem", "heb", "hebs", "hes", "hess", "heng", "hej", "hec", "hek", "het", "hep", "heh"];
  }
});

// node_modules/unidecode/data/xd6.js
var require_xd6 = __commonJS({
  "node_modules/unidecode/data/xd6.js"(exports, module2) {
    module2.exports = ["hyeo", "hyeog", "hyeogg", "hyeogs", "hyeon", "hyeonj", "hyeonh", "hyeod", "hyeol", "hyeolg", "hyeolm", "hyeolb", "hyeols", "hyeolt", "hyeolp", "hyeolh", "hyeom", "hyeob", "hyeobs", "hyeos", "hyeoss", "hyeong", "hyeoj", "hyeoc", "hyeok", "hyeot", "hyeop", "hyeoh", "hye", "hyeg", "hyegg", "hyegs", "hyen", "hyenj", "hyenh", "hyed", "hyel", "hyelg", "hyelm", "hyelb", "hyels", "hyelt", "hyelp", "hyelh", "hyem", "hyeb", "hyebs", "hyes", "hyess", "hyeng", "hyej", "hyec", "hyek", "hyet", "hyep", "hyeh", "ho", "hog", "hogg", "hogs", "hon", "honj", "honh", "hod", "hol", "holg", "holm", "holb", "hols", "holt", "holp", "holh", "hom", "hob", "hobs", "hos", "hoss", "hong", "hoj", "hoc", "hok", "hot", "hop", "hoh", "hwa", "hwag", "hwagg", "hwags", "hwan", "hwanj", "hwanh", "hwad", "hwal", "hwalg", "hwalm", "hwalb", "hwals", "hwalt", "hwalp", "hwalh", "hwam", "hwab", "hwabs", "hwas", "hwass", "hwang", "hwaj", "hwac", "hwak", "hwat", "hwap", "hwah", "hwae", "hwaeg", "hwaegg", "hwaegs", "hwaen", "hwaenj", "hwaenh", "hwaed", "hwael", "hwaelg", "hwaelm", "hwaelb", "hwaels", "hwaelt", "hwaelp", "hwaelh", "hwaem", "hwaeb", "hwaebs", "hwaes", "hwaess", "hwaeng", "hwaej", "hwaec", "hwaek", "hwaet", "hwaep", "hwaeh", "hoe", "hoeg", "hoegg", "hoegs", "hoen", "hoenj", "hoenh", "hoed", "hoel", "hoelg", "hoelm", "hoelb", "hoels", "hoelt", "hoelp", "hoelh", "hoem", "hoeb", "hoebs", "hoes", "hoess", "hoeng", "hoej", "hoec", "hoek", "hoet", "hoep", "hoeh", "hyo", "hyog", "hyogg", "hyogs", "hyon", "hyonj", "hyonh", "hyod", "hyol", "hyolg", "hyolm", "hyolb", "hyols", "hyolt", "hyolp", "hyolh", "hyom", "hyob", "hyobs", "hyos", "hyoss", "hyong", "hyoj", "hyoc", "hyok", "hyot", "hyop", "hyoh", "hu", "hug", "hugg", "hugs", "hun", "hunj", "hunh", "hud", "hul", "hulg", "hulm", "hulb", "huls", "hult", "hulp", "hulh", "hum", "hub", "hubs", "hus", "huss", "hung", "huj", "huc", "huk", "hut", "hup", "huh", "hweo", "hweog", "hweogg", "hweogs", "hweon", "hweonj", "hweonh", "hweod", "hweol", "hweolg", "hweolm", "hweolb", "hweols", "hweolt", "hweolp", "hweolh", "hweom", "hweob", "hweobs", "hweos", "hweoss", "hweong", "hweoj", "hweoc", "hweok", "hweot", "hweop", "hweoh", "hwe", "hweg", "hwegg", "hwegs"];
  }
});

// node_modules/unidecode/data/xd7.js
var require_xd7 = __commonJS({
  "node_modules/unidecode/data/xd7.js"(exports, module2) {
    module2.exports = ["hwen", "hwenj", "hwenh", "hwed", "hwel", "hwelg", "hwelm", "hwelb", "hwels", "hwelt", "hwelp", "hwelh", "hwem", "hweb", "hwebs", "hwes", "hwess", "hweng", "hwej", "hwec", "hwek", "hwet", "hwep", "hweh", "hwi", "hwig", "hwigg", "hwigs", "hwin", "hwinj", "hwinh", "hwid", "hwil", "hwilg", "hwilm", "hwilb", "hwils", "hwilt", "hwilp", "hwilh", "hwim", "hwib", "hwibs", "hwis", "hwiss", "hwing", "hwij", "hwic", "hwik", "hwit", "hwip", "hwih", "hyu", "hyug", "hyugg", "hyugs", "hyun", "hyunj", "hyunh", "hyud", "hyul", "hyulg", "hyulm", "hyulb", "hyuls", "hyult", "hyulp", "hyulh", "hyum", "hyub", "hyubs", "hyus", "hyuss", "hyung", "hyuj", "hyuc", "hyuk", "hyut", "hyup", "hyuh", "heu", "heug", "heugg", "heugs", "heun", "heunj", "heunh", "heud", "heul", "heulg", "heulm", "heulb", "heuls", "heult", "heulp", "heulh", "heum", "heub", "heubs", "heus", "heuss", "heung", "heuj", "heuc", "heuk", "heut", "heup", "heuh", "hyi", "hyig", "hyigg", "hyigs", "hyin", "hyinj", "hyinh", "hyid", "hyil", "hyilg", "hyilm", "hyilb", "hyils", "hyilt", "hyilp", "hyilh", "hyim", "hyib", "hyibs", "hyis", "hyiss", "hying", "hyij", "hyic", "hyik", "hyit", "hyip", "hyih", "hi", "hig", "higg", "higs", "hin", "hinj", "hinh", "hid", "hil", "hilg", "hilm", "hilb", "hils", "hilt", "hilp", "hilh", "him", "hib", "hibs", "his", "hiss", "hing", "hij", "hic", "hik", "hit", "hip", "hih", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/xf9.js
var require_xf9 = __commonJS({
  "node_modules/unidecode/data/xf9.js"(exports, module2) {
    module2.exports = ["Kay ", "Kayng ", "Ke ", "Ko ", "Kol ", "Koc ", "Kwi ", "Kwi ", "Kyun ", "Kul ", "Kum ", "Na ", "Na ", "Na ", "La ", "Na ", "Na ", "Na ", "Na ", "Na ", "Nak ", "Nak ", "Nak ", "Nak ", "Nak ", "Nak ", "Nak ", "Nan ", "Nan ", "Nan ", "Nan ", "Nan ", "Nan ", "Nam ", "Nam ", "Nam ", "Nam ", "Nap ", "Nap ", "Nap ", "Nang ", "Nang ", "Nang ", "Nang ", "Nang ", "Nay ", "Nayng ", "No ", "No ", "No ", "No ", "No ", "No ", "No ", "No ", "No ", "No ", "No ", "No ", "Nok ", "Nok ", "Nok ", "Nok ", "Nok ", "Nok ", "Non ", "Nong ", "Nong ", "Nong ", "Nong ", "Noy ", "Noy ", "Noy ", "Noy ", "Nwu ", "Nwu ", "Nwu ", "Nwu ", "Nwu ", "Nwu ", "Nwu ", "Nwu ", "Nuk ", "Nuk ", "Num ", "Nung ", "Nung ", "Nung ", "Nung ", "Nung ", "Twu ", "La ", "Lak ", "Lak ", "Lan ", "Lyeng ", "Lo ", "Lyul ", "Li ", "Pey ", "Pen ", "Pyen ", "Pwu ", "Pwul ", "Pi ", "Sak ", "Sak ", "Sam ", "Sayk ", "Sayng ", "Sep ", "Sey ", "Sway ", "Sin ", "Sim ", "Sip ", "Ya ", "Yak ", "Yak ", "Yang ", "Yang ", "Yang ", "Yang ", "Yang ", "Yang ", "Yang ", "Yang ", "Ye ", "Ye ", "Ye ", "Ye ", "Ye ", "Ye ", "Ye ", "Ye ", "Ye ", "Ye ", "Ye ", "Yek ", "Yek ", "Yek ", "Yek ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yen ", "Yel ", "Yel ", "Yel ", "Yel ", "Yel ", "Yel ", "Yem ", "Yem ", "Yem ", "Yem ", "Yem ", "Yep ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yeng ", "Yey ", "Yey ", "Yey ", "Yey ", "O ", "Yo ", "Yo ", "Yo ", "Yo ", "Yo ", "Yo ", "Yo ", "Yo ", "Yo ", "Yo ", "Yong ", "Wun ", "Wen ", "Yu ", "Yu ", "Yu ", "Yu ", "Yu ", "Yu ", "Yu ", "Yu ", "Yu ", "Yu ", "Yuk ", "Yuk ", "Yuk ", "Yun ", "Yun ", "Yun ", "Yun ", "Yul ", "Yul ", "Yul ", "Yul ", "Yung ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "I ", "Ik ", "Ik ", "In ", "In ", "In ", "In ", "In ", "In ", "In ", "Im ", "Im ", "Im ", "Ip ", "Ip ", "Ip ", "Cang ", "Cek ", "Ci ", "Cip ", "Cha ", "Chek "];
  }
});

// node_modules/unidecode/data/xfa.js
var require_xfa = __commonJS({
  "node_modules/unidecode/data/xfa.js"(exports, module2) {
    module2.exports = ["Chey ", "Thak ", "Thak ", "Thang ", "Thayk ", "Thong ", "Pho ", "Phok ", "Hang ", "Hang ", "Hyen ", "Hwak ", "Wu ", "Huo ", "[?] ", "[?] ", "Zhong ", "[?] ", "Qing ", "[?] ", "[?] ", "Xi ", "Zhu ", "Yi ", "Li ", "Shen ", "Xiang ", "Fu ", "Jing ", "Jing ", "Yu ", "[?] ", "Hagi ", "[?] ", "Zhu ", "[?] ", "[?] ", "Yi ", "Du ", "[?] ", "[?] ", "[?] ", "Fan ", "Si ", "Guan ", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/xfb.js
var require_xfb = __commonJS({
  "node_modules/unidecode/data/xfb.js"(exports, module2) {
    module2.exports = ["ff", "fi", "fl", "ffi", "ffl", "st", "st", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "mn", "me", "mi", "vn", "mkh", "[?]", "[?]", "[?]", "[?]", "[?]", "yi", "", "ay", "`", "", "d", "h", "k", "l", "m", "m", "t", "+", "sh", "s", "sh", "s", "a", "a", "", "b", "g", "d", "h", "v", "z", "[?]", "t", "y", "k", "k", "l", "[?]", "l", "[?]", "n", "n", "[?]", "p", "p", "[?]", "ts", "ts", "r", "sh", "t", "vo", "b", "k", "p", "l", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
  }
});

// node_modules/unidecode/data/xfc.js
var require_xfc = __commonJS({
  "node_modules/unidecode/data/xfc.js"(exports, module2) {
    module2.exports = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
  }
});

// node_modules/unidecode/data/xfd.js
var require_xfd = __commonJS({
  "node_modules/unidecode/data/xfd.js"(exports, module2) {
    module2.exports = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", "[?]"];
  }
});

// node_modules/unidecode/data/xfe.js
var require_xfe = __commonJS({
  "node_modules/unidecode/data/xfe.js"(exports, module2) {
    module2.exports = ["[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "", "", "", "~", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "..", "--", "-", "_", "_", "(", ") ", "{", "} ", "[", "] ", "[(", ")] ", "<<", ">> ", "<", "> ", "[", "] ", "{", "}", "[?]", "[?]", "[?]", "[?]", "", "", "", "", "", "", "", ",", ",", ".", "", ";", ":", "?", "!", "-", "(", ")", "{", "}", "{", "}", "#", "&", "*", "+", "-", "<", ">", "=", "", "\\", "$", "%", "@", "[?]", "[?]", "[?]", "[?]", "", "", "", "[?]", "", "[?]", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "[?]", "[?]", ""];
  }
});

// node_modules/unidecode/data/xff.js
var require_xff = __commonJS({
  "node_modules/unidecode/data/xff.js"(exports, module2) {
    module2.exports = ["[?]", "!", '"', "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", ":", ";", "<", "=", ">", "?", "@", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "[", "\\", "]", "^", "_", "`", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "{", "|", "}", "~", "[?]", "[?]", ".", "[", "]", ",", "*", "wo", "a", "i", "u", "e", "o", "ya", "yu", "yo", "tu", "+", "a", "i", "u", "e", "o", "ka", "ki", "ku", "ke", "ko", "sa", "si", "su", "se", "so", "ta", "ti", "tu", "te", "to", "na", "ni", "nu", "ne", "no", "ha", "hi", "hu", "he", "ho", "ma", "mi", "mu", "me", "mo", "ya", "yu", "yo", "ra", "ri", "ru", "re", "ro", "wa", "n", ":", ";", "", "g", "gg", "gs", "n", "nj", "nh", "d", "dd", "r", "lg", "lm", "lb", "ls", "lt", "lp", "rh", "m", "b", "bb", "bs", "s", "ss", "", "j", "jj", "c", "k", "t", "p", "h", "[?]", "[?]", "[?]", "a", "ae", "ya", "yae", "eo", "e", "[?]", "[?]", "yeo", "ye", "o", "wa", "wae", "oe", "[?]", "[?]", "yo", "u", "weo", "we", "wi", "yu", "[?]", "[?]", "eu", "yi", "i", "[?]", "[?]", "[?]", "/C", "PS", "!", "-", "|", "Y=", "W=", "[?]", "|", "-", "|", "-", "|", "#", "O", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "[?]", "{", "|", "}", "", "", "", ""];
  }
});

// node_modules/unidecode/unidecode.js
var require_unidecode = __commonJS({
  "node_modules/unidecode/unidecode.js"(exports, module2) {
    "use strict";
    var tr = {};
    var utf8_rx = /(?![\x00-\x7F]|[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3})./g;
    module2.exports = function(str) {
      return str.replace(utf8_rx, unidecode_internal_replace);
    };
    function unidecode_internal_replace(match) {
      var utf16 = utf8_to_utf16(match);
      if (utf16 > 65535) {
        return "_";
      } else {
        var h = utf16 >> 8;
        var l = utf16 & 255;
        if (h > 24 && h < 30)
          return "";
        if (h > 215 && h < 249)
          return "";
        if (!tr[h]) {
          switch (dec2hex(h)) {
            case "00":
              tr[h] = require_x00();
              break;
            case "01":
              tr[h] = require_x01();
              break;
            case "02":
              tr[h] = require_x02();
              break;
            case "03":
              tr[h] = require_x03();
              break;
            case "04":
              tr[h] = require_x04();
              break;
            case "05":
              tr[h] = require_x05();
              break;
            case "06":
              tr[h] = require_x06();
              break;
            case "07":
              tr[h] = require_x07();
              break;
            case "09":
              tr[h] = require_x09();
              break;
            case "0a":
              tr[h] = require_x0a();
              break;
            case "0b":
              tr[h] = require_x0b();
              break;
            case "0c":
              tr[h] = require_x0c();
              break;
            case "0d":
              tr[h] = require_x0d();
              break;
            case "0e":
              tr[h] = require_x0e();
              break;
            case "0f":
              tr[h] = require_x0f();
              break;
            case "10":
              tr[h] = require_x10();
              break;
            case "11":
              tr[h] = require_x11();
              break;
            case "12":
              tr[h] = require_x12();
              break;
            case "13":
              tr[h] = require_x13();
              break;
            case "14":
              tr[h] = require_x14();
              break;
            case "15":
              tr[h] = require_x15();
              break;
            case "16":
              tr[h] = require_x16();
              break;
            case "17":
              tr[h] = require_x17();
              break;
            case "18":
              tr[h] = require_x18();
              break;
            case "1e":
              tr[h] = require_x1e();
              break;
            case "1f":
              tr[h] = require_x1f();
              break;
            case "20":
              tr[h] = require_x20();
              break;
            case "21":
              tr[h] = require_x21();
              break;
            case "22":
              tr[h] = require_x22();
              break;
            case "23":
              tr[h] = require_x23();
              break;
            case "24":
              tr[h] = require_x24();
              break;
            case "25":
              tr[h] = require_x25();
              break;
            case "26":
              tr[h] = require_x26();
              break;
            case "27":
              tr[h] = require_x27();
              break;
            case "28":
              tr[h] = require_x28();
              break;
            case "2e":
              tr[h] = require_x2e();
              break;
            case "2f":
              tr[h] = require_x2f();
              break;
            case "30":
              tr[h] = require_x30();
              break;
            case "31":
              tr[h] = require_x31();
              break;
            case "32":
              tr[h] = require_x32();
              break;
            case "33":
              tr[h] = require_x33();
              break;
            case "4d":
              tr[h] = require_x4d();
              break;
            case "4e":
              tr[h] = require_x4e();
              break;
            case "4f":
              tr[h] = require_x4f();
              break;
            case "50":
              tr[h] = require_x50();
              break;
            case "51":
              tr[h] = require_x51();
              break;
            case "52":
              tr[h] = require_x52();
              break;
            case "53":
              tr[h] = require_x53();
              break;
            case "54":
              tr[h] = require_x54();
              break;
            case "55":
              tr[h] = require_x55();
              break;
            case "56":
              tr[h] = require_x56();
              break;
            case "57":
              tr[h] = require_x57();
              break;
            case "58":
              tr[h] = require_x58();
              break;
            case "59":
              tr[h] = require_x59();
              break;
            case "5a":
              tr[h] = require_x5a();
              break;
            case "5b":
              tr[h] = require_x5b();
              break;
            case "5c":
              tr[h] = require_x5c();
              break;
            case "5d":
              tr[h] = require_x5d();
              break;
            case "5e":
              tr[h] = require_x5e();
              break;
            case "5f":
              tr[h] = require_x5f();
              break;
            case "60":
              tr[h] = require_x60();
              break;
            case "61":
              tr[h] = require_x61();
              break;
            case "62":
              tr[h] = require_x62();
              break;
            case "63":
              tr[h] = require_x63();
              break;
            case "64":
              tr[h] = require_x64();
              break;
            case "65":
              tr[h] = require_x65();
              break;
            case "66":
              tr[h] = require_x66();
              break;
            case "67":
              tr[h] = require_x67();
              break;
            case "68":
              tr[h] = require_x68();
              break;
            case "69":
              tr[h] = require_x69();
              break;
            case "6a":
              tr[h] = require_x6a();
              break;
            case "6b":
              tr[h] = require_x6b();
              break;
            case "6c":
              tr[h] = require_x6c();
              break;
            case "6d":
              tr[h] = require_x6d();
              break;
            case "6e":
              tr[h] = require_x6e();
              break;
            case "6f":
              tr[h] = require_x6f();
              break;
            case "70":
              tr[h] = require_x70();
              break;
            case "71":
              tr[h] = require_x71();
              break;
            case "72":
              tr[h] = require_x72();
              break;
            case "73":
              tr[h] = require_x73();
              break;
            case "74":
              tr[h] = require_x74();
              break;
            case "75":
              tr[h] = require_x75();
              break;
            case "76":
              tr[h] = require_x76();
              break;
            case "77":
              tr[h] = require_x77();
              break;
            case "78":
              tr[h] = require_x78();
              break;
            case "79":
              tr[h] = require_x79();
              break;
            case "7a":
              tr[h] = require_x7a();
              break;
            case "7b":
              tr[h] = require_x7b();
              break;
            case "7c":
              tr[h] = require_x7c();
              break;
            case "7d":
              tr[h] = require_x7d();
              break;
            case "7e":
              tr[h] = require_x7e();
              break;
            case "7f":
              tr[h] = require_x7f();
              break;
            case "80":
              tr[h] = require_x80();
              break;
            case "81":
              tr[h] = require_x81();
              break;
            case "82":
              tr[h] = require_x82();
              break;
            case "83":
              tr[h] = require_x83();
              break;
            case "84":
              tr[h] = require_x84();
              break;
            case "85":
              tr[h] = require_x85();
              break;
            case "86":
              tr[h] = require_x86();
              break;
            case "87":
              tr[h] = require_x87();
              break;
            case "88":
              tr[h] = require_x88();
              break;
            case "89":
              tr[h] = require_x89();
              break;
            case "8a":
              tr[h] = require_x8a();
              break;
            case "8b":
              tr[h] = require_x8b();
              break;
            case "8c":
              tr[h] = require_x8c();
              break;
            case "8d":
              tr[h] = require_x8d();
              break;
            case "8e":
              tr[h] = require_x8e();
              break;
            case "8f":
              tr[h] = require_x8f();
              break;
            case "90":
              tr[h] = require_x90();
              break;
            case "91":
              tr[h] = require_x91();
              break;
            case "92":
              tr[h] = require_x92();
              break;
            case "93":
              tr[h] = require_x93();
              break;
            case "94":
              tr[h] = require_x94();
              break;
            case "95":
              tr[h] = require_x95();
              break;
            case "96":
              tr[h] = require_x96();
              break;
            case "97":
              tr[h] = require_x97();
              break;
            case "98":
              tr[h] = require_x98();
              break;
            case "99":
              tr[h] = require_x99();
              break;
            case "9a":
              tr[h] = require_x9a();
              break;
            case "9b":
              tr[h] = require_x9b();
              break;
            case "9c":
              tr[h] = require_x9c();
              break;
            case "9d":
              tr[h] = require_x9d();
              break;
            case "9e":
              tr[h] = require_x9e();
              break;
            case "9f":
              tr[h] = require_x9f();
              break;
            case "a0":
              tr[h] = require_xa0();
              break;
            case "a1":
              tr[h] = require_xa1();
              break;
            case "a2":
              tr[h] = require_xa2();
              break;
            case "a3":
              tr[h] = require_xa3();
              break;
            case "a4":
              tr[h] = require_xa4();
              break;
            case "ac":
              tr[h] = require_xac();
              break;
            case "ad":
              tr[h] = require_xad();
              break;
            case "ae":
              tr[h] = require_xae();
              break;
            case "af":
              tr[h] = require_xaf();
              break;
            case "b0":
              tr[h] = require_xb0();
              break;
            case "b1":
              tr[h] = require_xb1();
              break;
            case "b2":
              tr[h] = require_xb2();
              break;
            case "b3":
              tr[h] = require_xb3();
              break;
            case "b4":
              tr[h] = require_xb4();
              break;
            case "b5":
              tr[h] = require_xb5();
              break;
            case "b6":
              tr[h] = require_xb6();
              break;
            case "b7":
              tr[h] = require_xb7();
              break;
            case "b8":
              tr[h] = require_xb8();
              break;
            case "b9":
              tr[h] = require_xb9();
              break;
            case "ba":
              tr[h] = require_xba();
              break;
            case "bb":
              tr[h] = require_xbb();
              break;
            case "bc":
              tr[h] = require_xbc();
              break;
            case "bd":
              tr[h] = require_xbd();
              break;
            case "be":
              tr[h] = require_xbe();
              break;
            case "bf":
              tr[h] = require_xbf();
              break;
            case "c0":
              tr[h] = require_xc0();
              break;
            case "c1":
              tr[h] = require_xc1();
              break;
            case "c2":
              tr[h] = require_xc2();
              break;
            case "c3":
              tr[h] = require_xc3();
              break;
            case "c4":
              tr[h] = require_xc4();
              break;
            case "c5":
              tr[h] = require_xc5();
              break;
            case "c6":
              tr[h] = require_xc6();
              break;
            case "c7":
              tr[h] = require_xc7();
              break;
            case "c8":
              tr[h] = require_xc8();
              break;
            case "c9":
              tr[h] = require_xc9();
              break;
            case "ca":
              tr[h] = require_xca();
              break;
            case "cb":
              tr[h] = require_xcb();
              break;
            case "cc":
              tr[h] = require_xcc();
              break;
            case "cd":
              tr[h] = require_xcd();
              break;
            case "ce":
              tr[h] = require_xce();
              break;
            case "cf":
              tr[h] = require_xcf();
              break;
            case "d0":
              tr[h] = require_xd0();
              break;
            case "d1":
              tr[h] = require_xd1();
              break;
            case "d2":
              tr[h] = require_xd2();
              break;
            case "d3":
              tr[h] = require_xd3();
              break;
            case "d4":
              tr[h] = require_xd4();
              break;
            case "d5":
              tr[h] = require_xd5();
              break;
            case "d6":
              tr[h] = require_xd6();
              break;
            case "d7":
              tr[h] = require_xd7();
              break;
            case "f9":
              tr[h] = require_xf9();
              break;
            case "fa":
              tr[h] = require_xfa();
              break;
            case "fb":
              tr[h] = require_xfb();
              break;
            case "fc":
              tr[h] = require_xfc();
              break;
            case "fd":
              tr[h] = require_xfd();
              break;
            case "fe":
              tr[h] = require_xfe();
              break;
            case "ff":
              tr[h] = require_xff();
              break;
            default:
              return "";
          }
        }
        return tr[h][l];
      }
    }
    function dec2hex(i) {
      return (i + 256).toString(16).substr(-2);
    }
    function utf8_to_utf16(raw) {
      var b1, b2, b3, b4, x, y, z;
      while (Array.isArray(raw))
        raw = raw[0];
      switch (raw.length) {
        case 1:
          return ord(raw);
        case 2:
          b1 = ord(raw.substr(0, 1));
          b2 = ord(raw.substr(1, 1));
          x = (b1 & 3) << 6 | b2 & 63;
          y = (b1 & 28) >> 2;
          return y << 8 | x;
        case 3:
          b1 = ord(raw.substr(0, 1));
          b2 = ord(raw.substr(1, 1));
          b3 = ord(raw.substr(2, 1));
          x = (b2 & 3) << 6 | b3 & 63;
          y = (b1 & 15) << 4 | (b2 & 60) >> 2;
          return y << 8 | x;
        default:
          b1 = ord(raw.substr(0, 1));
          b2 = ord(raw.substr(1, 1));
          b3 = ord(raw.substr(2, 1));
          b4 = ord(raw.substr(3, 1));
          x = (b3 & 3) << 6 | b4 & 63;
          y = (b2 & 15) << 4 | (b3 & 60) >> 2;
          z = (b1 & 7) << 5 | (b2 & 48) >> 4;
          return z << 16 | y << 8 | x;
      }
    }
    function ord(string2) {
      var str = string2 + "", code = str.charCodeAt(0);
      if (55296 <= code && code <= 56319) {
        var hi = code;
        if (str.length === 1) {
          return code;
        }
        var low = str.charCodeAt(1);
        return (hi - 55296) * 1024 + (low - 56320) + 65536;
      }
      if (56320 <= code && code <= 57343) {
        return code;
      }
      return code;
    }
  }
});

// src/util/charCode.ts
var init_charCode = __esm({
  "src/util/charCode.ts"() {
    "use strict";
  }
});

// src/snippets/eval.ts
async function evalCode(nvim, kind, code, curr = "") {
  if (kind == "vim") {
    let res2 = await nvim.eval(code);
    return res2.toString();
  }
  if (kind == "shell") {
    let res2 = await (0, import_util44.promisify)(import_child_process6.exec)(code);
    return res2.stdout.replace(/\s*$/, "") || res2.stderr;
  }
  let lines = [`snip._reset("${escapeString(curr)}")`];
  lines.push(...code.split(/\r?\n/).map((line) => line.replace(/\t/g, "    ")));
  await executePythonCode(nvim, lines);
  let res = await nvim.call(`pyxeval`, "str(snip.rv)");
  return typeof res === "string" ? res : "";
}
function prepareMatchCode(snip) {
  let { range: range2, regex: regex3, line } = snip;
  let pyCodes = [];
  if (regex3 && range2 != null) {
    let trigger = line.slice(range2.start.character, range2.end.character);
    pyCodes.push(`pattern = re.compile("${escapeString(regex3)}")`);
    pyCodes.push(`match = pattern.search("${escapeString(trigger)}")`);
  } else {
    pyCodes.push(`match = None`);
  }
  return pyCodes.join("\n");
}
function preparePythonCodes(snip) {
  let { range: range2, context, line } = snip;
  let pyCodes = [
    "import re, os, vim, string, random",
    `path = vim.eval('expand("%:p")') or ""`,
    `fn = os.path.basename(path)`
  ];
  if (context) {
    pyCodes.push(`snip = ContextSnippet()`);
    pyCodes.push(`context = ${context}`);
  } else {
    pyCodes.push(`context = True`);
  }
  let start = `(${range2.start.line},${Buffer.byteLength(line.slice(0, range2.start.character))})`;
  let end = `(${range2.start.line},${Buffer.byteLength(line.slice(0, range2.end.character))})`;
  let indent = line.match(/^\s*/)[0];
  pyCodes.push(`snip = SnippetUtil("${escapeString(indent)}", ${start}, ${end}, context)`);
  return pyCodes;
}
async function executePythonCode(nvim, codes) {
  try {
    await nvim.command(`pyx ${addPythonTryCatch(codes.join("\n"))}`);
  } catch (e) {
    let err = new Error(e instanceof Error ? e.message : e.toString());
    err.stack = `Error on execute python code:
${codes.join("\n")}
` + (e instanceof Error ? e.stack : e);
    throw err;
  }
}
function getVariablesCode(values) {
  let keys = Object.keys(values);
  let maxIndex = keys.length ? Math.max.apply(null, keys.map((v) => Number(v))) : 0;
  let vals = new Array(maxIndex).fill('""');
  for (let [idx, val] of Object.entries(values)) {
    vals[idx] = `"${escapeString(val)}"`;
  }
  return `t = (${vals.join(",")},)`;
}
function addPythonTryCatch(code, force = false) {
  if (!isVim5 && force === false)
    return code;
  let lines = [
    "import traceback, vim",
    `vim.vars['errmsg'] = ''`,
    "try:"
  ];
  lines.push(...code.split("\n").map((line) => "    " + line));
  lines.push("except Exception as e:");
  lines.push(`    vim.vars['errmsg'] = traceback.format_exc()`);
  return lines.join("\n");
}
function escapeString(input) {
  return input.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\t/g, "\\t").replace(/\n/g, "\\n");
}
function convertRegex(str) {
  if (str.indexOf("\\z") !== -1) {
    throw new Error("pattern \\z not supported");
  }
  if (str.indexOf("(?s)") !== -1) {
    throw new Error("pattern (?s) not supported");
  }
  if (str.indexOf("(?x)") !== -1) {
    throw new Error("pattern (?x) not supported");
  }
  if (str.indexOf("\n") !== -1) {
    throw new Error("pattern \\n not supported");
  }
  if (conditionRe.test(str)) {
    throw new Error("pattern (?id/name)yes-pattern|no-pattern not supported");
  }
  return str.replace(regex, (match, p1) => {
    if (match == "\\A")
      return "^";
    if (match.startsWith("(?#"))
      return "";
    if (match.startsWith("(?P<"))
      return "(?" + match.slice(3);
    if (match.startsWith("(?P="))
      return `\\k<${p1}>`;
    return "";
  });
}
var import_child_process6, import_util44, logger80, isVim5, stringStartRe, conditionRe, commentRe, namedCaptureRe, namedReferenceRe, regex;
var init_eval = __esm({
  "src/snippets/eval.ts"() {
    "use strict";
    import_child_process6 = require("child_process");
    import_util44 = require("util");
    logger80 = require_logger2()("snippets-eval");
    isVim5 = process.env.VIM_NODE_RPC == "1";
    stringStartRe = /\\A/;
    conditionRe = /\(\?\(\w+\).+\|/;
    commentRe = /\(\?#.*?\)/;
    namedCaptureRe = /\(\?P<\w+>.*?\)/;
    namedReferenceRe = /\(\?P=(\w+)\)/;
    regex = new RegExp(`${commentRe.source}|${stringStartRe.source}|${namedCaptureRe.source}|${namedReferenceRe.source}`, "g");
  }
});

// src/snippets/parser.ts
function walk(marker, visitor) {
  const stack = [...marker];
  while (stack.length > 0) {
    const marker2 = stack.shift();
    const recurse = visitor(marker2);
    if (!recurse) {
      break;
    }
    stack.unshift(...marker2.children);
  }
}
function transformEscapes(input, backslashIndexes = []) {
  let res = "";
  let len = input.length;
  let i = 0;
  let toUpper = false;
  let toLower = false;
  while (i < len) {
    let ch = input[i];
    if (ch.charCodeAt(0) === 92 /* Backslash */ && !backslashIndexes.includes(i)) {
      let next = input[i + 1];
      if (escapedCharacters.includes(next)) {
        i++;
        continue;
      }
      if (next == "u" || next == "l") {
        let follow = input[i + 2];
        if (follow)
          res = res + (next == "u" ? follow.toUpperCase() : follow.toLowerCase());
        i = i + 3;
        continue;
      }
      if (next == "U" || next == "L") {
        if (next == "U") {
          toUpper = true;
        } else {
          toLower = true;
        }
        i = i + 2;
        continue;
      }
      if (next == "E") {
        toUpper = false;
        toLower = false;
        i = i + 2;
        continue;
      }
      if (next == "n") {
        res += "\n";
        i = i + 2;
        continue;
      }
      if (next == "t") {
        res += "	";
        i = i + 2;
        continue;
      }
    }
    if (toUpper) {
      ch = ch.toUpperCase();
    } else if (toLower) {
      ch = ch.toLowerCase();
    }
    res += ch;
    i++;
  }
  return res;
}
var import_unidecode, logger81, knownRegexOptions, _Scanner, Scanner, Marker, Text, CodeBlock, TransformableMarker, Placeholder, Choice, Transform, ConditionString, FormatString, Variable, TextmateSnippet, SnippetParser, escapedCharacters;
var init_parser2 = __esm({
  "src/snippets/parser.ts"() {
    "use strict";
    import_unidecode = __toESM(require_unidecode());
    init_array();
    init_charCode();
    init_string();
    init_eval();
    logger81 = require_logger2()("snippets-parser");
    knownRegexOptions = ["d", "g", "i", "m", "s", "u", "y"];
    _Scanner = class {
      static isDigitCharacter(ch) {
        return ch >= 48 /* Digit0 */ && ch <= 57 /* Digit9 */;
      }
      static isVariableCharacter(ch) {
        return ch === 95 /* Underline */ || ch >= 97 /* a */ && ch <= 122 /* z */ || ch >= 65 /* A */ && ch <= 90 /* Z */;
      }
      constructor() {
        this.text("");
      }
      text(value) {
        this.value = value;
        this.pos = 0;
      }
      tokenText(token) {
        return this.value.substr(token.pos, token.len);
      }
      next() {
        if (this.pos >= this.value.length) {
          return { type: 14 /* EOF */, pos: this.pos, len: 0 };
        }
        let pos = this.pos;
        let len = 0;
        let ch = this.value.charCodeAt(pos);
        let type;
        type = _Scanner._table[ch];
        if (typeof type === "number") {
          this.pos += 1;
          return { type, pos, len: 1 };
        }
        if (_Scanner.isDigitCharacter(ch)) {
          type = 8 /* Int */;
          do {
            len += 1;
            ch = this.value.charCodeAt(pos + len);
          } while (_Scanner.isDigitCharacter(ch));
          this.pos += len;
          return { type, pos, len };
        }
        if (_Scanner.isVariableCharacter(ch)) {
          type = 9 /* VariableName */;
          do {
            ch = this.value.charCodeAt(pos + ++len);
          } while (_Scanner.isVariableCharacter(ch) || _Scanner.isDigitCharacter(ch));
          this.pos += len;
          return { type, pos, len };
        }
        type = 10 /* Format */;
        do {
          len += 1;
          ch = this.value.charCodeAt(pos + len);
        } while (!isNaN(ch) && typeof _Scanner._table[ch] === "undefined" && !_Scanner.isDigitCharacter(ch) && !_Scanner.isVariableCharacter(ch));
        this.pos += len;
        return { type, pos, len };
      }
    };
    Scanner = _Scanner;
    Scanner._table = {
      [36 /* DollarSign */]: 0 /* Dollar */,
      [58 /* Colon */]: 1 /* Colon */,
      [44 /* Comma */]: 2 /* Comma */,
      [123 /* OpenCurlyBrace */]: 3 /* CurlyOpen */,
      [125 /* CloseCurlyBrace */]: 4 /* CurlyClose */,
      [92 /* Backslash */]: 5 /* Backslash */,
      [47 /* Slash */]: 6 /* Forwardslash */,
      [124 /* Pipe */]: 7 /* Pipe */,
      [43 /* Plus */]: 11 /* Plus */,
      [45 /* Dash */]: 12 /* Dash */,
      [63 /* QuestionMark */]: 13 /* QuestionMark */,
      [40 /* OpenParen */]: 15 /* OpenParen */,
      [41 /* CloseParen */]: 16 /* CloseParen */,
      [96 /* BackTick */]: 17 /* BackTick */,
      [33 /* ExclamationMark */]: 18 /* ExclamationMark */
    };
    Marker = class {
      constructor() {
        this._children = [];
      }
      appendChild(child) {
        if (child instanceof Text && this._children[this._children.length - 1] instanceof Text) {
          this._children[this._children.length - 1].value += child.value;
        } else {
          child.parent = this;
          this._children.push(child);
        }
        return this;
      }
      setOnlyChild(child) {
        child.parent = this;
        this._children = [child];
      }
      replaceChildren(children) {
        for (const child of children) {
          child.parent = this;
        }
        this._children = children;
      }
      get children() {
        return this._children;
      }
      get snippet() {
        let candidate = this;
        while (true) {
          if (!candidate) {
            return void 0;
          }
          if (candidate instanceof TextmateSnippet) {
            return candidate;
          }
          candidate = candidate.parent;
        }
      }
      toString() {
        return this.children.reduce((prev, cur) => prev + cur.toString(), "");
      }
      len() {
        return 0;
      }
    };
    Text = class extends Marker {
      constructor(value) {
        super();
        this.value = value;
      }
      static escape(value) {
        return value.replace(/\$|}|\\/g, "\\$&");
      }
      toString() {
        return this.value;
      }
      toTextmateString() {
        return Text.escape(this.value);
      }
      len() {
        return this.value.length;
      }
      clone() {
        return new Text(this.value);
      }
    };
    CodeBlock = class extends Marker {
      constructor(code, kind, value) {
        super();
        this.code = code;
        this.kind = kind;
        this._value = "";
        this._related = [];
        if (kind === "python") {
          let { _related } = this;
          let arr;
          let re = /\bt\[(\d+)\]/g;
          while (true) {
            arr = re.exec(code);
            if (arr == null)
              break;
            let n = parseInt(arr[1], 10);
            if (!_related.includes(n))
              _related.push(n);
          }
        }
        if (typeof value === "string")
          this._value = value;
      }
      get related() {
        return this._related;
      }
      update(map) {
        if (this.kind !== "python")
          return;
        let related = /* @__PURE__ */ new Set();
        this.code = this.code.replace(/\bt\[(\d+)\]/g, (_, p1) => {
          let idx = Number(p1);
          let id = map.has(idx) ? map.get(idx) : idx;
          related.add(id);
          return `t[${id}]`;
        });
        this._related = Array.from(related);
      }
      get index() {
        if (this.parent instanceof Placeholder) {
          return this.parent.index;
        }
        return void 0;
      }
      async resolve(nvim) {
        if (!this.code.length)
          return;
        let res = await evalCode(nvim, this.kind, this.code, this._value ?? "");
        if (res != null)
          this._value = res;
      }
      len() {
        return this._value.length;
      }
      toString() {
        return this._value;
      }
      get value() {
        return this._value;
      }
      toTextmateString() {
        let t = "";
        if (this.kind == "python") {
          t = "!p ";
        } else if (this.kind == "shell") {
          t = "";
        } else if (this.kind == "vim") {
          t = "!v ";
        }
        return "`" + t + this.code + "`";
      }
      clone() {
        return new CodeBlock(this.code, this.kind, this.value);
      }
    };
    TransformableMarker = class extends Marker {
    };
    Placeholder = class extends TransformableMarker {
      constructor(index) {
        super();
        this.index = index;
        this.primary = false;
      }
      get isFinalTabstop() {
        return this.index === 0;
      }
      get choice() {
        return this._children.length === 1 && this._children[0] instanceof Choice ? this._children[0] : void 0;
      }
      toTextmateString() {
        let transformString = "";
        if (this.transform) {
          transformString = this.transform.toTextmateString();
        }
        if (this.children.length === 0 && !this.transform) {
          return `$${this.index}`;
        } else if (this.children.length === 0) {
          return `\${${this.index}${transformString}}`;
        } else if (this.choice) {
          return `\${${this.index}|${this.choice.toTextmateString()}|${transformString}}`;
        } else {
          return `\${${this.index}:${this.children.map((child) => child.toTextmateString()).join("")}${transformString}}`;
        }
      }
      clone() {
        let ret = new Placeholder(this.index);
        if (this.transform) {
          ret.transform = this.transform.clone();
        }
        ret._children = this.children.map((child) => child.clone());
        return ret;
      }
    };
    Choice = class extends Marker {
      constructor() {
        super(...arguments);
        this.options = [];
      }
      appendChild(marker) {
        if (marker instanceof Text) {
          marker.parent = this;
          this.options.push(marker);
        }
        return this;
      }
      toString() {
        return this.options[0].value;
      }
      toTextmateString() {
        return this.options.map((option) => option.value.replace(/\||,/g, "\\$&")).join(",");
      }
      len() {
        return this.options[0].len();
      }
      clone() {
        let ret = new Choice();
        for (let opt of this.options) {
          ret.appendChild(opt);
        }
        return ret;
      }
    };
    Transform = class extends Marker {
      constructor() {
        super(...arguments);
        this.ascii = false;
        this.ultisnip = false;
      }
      resolve(value) {
        let didMatch = false;
        let ret = value.replace(this.regexp, (...args) => {
          didMatch = true;
          return this._replace(args.slice(0, -2));
        });
        if (!didMatch && this._children.some((child) => child instanceof FormatString && Boolean(child.elseValue))) {
          ret = this._replace([]);
        }
        return ret;
      }
      _replace(groups) {
        let ret = "";
        let backslashIndexes = [];
        for (const marker of this._children) {
          if (marker instanceof FormatString) {
            let val = marker.resolve(groups[marker.index] || "");
            if (this.ultisnip && val.indexOf("\\") !== -1) {
              let s = ret.length;
              backslashIndexes.push(...getCharIndexes(val, "\\").map((i) => i + s));
            }
            ret += val;
          } else if (marker instanceof ConditionString) {
            ret += marker.resolve(groups[marker.index]);
          } else {
            ret += marker.toString();
          }
        }
        if (this.ascii)
          ret = (0, import_unidecode.default)(ret);
        return this.ultisnip ? transformEscapes(ret, backslashIndexes) : ret;
      }
      toString() {
        return "";
      }
      toTextmateString() {
        return `/${this.regexp.source}/${this.children.map((c) => c.toTextmateString())}/${(this.regexp.ignoreCase ? "i" : "") + (this.regexp.global ? "g" : "")}`;
      }
      clone() {
        let ret = new Transform();
        ret.regexp = new RegExp(this.regexp.source, (this.regexp.ignoreCase ? "i" : "") + (this.regexp.global ? "g" : ""));
        ret._children = this.children.map((child) => child.clone());
        return ret;
      }
    };
    ConditionString = class extends Marker {
      constructor(index, ifValue, elseValue) {
        super();
        this.index = index;
        this.ifValue = ifValue;
        this.elseValue = elseValue;
      }
      resolve(value) {
        if (value)
          return this.ifValue;
        return this.elseValue;
      }
      toTextmateString() {
        return "(?" + this.index + ":" + this.ifValue + (this.elseValue ? ":" + this.elseValue : "") + ")";
      }
      clone() {
        return new ConditionString(this.index, this.ifValue, this.elseValue);
      }
    };
    FormatString = class extends Marker {
      constructor(index, shorthandName, ifValue, elseValue) {
        super();
        this.index = index;
        this.shorthandName = shorthandName;
        this.ifValue = ifValue;
        this.elseValue = elseValue;
      }
      resolve(value) {
        if (this.shorthandName === "upcase") {
          return !value ? "" : value.toLocaleUpperCase();
        } else if (this.shorthandName === "downcase") {
          return !value ? "" : value.toLocaleLowerCase();
        } else if (this.shorthandName === "capitalize") {
          return !value ? "" : value[0].toLocaleUpperCase() + value.substr(1);
        } else if (this.shorthandName === "pascalcase") {
          return !value ? "" : this._toPascalCase(value);
        } else if (Boolean(value) && typeof this.ifValue === "string") {
          return this.ifValue;
        } else if (!value && typeof this.elseValue === "string") {
          return this.elseValue;
        } else {
          return value || "";
        }
      }
      _toPascalCase(value) {
        const match = value.match(/[a-z]+/gi);
        if (!match) {
          return value;
        }
        return match.map((word) => word.charAt(0).toUpperCase() + word.substr(1).toLowerCase()).join("");
      }
      toTextmateString() {
        let value = "${";
        value += this.index;
        if (this.shorthandName) {
          value += `:/${this.shorthandName}`;
        } else if (this.ifValue && this.elseValue) {
          value += `:?${this.ifValue}:${this.elseValue}`;
        } else if (this.ifValue) {
          value += `:+${this.ifValue}`;
        } else if (this.elseValue) {
          value += `:-${this.elseValue}`;
        }
        value += "}";
        return value;
      }
      clone() {
        let ret = new FormatString(this.index, this.shorthandName, this.ifValue, this.elseValue);
        return ret;
      }
    };
    Variable = class extends TransformableMarker {
      constructor(name2, resolved) {
        super();
        this.name = name2;
        this._resolved = false;
        if (typeof resolved === "boolean") {
          this._resolved = resolved;
        }
      }
      get resolved() {
        return this._resolved;
      }
      async resolve(resolver2) {
        let value = await resolver2.resolve(this);
        this._resolved = true;
        if (value && value.includes("\n")) {
          let indent = "";
          this.snippet.walk((m) => {
            if (m == this) {
              return false;
            }
            if (m instanceof Text) {
              let lines2 = m.toString().split(/\r?\n/);
              indent = lines2[lines2.length - 1].match(/^\s*/)[0];
            }
            return true;
          });
          let lines = value.split("\n");
          let indents = lines.filter((s) => s.length > 0).map((s) => s.match(/^\s*/)[0]);
          let minIndent = indents.length == 0 ? "" : indents.reduce((p, c) => p.length < c.length ? p : c);
          let newLines = lines.map((s, i) => i == 0 || s.length == 0 || !s.startsWith(minIndent) ? s : indent + s.slice(minIndent.length));
          value = newLines.join("\n");
        }
        if (this.transform) {
          value = this.transform.resolve(value || "");
        }
        if (value !== void 0) {
          this._children = [new Text(value)];
          return true;
        }
        return false;
      }
      toTextmateString() {
        let transformString = "";
        if (this.transform) {
          transformString = this.transform.toTextmateString();
        }
        if (this.children.length === 0) {
          return `\${${this.name}${transformString}}`;
        } else {
          return `\${${this.name}:${this.children.map((child) => child.toTextmateString()).join("")}${transformString}}`;
        }
      }
      clone() {
        const ret = new Variable(this.name, this.resolved);
        if (this.transform) {
          ret.transform = this.transform.clone();
        }
        ret._children = this.children.map((child) => child.clone());
        return ret;
      }
    };
    TextmateSnippet = class extends Marker {
      constructor(ultisnip) {
        super();
        this.ultisnip = ultisnip === true;
      }
      get hasPython() {
        if (!this.ultisnip)
          return false;
        return this.pyBlocks.length > 0;
      }
      get hasCodeBlock() {
        if (!this.ultisnip)
          return false;
        let { pyBlocks, otherBlocks } = this;
        return pyBlocks.length > 0 || otherBlocks.length > 0;
      }
      get values() {
        if (this._values)
          return this._values;
        let values = {};
        let maxIndexNumber = 0;
        this.placeholders.forEach((c) => {
          maxIndexNumber = Math.max(c.index, maxIndexNumber);
          if (c.transform != null)
            return;
          if (c.primary || values[c.index] === void 0)
            values[c.index] = c.toString();
        });
        for (let i = 0; i <= maxIndexNumber; i++) {
          if (values[i] === void 0)
            values[i] = "";
        }
        this._values = values;
        return values;
      }
      get orderedPyIndexBlocks() {
        let res = [];
        let filtered = this.pyBlocks.filter((o) => typeof o.index === "number");
        if (filtered.length == 0)
          return res;
        let allIndexes = filtered.map((o) => o.index);
        let usedIndexes = [];
        const checkBlock = (b) => {
          let { related } = b;
          if (related.length == 0 || related.every((idx) => !allIndexes.includes(idx) || usedIndexes.includes(idx))) {
            usedIndexes.push(b.index);
            res.push(b);
            return true;
          }
          return false;
        };
        while (filtered.length > 0) {
          let c = false;
          for (let b of filtered) {
            if (checkBlock(b)) {
              c = true;
            }
          }
          if (!c) {
            break;
          }
          filtered = filtered.filter((o) => !usedIndexes.includes(o.index));
        }
        return res;
      }
      async evalCodeBlocks(nvim, prepareCodes) {
        let { pyBlocks, otherBlocks } = this;
        await Promise.all(otherBlocks.map((block2) => {
          let pre = block2.value;
          return block2.resolve(nvim).then(() => {
            if (block2.parent instanceof Placeholder && pre !== block2.value) {
              this.onPlaceholderUpdate(block2.parent);
            }
          });
        }));
        if (pyBlocks.length) {
          const variableCode = getVariablesCode(this.values);
          await executePythonCode(nvim, [...prepareCodes, variableCode]);
          for (let block2 of pyBlocks) {
            let pre = block2.value;
            await block2.resolve(nvim);
            if (pre === block2.value)
              continue;
            if (block2.parent instanceof Placeholder) {
              this.onPlaceholderUpdate(block2.parent);
              await executePythonCode(nvim, [getVariablesCode(this.values)]);
            }
          }
          for (let block2 of this.orderedPyIndexBlocks) {
            await this.updatePyIndexBlock(nvim, block2);
          }
          let filtered = pyBlocks.filter((o) => o.index === void 0 && o.related.length > 0);
          for (let block2 of filtered) {
            await block2.resolve(nvim);
          }
        }
      }
      async updatePythonCodes(nvim, marker) {
        let index;
        if (marker instanceof Placeholder) {
          index = marker.index;
        } else {
          while (marker.parent) {
            if (marker instanceof Placeholder) {
              index = marker.index;
              break;
            }
            marker = marker.parent;
          }
        }
        if (index === void 0)
          return;
        let blocks = this.getDependentPyIndexBlocks(index);
        await executePythonCode(nvim, [getVariablesCode(this.values)]);
        for (let block2 of blocks) {
          await this.updatePyIndexBlock(nvim, block2);
        }
        let filtered = this.pyBlocks.filter((o) => o.index === void 0 && o.related.length > 0);
        for (let block2 of filtered) {
          await block2.resolve(nvim);
        }
      }
      getDependentPyIndexBlocks(index) {
        const res = [];
        const taken = [];
        let filtered = this.pyBlocks.filter((o) => typeof o.index === "number");
        const search = (idx) => {
          let blocks = filtered.filter((o) => !taken.includes(o.index) && o.related.includes(idx));
          if (blocks.length > 0) {
            res.push(...blocks);
            blocks.forEach((b) => {
              search(b.index);
            });
          }
        };
        search(index);
        return res;
      }
      async updatePyIndexBlock(nvim, block2) {
        let pre = block2.value;
        await block2.resolve(nvim);
        if (pre === block2.value)
          return;
        if (block2.parent instanceof Placeholder) {
          this.onPlaceholderUpdate(block2.parent);
        }
        await executePythonCode(nvim, [getVariablesCode(this.values)]);
      }
      get placeholderInfo() {
        if (!this._placeholders) {
          const variables = [];
          const pyBlocks = [];
          const otherBlocks = [];
          let placeholders = [];
          this.walk((candidate) => {
            if (candidate instanceof Placeholder) {
              placeholders.push(candidate);
            } else if (candidate instanceof Variable) {
              let first = candidate.name.charCodeAt(0);
              if (first < 65 || first > 90) {
                variables.push(candidate);
              }
            } else if (candidate instanceof CodeBlock) {
              if (candidate.kind === "python") {
                pyBlocks.push(candidate);
              } else {
                otherBlocks.push(candidate);
              }
            }
            return true;
          });
          this._placeholders = { placeholders, pyBlocks, otherBlocks, variables };
        }
        return this._placeholders;
      }
      get variables() {
        return this.placeholderInfo.variables;
      }
      get placeholders() {
        return this.placeholderInfo.placeholders;
      }
      get pyBlocks() {
        return this.placeholderInfo.pyBlocks;
      }
      get otherBlocks() {
        return this.placeholderInfo.otherBlocks;
      }
      get maxIndexNumber() {
        let { placeholders } = this;
        return placeholders.reduce((curr, p) => Math.max(curr, p.index), 0);
      }
      get first() {
        let { placeholders, variables } = this;
        let [normals, finals] = groupBy(placeholders.filter((p) => !p.transform), (v) => v.index !== 0);
        if (normals.length) {
          let minIndex = Math.min.apply(null, normals.map((o) => o.index));
          let arr = normals.filter((v) => v.index == minIndex);
          return arr.find((p) => p.primary) ?? arr[0];
        }
        if (variables.length)
          return variables[0];
        return finals.find((o) => o.primary) ?? finals[0];
      }
      insertSnippet(snippet, marker, parts, ultisnip) {
        let index = marker instanceof Placeholder ? marker.index : this.maxIndexNumber + 1;
        let [before, after] = parts;
        let matchCode = ultisnip ? prepareMatchCode(ultisnip) : void 0;
        let nested = new SnippetParser(!!ultisnip, matchCode).parse(snippet, true);
        let maxIndexAdded = nested.maxIndexNumber + 1;
        let changed = /* @__PURE__ */ new Map();
        for (let p of nested.placeholders) {
          let idx = p.index;
          if (p.isFinalTabstop) {
            p.index = maxIndexAdded + index;
          } else {
            p.index = p.index + index;
          }
          changed.set(idx, p.index);
        }
        if (ultisnip) {
          nested.pyBlocks.forEach((b) => {
            b.update(changed);
          });
        }
        let map = /* @__PURE__ */ new Map();
        this.walk((m) => {
          if (m instanceof Placeholder && m.index > index) {
            let idx = m.index;
            m.index = m.index + maxIndexAdded;
            map.set(idx, m.index);
          }
          return true;
        });
        if (this.hasPython) {
          this.walk((m) => {
            if (m instanceof CodeBlock) {
              m.update(map);
            }
            return true;
          });
        }
        const select = nested.first;
        let children = nested.children.slice();
        if (before)
          children.unshift(new Text(before));
        if (after)
          children.push(new Text(after));
        this.replace(marker, children);
        return select;
      }
      async update(nvim, marker, value) {
        this.resetMarker(marker, value);
        if (this.hasPython) {
          await this.updatePythonCodes(nvim, marker);
        }
      }
      deleteText(offset, length) {
        let pos = 0;
        let marker;
        let end = offset + length;
        let start = 0;
        this.walk((candidate) => {
          let len = candidate.len();
          if (candidate instanceof Text && offset >= pos && pos + len >= end) {
            marker = candidate;
            start = offset - pos;
            return false;
          }
          pos += len;
          return true;
        });
        if (!marker)
          return false;
        let parent = marker.parent;
        let text = marker.value;
        let value = text.slice(0, start) + text.slice(start + length);
        let children = parent.children.slice();
        let idx = children.indexOf(marker);
        children.splice(idx, 1, new Text(value));
        parent.replaceChildren(children);
        return true;
      }
      resetMarker(marker, val) {
        let markers;
        if (marker instanceof Placeholder) {
          markers = this.placeholders.filter((o) => o.index == marker.index);
        } else {
          markers = this.variables.filter((o) => o.name == marker.name);
        }
        for (let p of markers) {
          let newText = p.transform ? p.transform.resolve(val) : val;
          p.setOnlyChild(new Text(newText || ""));
        }
        this.synchronizeParents(markers);
        this.reset();
      }
      onPlaceholderUpdate(marker) {
        let val = marker.toString();
        let markers;
        if (marker instanceof Placeholder) {
          this.values[marker.index] = val;
          markers = this.placeholders.filter((o) => o.index == marker.index);
        } else {
          markers = this.variables.filter((o) => o.name == marker.name);
        }
        for (let p of markers) {
          if (p === marker)
            continue;
          let newText = p.transform ? p.transform.resolve(val) : val;
          p.setOnlyChild(new Text(newText || ""));
        }
        this.synchronizeParents(markers);
      }
      synchronizeParents(markers) {
        let arr = [];
        markers.forEach((m) => {
          let p = m.parent;
          if (p instanceof Placeholder && !arr.includes(p)) {
            arr.push(p);
          }
        });
        arr.forEach((p) => {
          this.onPlaceholderUpdate(p);
        });
      }
      offset(marker) {
        let pos = 0;
        let found = false;
        this.walk((candidate) => {
          if (candidate === marker) {
            found = true;
            return false;
          }
          pos += candidate.len();
          return true;
        });
        if (!found) {
          return -1;
        }
        return pos;
      }
      fullLen(marker) {
        let ret = 0;
        walk([marker], (marker2) => {
          ret += marker2.len();
          return true;
        });
        return ret;
      }
      getTextBefore(marker, parent) {
        let res = "";
        const calc = (m) => {
          let p = m.parent;
          if (!p)
            return;
          let s = "";
          for (let b of p.children) {
            if (b === m)
              break;
            s = s + b.toString();
          }
          res = s + res;
          if (p == parent)
            return;
          calc(p);
        };
        calc(marker);
        return res;
      }
      enclosingPlaceholders(placeholder) {
        let ret = [];
        let { parent } = placeholder;
        while (parent) {
          if (parent instanceof Placeholder) {
            ret.push(parent);
          }
          parent = parent.parent;
        }
        return ret;
      }
      async resolveVariables(resolver2) {
        let items = [];
        this.walk((candidate) => {
          if (candidate instanceof Variable && !candidate.resolved) {
            items.push(candidate);
          }
          return true;
        });
        if (items.length) {
          await Promise.all(items.map((o) => o.resolve(resolver2)));
          this.synchronizeParents(items);
        }
      }
      appendChild(child) {
        this.reset();
        return super.appendChild(child);
      }
      replace(marker, children) {
        marker.replaceChildren(children);
        if (marker instanceof Placeholder || marker instanceof Variable) {
          this.onPlaceholderUpdate(marker);
        }
        this.reset();
      }
      reset() {
        this._placeholders = void 0;
        this._values = void 0;
      }
      toTextmateString() {
        return this.children.reduce((prev, cur) => prev + cur.toTextmateString(), "");
      }
      clone() {
        let ret = new TextmateSnippet(this.ultisnip);
        ret._children = this.children.map((child) => child.clone());
        return ret;
      }
      walk(visitor) {
        walk(this.children, visitor);
      }
    };
    SnippetParser = class {
      constructor(ultisnip, matchCode) {
        this.ultisnip = ultisnip;
        this.matchCode = matchCode;
        this._scanner = new Scanner();
      }
      static escape(value) {
        return value.replace(/\$|}|\\/g, "\\$&");
      }
      static isPlainText(value) {
        let s = new SnippetParser().parse(value.replace(/\$0$/, ""), false);
        return s.children.length == 1 && s.children[0] instanceof Text;
      }
      text(value) {
        return this.parse(value, false).toString();
      }
      parse(value, insertFinalTabstop) {
        this._scanner.text(value);
        this._token = this._scanner.next();
        const snippet = new TextmateSnippet(this.ultisnip);
        while (this._parse(snippet)) {
        }
        const defaultValues = /* @__PURE__ */ new Map();
        const incompletePlaceholders = [];
        let complexPlaceholders = [];
        let hasFinal = false;
        snippet.walk((marker) => {
          if (marker instanceof Placeholder) {
            if (marker.index == 0)
              hasFinal = true;
            if (marker.children.some((o) => o instanceof Placeholder)) {
              complexPlaceholders.push(marker);
            } else if (!defaultValues.has(marker.index) && marker.children.length > 0) {
              marker.primary = true;
              defaultValues.set(marker.index, marker.toString());
            } else {
              incompletePlaceholders.push(marker);
            }
          }
          return true;
        });
        const complexIndexes = complexPlaceholders.map((p) => p.index);
        for (const placeholder of incompletePlaceholders) {
          if (defaultValues.has(placeholder.index)) {
            let val = defaultValues.get(placeholder.index);
            let text = new Text(placeholder.transform ? placeholder.transform.resolve(val) : val);
            placeholder.setOnlyChild(text);
          } else if (!complexIndexes.includes(placeholder.index)) {
            if (placeholder.transform) {
              let text = new Text(placeholder.transform.resolve(""));
              placeholder.setOnlyChild(text);
            } else {
              placeholder.primary = true;
              defaultValues.set(placeholder.index, "");
            }
          }
        }
        const resolveComplex = () => {
          let resolved = /* @__PURE__ */ new Set();
          for (let p of complexPlaceholders) {
            if (p.children.every((o) => !(o instanceof Placeholder) || defaultValues.has(o.index))) {
              let val = p.toString();
              defaultValues.set(p.index, val);
              for (let placeholder of incompletePlaceholders.filter((o) => o.index == p.index)) {
                let text = new Text(placeholder.transform ? placeholder.transform.resolve(val) : val);
                placeholder.setOnlyChild(text);
              }
              resolved.add(p.index);
            }
          }
          complexPlaceholders = complexPlaceholders.filter((p) => !resolved.has(p.index));
          if (complexPlaceholders.length == 0 || !resolved.size)
            return;
          resolveComplex();
        };
        resolveComplex();
        if (!hasFinal && insertFinalTabstop) {
          snippet.appendChild(new Placeholder(0));
        }
        return snippet;
      }
      _accept(type, value) {
        if (type === void 0 || this._token.type === type) {
          let ret = !value ? true : this._scanner.tokenText(this._token);
          this._token = this._scanner.next();
          return ret;
        }
        return false;
      }
      _backTo(token) {
        this._scanner.pos = token.pos + token.len;
        this._token = token;
        return false;
      }
      _until(type, checkBackSlash = false) {
        if (this._token.type === 14 /* EOF */) {
          return false;
        }
        let start = this._token;
        let pre;
        while (this._token.type !== type || checkBackSlash && (pre == null ? void 0 : pre.type) === 5 /* Backslash */) {
          if (checkBackSlash)
            pre = this._token;
          this._token = this._scanner.next();
          if (this._token.type === 14 /* EOF */) {
            return false;
          }
        }
        let value = this._scanner.value.substring(start.pos, this._token.pos);
        this._token = this._scanner.next();
        return value;
      }
      _parse(marker) {
        return this._parseEscaped(marker) || this._parseCodeBlock(marker) || this._parseTabstopOrVariableName(marker) || this._parseComplexPlaceholder(marker) || this._parseComplexVariable(marker) || this._parseAnything(marker);
      }
      _parseEscaped(marker) {
        let value;
        if (value = this._accept(5 /* Backslash */, true)) {
          value = this._accept(0 /* Dollar */, true) || this._accept(4 /* CurlyClose */, true) || this._accept(5 /* Backslash */, true) || this.ultisnip && this._accept(3 /* CurlyOpen */, true) || this.ultisnip && this._accept(17 /* BackTick */, true) || value;
          marker.appendChild(new Text(value));
          return true;
        }
        return false;
      }
      _parseTabstopOrVariableName(parent) {
        let value;
        const token = this._token;
        const match = this._accept(0 /* Dollar */) && (value = this._accept(9 /* VariableName */, true) || this._accept(8 /* Int */, true));
        if (!match) {
          return this._backTo(token);
        }
        parent.appendChild(/^\d+$/.test(value) ? new Placeholder(Number(value)) : new Variable(value));
        return true;
      }
      _parseComplexPlaceholder(parent) {
        let index;
        const token = this._token;
        const match = this._accept(0 /* Dollar */) && this._accept(3 /* CurlyOpen */) && (index = this._accept(8 /* Int */, true));
        if (!match) {
          return this._backTo(token);
        }
        const placeholder = new Placeholder(Number(index));
        if (this._accept(1 /* Colon */)) {
          while (true) {
            if (this._accept(4 /* CurlyClose */)) {
              parent.appendChild(placeholder);
              return true;
            }
            if (this._parse(placeholder)) {
              continue;
            }
            parent.appendChild(new Text("${" + index + ":"));
            placeholder.children.forEach(parent.appendChild, parent);
            return true;
          }
        } else if (placeholder.index > 0 && this._accept(7 /* Pipe */)) {
          const choice = new Choice();
          while (true) {
            if (this._parseChoiceElement(choice)) {
              if (this._accept(2 /* Comma */)) {
                continue;
              }
              if (this._accept(7 /* Pipe */)) {
                placeholder.appendChild(choice);
                if (this._accept(4 /* CurlyClose */)) {
                  parent.appendChild(placeholder);
                  return true;
                }
              }
            }
            this._backTo(token);
            return false;
          }
        } else if (this._accept(6 /* Forwardslash */)) {
          if (this._parseTransform(placeholder)) {
            parent.appendChild(placeholder);
            return true;
          }
          this._backTo(token);
          return false;
        } else if (this._accept(4 /* CurlyClose */)) {
          parent.appendChild(placeholder);
          return true;
        } else {
          return this._backTo(token);
        }
      }
      _parseChoiceElement(parent) {
        const token = this._token;
        const values = [];
        while (true) {
          if (this._token.type === 2 /* Comma */ || this._token.type === 7 /* Pipe */) {
            break;
          }
          let value;
          if (value = this._accept(5 /* Backslash */, true)) {
            value = this._accept(2 /* Comma */, true) || this._accept(7 /* Pipe */, true) || this._accept(5 /* Backslash */, true) || value;
          } else {
            value = this._accept(void 0, true);
          }
          if (!value) {
            this._backTo(token);
            return false;
          }
          values.push(value);
        }
        if (values.length === 0) {
          this._backTo(token);
          return false;
        }
        parent.appendChild(new Text(values.join("")));
        return true;
      }
      _parseComplexVariable(parent) {
        let name2;
        const token = this._token;
        const match = this._accept(0 /* Dollar */) && this._accept(3 /* CurlyOpen */) && (name2 = this._accept(9 /* VariableName */, true));
        if (!match) {
          return this._backTo(token);
        }
        const variable = new Variable(name2);
        if (this._accept(1 /* Colon */)) {
          while (true) {
            if (this._accept(4 /* CurlyClose */)) {
              parent.appendChild(variable);
              return true;
            }
            if (this._parse(variable)) {
              continue;
            }
            parent.appendChild(new Text("${" + name2 + ":"));
            variable.children.forEach(parent.appendChild, parent);
            return true;
          }
        } else if (this._accept(6 /* Forwardslash */)) {
          if (this._parseTransform(variable)) {
            parent.appendChild(variable);
            return true;
          }
          this._backTo(token);
          return false;
        } else if (this._accept(4 /* CurlyClose */)) {
          parent.appendChild(variable);
          return true;
        } else {
          return this._backTo(token);
        }
      }
      _parseTransform(parent) {
        let transform = new Transform();
        transform.ultisnip = this.ultisnip === true;
        let regexValue = "";
        let regexOptions = "";
        while (true) {
          if (this._accept(6 /* Forwardslash */)) {
            break;
          }
          let escaped;
          if (escaped = this._accept(5 /* Backslash */, true)) {
            escaped = this._accept(6 /* Forwardslash */, true) || escaped;
            regexValue += escaped;
            continue;
          }
          if (this._token.type !== 14 /* EOF */) {
            regexValue += this._accept(void 0, true);
            continue;
          }
          return false;
        }
        while (true) {
          if (this._accept(6 /* Forwardslash */)) {
            break;
          }
          let escaped;
          if (escaped = this._accept(5 /* Backslash */, true)) {
            escaped = this._accept(6 /* Forwardslash */, true) || escaped;
            transform.appendChild(new Text(escaped));
            continue;
          }
          if (this._parseFormatString(transform) || this._parseConditionString(transform) || this._parseAnything(transform)) {
            continue;
          }
          return false;
        }
        let ascii = false;
        while (true) {
          if (this._accept(4 /* CurlyClose */)) {
            break;
          }
          if (this._token.type !== 14 /* EOF */) {
            let c = this._accept(void 0, true);
            if (c == "a") {
              ascii = true;
            } else {
              if (!knownRegexOptions.includes(c)) {
                logger81.error(`Unknown regex option: ${c}`);
              }
              regexOptions += c;
            }
            continue;
          }
          return false;
        }
        try {
          if (ascii)
            transform.ascii = true;
          if (this.ultisnip)
            regexValue = convertRegex(regexValue);
          transform.regexp = new RegExp(regexValue, regexOptions);
        } catch (e) {
          return false;
        }
        parent.transform = transform;
        return true;
      }
      _parseConditionString(parent) {
        if (!this.ultisnip)
          return false;
        const token = this._token;
        if (!this._accept(15 /* OpenParen */)) {
          return false;
        }
        if (!this._accept(13 /* QuestionMark */)) {
          this._backTo(token);
          return false;
        }
        let index = this._accept(8 /* Int */, true);
        if (!index) {
          this._backTo(token);
          return false;
        }
        if (!this._accept(1 /* Colon */)) {
          this._backTo(token);
          return false;
        }
        let text = this._until(16 /* CloseParen */, true);
        if (text) {
          let i = 0;
          while (i < text.length) {
            let t = text[i];
            if (t == ":" && text[i - 1] != "\\") {
              break;
            }
            i++;
          }
          let ifValue = text.slice(0, i);
          let elseValue = text.slice(i + 1);
          parent.appendChild(new ConditionString(Number(index), ifValue, elseValue));
          return true;
        }
        this._backTo(token);
        return false;
      }
      _parseFormatString(parent) {
        const token = this._token;
        if (!this._accept(0 /* Dollar */)) {
          return false;
        }
        let complex = false;
        if (this._accept(3 /* CurlyOpen */)) {
          complex = true;
        }
        let index = this._accept(8 /* Int */, true);
        if (!index) {
          this._backTo(token);
          return false;
        } else if (!complex) {
          parent.appendChild(new FormatString(Number(index)));
          return true;
        } else if (this._accept(4 /* CurlyClose */)) {
          parent.appendChild(new FormatString(Number(index)));
          return true;
        } else if (!this._accept(1 /* Colon */)) {
          this._backTo(token);
          return false;
        }
        if (this.ultisnip) {
          this._backTo(token);
          return false;
        }
        if (this._accept(6 /* Forwardslash */)) {
          let shorthand = this._accept(9 /* VariableName */, true);
          if (!shorthand || !this._accept(4 /* CurlyClose */)) {
            this._backTo(token);
            return false;
          } else {
            parent.appendChild(new FormatString(Number(index), shorthand));
            return true;
          }
        } else if (this._accept(11 /* Plus */)) {
          let ifValue = this._until(4 /* CurlyClose */);
          if (ifValue) {
            parent.appendChild(new FormatString(Number(index), void 0, ifValue, void 0));
            return true;
          }
        } else if (this._accept(12 /* Dash */)) {
          let elseValue = this._until(4 /* CurlyClose */);
          if (elseValue) {
            parent.appendChild(new FormatString(Number(index), void 0, void 0, elseValue));
            return true;
          }
        } else if (this._accept(13 /* QuestionMark */)) {
          let ifValue = this._until(1 /* Colon */);
          if (ifValue) {
            let elseValue = this._until(4 /* CurlyClose */);
            if (elseValue) {
              parent.appendChild(new FormatString(Number(index), void 0, ifValue, elseValue));
              return true;
            }
          }
        } else {
          let elseValue = this._until(4 /* CurlyClose */);
          if (elseValue) {
            parent.appendChild(new FormatString(Number(index), void 0, void 0, elseValue));
            return true;
          }
        }
        this._backTo(token);
        return false;
      }
      _parseCodeBlock(parent) {
        if (!this.ultisnip)
          return false;
        const token = this._token;
        if (!this._accept(17 /* BackTick */)) {
          return false;
        }
        let text = this._until(17 /* BackTick */, true);
        if (text) {
          if (!text.startsWith("!")) {
            let marker = new CodeBlock(text.trim(), "shell");
            parent.appendChild(marker);
            return true;
          }
          if (text.startsWith("!v")) {
            let marker = new CodeBlock(text.slice(2).trim(), "vim");
            parent.appendChild(marker);
            return true;
          }
          if (text.startsWith("!p")) {
            let code = text.slice(2);
            let pre = this.matchCode ? this.matchCode + "\n" : "";
            if (code.indexOf("\n") == -1) {
              let marker = new CodeBlock(pre + code.trim(), "python");
              parent.appendChild(marker);
            } else {
              let codes = code.split(/\r?\n/);
              codes = codes.filter((s) => !/^\s*$/.test(s));
              let ind = codes[0] ? codes[0].match(/^\s*/)[0] : "";
              if (ind.length && codes.every((s) => s.startsWith(ind))) {
                codes = codes.map((s) => s.slice(ind.length));
              }
              if (ind == " " && codes[0].startsWith(ind))
                codes[0] = codes[0].slice(1);
              let marker = new CodeBlock(pre + codes.join("\n"), "python");
              parent.appendChild(marker);
            }
            return true;
          }
        }
        this._backTo(token);
        return false;
      }
      _parseAnything(marker) {
        if (this._token.type !== 14 /* EOF */) {
          let text = this._scanner.tokenText(this._token);
          marker.appendChild(new Text(text));
          this._accept(void 0);
          return true;
        }
        return false;
      }
    };
    escapedCharacters = [":", "(", ")", "{", "}"];
  }
});

// src/snippets/snippet.ts
function reduceTextEdit(edit2, oldText) {
  let { range: range2, newText } = edit2;
  let ol = oldText.length;
  let nl = newText.length;
  if (ol === 0 || nl === 0)
    return edit2;
  let { start, end } = range2;
  let bo = 0;
  for (let i = 1; i <= Math.min(nl, ol); i++) {
    if (newText[i - 1] === oldText[i - 1]) {
      bo = i;
    } else {
      break;
    }
  }
  let eo = 0;
  let t = Math.min(nl - bo, ol - bo);
  if (t > 0) {
    for (let i = 1; i <= t; i++) {
      if (newText[nl - i] === oldText[ol - i]) {
        eo = i;
      } else {
        break;
      }
    }
  }
  let text = eo == 0 ? newText.slice(bo) : newText.slice(bo, -eo);
  if (bo > 0)
    start = getEnd(start, newText.slice(0, bo));
  if (eo > 0)
    end = getEnd(range2.start, oldText.slice(0, -eo));
  return import_vscode_languageserver_protocol83.TextEdit.replace(import_vscode_languageserver_protocol83.Range.create(start, end), text);
}
function checkCursor(start, cursor, newText) {
  let r = import_vscode_languageserver_protocol83.Range.create(start, getEnd(start, newText));
  return positionInRange(cursor, r) == 0;
}
function checkContentBefore(position, oldTextDocument, textDocument) {
  let lines = textDocument.lines;
  if (lines.length < position.line)
    return false;
  let checked = true;
  for (let i = position.line; i >= 0; i--) {
    let newLine = textDocument.lines[i] ?? "";
    if (i === position.line) {
      let before = oldTextDocument.lines[i].slice(0, position.character);
      if (!newLine.startsWith(before)) {
        checked = false;
        break;
      }
    } else if (newLine !== oldTextDocument.lines[i]) {
      checked = false;
      break;
    }
  }
  return checked;
}
function getEndPosition(position, oldTextDocument, textDocument) {
  let total = oldTextDocument.lines.length;
  if (textDocument.lines.length < total - position.line)
    return void 0;
  let end;
  let cl = textDocument.lines.length - total;
  for (let i = position.line; i < total; i++) {
    let newLine = textDocument.lines[i + cl];
    if (i == position.line) {
      let text = oldTextDocument.lines[i].slice(position.character);
      if (text.length && !newLine.endsWith(text))
        break;
      end = import_vscode_languageserver_protocol83.Position.create(i + cl, newLine.length - text.length);
    } else if (newLine !== oldTextDocument.lines[i]) {
      end = void 0;
      break;
    }
  }
  return end;
}
function getParts(text, range2, r) {
  let before = [];
  let after = [];
  let lines = text.split("\n");
  let d = r.start.line - range2.start.line;
  for (let i = 0; i <= d; i++) {
    let s = lines[i] ?? "";
    if (i == d) {
      before.push(i == 0 ? s.substring(0, r.start.character - range2.start.character) : s.substring(0, r.start.character));
    } else {
      before.push(s);
    }
  }
  d = range2.end.line - r.end.line;
  for (let i = 0; i <= d; i++) {
    let s = lines[r.end.line - range2.start.line + i] ?? "";
    if (i == 0) {
      if (d == 0) {
        after.push(range2.end.character == r.end.character ? "" : s.slice(r.end.character - range2.end.character));
      } else {
        after.push(s.substring(r.end.character));
      }
    } else {
      after.push(s);
    }
  }
  return [before.join("\n"), after.join("\n")];
}
function normalizeSnippetString(snippet, indent, opts) {
  let lines = snippet.split(/\r?\n/);
  let ind = opts.insertSpaces ? " ".repeat(opts.tabSize) : "	";
  let tabSize = opts.tabSize || 2;
  lines = lines.map((line, idx) => {
    let space = line.match(/^\s*/)[0];
    let pre = space;
    let isTab = space.startsWith("	");
    if (isTab && opts.insertSpaces) {
      pre = ind.repeat(space.length);
    } else if (!isTab && !opts.insertSpaces) {
      pre = ind.repeat(space.length / tabSize);
    }
    return (idx == 0 || line.length == 0 ? "" : indent) + pre + line.slice(space.length);
  });
  return lines.join("\n");
}
function shouldFormat(snippet) {
  if (/^\s/.test(snippet))
    return true;
  if (snippet.indexOf("\n") !== -1)
    return true;
  return false;
}
var import_vscode_languageserver_protocol83, logger82, CocSnippet;
var init_snippet = __esm({
  "src/snippets/snippet.ts"() {
    "use strict";
    import_vscode_languageserver_protocol83 = __toESM(require_main2());
    init_main3();
    init_position();
    init_textedit();
    init_eval();
    init_parser2();
    logger82 = require_logger2()("snippets-snipet");
    CocSnippet = class {
      constructor(snippetString, position, nvim, resolver2) {
        this.snippetString = snippetString;
        this.position = position;
        this.nvim = nvim;
        this.resolver = resolver2;
      }
      async init(ultisnip, isResolve = false) {
        const matchCode = ultisnip ? prepareMatchCode(ultisnip) : void 0;
        const parser2 = new SnippetParser(!!ultisnip, matchCode);
        const snippet = parser2.parse(this.snippetString, true);
        this.tmSnippet = snippet;
        await this.resolve(ultisnip);
        this.synchronize();
        if (!isResolve) {
          this.nvim.call("coc#compat#del_var", ["coc_selected_text"], true);
          this.nvim.call("coc#compat#del_var", ["coc_last_placeholder"], true);
        }
      }
      async resolve(ultisnip) {
        let { snippet } = this.tmSnippet;
        let { resolver: resolver2, nvim } = this;
        if (resolver2) {
          await snippet.resolveVariables(resolver2);
        }
        if (ultisnip && ultisnip.noPython !== true) {
          let pyCodes = [];
          if (snippet.hasPython)
            pyCodes = preparePythonCodes(ultisnip);
          await snippet.evalCodeBlocks(nvim, pyCodes);
        }
      }
      getRanges(placeholder) {
        let marker = placeholder.marker;
        if (placeholder.value.length == 0)
          return [];
        let placeholders = this._placeholders.filter((o) => o.index == placeholder.index);
        let ranges = placeholders.map((o) => o.range);
        let parents = this.tmSnippet.enclosingPlaceholders(marker);
        let markers;
        let p = marker.parent;
        if (marker instanceof Placeholder) {
          let index = marker.index;
          markers = this.tmSnippet.placeholders.filter((o) => o.index == index && o.parent == p);
        } else {
          let name2 = marker.name;
          markers = this.tmSnippet.variables.filter((o) => o.name == name2 && o.parent == p);
        }
        parents.forEach((p2) => {
          let arr = this._placeholders.filter((o) => o.index == p2.index && o.marker !== p2);
          if (!arr.length)
            return;
          for (let m of markers) {
            let before = this.tmSnippet.getTextBefore(m, p2);
            arr.forEach((item) => {
              if (item.transform) {
                ranges.push(item.range);
              } else {
                let s = item.range.start;
                ranges.push(import_vscode_languageserver_protocol83.Range.create(getEnd(s, before), getEnd(s, before + m.toString())));
              }
            });
          }
        });
        return ranges.filter((r) => !emptyRange(r));
      }
      getSortedPlaceholders(curr) {
        let res = curr ? [curr] : [];
        let arr = this._placeholders.filter((o) => o !== curr && !o.transform);
        arr.sort((a, b) => {
          if (a.primary !== b.primary)
            return a.primary ? -1 : 1;
          if (a.index == 0 || b.index == 0)
            return a.index == 0 ? 1 : -1;
          return a.index - b.index;
        });
        res.push(...arr);
        return res;
      }
      get hasPython() {
        return this.tmSnippet.pyBlocks.length > 0;
      }
      resetStartPosition(pos) {
        this.position = pos;
        this.synchronize();
      }
      get start() {
        return Object.assign({}, this.position);
      }
      get range() {
        return import_vscode_languageserver_protocol83.Range.create(this.position, getEnd(this.position, this._text));
      }
      get text() {
        return this._text;
      }
      get finalCount() {
        return this._placeholders.filter((o) => o.index == 0).length;
      }
      get placeholders() {
        return this._placeholders.map((o) => o.marker);
      }
      get firstPlaceholder() {
        let index = 0;
        for (let p of this._placeholders) {
          if (p.index == 0 || p.transform)
            continue;
          if (index == 0 || p.index < index) {
            index = p.index;
          }
        }
        return this.getPlaceholder(index);
      }
      getPlaceholderByMarker(marker) {
        return this._placeholders.find((o) => o.marker === marker);
      }
      getPlaceholder(index) {
        let filtered = this._placeholders.filter((o) => o.index == index && !o.transform);
        let find = filtered.find((o) => o.primary) || filtered[0];
        return find ?? filtered[0];
      }
      getPrevPlaceholder(index) {
        if (index <= 1)
          return void 0;
        let placeholders = this._placeholders.filter((o) => o.index < index && o.index != 0 && !o.transform);
        let find;
        while (index > 1) {
          index = index - 1;
          let arr = placeholders.filter((o) => o.index == index);
          if (arr.length) {
            find = arr.find((o) => o.primary) || arr[0];
            break;
          }
        }
        return find;
      }
      getNextPlaceholder(index) {
        let placeholders = this._placeholders.filter((o) => !o.transform);
        let find;
        let indexes = placeholders.map((o) => o.index);
        let max = Math.max.apply(null, indexes);
        for (let i = index + 1; i <= max + 1; i++) {
          let idx = i == max + 1 ? 0 : i;
          let arr = placeholders.filter((o) => o.index == idx);
          if (arr.length) {
            find = arr.find((o) => o.primary) || arr[0];
            break;
          }
        }
        return find;
      }
      getPlaceholderByRange(range2) {
        return this._placeholders.find((o) => rangeInRange(range2, o.range));
      }
      async insertSnippet(placeholder, snippet, parts, ultisnip) {
        if (ultisnip) {
          let { start, end } = placeholder.range;
          this.nvim.setVar("coc_last_placeholder", {
            current_text: placeholder.value,
            start: { line: start.line, col: start.character, character: start.character },
            end: { line: end.line, col: end.character, character: end.character }
          }, true);
        }
        let select = this.tmSnippet.insertSnippet(snippet, placeholder.marker, parts, ultisnip);
        await this.resolve(ultisnip);
        this.synchronize();
        return select;
      }
      getNewText(placeholder, inserted) {
        let { before, after } = placeholder;
        if (!inserted.startsWith(before))
          return void 0;
        if (inserted.length < before.length + after.length)
          return void 0;
        if (!inserted.endsWith(after))
          return void 0;
        if (!after.length)
          return inserted.slice(before.length);
        return inserted.slice(before.length, -after.length);
      }
      async updatePlaceholder(placeholder, cursor, newText, token) {
        let start = this.position;
        let { marker, before } = placeholder;
        let cloned = this.tmSnippet.clone();
        token.onCancellationRequested(() => {
          this.tmSnippet = cloned;
          this.synchronize();
        });
        let r = import_vscode_languageserver_protocol83.Range.create(start, getEnd(start, before));
        await this.tmSnippet.update(this.nvim, marker, newText);
        if (token.isCancellationRequested)
          return void 0;
        this.synchronize();
        let p = this._placeholders.find((o) => o.marker == marker);
        let after = p ? p.before : before;
        return { text: this._text, delta: getChangedPosition(cursor, import_vscode_languageserver_protocol83.TextEdit.replace(r, after)) };
      }
      removeText(offset, length) {
        let succeed = this.tmSnippet.deleteText(offset, length);
        if (succeed)
          this.synchronize();
        return succeed;
      }
      synchronize() {
        const snippet = this.tmSnippet;
        const { line, character } = this.position;
        const document2 = TextDocument2.create("untitled:/1", "snippet", 0, snippet.toString());
        let { placeholders, variables, maxIndexNumber } = snippet;
        const variableIndexMap = /* @__PURE__ */ new Map();
        let variableIndex = maxIndexNumber + 1;
        this._placeholders = [...placeholders, ...variables].map((p) => {
          const offset = snippet.offset(p);
          const position = document2.positionAt(offset);
          const start = {
            line: line + position.line,
            character: position.line == 0 ? character + position.character : position.character
          };
          let index;
          if (p instanceof Variable) {
            let key = p.name;
            if (variableIndexMap.has(key)) {
              index = variableIndexMap.get(key);
            } else {
              variableIndexMap.set(key, variableIndex);
              index = variableIndex;
              variableIndex = variableIndex + 1;
            }
          } else {
            index = p.index;
          }
          const value = p.toString();
          const end = getEnd(position, value);
          let res = {
            index,
            value,
            marker: p,
            transform: !!p.transform,
            range: import_vscode_languageserver_protocol83.Range.create(start, getEnd(start, value)),
            before: document2.getText(import_vscode_languageserver_protocol83.Range.create(import_vscode_languageserver_protocol83.Position.create(0, 0), position)),
            after: document2.getText(import_vscode_languageserver_protocol83.Range.create(end, import_vscode_languageserver_protocol83.Position.create(document2.lineCount, 0))),
            primary: p instanceof Placeholder && p.primary === true
          };
          return res;
        });
        this._text = this.tmSnippet.toString();
      }
    };
  }
});

// src/snippets/variableResolve.ts
function padZero(n) {
  return n < 10 ? "0" + n : n.toString();
}
function parseComments(comments) {
  let start;
  let end;
  let single;
  let parts = comments.split(",");
  for (let s of parts) {
    if (start && end && single)
      break;
    if (!s.includes(":"))
      continue;
    let [flag, str] = s.split(":");
    if (flag.includes("s")) {
      start = str;
    } else if (flag.includes("e")) {
      end = str;
    } else if (!single && flag == "") {
      single = str;
    }
  }
  return { start, end, single };
}
function parseCommentstring(commentstring) {
  if (commentstring.endsWith("%s"))
    return commentstring.slice(0, -2).trim();
  return void 0;
}
var import_path33, logger83, SnippetVariableResolver;
var init_variableResolve = __esm({
  "src/snippets/variableResolve.ts"() {
    "use strict";
    import_path33 = __toESM(require("path"));
    init_esm_node();
    init_esm();
    logger83 = require_logger2()("snippets-variable");
    SnippetVariableResolver = class {
      constructor(nvim, workspaceFolder) {
        this.nvim = nvim;
        this.workspaceFolder = workspaceFolder;
        this._variableToValue = {};
        const currentDate = new Date();
        const fullyear = currentDate.getFullYear().toString();
        Object.assign(this._variableToValue, {
          CURRENT_YEAR: fullyear,
          CURRENT_YEAR_SHORT: fullyear.slice(-2),
          CURRENT_MONTH: padZero(currentDate.getMonth() + 1),
          CURRENT_DATE: padZero(currentDate.getDate()),
          CURRENT_HOUR: padZero(currentDate.getHours()),
          CURRENT_MINUTE: padZero(currentDate.getMinutes()),
          CURRENT_SECOND: padZero(currentDate.getSeconds()),
          CURRENT_DAY_NAME: currentDate.toLocaleString("en-US", { weekday: "long" }),
          CURRENT_DAY_NAME_SHORT: currentDate.toLocaleString("en-US", { weekday: "short" }),
          CURRENT_MONTH_NAME: currentDate.toLocaleString("en-US", { month: "long" }),
          CURRENT_MONTH_NAME_SHORT: currentDate.toLocaleString("en-US", { month: "short" }),
          TM_FILENAME: null,
          TM_FILENAME_BASE: null,
          TM_DIRECTORY: null,
          TM_FILEPATH: null,
          YANK: null,
          TM_LINE_INDEX: null,
          TM_LINE_NUMBER: null,
          TM_CURRENT_LINE: null,
          TM_CURRENT_WORD: null,
          TM_SELECTED_TEXT: null,
          VISUAL: null,
          CLIPBOARD: null,
          RELATIVE_FILEPATH: null,
          RANDOM: null,
          RANDOM_HEX: null,
          UUID: null,
          BLOCK_COMMENT_START: null,
          BLOCK_COMMENT_END: null,
          LINE_COMMENT: null,
          WORKSPACE_NAME: null,
          WORKSPACE_FOLDER: null
        });
      }
      async resolveValue(name2) {
        let { nvim } = this;
        if (["TM_FILENAME", "TM_FILENAME_BASE", "TM_DIRECTORY", "TM_FILEPATH"].includes(name2)) {
          let filepath = await nvim.eval('expand("%:p")');
          if (name2 === "TM_FILENAME")
            return import_path33.default.basename(filepath);
          if (name2 === "TM_FILENAME_BASE")
            return import_path33.default.basename(filepath, import_path33.default.extname(filepath));
          if (name2 === "TM_DIRECTORY")
            return import_path33.default.dirname(filepath);
          if (name2 === "TM_FILEPATH")
            return filepath;
        }
        if (name2 === "YANK") {
          return await nvim.call("getreg", ['""']);
        }
        if (name2 === "TM_LINE_INDEX") {
          let lnum = await nvim.call("line", ["."]);
          return (lnum - 1).toString();
        }
        if (name2 === "TM_LINE_NUMBER") {
          let lnum = await nvim.call("line", ["."]);
          return lnum.toString();
        }
        if (name2 === "TM_CURRENT_LINE") {
          return await nvim.call("getline", ["."]);
        }
        if (name2 === "TM_CURRENT_WORD") {
          return await nvim.eval(`expand('<cword>')`);
        }
        if (name2 === "TM_SELECTED_TEXT" || name2 == "VISUAL") {
          return await nvim.eval(`get(g:,'coc_selected_text', v:null)`);
        }
        if (name2 === "CLIPBOARD") {
          return await nvim.eval("@*");
        }
        if (name2 === "RANDOM") {
          return Math.random().toString().slice(-6);
        }
        if (name2 === "RANDOM_HEX") {
          return Math.random().toString(16).slice(-6);
        }
        if (name2 === "UUID") {
          return v4_default();
        }
        if (["RELATIVE_FILEPATH", "WORKSPACE_NAME", "WORKSPACE_FOLDER"].includes(name2)) {
          let filepath = await nvim.eval('expand("%:p")');
          let folder = this.workspaceFolder.getWorkspaceFolder(URI2.file(filepath));
          if (name2 === "RELATIVE_FILEPATH")
            return this.workspaceFolder.getRelativePath(filepath);
          if (name2 === "WORKSPACE_NAME")
            return folder.name;
          if (name2 === "WORKSPACE_FOLDER")
            return URI2.parse(folder.uri).fsPath;
        }
        if (name2 === "LINE_COMMENT") {
          let commentstring = await nvim.eval("&commentstring");
          let s = parseCommentstring(commentstring);
          if (s)
            return s;
          let comments = await nvim.eval("&comments");
          let { single } = parseComments(comments);
          return single ?? "";
        }
        if (["BLOCK_COMMENT_START", "BLOCK_COMMENT_END"].includes(name2)) {
          let comments = await nvim.eval("&comments");
          let { start, end } = parseComments(comments);
          if (name2 === "BLOCK_COMMENT_START")
            return start ?? "";
          if (name2 === "BLOCK_COMMENT_END")
            return end ?? "";
        }
      }
      async resolve(variable) {
        const name2 = variable.name;
        let resolved = this._variableToValue[name2];
        if (resolved != null)
          return resolved.toString();
        if (this._variableToValue.hasOwnProperty(name2)) {
          let value = await this.resolveValue(name2);
          if (!value && variable.children.length) {
            return variable.toString();
          }
          return value == null ? "" : value.toString();
        }
        if (variable.children.length)
          return variable.toString();
        return name2;
      }
    };
  }
});

// src/snippets/session.ts
var import_vscode_languageserver_protocol84, logger84, NAME_SPACE2, SnippetSession;
var init_session2 = __esm({
  "src/snippets/session.ts"() {
    "use strict";
    import_vscode_languageserver_protocol84 = __toESM(require_main2());
    init_mutex();
    init_object();
    init_position();
    init_string();
    init_window();
    init_workspace();
    init_parser2();
    init_snippet();
    init_variableResolve();
    logger84 = require_logger2()("snippets-session");
    NAME_SPACE2 = "snippets";
    SnippetSession = class {
      constructor(nvim, document2, config) {
        this.nvim = nvim;
        this.document = document2;
        this.config = config;
        this.mutex = new Mutex();
        this._applying = false;
        this._isActive = false;
        this._snippet = null;
        this._onCancelEvent = new import_vscode_languageserver_protocol84.Emitter();
        this.onCancel = this._onCancelEvent.event;
        this.disposable = document2.onDocumentChange(async (e) => {
          if (this._applying || !this._isActive)
            return;
          let changes = e.contentChanges;
          if (changes.length === 0)
            return;
          await this.synchronize({ version: e.textDocument.version, change: changes[0] });
        });
      }
      async start(inserted, range2, select = true, context) {
        var _a;
        const { document: document2 } = this;
        const placeholder = this.getReplacePlaceholder(range2);
        const edits = [];
        if (placeholder) {
          let r = this.snippet.range;
          let previous = document2.textDocument.getText(r);
          let parts = getParts(placeholder.value, placeholder.range, range2);
          this.current = await this.snippet.insertSnippet(placeholder, inserted, parts, context);
          let edit2 = reduceTextEdit({
            range: r,
            newText: this.snippet.text
          }, previous);
          edits.push(edit2);
        } else {
          const resolver2 = new SnippetVariableResolver(this.nvim, workspace_default.workspaceFolderControl);
          let snippet = new CocSnippet(inserted, range2.start, this.nvim, resolver2);
          await snippet.init(context);
          this._snippet = snippet;
          this.current = (_a = snippet.firstPlaceholder) == null ? void 0 : _a.marker;
          edits.push(import_vscode_languageserver_protocol84.TextEdit.replace(range2, snippet.text));
          if (inserted.replace(/\$0$/, "").endsWith("\n")) {
            const currentLine = document2.getline(range2.start.line);
            const remain = currentLine.slice(range2.end.character);
            if (remain.length) {
              let s = range2.end.character;
              let l = remain.match(/^\s*/)[0].length;
              let r = import_vscode_languageserver_protocol84.Range.create(range2.end.line, s, range2.end.line, s + l);
              edits.push(import_vscode_languageserver_protocol84.TextEdit.replace(r, currentLine.match(/^\s*/)[0]));
            }
          }
        }
        await this.applyEdits(edits);
        this.textDocument = document2.textDocument;
        this.activate();
        if (select && this.current) {
          let placeholder2 = this.snippet.getPlaceholderByMarker(this.current);
          await this.selectPlaceholder(placeholder2, true);
        }
        return this._isActive;
      }
      async applyEdits(edits) {
        this._applying = true;
        await this.document.applyEdits(edits);
        this._applying = false;
      }
      getReplacePlaceholder(range2) {
        if (!this.snippet)
          return void 0;
        let placeholder = this.findPlaceholder(range2);
        if (!placeholder || placeholder.index == 0)
          return void 0;
        return placeholder;
      }
      activate() {
        if (this._isActive)
          return;
        this._isActive = true;
        this.nvim.call("coc#snippet#enable", [this.config.preferComplete ? 1 : 0], true);
      }
      deactivate() {
        this.cancel();
        if (!this._isActive)
          return;
        this.disposable.dispose();
        this._isActive = false;
        this.current = null;
        this.nvim.call("coc#snippet#disable", [], true);
        if (this.config.highlight)
          this.nvim.call("coc#highlight#clear_highlight", [this.bufnr, NAME_SPACE2, 0, -1], true);
        this._onCancelEvent.fire(void 0);
        logger84.debug(`session ${this.bufnr} cancelled`);
      }
      get isActive() {
        return this._isActive;
      }
      get bufnr() {
        return this.document.bufnr;
      }
      async nextPlaceholder() {
        await this.forceSynchronize();
        let curr = this.placeholder;
        if (!curr)
          return;
        let next = this.snippet.getNextPlaceholder(curr.index);
        if (next)
          await this.selectPlaceholder(next);
      }
      async previousPlaceholder() {
        await this.forceSynchronize();
        let curr = this.placeholder;
        if (!curr)
          return;
        let prev = this.snippet.getPrevPlaceholder(curr.index);
        if (prev)
          await this.selectPlaceholder(prev);
      }
      async selectCurrentPlaceholder(triggerAutocmd = true) {
        await this.forceSynchronize();
        if (!this.snippet)
          return;
        let placeholder = this.snippet.getPlaceholderByMarker(this.current);
        if (placeholder)
          await this.selectPlaceholder(placeholder, triggerAutocmd);
      }
      async selectPlaceholder(placeholder, triggerAutocmd = true) {
        let { nvim, document: document2 } = this;
        if (!document2 || !placeholder)
          return;
        let { start, end } = placeholder.range;
        const len = end.character - start.character;
        const col = byteLength(document2.getline(start.line).slice(0, start.character)) + 1;
        let marker = this.current = placeholder.marker;
        if (marker instanceof Placeholder && marker.choice && marker.choice.options.length) {
          let arr = marker.choice.options.map((o) => o.value);
          await nvim.call("coc#snippet#show_choices", [start.line + 1, col, len, arr]);
          if (triggerAutocmd)
            nvim.call("coc#util#do_autocmd", ["CocJumpPlaceholder"], true);
        } else {
          let finalCount = this.snippet.finalCount;
          await this.select(placeholder, triggerAutocmd);
          this.highlights(placeholder);
          if (placeholder.index == 0) {
            if (finalCount == 1) {
              logger84.info("Jump to final placeholder, cancelling snippet session");
              this.deactivate();
            } else {
              nvim.call("coc#snippet#disable", [], true);
            }
          }
        }
      }
      highlights(placeholder, redrawVim = true) {
        if (!this.config.highlight)
          return;
        let buf = this.document.buffer;
        this.nvim.pauseNotification();
        buf.clearNamespace(NAME_SPACE2);
        let ranges = this.snippet.getRanges(placeholder);
        if (ranges.length) {
          buf.highlightRanges(NAME_SPACE2, "CocSnippetVisual", ranges);
        }
        this.nvim.resumeNotification(redrawVim, true);
      }
      async select(placeholder, triggerAutocmd = true) {
        let { range: range2, value } = placeholder;
        let { nvim } = this;
        if (value.length > 0) {
          await nvim.call("coc#snippet#select", [range2.start, range2.end, value]);
        } else {
          await nvim.call("coc#snippet#move", [range2.start]);
        }
        if (triggerAutocmd)
          nvim.call("coc#util#do_autocmd", ["CocJumpPlaceholder"], true);
        nvim.redrawVim();
      }
      async checkPosition() {
        if (!this.isActive)
          return;
        let position = await window_default.getCursorPosition();
        if (this.snippet && positionInRange(position, this.snippet.range) != 0) {
          logger84.info("Cursor insert out of range, cancelling snippet session");
          this.deactivate();
        }
      }
      findPlaceholder(range2) {
        let { placeholder } = this;
        if (placeholder && rangeInRange(range2, placeholder.range))
          return placeholder;
        return this.snippet.getPlaceholderByRange(range2) || null;
      }
      async synchronize(change) {
        this.cancel();
        await this.mutex.use(() => {
          let version2 = this.textDocument ? this.textDocument.version : -1;
          if (change && (this.document.version != change.version || change.version - version2 !== 1)) {
            change = void 0;
          }
          return this._synchronize(change ? change.change : void 0);
        });
      }
      async _synchronize(change) {
        let { document: document2, textDocument } = this;
        if (!document2.attached || !this._isActive)
          return;
        let start = Date.now();
        let d = document2.textDocument;
        if (d.version == textDocument.version || equals(textDocument.lines, d.lines))
          return;
        let { range: range2, text } = this.snippet;
        if (change && !rangeInRange(change.range, range2))
          change = void 0;
        let end = getEndPosition(range2.end, textDocument, d);
        if (!end) {
          logger84.info("Content change after snippet, cancel snippet session");
          this.deactivate();
          return;
        }
        let checked = checkContentBefore(range2.start, textDocument, d);
        if (!checked) {
          let content = d.getText(import_vscode_languageserver_protocol84.Range.create(import_vscode_languageserver_protocol84.Position.create(0, 0), end));
          if (content.endsWith(text)) {
            let pos = d.positionAt(content.length - text.length);
            this.snippet.resetStartPosition(pos);
            this.textDocument = d;
            logger84.info("Content change before snippet, reset snippet position");
            return;
          }
          logger84.info("Before and snippet body changed, cancel snippet session");
          this.deactivate();
          return;
        }
        let tokenSource = this.tokenSource = new import_vscode_languageserver_protocol84.CancellationTokenSource();
        let cursor = await window_default.getCursorPosition();
        if (tokenSource.token.isCancellationRequested || document2.hasChanged)
          return;
        let placeholder;
        let newText;
        let inserted = d.getText(import_vscode_languageserver_protocol84.Range.create(range2.start, end));
        let curr = this.placeholder;
        if (change) {
          for (let p of this.snippet.getSortedPlaceholders(curr)) {
            if (rangeInRange(change.range, p.range)) {
              placeholder = p;
              newText = this.snippet.getNewText(p, inserted);
              break;
            }
          }
          if (!placeholder && change.text.length == 0 && !emptyRange(change.range) && isSingleLine(change.range)) {
            let length = change.range.end.character - change.range.start.character;
            let offset = d.getText(import_vscode_languageserver_protocol84.Range.create(range2.start, change.range.start)).length;
            if (this.snippet.removeText(offset, length)) {
              this.textDocument = d;
              return;
            }
          }
        } else {
          for (let p of this.snippet.getSortedPlaceholders(curr)) {
            if (comparePosition(cursor, p.range.start) < 0)
              continue;
            newText = this.snippet.getNewText(p, inserted);
            if (newText != null && checkCursor(p.range.start, cursor, newText)) {
              placeholder = p;
              break;
            }
          }
        }
        if (!placeholder && inserted.endsWith(text)) {
          let pos = getEnd(range2.start, inserted.slice(0, -text.length));
          this.snippet.resetStartPosition(pos);
          this.textDocument = d;
          logger84.info("Content change before snippet, reset snippet position");
          return;
        }
        if (!placeholder) {
          logger84.info("Unable to find changed placeholder, cancel snippet session");
          this.deactivate();
          return;
        }
        let res = await this.snippet.updatePlaceholder(placeholder, cursor, newText, tokenSource.token);
        if (res == null || tokenSource.token.isCancellationRequested)
          return;
        if (document2.hasChanged) {
          tokenSource.cancel();
          tokenSource.dispose();
          return;
        }
        tokenSource.dispose();
        this.current = placeholder.marker;
        if (res.text !== inserted) {
          let edit2 = reduceTextEdit({
            range: import_vscode_languageserver_protocol84.Range.create(this.snippet.start, end),
            newText: res.text
          }, inserted);
          await this.applyEdits([edit2]);
          let { delta } = res;
          if (delta.line != 0 || delta.character != 0) {
            this.nvim.call(`coc#cursor#move_to`, [cursor.line + delta.line, cursor.character + delta.character], true);
          }
          this.highlights(placeholder, false);
          this.nvim.redrawVim();
        } else {
          this.highlights(placeholder);
        }
        logger84.debug("update cost:", Date.now() - start, res.delta);
        this.textDocument = this.document.textDocument;
        if (this.config.nextOnDelete) {
          if (curr && curr.value.length > 0 && placeholder.marker.toString() === "") {
            let next = this.snippet.getNextPlaceholder(placeholder.index);
            if (next)
              await this.selectPlaceholder(next);
          }
        }
      }
      async forceSynchronize() {
        this.cancel();
        await this.document.patchChange();
        let release = await this.mutex.acquire();
        release();
      }
      cancel() {
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource.dispose();
          this.tokenSource = null;
        }
      }
      get placeholder() {
        if (!this.snippet || !this.current)
          return void 0;
        return this.snippet.getPlaceholderByMarker(this.current);
      }
      get snippet() {
        return this._snippet;
      }
      static async resolveSnippet(nvim, snippetString, ultisnip) {
        let position = ultisnip && import_vscode_languageserver_protocol84.Range.is(ultisnip.range) ? ultisnip.range.start : await window_default.getCursorPosition();
        let line = ultisnip && typeof ultisnip.line === "string" ? ultisnip.line : await nvim.line;
        let context;
        if (ultisnip)
          context = Object.assign({ range: import_vscode_languageserver_protocol84.Range.create(position, position), line }, ultisnip);
        const resolver2 = new SnippetVariableResolver(nvim, workspace_default.workspaceFolderControl);
        let snippet = new CocSnippet(snippetString, position, nvim, resolver2);
        await snippet.init(context, true);
        return snippet.text;
      }
    };
  }
});

// src/snippets/string.ts
var SnippetString;
var init_string2 = __esm({
  "src/snippets/string.ts"() {
    "use strict";
    SnippetString = class {
      constructor(value) {
        this._tabstop = 1;
        this.value = value || "";
      }
      static isSnippetString(thing) {
        if (thing instanceof SnippetString) {
          return true;
        }
        if (!thing) {
          return false;
        }
        return typeof thing.value === "string";
      }
      static _escape(value) {
        return value.replace(/\$|}|\\/g, "\\$&");
      }
      appendText(str) {
        this.value += SnippetString._escape(str);
        return this;
      }
      appendTabstop(num = this._tabstop++) {
        this.value += "$";
        this.value += num;
        return this;
      }
      appendPlaceholder(value, num = this._tabstop++) {
        if (typeof value === "function") {
          const nested = new SnippetString();
          nested._tabstop = this._tabstop;
          value(nested);
          this._tabstop = nested._tabstop;
          value = nested.value;
        } else {
          value = SnippetString._escape(value);
        }
        this.value += "${";
        this.value += num;
        this.value += ":";
        this.value += value;
        this.value += "}";
        return this;
      }
      appendChoice(values, num = this._tabstop++) {
        const value = values.map((s) => s.replace(/\$|}|\\|,/g, "\\$&")).join(",");
        this.value += "${";
        this.value += num;
        this.value += "|";
        this.value += value;
        this.value += "|}";
        return this;
      }
      appendVariable(name2, defaultValue) {
        if (typeof defaultValue === "function") {
          const nested = new SnippetString();
          nested._tabstop = this._tabstop;
          defaultValue(nested);
          this._tabstop = nested._tabstop;
          defaultValue = nested.value;
        } else if (typeof defaultValue === "string") {
          defaultValue = defaultValue.replace(/\$|}/g, "\\$&");
        }
        this.value += "${";
        this.value += name2;
        if (defaultValue) {
          this.value += ":";
          this.value += defaultValue;
        }
        this.value += "}";
        return this;
      }
    };
  }
});

// src/snippets/manager.ts
var import_vscode_languageserver_protocol85, logger85, SnippetManager, manager_default3;
var init_manager3 = __esm({
  "src/snippets/manager.ts"() {
    "use strict";
    import_vscode_languageserver_protocol85 = __toESM(require_main2());
    init_events();
    init_object();
    init_position();
    init_window();
    init_workspace();
    init_session2();
    init_snippet();
    init_string2();
    logger85 = require_logger2()("snippets-manager");
    SnippetManager = class {
      constructor() {
        this.sessionMap = /* @__PURE__ */ new Map();
        this.disposables = [];
        events_default.on("InsertCharPre", () => {
          var _a;
          (_a = this.session) == null ? void 0 : _a.cancel();
        }, null, this.disposables);
        window_default.onDidChangeActiveTextEditor((e) => {
          if (!this.statusItem)
            return;
          let session = this.getSession(e.document.bufnr);
          if (session) {
            this.statusItem.show();
          } else {
            this.statusItem.hide();
          }
        }, null, this.disposables);
        events_default.on("InsertEnter", async (bufnr) => {
          let session = this.getSession(bufnr);
          if (session)
            await session.checkPosition();
        }, null, this.disposables);
        workspace_default.onDidCloseTextDocument((e) => {
          let session = this.getSession(e.bufnr);
          if (session)
            session.deactivate();
        }, null, this.disposables);
      }
      get nvim() {
        return workspace_default.nvim;
      }
      init() {
        if (!this.statusItem)
          this.statusItem = window_default.createStatusBarItem(0);
        let config = workspace_default.getConfiguration("coc.preferences");
        const snippetConfig = workspace_default.getConfiguration("snippet");
        this.statusItem.text = config.get("snippetStatusText", snippetConfig.get("statusText", "SNIP"));
      }
      getSnippetConfig(resource) {
        let config = workspace_default.getConfiguration("coc.preferences", resource);
        const snippetConfig = workspace_default.getConfiguration("snippet", resource);
        const suggest = workspace_default.getConfiguration("suggest", resource);
        return {
          highlight: config.get("snippetHighlight", snippetConfig.get("highlight", false)),
          nextOnDelete: config.get("nextPlaceholderOnDelete", snippetConfig.get(".nextPlaceholderOnDelete", false)),
          preferComplete: suggest.get("preferCompleteThanJumpPlaceholder", false)
        };
      }
      async insertSnippet(snippet, select = true, range2, insertTextMode, ultisnip) {
        let { bufnr } = workspace_default;
        let doc = workspace_default.getAttachedDocument(bufnr);
        if (range2 && !rangeInRange(range2, import_vscode_languageserver_protocol85.Range.create(0, 0, doc.lineCount + 1, 0))) {
          throw new Error(`Unable to insert snippet, invalid range.`);
        }
        let context;
        if (events_default.pumvisible)
          this.nvim.call("coc#pum#close", [], true);
        if (!range2) {
          let pos = await window_default.getCursorPosition();
          range2 = import_vscode_languageserver_protocol85.Range.create(pos, pos);
        }
        const currentLine = doc.getline(range2.start.line);
        const snippetStr = SnippetString.isSnippetString(snippet) ? snippet.value : snippet;
        const inserted = await this.normalizeInsertText(doc.uri, snippetStr, currentLine, insertTextMode);
        let session = this.getSession(bufnr);
        if (session)
          session.cancel();
        if (ultisnip != null) {
          context = Object.assign({ range: deepClone(range2), line: currentLine }, ultisnip);
          if (!emptyRange(range2) && inserted.includes("`!p")) {
            this.nvim.call("coc#cursor#move_to", [range2.start.line, range2.start.character], true);
            await doc.applyEdits([{ range: range2, newText: "" }]);
            range2.end = import_vscode_languageserver_protocol85.Position.create(range2.start.line, range2.start.character);
          }
        }
        if (session) {
          await session.forceSynchronize();
          session = this.getSession(bufnr);
        } else {
          await doc.patchChange(true);
        }
        if (!session) {
          let config = this.getSnippetConfig(doc.uri);
          session = new SnippetSession(this.nvim, doc, config);
          session.onCancel(() => {
            this.sessionMap.delete(bufnr);
            this.statusItem.hide();
          });
        }
        let isActive = await session.start(inserted, range2, select, context);
        if (isActive) {
          this.statusItem.show();
          this.sessionMap.set(bufnr, session);
        } else {
          this.statusItem.hide();
          this.sessionMap.delete(bufnr);
        }
        return isActive;
      }
      async selectCurrentPlaceholder(triggerAutocmd = true) {
        let { session } = this;
        if (session)
          return await session.selectCurrentPlaceholder(triggerAutocmd);
      }
      async nextPlaceholder() {
        let { session } = this;
        if (session) {
          await session.nextPlaceholder();
        } else {
          this.nvim.call("coc#snippet#disable", [], true);
          this.statusItem.hide();
        }
        return "";
      }
      async previousPlaceholder() {
        let { session } = this;
        if (session) {
          await session.previousPlaceholder();
        } else {
          this.nvim.call("coc#snippet#disable", [], true);
          this.statusItem.hide();
        }
        return "";
      }
      cancel() {
        let session = this.getSession(workspace_default.bufnr);
        if (session)
          return session.deactivate();
        this.nvim.call("coc#snippet#disable", [], true);
        if (this.statusItem)
          this.statusItem.hide();
      }
      get session() {
        return this.getSession(workspace_default.bufnr);
      }
      getSession(bufnr) {
        return this.sessionMap.get(bufnr);
      }
      jumpable() {
        let { session } = this;
        if (!session)
          return false;
        return session.placeholder != null && session.placeholder.index != 0;
      }
      async editsInsideSnippet(edits) {
        let session = this.getSession(workspace_default.bufnr);
        if (!session || !session.snippet)
          return false;
        await session.forceSynchronize();
        let range2 = session.snippet.range;
        if (edits.some((e) => rangeOverlap(e.range, range2))) {
          return true;
        }
        return false;
      }
      async resolveSnippet(snippetString, ultisnip) {
        if (ultisnip) {
          let session = this.getSession(workspace_default.bufnr);
          ultisnip.noPython = session != null && session.snippet.hasPython;
        }
        return await SnippetSession.resolveSnippet(this.nvim, snippetString, ultisnip);
      }
      async normalizeInsertText(uri, snippetString, currentLine, insertTextMode) {
        let inserted = "";
        if (insertTextMode === import_vscode_languageserver_protocol85.InsertTextMode.asIs || !shouldFormat(snippetString)) {
          inserted = snippetString;
        } else {
          const currentIndent = currentLine.match(/^\s*/)[0];
          const formatOptions = window_default.activeTextEditor ? window_default.activeTextEditor.options : await workspace_default.getFormatOptions(uri);
          inserted = normalizeSnippetString(snippetString, currentIndent, formatOptions);
        }
        return inserted;
      }
      dispose() {
        this.cancel();
        for (let d of this.disposables) {
          d.dispose();
        }
      }
    };
    manager_default3 = new SnippetManager();
  }
});

// src/tree/index.ts
var init_tree = __esm({
  "src/tree/index.ts"() {
    "use strict";
    init_TreeItem();
  }
});

// src/model/semanticTokensBuilder.ts
function isStringArray(value) {
  return Array.isArray(value) && value.every((elem) => typeof elem === "string");
}
function isStrArrayOrUndefined(arg) {
  return typeof arg === "undefined" || isStringArray(arg);
}
var import_vscode_languageserver_protocol86, SemanticTokensBuilder;
var init_semanticTokensBuilder = __esm({
  "src/model/semanticTokensBuilder.ts"() {
    "use strict";
    import_vscode_languageserver_protocol86 = __toESM(require_main2());
    SemanticTokensBuilder = class {
      constructor(legend) {
        this._prevLine = 0;
        this._prevChar = 0;
        this._dataIsSortedAndDeltaEncoded = true;
        this._data = [];
        this._dataLen = 0;
        this._tokenTypeStrToInt = /* @__PURE__ */ new Map();
        this._tokenModifierStrToInt = /* @__PURE__ */ new Map();
        this._hasLegend = false;
        if (legend) {
          this._hasLegend = true;
          for (let i = 0, len = legend.tokenTypes.length; i < len; i++) {
            this._tokenTypeStrToInt.set(legend.tokenTypes[i], i);
          }
          for (let i = 0, len = legend.tokenModifiers.length; i < len; i++) {
            this._tokenModifierStrToInt.set(legend.tokenModifiers[i], i);
          }
        }
      }
      push(arg0, arg1, arg2, arg3, arg4) {
        if (typeof arg0 === "number" && typeof arg1 === "number" && typeof arg2 === "number" && typeof arg3 === "number" && (typeof arg4 === "number" || typeof arg4 === "undefined")) {
          if (typeof arg4 === "undefined") {
            arg4 = 0;
          }
          return this._pushEncoded(arg0, arg1, arg2, arg3, arg4);
        }
        if (import_vscode_languageserver_protocol86.Range.is(arg0) && typeof arg1 === "string" && isStrArrayOrUndefined(arg2)) {
          return this._push(arg0, arg1, arg2);
        }
        throw new Error("Illegal argument");
      }
      _push(range2, tokenType, tokenModifiers) {
        if (!this._hasLegend) {
          throw new Error("Legend must be provided in constructor");
        }
        if (range2.start.line !== range2.end.line) {
          throw new Error("`range` cannot span multiple lines");
        }
        if (!this._tokenTypeStrToInt.has(tokenType)) {
          throw new Error("`tokenType` is not in the provided legend");
        }
        const line = range2.start.line;
        const char = range2.start.character;
        const length = range2.end.character - range2.start.character;
        const nTokenType = this._tokenTypeStrToInt.get(tokenType);
        let nTokenModifiers = 0;
        if (tokenModifiers) {
          for (const tokenModifier of tokenModifiers) {
            if (!this._tokenModifierStrToInt.has(tokenModifier)) {
              throw new Error("`tokenModifier` is not in the provided legend");
            }
            const nTokenModifier = this._tokenModifierStrToInt.get(tokenModifier);
            nTokenModifiers |= 1 << nTokenModifier >>> 0;
          }
        }
        this._pushEncoded(line, char, length, nTokenType, nTokenModifiers);
      }
      _pushEncoded(line, char, length, tokenType, tokenModifiers) {
        if (this._dataIsSortedAndDeltaEncoded && (line < this._prevLine || line === this._prevLine && char < this._prevChar)) {
          this._dataIsSortedAndDeltaEncoded = false;
          const tokenCount = this._data.length / 5 | 0;
          let prevLine = 0;
          let prevChar = 0;
          for (let i = 0; i < tokenCount; i++) {
            let line2 = this._data[5 * i];
            let char2 = this._data[5 * i + 1];
            if (line2 === 0) {
              line2 = prevLine;
              char2 += prevChar;
            } else {
              line2 += prevLine;
            }
            this._data[5 * i] = line2;
            this._data[5 * i + 1] = char2;
            prevLine = line2;
            prevChar = char2;
          }
        }
        let pushLine = line;
        let pushChar = char;
        if (this._dataIsSortedAndDeltaEncoded && this._dataLen > 0) {
          pushLine -= this._prevLine;
          if (pushLine === 0) {
            pushChar -= this._prevChar;
          }
        }
        this._data[this._dataLen++] = pushLine;
        this._data[this._dataLen++] = pushChar;
        this._data[this._dataLen++] = length;
        this._data[this._dataLen++] = tokenType;
        this._data[this._dataLen++] = tokenModifiers;
        this._prevLine = line;
        this._prevChar = char;
      }
      static _sortAndDeltaEncode(data) {
        let pos = [];
        const tokenCount = data.length / 5 | 0;
        for (let i = 0; i < tokenCount; i++) {
          pos[i] = i;
        }
        pos.sort((a, b) => {
          const aLine = data[5 * a];
          const bLine = data[5 * b];
          if (aLine === bLine) {
            const aChar = data[5 * a + 1];
            const bChar = data[5 * b + 1];
            return aChar - bChar;
          }
          return aLine - bLine;
        });
        const result = new Array(data.length);
        let prevLine = 0;
        let prevChar = 0;
        for (let i = 0; i < tokenCount; i++) {
          const srcOffset = 5 * pos[i];
          const line = data[srcOffset + 0];
          const char = data[srcOffset + 1];
          const length = data[srcOffset + 2];
          const tokenType = data[srcOffset + 3];
          const tokenModifiers = data[srcOffset + 4];
          const pushLine = line - prevLine;
          const pushChar = pushLine === 0 ? char - prevChar : char;
          const dstOffset = 5 * i;
          result[dstOffset + 0] = pushLine;
          result[dstOffset + 1] = pushChar;
          result[dstOffset + 2] = length;
          result[dstOffset + 3] = tokenType;
          result[dstOffset + 4] = tokenModifiers;
          prevLine = line;
          prevChar = char;
        }
        return result;
      }
      build(resultId) {
        if (!this._dataIsSortedAndDeltaEncoded) {
          return { data: SemanticTokensBuilder._sortAndDeltaEncode(this._data), resultId };
        }
        return { data: this._data, resultId };
      }
    };
  }
});

// src/model/line.ts
var LineBuilder;
var init_line = __esm({
  "src/model/line.ts"() {
    init_string();
    LineBuilder = class {
      constructor(addSpace = false) {
        this.addSpace = addSpace;
        this._label = "";
        this._len = 0;
        this._highlights = [];
      }
      append(text, hlGroup, nested) {
        if (text.length == 0)
          return;
        let space = this._len > 0 && this.addSpace ? " " : "";
        let start = this._len + space.length;
        this._label = this._label + space + text;
        this._len = this._len + byteLength(text) + space.length;
        if (hlGroup) {
          this._highlights.push({
            hlGroup,
            span: [start, start + byteLength(text)]
          });
        }
        if (nested) {
          for (let item of nested) {
            let s = start + byteLength(text.slice(0, item.offset));
            let e = start + byteLength(text.slice(0, item.offset + item.length));
            this._highlights.push({
              hlGroup: item.hlGroup,
              span: [s, e]
            });
          }
        }
      }
      appendBuilder(builder) {
        let space = this._len > 0 && this.addSpace ? " " : "";
        let curr = this._len + space.length;
        this._label = this._label + space + builder.label;
        this._len = this._len + byteLength(builder.label) + space.length;
        this._highlights.push(...builder.highlights.map((item) => {
          return {
            hlGroup: item.hlGroup,
            span: item.span.map((v) => {
              return curr + v;
            })
          };
        }));
      }
      get label() {
        return this._label;
      }
      get highlights() {
        return this._highlights;
      }
    };
  }
});

// src/index.ts
var require_src3 = __commonJS({
  "src/index.ts"(exports, module2) {
    "use strict";
    init_commands2();
    init_events();
    init_languages();
    init_mru();
    init_floatFactory();
    init_fetch();
    init_download();
    init_highligher();
    init_relativePattern();
    init_services();
    init_sources2();
    init_workspace();
    init_window();
    init_extensions3();
    init_manager2();
    init_manager3();
    init_string2();
    init_manager4();
    init_ansiparse();
    init_basic();
    init_mutex();
    init_esm();
    var import_vscode_languageserver_protocol132 = __toESM(require_main2());
    init_types();
    init_language_client();
    init_util();
    init_tree();
    init_semanticTokensBuilder();
    init_line();
    module2.exports = {
      Uri: URI2,
      LineBuilder,
      NullLogger,
      SettingMonitor,
      LanguageClient,
      CancellationTokenSource: import_vscode_languageserver_protocol132.CancellationTokenSource,
      ProgressType: import_vscode_languageserver_protocol132.ProgressType,
      RequestType: import_vscode_languageserver_protocol132.RequestType,
      RequestType0: import_vscode_languageserver_protocol132.RequestType0,
      NotificationType: import_vscode_languageserver_protocol132.NotificationType,
      NotificationType0: import_vscode_languageserver_protocol132.NotificationType0,
      Highligher: Highlighter,
      Mru,
      Emitter: import_vscode_languageserver_protocol132.Emitter,
      SnippetString,
      BasicList,
      Mutex,
      TreeItem,
      SemanticTokensBuilder,
      FloatFactory: FloatFactoryImpl,
      RelativePattern,
      DocumentDiagnosticReportKind: import_vscode_languageserver_protocol132.DocumentDiagnosticReportKind,
      UniquenessLevel: import_vscode_languageserver_protocol132.UniquenessLevel,
      MonikerKind: import_vscode_languageserver_protocol132.MonikerKind,
      PatternType,
      SourceType,
      MessageLevel,
      ConfigurationTarget,
      ServiceStat,
      FileType,
      State,
      ClientState,
      CloseAction,
      ErrorAction,
      TransportKind,
      MessageTransports,
      RevealOutputChannelOn,
      MarkupKind: import_vscode_languageserver_protocol132.MarkupKind,
      DiagnosticTag: import_vscode_languageserver_protocol132.DiagnosticTag,
      DocumentHighlightKind: import_vscode_languageserver_protocol132.DocumentHighlightKind,
      SymbolKind: import_vscode_languageserver_protocol132.SymbolKind,
      SignatureHelpTriggerKind: import_vscode_languageserver_protocol132.SignatureHelpTriggerKind,
      FileChangeType: import_vscode_languageserver_protocol132.FileChangeType,
      CodeActionKind: import_vscode_languageserver_protocol132.CodeActionKind,
      Diagnostic: import_vscode_languageserver_protocol132.Diagnostic,
      DiagnosticSeverity: import_vscode_languageserver_protocol132.DiagnosticSeverity,
      CompletionItemKind: import_vscode_languageserver_protocol132.CompletionItemKind,
      InsertTextFormat: import_vscode_languageserver_protocol132.InsertTextFormat,
      Location: import_vscode_languageserver_protocol132.Location,
      LocationLink: import_vscode_languageserver_protocol132.LocationLink,
      CancellationToken: import_vscode_languageserver_protocol132.CancellationToken,
      Position: import_vscode_languageserver_protocol132.Position,
      Range: import_vscode_languageserver_protocol132.Range,
      TextEdit: import_vscode_languageserver_protocol132.TextEdit,
      Disposable: import_vscode_languageserver_protocol132.Disposable,
      Event: import_vscode_languageserver_protocol132.Event,
      workspace: workspace_default,
      window: window_default,
      CodeActionTriggerKind: import_vscode_languageserver_protocol132.CodeActionTriggerKind,
      CompletionTriggerKind: import_vscode_languageserver_protocol132.CompletionTriggerKind,
      snippetManager: manager_default3,
      events: events_default,
      services: services_default,
      commands: commands_default,
      sources: sources_default,
      languages: languages_default,
      diagnosticManager: manager_default,
      extensions: extensions_default,
      listManager: manager_default2,
      TreeItemCollapsibleState,
      fetch,
      download,
      ansiparse,
      disposeAll,
      concurrent,
      watchFile,
      wait,
      runCommand,
      isRunning,
      executable
    };
  }
});

// src/util/factory.ts
function removedGlobalStub(name2) {
  return () => {
    throw new Error(`process.${name2}() is not allowed in extension sandbox`);
  };
}
function makeRequireFunction() {
  const req = (p) => {
    if (p === "coc.nvim") {
      return require_src3();
    }
    return this.require(p);
  };
  req.resolve = (request2) => Module._resolveFilename(request2, this);
  req.main = process.mainModule;
  req.extensions = Module._extensions;
  req.cache = Module._cache;
  return req;
}
function compileInSandbox(sandbox) {
  return function(content, filename) {
    const require2 = makeRequireFunction.call(this);
    const dirname3 = import_path34.default.dirname(filename);
    const newContent = content.replace(/^\#\!.*/, "");
    const wrapper = Module.wrap(newContent);
    const compiledWrapper = vm.runInContext(wrapper, sandbox, { filename });
    const args = [this.exports, require2, this, filename, dirname3];
    return compiledWrapper.apply(this.exports, args);
  };
}
function createSandbox(filename, logger138) {
  const module2 = new Module(filename);
  module2.paths = Module._nodeModulePaths(filename);
  const sandbox = vm.createContext({
    module: module2,
    Buffer,
    URL: globalThis.URL,
    console: {
      debug: (...args) => {
        logger138.debug.apply(logger138, args);
      },
      log: (...args) => {
        logger138.info.apply(logger138, args);
      },
      error: (...args) => {
        logger138.error.apply(logger138, args);
      },
      info: (...args) => {
        logger138.info.apply(logger138, args);
      },
      warn: (...args) => {
        logger138.warn.apply(logger138, args);
      }
    }
  });
  defaults2(sandbox, global);
  sandbox.Reflect = Reflect;
  sandbox.require = function sandboxRequire(p) {
    const oldCompile = Module.prototype._compile;
    Module.prototype._compile = compileInSandbox(sandbox);
    const moduleExports = sandbox.module.require(p);
    Module.prototype._compile = oldCompile;
    return moduleExports;
  };
  sandbox.process = new process.constructor();
  for (let key of Object.keys(process)) {
    sandbox.process[key] = process[key];
  }
  REMOVED_GLOBALS.forEach((name2) => {
    sandbox.process[name2] = removedGlobalStub(name2);
  });
  sandbox.process["chdir"] = () => {
  };
  sandbox.process.umask = (mask) => {
    if (typeof mask !== "undefined") {
      throw new Error("Cannot use process.umask() to change mask (read-only)");
    }
    return process.umask();
  };
  return sandbox;
}
function createExtension(id, filename, isEmpty = false) {
  if (isEmpty || !import_fs33.default.existsSync(filename))
    return {
      activate: () => {
      },
      deactivate: null
    };
  const sandbox = createSandbox(filename, createLogger(`extension:${id}`));
  delete Module._cache[require.resolve(filename)];
  const defaultImport = sandbox.require(filename);
  const activate = defaultImport && defaultImport.activate || defaultImport;
  if (typeof activate !== "function") {
    return { activate: () => {
    }, deactivate: null };
  }
  return {
    activate,
    deactivate: typeof defaultImport.deactivate === "function" ? defaultImport.deactivate : null
  };
}
var import_fs33, import_path34, vm, createLogger, logger86, Module, REMOVED_GLOBALS;
var init_factory = __esm({
  "src/util/factory.ts"() {
    "use strict";
    import_fs33 = __toESM(require("fs"));
    import_path34 = __toESM(require("path"));
    vm = __toESM(require("vm"));
    init_lodash();
    createLogger = require_logger2();
    logger86 = createLogger("util-factoroy");
    Module = require("module");
    REMOVED_GLOBALS = [
      "reallyExit",
      "abort",
      "umask",
      "setuid",
      "setgid",
      "setgroups",
      "_fatalException",
      "exit",
      "kill"
    ];
  }
});

// src/extensions.ts
var extensions_exports = {};
__export(extensions_exports, {
  ExtensionType: () => ExtensionType,
  Extensions: () => Extensions,
  default: () => extensions_default
});
var import_debounce8, import_fs_extra11, import_isuri2, import_path35, import_semver3, import_vscode_languageserver_protocol87, import_which4, createLogger2, logger87, ExtensionType, Extensions, extensions_default;
var init_extensions3 = __esm({
  "src/extensions.ts"() {
    "use strict";
    import_debounce8 = __toESM(require_debounce());
    import_fs_extra11 = __toESM(require_lib4());
    import_isuri2 = __toESM(require_isuri());
    init_main2();
    import_path35 = __toESM(require("path"));
    import_semver3 = __toESM(require_semver2());
    import_vscode_languageserver_protocol87 = __toESM(require_main2());
    init_esm();
    import_which4 = __toESM(require_which());
    init_commands2();
    init_watchman();
    init_events();
    init_db();
    init_installBuffer();
    init_installer();
    init_memos();
    init_util();
    init_array();
    init_extensions();
    init_factory();
    init_fs();
    init_is();
    init_window();
    init_workspace();
    createLogger2 = require_logger2();
    logger87 = createLogger2("extensions");
    ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {
      ExtensionType2[ExtensionType2["Global"] = 0] = "Global";
      ExtensionType2[ExtensionType2["Local"] = 1] = "Local";
      ExtensionType2[ExtensionType2["SingleFile"] = 2] = "SingleFile";
      ExtensionType2[ExtensionType2["Internal"] = 3] = "Internal";
      return ExtensionType2;
    })(ExtensionType || {});
    Extensions = class {
      constructor() {
        this.extensions = /* @__PURE__ */ new Map();
        this.disabled = /* @__PURE__ */ new Set();
        this._onDidLoadExtension = new import_vscode_languageserver_protocol87.Emitter();
        this._onDidActiveExtension = new import_vscode_languageserver_protocol87.Emitter();
        this._onDidUnloadExtension = new import_vscode_languageserver_protocol87.Emitter();
        this._additionalSchemes = {};
        this.activated = false;
        this.disposables = [];
        this.ready = true;
        this.onDidLoadExtension = this._onDidLoadExtension.event;
        this.onDidActiveExtension = this._onDidActiveExtension.event;
        this.onDidUnloadExtension = this._onDidUnloadExtension.event;
        let folder = global.__TEST__ ? import_path35.default.join(__dirname, "__tests__") : process.env.COC_DATA_HOME;
        let root = this.root = import_path35.default.join(folder, "extensions");
        let checked = this.checkRoot(root);
        if (checked) {
          let filepath = import_path35.default.join(root, "db.json");
          this.db = new DB(filepath);
        }
      }
      checkRoot(root) {
        try {
          if (!import_fs_extra11.default.existsSync(root)) {
            import_fs_extra11.default.mkdirpSync(root);
          }
          let stat = import_fs_extra11.default.statSync(root);
          if (stat.isFile()) {
            logger87.info(`Trying to delete ${root}`);
            import_fs_extra11.default.unlinkSync(root);
            import_fs_extra11.default.mkdirpSync(root);
          } else if (!stat.isDirectory()) {
            console.error(`Data home ${root} it not a valid directory`);
            return false;
          }
          let jsonFile = import_path35.default.join(root, "package.json");
          if (!import_fs_extra11.default.existsSync(jsonFile)) {
            import_fs_extra11.default.writeFileSync(jsonFile, '{"dependencies":{}}', "utf8");
          }
        } catch (e) {
          console.error(`Unexpected error when check data home: ${e}`);
          return false;
        }
        return true;
      }
      get outputChannel() {
        if (this._outputChannel)
          return this._outputChannel;
        this._outputChannel = window_default.createOutputChannel("extensions");
        return this._outputChannel;
      }
      async init() {
        let extensionObj = this.db.fetch("extension") || {};
        let keys = Object.keys(extensionObj);
        for (let key of keys) {
          if (extensionObj[key].disabled == true) {
            this.disabled.add(key);
          }
        }
        if (process.env.COC_NO_PLUGINS)
          return;
        let stats = await this.globalExtensionStats();
        let localStats = await this.localExtensionStats(stats.map((o) => o.id));
        stats = stats.concat(localStats);
        this.memos = new Memos(import_path35.default.resolve(this.root, "../memos.json"));
        stats.map((stat) => {
          let extensionType = stat.isLocal ? 1 /* Local */ : 0 /* Global */;
          try {
            this.createExtension(stat.root, stat.packageJSON, extensionType);
          } catch (e) {
            logger87.error(`Error on create ${stat.root}:`, e);
          }
        });
        await this.loadFileExtensions();
        commands_default.register({
          id: "extensions.forceUpdateAll",
          execute: async () => {
            let arr = await this.cleanExtensions();
            logger87.info(`Force update extensions: ${arr}`);
            await this.installExtensions(arr);
          }
        }, false, "remove all global extensions and install them");
        workspace_default.onDidRuntimePathChange(async (paths) => {
          for (let p of paths) {
            if (p && this.checkDirectory(p) === true) {
              await this.loadExtension(p);
            }
          }
        }, null, this.disposables);
      }
      getExtensionsInfo() {
        let res = [];
        for (let [key, entry] of this.extensions.entries()) {
          let { directory, filepath } = entry;
          if (!directory)
            directory = filepath;
          entry.type;
          if (directory)
            res.push({
              name: key,
              filepath,
              directory: directory.endsWith(import_path35.default.sep) ? directory : directory + import_path35.default.sep
            });
        }
        return res;
      }
      activateExtensions() {
        this.activated = true;
        for (let item of this.extensions.values()) {
          let { id, packageJSON } = item.extension;
          this.setupActiveEvents(id, packageJSON).logError();
        }
        let floatFactory = window_default.createFloatFactory({ modes: ["n"] });
        events_default.on("CursorMoved", (0, import_debounce8.debounce)(async (bufnr) => {
          if (this.installBuffer && bufnr == this.installBuffer.bufnr) {
            let lnum = await workspace_default.nvim.call("line", ["."]);
            let msgs = this.installBuffer.getMessages(lnum - 1);
            let docs = msgs && msgs.length ? [{ content: msgs.join("\n"), filetype: "txt" }] : [];
            await floatFactory.show(docs);
          }
        }, 500));
        if (global.__TEST__) {
          floatFactory.dispose();
          return;
        }
        this.checkExtensions();
        let config = workspace_default.getConfiguration("coc.preferences");
        let interval = config.get("extensionUpdateCheck", "never");
        let silent = config.get("silentAutoupdate", true);
        if (interval != "never") {
          let now = new Date();
          let day = new Date(now.getFullYear(), now.getMonth(), now.getDate() - (interval == "daily" ? 0 : 7));
          let ts = this.db.fetch("lastUpdate");
          if (ts && Number(ts) > day.getTime())
            return;
          this.outputChannel.appendLine("Start auto update...");
          this.updateExtensions(false, silent).logError();
        }
      }
      async updateExtensions(sync, silent = false) {
        if (!this.npm)
          return;
        let lockedList = await this.getLockedList();
        let stats = await this.globalExtensionStats();
        stats = stats.filter((o) => ![...lockedList, ...this.disabled].includes(o.id));
        this.db.push("lastUpdate", Date.now());
        if (silent) {
          window_default.showMessage("Updating extensions, checkout output:///extensions for details.", "more");
        }
        let installBuffer = this.installBuffer = new InstallBuffer(true, sync, silent ? this.outputChannel : void 0);
        installBuffer.setExtensions(stats.map((o) => o.id));
        await installBuffer.show(workspace_default.nvim);
        let createInstaller = createInstallerFactory(this.npm, this.modulesFolder);
        let fn = (stat) => {
          let { id } = stat;
          installBuffer.startProgress([id]);
          let url = stat.exotic ? stat.uri : null;
          let installer = createInstaller(id);
          installer.on("message", (msg, isProgress) => {
            installBuffer.addMessage(id, msg, isProgress);
          });
          return installer.update(url).then((directory) => {
            installBuffer.finishProgress(id, true);
            if (directory) {
              this.loadExtension(directory).logError();
            }
          }, (err) => {
            installBuffer.addMessage(id, err.message);
            installBuffer.finishProgress(id, false);
          });
        };
        await concurrent(stats, fn, silent ? 1 : 3);
      }
      checkExtensions() {
        let { globalExtensions } = workspace_default.env;
        if (globalExtensions && globalExtensions.length) {
          let names = this.filterGlobalExtensions(globalExtensions);
          void this.installExtensions(names);
        }
      }
      get installer() {
        return createInstallerFactory(this.npm, this.modulesFolder);
      }
      async installExtensions(list2 = []) {
        let { npm } = this;
        if (!npm || !list2.length)
          return;
        list2 = distinct(list2);
        let installBuffer = this.installBuffer = new InstallBuffer();
        installBuffer.setExtensions(list2);
        await installBuffer.show(workspace_default.nvim);
        let createInstaller = createInstallerFactory(this.npm, this.modulesFolder);
        let fn = (key) => {
          installBuffer.startProgress([key]);
          let installer = createInstaller(key);
          installer.on("message", (msg, isProgress) => {
            installBuffer.addMessage(key, msg, isProgress);
          });
          return installer.install().then((name2) => {
            installBuffer.finishProgress(key, true);
            let directory = import_path35.default.join(this.modulesFolder, name2);
            this.loadExtension(directory).logError();
            let ms = key.match(/(.+)@([^/]+)$/);
            if (ms != null)
              void this.lockExtension(name2, true);
          }, (err) => {
            installBuffer.addMessage(key, err.message);
            installBuffer.finishProgress(key, false);
            logger87.error(`Error on install ${key}`, err);
          });
        };
        await concurrent(list2, fn);
      }
      getMissingExtensions() {
        let json = this.loadJson() || { dependencies: {} };
        let ids = [];
        for (let key of Object.keys(json.dependencies)) {
          let folder = import_path35.default.join(this.modulesFolder, key);
          if (!import_fs_extra11.default.existsSync(folder)) {
            let val = json.dependencies[key];
            if (val.startsWith("http")) {
              ids.push(val);
            } else {
              ids.push(key);
            }
          }
        }
        return ids;
      }
      get npm() {
        let npm = workspace_default.getConfiguration("npm").get("binPath", "npm");
        npm = workspace_default.expand(npm);
        for (let exe of [npm, "yarnpkg", "yarn", "npm"]) {
          try {
            let res = import_which4.default.sync(exe);
            return res;
          } catch (e) {
            continue;
          }
        }
        window_default.showMessage(`Can't find npm or yarn in your $PATH`, "error");
        return null;
      }
      get all() {
        return Array.from(this.extensions.values()).map((o) => o.extension).filter((o) => !this.isDisabled(o.id));
      }
      getExtension(id) {
        return this.extensions.get(id);
      }
      getExtensionState(id) {
        let disabled = this.isDisabled(id);
        if (disabled)
          return "disabled";
        let item = this.extensions.get(id);
        if (!item)
          return "unknown";
        let { extension } = item;
        return extension.isActive ? "activated" : "loaded";
      }
      async getExtensionStates() {
        let localStats = await this.localExtensionStats([]);
        let globalStats = await this.globalExtensionStats();
        return localStats.concat(globalStats.filter((o) => localStats.find((s) => s.id == o.id) == null));
      }
      async getLockedList() {
        let obj = await this.db.fetch("extension");
        obj = obj || {};
        return Object.keys(obj).filter((id) => obj[id].locked === true);
      }
      async lockExtension(id, lock) {
        let key = `extension.${id}.locked`;
        let locked = await this.db.fetch(key);
        lock = lock === void 0 ? !locked : lock;
        if (lock) {
          this.db.push(key, true);
        } else {
          this.db.delete(key);
        }
      }
      async toggleExtension(id) {
        let state = this.getExtensionState(id);
        if (state == null)
          return;
        if (state == "activated") {
          await this.deactivate(id);
        }
        let key = `extension.${id}.disabled`;
        this.db.push(key, state == "disabled" ? false : true);
        if (state != "disabled") {
          this.disabled.add(id);
          await this.unloadExtension(id);
        } else {
          this.disabled.delete(id);
          let folder = import_path35.default.join(this.modulesFolder, id);
          if (import_fs_extra11.default.existsSync(folder)) {
            await this.loadExtension(folder);
          }
        }
        await wait(200);
      }
      async reloadExtension(id) {
        let item = this.extensions.get(id);
        if (!item) {
          window_default.showMessage(`Extension ${id} not registered`, "error");
          return;
        }
        if (item.type == 3 /* Internal */) {
          window_default.showMessage(`Can't reload internal extension "${item.id}"`, "warning");
          return;
        }
        if (item.type == 2 /* SingleFile */) {
          await this.loadExtensionFile(item.filepath);
        } else if (item.directory) {
          await this.loadExtension(item.directory);
        } else {
          window_default.showMessage(`Can't reload extension ${item.id}`, "warning");
        }
      }
      async cleanExtensions() {
        let dir = this.modulesFolder;
        if (!import_fs_extra11.default.existsSync(dir))
          return [];
        let ids = this.globalExtensions;
        let res = [];
        for (let id of ids) {
          let directory = import_path35.default.join(dir, id);
          let stat = await import_fs_extra11.default.lstat(directory);
          if (!stat || stat && stat.isSymbolicLink())
            continue;
          await this.unloadExtension(id);
          await import_fs_extra11.default.remove(directory);
          res.push(id);
        }
        return res;
      }
      async uninstallExtension(ids) {
        try {
          if (!ids.length)
            return;
          let [globals2, filtered] = splitArray(ids, (id) => this.globalExtensions.includes(id));
          if (filtered.length) {
            window_default.showMessage(`Extensions ${filtered} not global extensions, can't uninstall!`, "warning");
          }
          let json = this.loadJson() || { dependencies: {} };
          for (let id of globals2) {
            await this.unloadExtension(id);
            delete json.dependencies[id];
            let folder = import_path35.default.join(this.modulesFolder, id);
            if (import_fs_extra11.default.existsSync(folder)) {
              await import_fs_extra11.default.remove(folder);
            }
          }
          const sortedObj = { dependencies: {} };
          Object.keys(json.dependencies).sort().forEach((k) => {
            sortedObj.dependencies[k] = json.dependencies[k];
          });
          let jsonFile = import_path35.default.join(this.root, "package.json");
          import_fs_extra11.default.writeFileSync(jsonFile, JSON.stringify(sortedObj, null, 2), { encoding: "utf8" });
          window_default.showMessage(`Removed: ${globals2.join(" ")}`);
        } catch (e) {
          window_default.showMessage(`Uninstall failed: ${e}`, "error");
        }
      }
      isDisabled(id) {
        return this.disabled.has(id);
      }
      has(id) {
        return this.extensions.has(id);
      }
      isActivated(id) {
        let item = this.extensions.get(id);
        if (item && item.extension.isActive) {
          return true;
        }
        return false;
      }
      async loadExtension(folder) {
        if (Array.isArray(folder)) {
          for (let f of folder) {
            await this.loadExtension(f);
          }
          return true;
        }
        try {
          let parentFolder = import_path35.default.dirname(folder);
          let isLocal = import_path35.default.normalize(parentFolder) != import_path35.default.normalize(this.modulesFolder);
          let jsonFile = import_path35.default.join(folder, "package.json");
          let packageJSON = JSON.parse(import_fs_extra11.default.readFileSync(jsonFile, "utf8"));
          let { name: name2 } = packageJSON;
          if (this.isDisabled(name2))
            return false;
          await this.unloadExtension(name2);
          this.createExtension(folder, Object.freeze(packageJSON), isLocal ? 1 /* Local */ : 0 /* Global */);
          return true;
        } catch (e) {
          window_default.showMessage(`Error on load extension from "${folder}": ${e}`, "error");
          logger87.error(`Error on load extension from ${folder}`, e);
          return false;
        }
      }
      async loadFileExtensions() {
        if (!process.env.COC_VIMCONFIG)
          return;
        let folder = import_path35.default.join(process.env.COC_VIMCONFIG, "coc-extensions");
        if (!import_fs_extra11.default.existsSync(folder))
          return;
        let files = await import_fs_extra11.default.readdir(folder);
        files = files.filter((f) => f.endsWith(".js"));
        for (let file of files) {
          await this.loadExtensionFile(import_path35.default.join(folder, file));
        }
      }
      loadedExtensions() {
        return Array.from(this.extensions.keys());
      }
      async watchExtension(id) {
        let item = this.extensions.get(id);
        if (!item) {
          window_default.showMessage(`extension ${id} not found`, "error");
          return;
        }
        if (id.startsWith("single-")) {
          window_default.showMessage(`watching ${item.filepath}`);
          this.disposables.push(watchFile(item.filepath, async () => {
            await this.loadExtensionFile(item.filepath);
            window_default.showMessage(`reloaded ${id}`);
          }));
        } else {
          let watchmanPath = workspace_default.getWatchmanPath();
          if (!watchmanPath) {
            window_default.showMessage("watchman not found", "error");
            return;
          }
          let client;
          try {
            client = await Watchman.createClient(watchmanPath, item.directory);
          } catch (e) {
            window_default.showMessage("Unable to create watchman client: " + e.message, "error");
            return;
          }
          window_default.showMessage(`watching ${item.directory}`);
          this.disposables.push(client);
          client.subscribe("**/*.js", async () => {
            await this.reloadExtension(id);
            window_default.showMessage(`reloaded ${id}`);
          }).then((disposable) => {
            this.disposables.push(disposable);
          }, (_e) => {
          });
        }
      }
      async loadExtensionFile(filepath) {
        let filename = import_path35.default.basename(filepath);
        let basename = import_path35.default.basename(filepath, ".js");
        let name2 = "single-" + basename;
        if (this.isDisabled(name2))
          return;
        let root = import_path35.default.dirname(filepath);
        let packageJSON = {
          name: name2,
          main: filename,
          engines: { coc: "^0.0.79" }
        };
        let confpath = import_path35.default.join(root, basename + ".json");
        let stat = await statAsync(confpath);
        if (stat && stat.isFile()) {
          let content = await readFile(confpath, "utf8");
          let obj = JSON.parse(content);
          if (obj) {
            let attrs = ["activationEvents", "contributes"];
            for (const attr of attrs) {
              if (obj[attr]) {
                packageJSON[attr] = obj[attr];
              }
            }
          }
        }
        await this.unloadExtension(name2);
        this.createExtension(root, packageJSON, 2 /* SingleFile */);
      }
      async activate(id) {
        if (this.isDisabled(id)) {
          throw new Error(`Extension ${id} is disabled!`);
        }
        let item = this.extensions.get(id);
        if (!item) {
          throw new Error(`Extension ${id} not registered!`);
        }
        let { extension } = item;
        if (extension.isActive)
          return true;
        await Promise.resolve(extension.activate());
        if (extension.isActive) {
          this._onDidActiveExtension.fire(extension);
          return true;
        }
        return false;
      }
      async deactivate(id) {
        let item = this.extensions.get(id);
        if (!item)
          return false;
        await Promise.resolve(item.deactivate());
        return true;
      }
      async call(id, method, args) {
        let item = this.extensions.get(id);
        if (!item)
          throw new Error(`extension ${id} not registered`);
        let { extension } = item;
        if (!extension.isActive) {
          await this.activate(id);
        }
        let { exports } = extension;
        if (!exports || !exports.hasOwnProperty(method)) {
          throw new Error(`method ${method} not found on extension ${id}`);
        }
        return await Promise.resolve(exports[method].apply(null, args));
      }
      getExtensionApi(id) {
        let item = this.extensions.get(id);
        if (!item)
          return null;
        let { extension } = item;
        return extension.isActive ? extension.exports : null;
      }
      registerExtension(extension, deactivate) {
        let { id, packageJSON } = extension;
        this.extensions.set(id, { id, type: 3 /* Internal */, extension, deactivate, isLocal: true });
        let { contributes } = packageJSON;
        if (contributes) {
          let { configuration } = contributes;
          if (configuration && configuration.properties) {
            let { properties } = configuration;
            let props = {};
            for (let key of Object.keys(properties)) {
              let val = properties[key].default;
              if (val != null)
                props[key] = val;
            }
            workspace_default.configurations.extendsDefaults(props, id);
          }
        }
        this._onDidLoadExtension.fire(extension);
        this.setupActiveEvents(id, packageJSON).logError();
      }
      get globalExtensions() {
        let json = this.loadJson();
        if (!json || !json.dependencies)
          return [];
        return Object.keys(json.dependencies);
      }
      async globalExtensionStats() {
        let json = this.loadJson();
        if (!json || !json.dependencies)
          return [];
        let { modulesFolder } = this;
        let res = await Promise.all(Object.keys(json.dependencies).map((key) => new Promise(async (resolve3) => {
          try {
            let val = json.dependencies[key];
            let root = import_path35.default.join(modulesFolder, key);
            let res2 = this.checkDirectory(root);
            if (res2 instanceof Error) {
              window_default.showMessage(`Unable to load global extension at ${root}: ${res2.message}`, "error");
              logger87.error(`Error on load ${root}`, res2);
              return resolve3(null);
            }
            let content = await readFile(import_path35.default.join(root, "package.json"), "utf8");
            root = await import_fs_extra11.default.realpath(root);
            let obj = JSON.parse(content);
            let version2 = obj ? obj.version || "" : "";
            let description = obj ? obj.description || "" : "";
            let uri = import_isuri2.default.isValid(val) ? val : "";
            resolve3({
              id: key,
              isLocal: false,
              version: version2,
              description,
              exotic: /^https?:/.test(val),
              uri: uri.replace(/\.git(#master)?$/, ""),
              root,
              state: this.getExtensionState(key),
              packageJSON: Object.freeze(obj)
            });
          } catch (e) {
            logger87.error(e);
            resolve3(null);
          }
        })));
        return res.filter((info) => info != null);
      }
      async localExtensionStats(excludes) {
        let runtimepath = await workspace_default.nvim.eval('join(globpath(&runtimepath, "", 0, 1), ",")');
        let paths = runtimepath.split(",");
        let res = await Promise.all(paths.map((root) => new Promise(async (resolve3) => {
          try {
            let res2 = this.checkDirectory(root);
            if (res2 !== true)
              return resolve3(null);
            let jsonFile = import_path35.default.join(root, "package.json");
            let content = await readFile(jsonFile, "utf8");
            let obj = JSON.parse(content);
            let exist = this.extensions.get(obj.name);
            if (exist && !exist.isLocal) {
              logger87.info(`Extension "${obj.name}" in runtimepath already loaded.`);
              return resolve3(null);
            }
            if (excludes.includes(obj.name)) {
              logger87.info(`Skipped load vim plugin from "${root}", "${obj.name}" already global extension.`);
              return resolve3(null);
            }
            let version2 = obj ? obj.version || "" : "";
            let description = obj ? obj.description || "" : "";
            resolve3({
              id: obj.name,
              isLocal: true,
              version: version2,
              description,
              exotic: false,
              root,
              state: this.getExtensionState(obj.name),
              packageJSON: Object.freeze(obj)
            });
          } catch (e) {
            logger87.error(e);
            resolve3(null);
          }
        })));
        return res.filter((info) => info != null);
      }
      loadJson() {
        let { root } = this;
        let jsonFile = import_path35.default.join(root, "package.json");
        if (!import_fs_extra11.default.existsSync(jsonFile))
          return null;
        let errors = [];
        let content = import_fs_extra11.default.readFileSync(jsonFile, "utf8");
        let data = parse2(content, errors, { allowTrailingComma: true });
        if (errors && errors.length > 0) {
          window_default.showMessage(`Error on parse ${jsonFile}`, "error");
          workspace_default.nvim.call("coc#util#open_file", ["edit", jsonFile], true);
        }
        return data;
      }
      get schemes() {
        return this._additionalSchemes;
      }
      addSchemeProperty(key, def) {
        this._additionalSchemes[key] = def;
        workspace_default.configurations.extendsDefaults({ [key]: def.default });
      }
      async setupActiveEvents(id, packageJSON) {
        let { activationEvents } = packageJSON;
        if (!this.canActivate(id))
          return;
        if (!activationEvents || Array.isArray(activationEvents) && activationEvents.includes("*")) {
          await this.activate(id).catch((e) => {
            window_default.showMessage(`Error on activate extension ${id}: ${e.message}`);
            this.outputChannel.appendLine(`Error on activate extension ${id}.
${e.message}
 ${e.stack}`);
          });
          return;
        }
        let disposables = [];
        let called = false;
        let active = () => {
          if (called)
            return;
          called = true;
          disposeAll(disposables);
          return new Promise((resolve3) => {
            if (!this.canActivate(id)) {
              this.outputChannel.appendLine(`Extension ${id} is disabled or not loaded.`);
              return resolve3();
            }
            this.activate(id).then(() => {
              resolve3();
            }, (e) => {
              window_default.showMessage(`Error on activate extension ${id}: ${e.message}`);
              this.outputChannel.appendLine(`Error on activate extension ${id}:${e.message}
 ${e.stack}`);
              resolve3();
            });
          });
        };
        for (let eventName of activationEvents) {
          let parts = eventName.split(":");
          let ev = parts[0];
          if (ev == "onLanguage") {
            if (workspace_default.languageIds.has(parts[1]) || workspace_default.filetypes.has(parts[1])) {
              await active();
              return;
            }
            workspace_default.onDidOpenTextDocument((document2) => {
              let doc = workspace_default.getDocument(document2.bufnr);
              if (document2.languageId == parts[1] || doc.filetype == parts[1]) {
                void active();
              }
            }, null, disposables);
          } else if (ev == "onCommand") {
            commands_default.onCommandList.push(parts[1]);
            events_default.on("Command", async (command) => {
              if (command == parts[1]) {
                await active();
                await wait(500);
              }
            }, null, disposables);
          } else if (ev == "workspaceContains") {
            let check = async () => {
              let folders = workspace_default.workspaceFolders.map((o) => URI2.parse(o.uri).fsPath);
              for (let folder of folders) {
                for (let pattern of parts[1].split(/\s+/)) {
                  let exists = await checkFolder(folder, pattern);
                  if (exists) {
                    await active();
                    return true;
                  }
                }
              }
              return false;
            };
            workspace_default.onDidChangeWorkspaceFolders(check, null, disposables);
            let checked = await check();
            if (checked)
              return;
          } else if (ev == "onFileSystem") {
            for (let doc of workspace_default.documents) {
              let u = URI2.parse(doc.uri);
              if (u.scheme == parts[1]) {
                await active();
                return;
              }
            }
            workspace_default.onDidOpenTextDocument((document2) => {
              let u = URI2.parse(document2.uri);
              if (u.scheme == parts[1]) {
                void active();
              }
            }, null, disposables);
          } else {
            window_default.showMessage(`Unsupported event ${eventName} of ${id}`, "error");
          }
        }
      }
      createExtension(root, packageJSON, type) {
        let id = packageJSON.name;
        let isActive = false;
        let result;
        let filename = import_path35.default.join(root, packageJSON.main || "index.js");
        let ext;
        let subscriptions = [];
        let exports;
        let extension = {
          activate: () => {
            if (result)
              return result;
            let context = {
              subscriptions,
              extensionPath: root,
              globalState: this.memos.createMemento(`${id}|global`),
              workspaceState: this.memos.createMemento(`${id}|${workspace_default.rootPath}`),
              asAbsolutePath: (relativePath) => import_path35.default.join(root, relativePath),
              storagePath: import_path35.default.join(this.root, `${id}-data`),
              logger: createLogger2(id)
            };
            if (!ext) {
              try {
                let isEmpty = !(packageJSON.engines || {}).hasOwnProperty("coc");
                ext = createExtension(id, filename, isEmpty);
              } catch (e) {
                logger87.error(`Error on createExtension ${id} from ${filename}`, e);
                return;
              }
            }
            result = new Promise((resolve3, reject) => {
              try {
                Promise.resolve(ext.activate(context)).then((res) => {
                  isActive = true;
                  exports = res;
                  resolve3(res);
                }, (e) => {
                  logger87.error(`Error on active extension ${id}: ${e.message}`, e);
                  reject(e);
                });
              } catch (e) {
                logger87.error(`Error on active extension ${id}: ${e}`, e instanceof Error ? e.stack : e);
                reject(e);
              }
            });
            return result;
          }
        };
        Object.defineProperties(extension, {
          id: {
            get: () => id,
            enumerable: true
          },
          packageJSON: {
            get: () => packageJSON,
            enumerable: true
          },
          extensionPath: {
            get: () => root,
            enumerable: true
          },
          isActive: {
            get: () => isActive,
            enumerable: true
          },
          exports: {
            get: () => {
              if (!isActive)
                throw new Error(`Invalid access to exports, extension "${id}" not activated`);
              return exports;
            },
            enumerable: true
          }
        });
        this.extensions.set(id, {
          id,
          type,
          isLocal: type == 1 /* Local */,
          extension,
          directory: root,
          filepath: filename,
          deactivate: () => {
            if (!isActive)
              return;
            result = void 0;
            exports = void 0;
            isActive = false;
            disposeAll(subscriptions);
            subscriptions.splice(0, subscriptions.length);
            subscriptions = [];
            if (ext && ext.deactivate) {
              try {
                return Promise.resolve(ext.deactivate()).catch((e) => {
                  logger87.error(`Error on ${id} deactivate: `, e);
                });
              } catch (e) {
                logger87.error(`Error on ${id} deactivate: `, e);
              }
            }
          }
        });
        let { contributes } = packageJSON;
        if (contributes) {
          let { configuration, rootPatterns, commands } = contributes;
          if (configuration && configuration.properties) {
            let { properties } = configuration;
            let props = {};
            for (let key of Object.keys(properties)) {
              let val = properties[key].default;
              if (val != null)
                props[key] = val;
            }
            workspace_default.configurations.extendsDefaults(props, id);
          }
          if (rootPatterns && rootPatterns.length) {
            for (let item of rootPatterns) {
              workspace_default.workspaceFolderControl.addRootPattern(item.filetype, item.patterns);
            }
          }
          if (commands && commands.length) {
            for (let cmd of commands) {
              commands_default.titles.set(cmd.command, cmd.title);
            }
          }
        }
        this._onDidLoadExtension.fire(extension);
        if (this.activated) {
          this.setupActiveEvents(id, packageJSON).logError();
        }
      }
      filterGlobalExtensions(names) {
        let map = /* @__PURE__ */ new Map();
        names.forEach((def) => {
          let name2 = this.getExtensionName(def);
          if (name2)
            map.set(name2, def);
        });
        let json = this.loadJson();
        let urls = [];
        let exists = [];
        if (json && json.dependencies) {
          for (let key of Object.keys(json.dependencies)) {
            let val = json.dependencies[key];
            if (typeof val !== "string")
              continue;
            if (import_fs_extra11.default.existsSync(import_path35.default.join(this.modulesFolder, key, "package.json"))) {
              exists.push(key);
              if (/^https?:/.test(val)) {
                urls.push(val);
              }
            }
          }
        }
        for (let name2 of map.keys()) {
          if (this.disabled.has(name2) || this.extensions.has(name2)) {
            map.delete(name2);
            continue;
          }
          if (/^https?:/.test(name2) && urls.some((url) => url.startsWith(name2)) || exists.includes(name2)) {
            map.delete(name2);
          }
        }
        return Array.from(map.values());
      }
      getExtensionName(def) {
        if (/^https?:/.test(def))
          return def;
        if (!def.includes("@"))
          return def;
        return def.replace(/@[\d.]+$/, "");
      }
      get modulesFolder() {
        return import_path35.default.join(this.root, global.__TEST__ ? "" : "node_modules");
      }
      canActivate(id) {
        return !this.disabled.has(id) && this.extensions.has(id);
      }
      async unloadExtension(id) {
        let item = this.extensions.get(id);
        if (item) {
          await this.deactivate(id);
          this.extensions.delete(id);
          this._onDidUnloadExtension.fire(id);
        }
      }
      checkDirectory(folder) {
        try {
          let jsonFile = import_path35.default.join(folder, "package.json");
          if (!import_fs_extra11.default.existsSync(jsonFile))
            throw new Error("package.json not found");
          let packageJSON = JSON.parse(import_fs_extra11.default.readFileSync(jsonFile, "utf8"));
          let { name: name2, engines, main } = packageJSON;
          if (!name2 || !engines)
            throw new Error(`can't find name & engines in package.json`);
          if (!engines || !objectLiteral(engines)) {
            throw new Error(`invalid engines in ${jsonFile}`);
          }
          if (main && !import_fs_extra11.default.existsSync(import_path35.default.join(folder, main))) {
            throw new Error(`main file ${main} not found, you may need to build the project.`);
          }
          let keys = Object.keys(engines);
          if (!keys.includes("coc") && !keys.includes("vscode")) {
            throw new Error(`Engines in package.json doesn't have coc or vscode`);
          }
          if (keys.includes("coc")) {
            let required = engines["coc"].replace(/^\^/, ">=");
            if (!import_semver3.default.satisfies(workspace_default.version, required)) {
              throw new Error(`Please update coc.nvim, ${packageJSON.name} requires coc.nvim ${engines["coc"]}`);
            }
          }
          return true;
        } catch (e) {
          return e;
        }
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
    extensions_default = new Extensions();
  }
});

// src/sources/keywords.ts
var import_vscode_languageserver_protocol88, logger88, MAX_LENGTH, KeywordsBuffer;
var init_keywords = __esm({
  "src/sources/keywords.ts"() {
    "use strict";
    import_vscode_languageserver_protocol88 = __toESM(require_main2());
    init_esm();
    init_events();
    init_fs();
    logger88 = require_logger2()("sources-keywords");
    MAX_LENGTH = 10 * 1024;
    KeywordsBuffer = class {
      constructor(doc) {
        this.doc = doc;
        this._words = /* @__PURE__ */ new Set();
        this._gitIgnored = false;
        this.parse();
        let uri = URI2.parse(doc.uri);
        if (uri.scheme === "file") {
          void isGitIgnored(uri.fsPath).then((ignored) => {
            this._gitIgnored = ignored;
          });
        }
      }
      get bufnr() {
        return this.doc.bufnr;
      }
      get gitIgnored() {
        return this._gitIgnored;
      }
      get words() {
        return this._words;
      }
      parse() {
        if (!this.doc.attached || events_default.completing)
          return;
        let { textDocument } = this.doc;
        let { version: version2, lineCount } = textDocument;
        if (this.version === version2)
          return;
        if (events_default.insertMode && this.lineCount == lineCount && textDocument.length > MAX_LENGTH)
          return;
        this.cancel();
        let tokenSource = this.tokenSource = new import_vscode_languageserver_protocol88.CancellationTokenSource();
        void this.doc.matchWords(tokenSource.token).then((res) => {
          if (res != null) {
            this._words = res;
            this.lineCount = lineCount;
            this.version = version2;
          }
        });
      }
      cancel() {
        if (this.tokenSource) {
          this.tokenSource.cancel();
          this.tokenSource = null;
        }
      }
      onChange(e) {
        if (e.contentChanges.length == 0)
          return;
        this.parse();
      }
      dispose() {
        this.cancel();
        this._words.clear();
      }
    };
  }
});

// src/sources/source.ts
var logger89, Source;
var init_source = __esm({
  "src/sources/source.ts"() {
    "use strict";
    init_types();
    init_string();
    init_workspace();
    logger89 = require_logger2()("sources-source");
    Source = class {
      constructor(option) {
        this._disabled = false;
        this.nvim = workspace_default.nvim;
        this.name = option.name;
        this.filepath = option.filepath || "";
        this.sourceType = option.sourceType || 0 /* Native */;
        this.isSnippet = !!option.isSnippet;
        this.defaults = option;
      }
      get priority() {
        return this.getConfig("priority", 1);
      }
      get triggerOnly() {
        let triggerOnly = this.defaults["triggerOnly"];
        if (typeof triggerOnly == "boolean")
          return triggerOnly;
        if (!this.triggerCharacters && !this.triggerPatterns)
          return false;
        return Array.isArray(this.triggerPatterns) && this.triggerPatterns.length != 0;
      }
      get triggerCharacters() {
        return this.getConfig("triggerCharacters", null);
      }
      get optionalFns() {
        return this.defaults["optionalFns"] || [];
      }
      get triggerPatterns() {
        let patterns = this.getConfig("triggerPatterns", null);
        if (!patterns || patterns.length == 0)
          return null;
        return patterns.map((s) => typeof s === "string" ? new RegExp(s + "$") : s);
      }
      get shortcut() {
        let shortcut = this.getConfig("shortcut", "");
        return shortcut ? shortcut : this.name.slice(0, 3);
      }
      get enable() {
        if (this._disabled)
          return false;
        return this.getConfig("enable", true);
      }
      get filetypes() {
        return this.getConfig("filetypes", null);
      }
      get disableSyntaxes() {
        return this.getConfig("disableSyntaxes", []);
      }
      getConfig(key, defaultValue) {
        let config = workspace_default.getConfiguration(`coc.source.${this.name}`);
        defaultValue = this.defaults.hasOwnProperty(key) ? this.defaults[key] : defaultValue;
        return config.get(key, defaultValue);
      }
      toggle() {
        this._disabled = !this._disabled;
      }
      get firstMatch() {
        return this.getConfig("firstMatch", true);
      }
      get menu() {
        return "";
      }
      fixStartcol(opt, valids) {
        let { col, input, line, bufnr } = opt;
        let start = byteSlice(line, 0, col);
        let document2 = workspace_default.getDocument(bufnr);
        if (!document2)
          return col;
        let { chars } = document2;
        for (let i = start.length - 1; i >= 0; i--) {
          let c = start[i];
          if (!chars.isKeywordChar(c) && !valids.includes(c)) {
            break;
          }
          input = `${c}${input}`;
          col = col - 1;
        }
        opt.col = col;
        opt.input = input;
        return col;
      }
      async shouldComplete(opt) {
        let { disableSyntaxes } = this;
        if (opt.synname && disableSyntaxes && disableSyntaxes.length) {
          let synname = (opt.synname || "").toLowerCase();
          if (disableSyntaxes.findIndex((s) => synname.includes(s.toLowerCase())) !== -1) {
            return false;
          }
        }
        let fn = this.defaults["shouldComplete"];
        if (typeof fn === "function")
          return await Promise.resolve(fn.call(this, opt));
        return true;
      }
      async refresh() {
        let fn = this.defaults["refresh"];
        if (typeof fn === "function")
          await Promise.resolve(fn.call(this));
      }
      async onCompleteDone(item, opt) {
        let fn = this.defaults["onCompleteDone"];
        if (typeof fn === "function")
          await Promise.resolve(fn.call(this, item, opt));
      }
      async doComplete(opt, token) {
        let fn = this.defaults["doComplete"];
        if (typeof fn === "function")
          return await Promise.resolve(fn.call(this, opt, token));
        return null;
      }
      async onCompleteResolve(item, opt, token) {
        let fn = this.defaults["onCompleteResolve"];
        if (typeof fn === "function")
          await Promise.resolve(fn.call(this, item, opt, token));
      }
    };
  }
});

// src/sources/source-language.ts
function isCompletionList(obj) {
  return !Array.isArray(obj) && Array.isArray(obj.items);
}
function getRange(item, itemDefaults) {
  if (!item)
    return void 0;
  if (item.textEdit) {
    let range2 = import_vscode_languageserver_protocol89.InsertReplaceEdit.is(item.textEdit) ? item.textEdit.replace : item.textEdit.range;
    if (range2)
      return range2;
  }
  let editRange = itemDefaults == null ? void 0 : itemDefaults.editRange;
  if (!editRange)
    return void 0;
  return import_vscode_languageserver_protocol89.Range.is(editRange) ? editRange : editRange.replace;
}
function getStartColumn(line, items, itemDefaults) {
  let first = items[0];
  let range2 = getRange(first, itemDefaults);
  if (range2 === void 0)
    return void 0;
  let { character } = range2.start;
  for (let i = 1; i < Math.min(10, items.length); i++) {
    let o = items[i];
    if (!o.textEdit)
      return void 0;
    let r = getRange(o, itemDefaults);
    if (!r || r.start.character !== character)
      return void 0;
  }
  return byteIndex(line, range2.start.character);
}
function getKindString(kind, map, defaultValue = "") {
  return map.get(kind) || defaultValue;
}
function getWord(item, opt, invalidInsertCharacters, itemDefaults) {
  let { label, data, insertTextFormat, insertText, textEdit } = item;
  let isSnippet = (insertTextFormat ?? itemDefaults.insertTextFormat) === import_vscode_languageserver_protocol89.InsertTextFormat.Snippet;
  let word;
  let newText = insertText;
  if (data && typeof data.word === "string")
    return data.word;
  let range2;
  if (textEdit) {
    range2 = import_vscode_languageserver_protocol89.InsertReplaceEdit.is(textEdit) ? textEdit.replace : textEdit.range;
    newText = textEdit.newText;
  } else if (itemDefaults.editRange) {
    let editRange = itemDefaults.editRange;
    range2 = import_vscode_languageserver_protocol89.Range.is(editRange) ? editRange : editRange.replace;
    newText = insertText ?? label;
  }
  if (range2 && range2.start.line == range2.end.line) {
    let { line, col, colnr } = opt;
    let character = characterIndex(line, col);
    if (range2.start.character > character) {
      let before = line.slice(character, range2.start.character);
      newText = before + newText;
    } else {
      let start = line.slice(range2.start.character, character);
      if (start.length && newText.startsWith(start)) {
        newText = newText.slice(start.length);
      }
    }
    character = characterIndex(line, colnr - 1);
    if (range2.end.character > character) {
      let end = line.slice(character, range2.end.character);
      if (newText.endsWith(end)) {
        newText = newText.slice(0, -end.length);
      }
    }
  }
  if (isSnippet && newText) {
    let parser2 = new SnippetParser();
    let text = parser2.text(newText);
    word = text ? getValidWord(text, invalidInsertCharacters) : label;
  } else {
    word = getValidWord(newText, ["\n", "\r"]) ?? label;
  }
  return word ?? "";
}
function getValidWord(text, invalidChars, start = 2) {
  if (text == null)
    return void 0;
  if (invalidChars.length === 0)
    return text;
  for (let i = start; i < text.length; i++) {
    let c = text[i];
    if (invalidChars.includes(c)) {
      return text.slice(0, i);
    }
  }
  return text;
}
function fixIndent(line, currline, range2) {
  let oldIndent = line.match(/^\s*/)[0];
  let newIndent = currline.match(/^\s*/)[0];
  if (oldIndent == newIndent)
    return;
  let d = newIndent.length - oldIndent.length;
  range2.start.character += d;
  range2.end.character += d;
  return d;
}
var import_vscode_languageserver_protocol89, logger90, highlightsMap, LanguageSource;
var init_source_language = __esm({
  "src/sources/source-language.ts"() {
    "use strict";
    import_vscode_languageserver_protocol89 = __toESM(require_main2());
    init_commands2();
    init_manager3();
    init_parser2();
    init_fuzzy();
    init_string();
    init_window();
    init_workspace();
    logger90 = require_logger2()("source-language");
    highlightsMap = {
      [import_vscode_languageserver_protocol89.CompletionItemKind.Text]: "CocSymbolText",
      [import_vscode_languageserver_protocol89.CompletionItemKind.Method]: "CocSymbolMethod",
      [import_vscode_languageserver_protocol89.CompletionItemKind.Function]: "CocSymbolFunction",
      [import_vscode_languageserver_protocol89.CompletionItemKind.Constructor]: "CocSymbolConstructor",
      [import_vscode_languageserver_protocol89.CompletionItemKind.Field]: "CocSymbolField",
      [import_vscode_languageserver_protocol89.CompletionItemKind.Variable]: "CocSymbolVariable",
      [import_vscode_languageserver_protocol89.CompletionItemKind.Class]: "CocSymbolClass",
      [import_vscode_languageserver_protocol89.CompletionItemKind.Interface]: "CocSymbolInterface",
      [import_vscode_languageserver_protocol89.CompletionItemKind.Module]: "CocSymbolModule",
      [import_vscode_languageserver_protocol89.CompletionItemKind.Property]: "CocSymbolProperty",
      [import_vscode_languageserver_protocol89.CompletionItemKind.Unit]: "CocSymbolUnit",
      [import_vscode_languageserver_protocol89.CompletionItemKind.Value]: "CocSymbolValue",
      [import_vscode_languageserver_protocol89.CompletionItemKind.Enum]: "CocSymbolEnum",
      [import_vscode_languageserver_protocol89.CompletionItemKind.Keyword]: "CocSymbolKeyword",
      [import_vscode_languageserver_protocol89.CompletionItemKind.Snippet]: "CocSymbolSnippet",
      [import_vscode_languageserver_protocol89.CompletionItemKind.Color]: "CocSymbolColor",
      [import_vscode_languageserver_protocol89.CompletionItemKind.File]: "CocSymbolFile",
      [import_vscode_languageserver_protocol89.CompletionItemKind.Reference]: "CocSymbolReference",
      [import_vscode_languageserver_protocol89.CompletionItemKind.Folder]: "CocSymbolFolder",
      [import_vscode_languageserver_protocol89.CompletionItemKind.EnumMember]: "CocSymbolEnumMember",
      [import_vscode_languageserver_protocol89.CompletionItemKind.Constant]: "CocSymbolConstant",
      [import_vscode_languageserver_protocol89.CompletionItemKind.Struct]: "CocSymbolStruct",
      [import_vscode_languageserver_protocol89.CompletionItemKind.Event]: "CocSymbolEvent",
      [import_vscode_languageserver_protocol89.CompletionItemKind.Operator]: "CocSymbolOperator",
      [import_vscode_languageserver_protocol89.CompletionItemKind.TypeParameter]: "CocSymbolTypeParameter"
    };
    LanguageSource = class {
      constructor(name2, shortcut, provider, documentSelector, triggerCharacters, allCommitCharacters, priority, completeConfig) {
        this.name = name2;
        this.shortcut = shortcut;
        this.provider = provider;
        this.documentSelector = documentSelector;
        this.triggerCharacters = triggerCharacters;
        this.allCommitCharacters = allCommitCharacters;
        this.completeConfig = completeConfig;
        this._enabled = true;
        this.completeItems = [];
        this.itemDefaults = {};
        this.priority = typeof priority === "number" ? priority : completeConfig.priority;
      }
      get enable() {
        return this._enabled;
      }
      toggle() {
        this._enabled = !this._enabled;
      }
      shouldCommit(item, character) {
        let completeItem = this.completeItems[item.index];
        if (!completeItem)
          return false;
        if (this.allCommitCharacters.includes(character))
          return true;
        let commitCharacters = completeItem.commitCharacters ?? (this.itemDefaults.commitCharacters ?? []);
        return commitCharacters.includes(character);
      }
      async doComplete(opt, token) {
        let { triggerCharacter, input, bufnr } = opt;
        this.completeItems = [];
        let triggerKind = this.getTriggerKind(opt);
        let position = this.getPosition(opt);
        let context = { triggerKind, option: opt };
        if (triggerKind == import_vscode_languageserver_protocol89.CompletionTriggerKind.TriggerCharacter)
          context.triggerCharacter = triggerCharacter;
        let doc = workspace_default.getAttachedDocument(bufnr);
        let result = await Promise.resolve(this.provider.provideCompletionItems(doc.textDocument, position, token, context));
        if (!result || token.isCancellationRequested)
          return null;
        let completeItems = Array.isArray(result) ? result : result.items;
        if (!completeItems || completeItems.length == 0)
          return null;
        this.itemDefaults = isCompletionList(result) ? result.itemDefaults ?? {} : {};
        this.completeItems = completeItems;
        let option = Object.assign({}, opt);
        let startcol = getStartColumn(opt.line, completeItems, this.itemDefaults);
        if (startcol > opt.col && input.length > 0) {
          startcol = opt.col;
          let character = characterIndex(opt.line, startcol);
          completeItems.forEach((item) => {
            let { textEdit } = item;
            if (import_vscode_languageserver_protocol89.TextEdit.is(textEdit)) {
              textEdit.range.start.character = character;
            } else if (import_vscode_languageserver_protocol89.InsertReplaceEdit.is(textEdit)) {
              textEdit.replace.start.character = character;
              textEdit.insert.start.character = character;
            }
          });
        }
        let prefix;
        let isIncomplete = isCompletionList(result) ? result.isIncomplete == true : false;
        if (startcol == null && input.length > 0 && this.triggerCharacters.includes(opt.triggerCharacter)) {
          if (!completeItems.every((item) => (item.insertText ?? item.label).startsWith(opt.input))) {
            startcol = opt.col + byteLength(opt.input);
          }
        }
        if (typeof startcol === "number" && startcol < option.col) {
          prefix = startcol < option.col ? byteSlice(opt.line, startcol, option.col) : "";
          option.col = startcol;
        }
        let items = completeItems.map((o, index) => {
          let item = this.convertVimCompleteItem(o, option, prefix);
          item.index = index;
          return item;
        });
        return { startcol, isIncomplete, items };
      }
      async onCompleteResolve(item, opt, token) {
        let { index, detailRendered } = item;
        let completeItem = this.completeItems[index];
        if (!completeItem || item.resolved)
          return;
        let hasResolve = typeof this.provider.resolveCompletionItem === "function";
        if (hasResolve) {
          let resolved = await Promise.resolve(this.provider.resolveCompletionItem(completeItem, token));
          if (token.isCancellationRequested || !resolved)
            return;
          Object.assign(completeItem, resolved);
        }
        item.resolved = true;
        let { documentation, detail, labelDetails } = completeItem;
        let docs = [];
        if (labelDetails && !detailRendered) {
          let content = (labelDetails.detail ?? "") + (labelDetails.description ? ` ${labelDetails.description}` : "");
          docs.push({ filetype: "txt", content });
        } else if (detail && !item.detailShown && detail != item.word) {
          detail = detail.replace(/\n\s*/g, " ");
          if (detail.length) {
            let isText = /^[\w-\s.,\t\n]+$/.test(detail);
            docs.push({ filetype: isText ? "txt" : opt.filetype, content: detail });
          }
        }
        if (documentation) {
          if (typeof documentation == "string") {
            docs.push({ filetype: "txt", content: documentation });
          } else if (documentation.value) {
            docs.push({
              filetype: documentation.kind == "markdown" ? "markdown" : "txt",
              content: documentation.value
            });
          }
        }
        if (docs.length == 0)
          return;
        item.documentation = docs;
      }
      async onCompleteDone(vimItem, opt) {
        let item = this.completeItems[vimItem.index];
        if (!item)
          return;
        if (typeof vimItem.line === "string")
          Object.assign(opt, { line: vimItem.line });
        let doc = workspace_default.getAttachedDocument(opt.bufnr);
        await doc.patchChange(true);
        let additionalEdits = Array.isArray(item.additionalTextEdits) && item.additionalTextEdits.length > 0;
        if (additionalEdits) {
          let shouldCancel = await manager_default3.editsInsideSnippet(item.additionalTextEdits);
          if (shouldCancel)
            manager_default3.cancel();
        }
        let version2 = doc.version;
        let isSnippet = await this.applyTextEdit(doc, additionalEdits, item, vimItem.word, opt);
        if (additionalEdits) {
          await doc.applyEdits(item.additionalTextEdits, doc.version != version2, !isSnippet);
          if (isSnippet)
            await manager_default3.selectCurrentPlaceholder();
        }
        if (item.command) {
          if (commands_default.has(item.command.command)) {
            await commands_default.execute(item.command);
          } else {
            logger90.warn(`Command "${item.command.command}" not registered to coc.nvim`);
          }
        }
      }
      isSnippetItem(item) {
        let insertTextFormat = item.insertTextFormat ?? this.itemDefaults.insertTextFormat;
        return insertTextFormat === import_vscode_languageserver_protocol89.InsertTextFormat.Snippet;
      }
      async applyTextEdit(doc, additionalEdits, item, word, option) {
        var _a, _b;
        let { line, linenr, colnr, col } = option;
        let pos = await window_default.getCursorPosition();
        if (pos.line != linenr - 1)
          return;
        let range2;
        let { textEdit, insertText, label } = item;
        let beginIdx = characterIndex(line, colnr - 1);
        if (textEdit) {
          range2 = import_vscode_languageserver_protocol89.InsertReplaceEdit.is(textEdit) ? textEdit.replace : textEdit.range;
        } else {
          let editRange = this.itemDefaults.editRange;
          if (editRange) {
            range2 = import_vscode_languageserver_protocol89.Range.is(editRange) ? editRange : editRange.replace;
          } else if (item.insertText) {
            range2 = import_vscode_languageserver_protocol89.Range.create(pos.line, characterIndex(line, col), pos.line, beginIdx);
          }
        }
        if (!range2)
          return false;
        let currline = doc.getline(linenr - 1);
        let newText = textEdit ? textEdit.newText : insertText ?? label;
        let n = fixIndent(line, currline, range2);
        if (n)
          beginIdx += n;
        if (range2.end.character < beginIdx)
          range2.end.character = beginIdx;
        if (pos.character > beginIdx)
          range2.end.character += pos.character - beginIdx;
        let isSnippet = this.isSnippetItem(item);
        if (isSnippet && this.completeConfig.snippetsSupport === false) {
          isSnippet = false;
          newText = word;
        }
        if (isSnippet) {
          let opts = ((_a = item.data) == null ? void 0 : _a.ultisnip) === true ? {} : (_b = item.data) == null ? void 0 : _b.ultisnip;
          let insertTextMode = item.insertTextMode ?? this.itemDefaults.insertTextMode;
          return await manager_default3.insertSnippet(newText, !additionalEdits, range2, insertTextMode, opts ? opts : void 0);
        }
        await doc.applyEdits([import_vscode_languageserver_protocol89.TextEdit.replace(range2, newText)], false, pos);
        return false;
      }
      getTriggerKind(opt) {
        let { triggerCharacters } = this;
        let isTrigger = triggerCharacters.includes(opt.triggerCharacter);
        let triggerKind = import_vscode_languageserver_protocol89.CompletionTriggerKind.Invoked;
        if (opt.triggerForInComplete) {
          triggerKind = import_vscode_languageserver_protocol89.CompletionTriggerKind.TriggerForIncompleteCompletions;
        } else if (isTrigger) {
          triggerKind = import_vscode_languageserver_protocol89.CompletionTriggerKind.TriggerCharacter;
        }
        return triggerKind;
      }
      convertVimCompleteItem(item, opt, prefix) {
        var _a, _b, _c;
        let { detailMaxLength, detailField, invalidInsertCharacters, labels, defaultKindText } = this.completeConfig;
        let hasAdditionalEdit = item.additionalTextEdits != null && item.additionalTextEdits.length > 0;
        let isSnippet = this.isSnippetItem(item) || hasAdditionalEdit;
        let label = typeof item.label === "string" ? item.label.trim() : item.insertText ?? "";
        let obj = {
          word: getWord(item, opt, invalidInsertCharacters, this.itemDefaults),
          abbr: label,
          kind: getKindString(item.kind, labels, defaultKindText),
          kindHighlight: highlightsMap[item.kind] ?? "CocSymbolDefault",
          sortText: item.sortText ?? null,
          sourceScore: item["score"] ?? null,
          filterText: item.filterText ?? label,
          preselect: item.preselect === true,
          deprecated: item.deprecated === true || ((_a = item.tags) == null ? void 0 : _a.includes(import_vscode_languageserver_protocol89.CompletionItemTag.Deprecated)),
          isSnippet,
          labelDetails: item.labelDetails,
          dup: ((_b = item.data) == null ? void 0 : _b.dup) == 0 ? 0 : 1
        };
        obj.line = opt.line;
        if (prefix) {
          if (!obj.filterText.startsWith(prefix)) {
            if (item.textEdit && fuzzyMatch(getCharCodes(prefix), item.textEdit.newText)) {
              obj.filterText = item.textEdit.newText.replace(/\r?\n/g, "");
            }
          }
          if (!item.textEdit && !obj.word.startsWith(prefix)) {
            obj.word = `${prefix}${obj.word}`;
          }
        }
        if (detailField == "abbr" && item.detail) {
          let detail = item.detail.replace(/\r?\n\s*/g, " ");
          if (byteLength(obj.abbr + detail) < detailMaxLength - 3) {
            obj.abbr = `${obj.abbr} - ${detail}`;
            obj.detailShown = 1;
          }
        }
        if (item.kind === import_vscode_languageserver_protocol89.CompletionItemKind.Folder && !obj.abbr.endsWith("/"))
          obj.abbr = obj.abbr + "/";
        if (((_c = item.data) == null ? void 0 : _c.optional) && !obj.abbr.endsWith("?"))
          obj.abbr = obj.abbr + "?";
        return obj;
      }
      getPosition(opt) {
        let { line, linenr, colnr } = opt;
        let part = byteSlice(line, 0, colnr - 1);
        return {
          line: linenr - 1,
          character: part.length
        };
      }
    };
  }
});

// src/sources/source-vim.ts
var logger91, VimSource;
var init_source_vim = __esm({
  "src/sources/source-vim.ts"() {
    "use strict";
    init_fuzzy();
    init_string();
    init_workspace();
    init_window();
    init_source();
    logger91 = require_logger2()("sources-source-vim");
    VimSource = class extends Source {
      async callOptionalFunc(fname, args) {
        let exists = this.optionalFns.includes(fname);
        if (!exists)
          return null;
        let name2 = `coc#source#${this.name}#${fname}`;
        let res;
        try {
          res = await this.nvim.call(name2, args);
        } catch (e) {
          window_default.showMessage(`Vim error from source ${this.name}: ${e}`, "error");
          return null;
        }
        return res;
      }
      async shouldComplete(opt) {
        let shouldRun = await super.shouldComplete(opt);
        if (!shouldRun)
          return false;
        if (!this.optionalFns.includes("should_complete"))
          return true;
        let res = await this.callOptionalFunc("should_complete", [opt]);
        return !!res;
      }
      async refresh() {
        await this.callOptionalFunc("refresh", []);
      }
      async onCompleteDone(item, _opt) {
        if (!this.optionalFns.includes("on_complete"))
          return;
        await this.callOptionalFunc("on_complete", [item]);
      }
      onEnter(bufnr) {
        if (!this.optionalFns.includes("on_enter"))
          return;
        let doc = workspace_default.getDocument(bufnr);
        if (!doc)
          return;
        let { filetypes } = this;
        if (filetypes && !filetypes.includes(doc.filetype))
          return;
        this.callOptionalFunc("on_enter", [{
          bufnr,
          uri: doc.uri,
          languageId: doc.filetype
        }]).logError();
      }
      async doComplete(opt, token) {
        let { col, input, line, colnr } = opt;
        let startcol = await this.callOptionalFunc("get_startcol", [opt]);
        if (token.isCancellationRequested)
          return;
        if (startcol) {
          if (startcol < 0)
            return null;
          startcol = Number(startcol);
          if (isNaN(startcol) || startcol < 0)
            startcol = col;
          if (startcol !== col) {
            input = byteSlice(line, startcol, colnr - 1);
            opt = Object.assign({}, opt, {
              col: startcol,
              changed: col - startcol,
              input
            });
          }
        }
        let items = await this.nvim.callAsync("coc#util#do_complete", [this.name, opt]);
        if (!items || items.length == 0 || token.isCancellationRequested)
          return null;
        if (this.firstMatch && input.length) {
          let ch = input[0];
          items = items.filter((item) => {
            let cfirst = item.filterText ? item.filterText[0] : item.word[0];
            return fuzzyChar(ch, cfirst);
          });
        }
        items = items.map((item) => {
          if (typeof item == "string") {
            return { word: item, menu: this.menu, isSnippet: this.isSnippet };
          }
          let menu = item.menu ? item.menu + " " : "";
          item.menu = `${menu}${this.menu}`;
          item.isSnippet = this.isSnippet;
          return item;
        });
        let res = { items };
        if (startcol)
          res.startcol = startcol;
        return res;
      }
    };
  }
});

// src/sources/native/around.ts
var around_exports = {};
__export(around_exports, {
  default: () => Around,
  regist: () => regist
});
function regist(sourceMap, keywords) {
  sourceMap.set("around", new Around(keywords));
  return import_vscode_languageserver_protocol90.Disposable.create(() => {
    sourceMap.delete("around");
  });
}
var import_vscode_languageserver_protocol90, logger92, Around;
var init_around = __esm({
  "src/sources/native/around.ts"() {
    "use strict";
    import_vscode_languageserver_protocol90 = __toESM(require_main2());
    init_util();
    init_fuzzy();
    init_source();
    logger92 = require_logger2()("sources-around");
    Around = class extends Source {
      constructor(keywords) {
        super({
          name: "around",
          filepath: __filename
        });
        this.keywords = keywords;
      }
      async filterWords(words, opt, token, res) {
        let isIncomplete = false;
        let { input } = opt;
        let cword = opt.word;
        let first = input[0];
        let fuzzy = input.length > 1;
        let min = opt.input.length;
        let code = first.charCodeAt(0);
        let ignoreCase = code >= 97 && code <= 122;
        let needle = fuzzy ? getCharCodes(input) : [];
        let checkInput = true;
        let checkCword = true;
        let ts = Date.now();
        for (let word of words) {
          let len = word.length;
          if (len < min)
            continue;
          if (checkInput && len == min && word === input) {
            checkInput = false;
            continue;
          }
          if (checkCword && len == cword.length && word === cword) {
            checkCword = false;
            continue;
          }
          if (Date.now() - ts > 15) {
            await waitImmediate();
            if (token.isCancellationRequested)
              return void 0;
            ts = Date.now();
          }
          let ch = ignoreCase ? word[0].toLowerCase() : word[0];
          if (fuzzy) {
            if (ch.charCodeAt(0) === code && fuzzyMatch(needle, word)) {
              res.push(word);
              if (res.length == 100) {
                isIncomplete = true;
                break;
              }
            }
          } else {
            if (ch.charCodeAt(0) === code) {
              res.push(word);
              if (res.length == 100) {
                isIncomplete = true;
                break;
              }
            }
          }
        }
        return isIncomplete;
      }
      async doComplete(opt, token) {
        let { bufnr, input } = opt;
        if (input.length === 0)
          return null;
        await waitImmediate();
        if (token.isCancellationRequested)
          return null;
        let item = this.keywords.getItem(bufnr);
        let words = item == null ? void 0 : item.words;
        if (!words)
          return null;
        let arr = [];
        let isIncomplete = await this.filterWords(words, opt, token, arr);
        if (token.isCancellationRequested)
          return null;
        return {
          isIncomplete,
          items: arr.map((word) => ({
            word,
            menu: this.menu
          }))
        };
      }
    };
  }
});

// src/sources/native/buffer.ts
var buffer_exports = {};
__export(buffer_exports, {
  default: () => Buffer2,
  regist: () => regist2
});
function regist2(sourceMap, keywords) {
  sourceMap.set("buffer", new Buffer2(keywords));
  return import_vscode_languageserver_protocol91.Disposable.create(() => {
    sourceMap.delete("buffer");
  });
}
var import_vscode_languageserver_protocol91, logger93, Buffer2;
var init_buffer = __esm({
  "src/sources/native/buffer.ts"() {
    "use strict";
    import_vscode_languageserver_protocol91 = __toESM(require_main2());
    init_util();
    init_fuzzy();
    init_source();
    logger93 = require_logger2()("sources-buffer");
    Buffer2 = class extends Source {
      constructor(keywords) {
        super({
          name: "buffer",
          filepath: __filename
        });
        this.keywords = keywords;
      }
      get ignoreGitignore() {
        return this.getConfig("ignoreGitignore", true);
      }
      async getWords(bufnr, opt, token, words) {
        let { ignoreGitignore } = this;
        let isIncomplete = false;
        let first = opt.input[0];
        let min = opt.input.length;
        let fuzzy = min > 1;
        let code = first.charCodeAt(0);
        let ignoreCase = code >= 97 && code <= 122;
        let needle = fuzzy ? getCharCodes(opt.input) : [];
        let ts = Date.now();
        for (let item of this.keywords.items) {
          if (words.size == 100)
            break;
          if (item.bufnr === bufnr || ignoreGitignore && item.gitIgnored)
            continue;
          for (let w of item.words) {
            if (Date.now() - ts > 15) {
              await waitImmediate();
              if (token.isCancellationRequested)
                return void 0;
              ts = Date.now();
            }
            if (w.length < min)
              continue;
            let ch = ignoreCase ? w[0].toLowerCase() : w[0];
            if (fuzzy) {
              if (ch.charCodeAt(0) === code && fuzzyMatch(needle, w)) {
                words.add(w);
                if (words.size == 100) {
                  isIncomplete = true;
                  break;
                }
              }
            } else {
              if (ch.charCodeAt(0) === code) {
                words.add(w);
                if (words.size == 100) {
                  isIncomplete = true;
                  break;
                }
              }
            }
          }
        }
        return isIncomplete;
      }
      async doComplete(opt, token) {
        let { bufnr, input } = opt;
        if (input.length == 0)
          return null;
        await waitImmediate();
        if (token.isCancellationRequested)
          return null;
        let words = /* @__PURE__ */ new Set();
        let isIncomplete = await this.getWords(bufnr, opt, token, words);
        return {
          isIncomplete,
          items: Array.from(words).map((word) => ({
            word,
            menu: this.menu
          }))
        };
      }
    };
  }
});

// src/sources/native/file.ts
var file_exports = {};
__export(file_exports, {
  default: () => File,
  regist: () => regist3
});
function regist3(sourceMap) {
  sourceMap.set("file", new File());
  return import_vscode_languageserver_protocol92.Disposable.create(() => {
    sourceMap.delete("file");
  });
}
var import_fs36, import_minimatch8, import_path36, import_util48, import_vscode_languageserver_protocol92, logger94, pathRe, File;
var init_file = __esm({
  "src/sources/native/file.ts"() {
    "use strict";
    import_fs36 = __toESM(require("fs"));
    import_minimatch8 = __toESM(require_minimatch());
    import_path36 = __toESM(require("path"));
    import_util48 = __toESM(require("util"));
    import_vscode_languageserver_protocol92 = __toESM(require_main2());
    init_source();
    init_fs();
    init_string();
    init_platform();
    init_workspace();
    logger94 = require_logger2()("sources-file");
    pathRe = /(?:\.{0,2}|~|\$HOME|([\w]+)|[a-zA-Z]:|)(\/|\\+)(?:[\u4E00-\u9FA5\u00A0-\u024F\w .@()-]+(\/|\\+))*(?:[\u4E00-\u9FA5\u00A0-\u024F\w .@()-])*$/;
    File = class extends Source {
      constructor() {
        super({
          name: "file",
          filepath: __filename
        });
      }
      get triggerCharacters() {
        let characters = this.getConfig("triggerCharacters", []);
        return isWindows ? characters : characters.filter((s) => s != "\\");
      }
      resolveEnvVariables(str) {
        let replaced = str;
        replaced = replaced.replace(/%([^%]+)%/g, (_, n) => process.env[n]);
        replaced = replaced.replace(/\$([A-Z_]+[A-Z0-9_]*)|\${([A-Z0-9_]*)}/gi, (_, a, b) => process.env[a || b]);
        return replaced;
      }
      getPathOption(opt) {
        let { line, colnr } = opt;
        let part = byteSlice(line, 0, colnr - 1);
        part = this.resolveEnvVariables(part);
        if (!part || part.endsWith("//"))
          return null;
        let ms = part.match(pathRe);
        if (ms && ms.length) {
          const pathstr = workspace_default.expand(ms[0]);
          let input = ms[0].match(/[^/\\]*$/)[0];
          return { pathstr, part: ms[1], startcol: colnr - input.length - 1, input };
        }
        return null;
      }
      async getFileItem(root, filename) {
        let f = import_path36.default.join(root, filename);
        let stat = await statAsync(f);
        if (stat) {
          let abbr = stat.isDirectory() ? filename + "/" : filename;
          let word = filename;
          return { word, abbr };
        }
        return null;
      }
      filterFiles(files) {
        let ignoreHidden = this.getConfig("ignoreHidden", true);
        let ignorePatterns = this.getConfig("ignorePatterns", []);
        return files.filter((f) => {
          if (f == null)
            return false;
          if (ignoreHidden && f.startsWith("."))
            return false;
          for (let p of ignorePatterns) {
            if ((0, import_minimatch8.default)(f, p, { dot: true }))
              return false;
          }
          return true;
        });
      }
      async getItemsFromRoot(pathstr, root) {
        let res = [];
        let part = /[\\/]$/.test(pathstr) ? pathstr : import_path36.default.dirname(pathstr);
        let dir = import_path36.default.isAbsolute(pathstr) ? part : import_path36.default.join(root, part);
        try {
          let stat = await statAsync(dir);
          if (stat && stat.isDirectory()) {
            let files = await import_util48.default.promisify(import_fs36.default.readdir)(dir);
            files = this.filterFiles(files);
            let items = await Promise.all(files.map((filename) => this.getFileItem(dir, filename)));
            res = res.concat(items);
          }
          res = res.filter((item) => item != null);
          return res;
        } catch (e) {
          logger94.error(`Error on list files:`, e);
          return res;
        }
      }
      get trimSameExts() {
        return this.getConfig("trimSameExts", []);
      }
      async doComplete(opt) {
        let { col, filepath } = opt;
        let option = this.getPathOption(opt);
        if (!option)
          return null;
        let { pathstr, part, startcol, input } = option;
        if (startcol < opt.col)
          return null;
        let startPart = opt.col == startcol ? "" : byteSlice(opt.line, opt.col, startcol);
        let dirname3 = import_path36.default.dirname(filepath);
        let ext = import_path36.default.extname(import_path36.default.basename(filepath));
        let cwd = await this.nvim.call("getcwd", []);
        let root;
        if (pathstr.startsWith(".")) {
          root = filepath ? import_path36.default.dirname(filepath) : cwd;
        } else if (isWindows && /^\w+:/.test(pathstr)) {
          root = /[\\/]$/.test(pathstr) ? pathstr : import_path36.default.dirname(pathstr);
        } else if (!isWindows && pathstr.startsWith("/")) {
          root = pathstr.endsWith("/") ? pathstr : import_path36.default.dirname(pathstr);
        } else if (part) {
          if (import_fs36.default.existsSync(import_path36.default.join(dirname3, part))) {
            root = dirname3;
          } else if (import_fs36.default.existsSync(import_path36.default.join(cwd, part))) {
            root = cwd;
          }
        } else {
          root = cwd;
        }
        if (!root)
          return null;
        let items = await this.getItemsFromRoot(pathstr, root);
        let trimExt = this.trimSameExts.includes(ext);
        let first = input[0];
        if (first && col == startcol)
          items = items.filter((o) => o.word[0] === first);
        return {
          items: items.map((item) => {
            let ex = import_path36.default.extname(item.word);
            item.word = trimExt && ex === ext ? item.word.replace(ext, "") : item.word;
            return {
              word: `${startPart}${item.word}`,
              abbr: `${startPart}${item.abbr}`,
              menu: this.menu
            };
          })
        };
      }
    };
  }
});

// src/sources/index.ts
var sources_exports = {};
__export(sources_exports, {
  Sources: () => Sources,
  default: () => sources_default
});
var import_fs38, import_path37, import_util49, import_vscode_languageserver_protocol93, logger95, Sources, sources_default;
var init_sources2 = __esm({
  "src/sources/index.ts"() {
    "use strict";
    import_fs38 = __toESM(require("fs"));
    import_path37 = __toESM(require("path"));
    import_util49 = __toESM(require("util"));
    import_vscode_languageserver_protocol93 = __toESM(require_main2());
    init_events();
    init_extensions3();
    init_types();
    init_util();
    init_array();
    init_fs();
    init_string();
    init_keywords();
    init_window();
    init_workspace();
    init_source();
    init_source_language();
    init_source_vim();
    logger95 = require_logger2()("sources");
    Sources = class {
      constructor() {
        this.sourceMap = /* @__PURE__ */ new Map();
        this.disposables = [];
        this.remoteSourcePaths = [];
      }
      init() {
        this.loadCompleteConfig();
        this.keywords = workspace_default.registerBufferSync((doc) => {
          return new KeywordsBuffer(doc);
        });
        workspace_default.onDidChangeConfiguration((e) => {
          if (e.affectsConfiguration("suggest")) {
            this.loadCompleteConfig();
          }
        }, null, this.disposables);
        this.createNativeSources();
        this.createRemoteSources();
        events_default.on("InsertLeave", () => {
          for (let item of this.keywords.items) {
            item.parse();
          }
        }, this, this.disposables);
        events_default.on("BufEnter", this.onDocumentEnter, this, this.disposables);
        workspace_default.onDidRuntimePathChange((newPaths) => {
          for (let p of newPaths) {
            if (p)
              void this.createVimSources(p);
          }
        }, null, this.disposables);
      }
      getShortcut(name2) {
        let source = this.sourceMap.get(name2);
        return source ? source.shortcut : "";
      }
      loadCompleteConfig() {
        let suggest = workspace_default.getConfiguration("suggest");
        let labels = suggest.get("completionItemKindLabels", {});
        let map = /* @__PURE__ */ new Map([
          [import_vscode_languageserver_protocol93.CompletionItemKind.Text, labels["text"] ?? "v"],
          [import_vscode_languageserver_protocol93.CompletionItemKind.Method, labels["method"] ?? "f"],
          [import_vscode_languageserver_protocol93.CompletionItemKind.Function, labels["function"] ?? "f"],
          [import_vscode_languageserver_protocol93.CompletionItemKind.Constructor, typeof labels["constructor"] == "function" ? "f" : labels["constructor"] ?? ""],
          [import_vscode_languageserver_protocol93.CompletionItemKind.Field, labels["field"] ?? "m"],
          [import_vscode_languageserver_protocol93.CompletionItemKind.Variable, labels["variable"] ?? "v"],
          [import_vscode_languageserver_protocol93.CompletionItemKind.Class, labels["class"] ?? "C"],
          [import_vscode_languageserver_protocol93.CompletionItemKind.Interface, labels["interface"] ?? "I"],
          [import_vscode_languageserver_protocol93.CompletionItemKind.Module, labels["module"] ?? "M"],
          [import_vscode_languageserver_protocol93.CompletionItemKind.Property, labels["property"] ?? "m"],
          [import_vscode_languageserver_protocol93.CompletionItemKind.Unit, labels["unit"] ?? "U"],
          [import_vscode_languageserver_protocol93.CompletionItemKind.Value, labels["value"] ?? "v"],
          [import_vscode_languageserver_protocol93.CompletionItemKind.Enum, labels["enum"] ?? "E"],
          [import_vscode_languageserver_protocol93.CompletionItemKind.Keyword, labels["keyword"] ?? "k"],
          [import_vscode_languageserver_protocol93.CompletionItemKind.Snippet, labels["snippet"] ?? "S"],
          [import_vscode_languageserver_protocol93.CompletionItemKind.Color, labels["color"] ?? "v"],
          [import_vscode_languageserver_protocol93.CompletionItemKind.File, labels["file"] ?? "F"],
          [import_vscode_languageserver_protocol93.CompletionItemKind.Reference, labels["reference"] ?? "r"],
          [import_vscode_languageserver_protocol93.CompletionItemKind.Folder, labels["folder"] ?? "F"],
          [import_vscode_languageserver_protocol93.CompletionItemKind.EnumMember, labels["enumMember"] ?? "m"],
          [import_vscode_languageserver_protocol93.CompletionItemKind.Constant, labels["constant"] ?? "v"],
          [import_vscode_languageserver_protocol93.CompletionItemKind.Struct, labels["struct"] ?? "S"],
          [import_vscode_languageserver_protocol93.CompletionItemKind.Event, labels["event"] ?? "E"],
          [import_vscode_languageserver_protocol93.CompletionItemKind.Operator, labels["operator"] ?? "O"],
          [import_vscode_languageserver_protocol93.CompletionItemKind.TypeParameter, labels["typeParameter"] ?? "T"]
        ]);
        let detailField = suggest.get("detailField", "preview");
        this.completeConfig = Object.assign(this.completeConfig || {}, {
          labels: map,
          detailField,
          defaultKindText: labels["default"] || "",
          priority: suggest.get("languageSourcePriority", 99),
          snippetsSupport: suggest.get("snippetsSupport", true),
          detailMaxLength: suggest.get("detailMaxLength", 100),
          invalidInsertCharacters: suggest.get("invalidInsertCharacters", ["(", "<", "{", "[", "\r", "\n"])
        });
      }
      get nvim() {
        return workspace_default.nvim;
      }
      createNativeSources() {
        this.disposables.push((init_around(), __toCommonJS(around_exports)).regist(this.sourceMap, this.keywords));
        this.disposables.push((init_buffer(), __toCommonJS(buffer_exports)).regist(this.sourceMap, this.keywords));
        this.disposables.push((init_file(), __toCommonJS(file_exports)).regist(this.sourceMap));
      }
      createLanguageSource(name2, shortcut, selector, provider, triggerCharacters, priority, allCommitCharacters) {
        let source = new LanguageSource(name2, shortcut, provider, selector, triggerCharacters || [], allCommitCharacters || [], priority, this.completeConfig);
        logger95.debug("created service source", name2);
        this.sourceMap.set(name2, source);
        return {
          dispose: () => {
            this.sourceMap.delete(name2);
          }
        };
      }
      async createVimSourceExtension(nvim, filepath) {
        let name2 = import_path37.default.basename(filepath, ".vim");
        try {
          await nvim.command(`source ${filepath}`);
          let fns = await nvim.call("coc#util#remote_fns", name2);
          for (let fn of ["init", "complete"]) {
            if (!fns.includes(fn)) {
              window_default.showMessage(`${fn} not found for source ${name2}`, "error");
              return null;
            }
          }
          let props = await nvim.call(`coc#source#${name2}#init`, []);
          let packageJSON = {
            name: `coc-source-${name2}`,
            engines: {
              coc: ">= 0.0.1"
            },
            activationEvents: props.filetypes ? props.filetypes.map((f) => `onLanguage:${f}`) : ["*"],
            contributes: {
              configuration: {
                properties: {
                  [`coc.source.${name2}.enable`]: {
                    type: "boolean",
                    default: true
                  },
                  [`coc.source.${name2}.firstMatch`]: {
                    type: "boolean",
                    default: !!props.firstMatch
                  },
                  [`coc.source.${name2}.triggerCharacters`]: {
                    type: "number",
                    default: props.triggerCharacters || []
                  },
                  [`coc.source.${name2}.priority`]: {
                    type: "number",
                    default: props.priority || 9
                  },
                  [`coc.source.${name2}.shortcut`]: {
                    type: "string",
                    default: props.shortcut || name2.slice(0, 3).toUpperCase(),
                    description: "Shortcut text shown in complete menu."
                  },
                  [`coc.source.${name2}.disableSyntaxes`]: {
                    type: "array",
                    default: [],
                    items: {
                      type: "string"
                    }
                  },
                  [`coc.source.${name2}.filetypes`]: {
                    type: "array",
                    default: props.filetypes || null,
                    description: "Enabled filetypes.",
                    items: {
                      type: "string"
                    }
                  }
                }
              }
            }
          };
          let source = new VimSource({
            name: name2,
            filepath,
            sourceType: 1 /* Remote */,
            optionalFns: fns.filter((n) => !["init", "complete"].includes(n))
          });
          let isActive = false;
          let extension = {
            id: packageJSON.name,
            packageJSON,
            exports: void 0,
            extensionPath: filepath,
            activate: () => {
              isActive = true;
              this.addSource(source);
              return Promise.resolve();
            }
          };
          Object.defineProperty(extension, "isActive", {
            get: () => isActive
          });
          extensions_default.registerExtension(extension, () => {
            isActive = false;
            this.removeSource(source);
          });
        } catch (e) {
          window_default.showMessage(`Error on create vim source ${name2}: ${e}`, "error");
        }
      }
      createRemoteSources() {
        let { runtimepath } = workspace_default.env;
        let paths = runtimepath.split(",");
        for (let path41 of paths) {
          this.createVimSources(path41).logError();
        }
      }
      async createVimSources(pluginPath) {
        if (this.remoteSourcePaths.includes(pluginPath))
          return;
        this.remoteSourcePaths.push(pluginPath);
        let folder = import_path37.default.join(pluginPath, "autoload/coc/source");
        let stat = await statAsync(folder);
        if (stat && stat.isDirectory()) {
          let arr = await import_util49.default.promisify(import_fs38.default.readdir)(folder);
          arr = arr.filter((s) => s.endsWith(".vim"));
          let files = arr.map((s) => import_path37.default.join(folder, s));
          if (files.length == 0)
            return;
          await Promise.all(files.map((p) => this.createVimSourceExtension(this.nvim, p)));
        }
      }
      get names() {
        return Array.from(this.sourceMap.keys());
      }
      get sources() {
        return Array.from(this.sourceMap.values());
      }
      has(name2) {
        return this.names.findIndex((o) => o == name2) != -1;
      }
      getSource(name2) {
        if (!name2)
          return null;
        return this.sourceMap.get(name2) || null;
      }
      shouldCommit(item, commitCharacter) {
        if (!item || !item.source)
          return false;
        let source = this.getSource(item.source);
        if (source && typeof source.shouldCommit === "function") {
          return source.shouldCommit(item, commitCharacter);
        }
        return false;
      }
      getCompleteSources(opt) {
        let { filetype } = opt;
        let pre = byteSlice(opt.line, 0, opt.colnr - 1);
        let isTriggered = opt.input == "" && !!opt.triggerCharacter;
        let uri = getUri(opt.filepath, opt.bufnr, "", workspace_default.env.isCygwin);
        if (isTriggered)
          return this.getTriggerSources(pre, filetype, uri);
        return this.getNormalSources(opt.filetype, uri);
      }
      getNormalSources(filetype, uri) {
        let languageIds = filetype.split(".");
        return this.sources.filter((source) => {
          let { filetypes, triggerOnly, documentSelector, enable } = source;
          if (!enable || triggerOnly || filetypes && !intersect(filetypes, languageIds)) {
            return false;
          }
          if (documentSelector && languageIds.every((filetype2) => workspace_default.match(documentSelector, { uri, languageId: filetype2 }) == 0)) {
            return false;
          }
          return true;
        });
      }
      checkTrigger(source, pre, character) {
        let { triggerCharacters, triggerPatterns } = source;
        if ((triggerCharacters == null ? void 0 : triggerCharacters.length) > 0 && triggerCharacters.includes(character)) {
          return true;
        }
        if ((triggerPatterns == null ? void 0 : triggerPatterns.length) > 0 && triggerPatterns.findIndex((p) => p.test(pre)) !== -1) {
          return true;
        }
        return false;
      }
      shouldTrigger(pre, filetype, uri) {
        return this.getTriggerSources(pre, filetype, uri).length > 0;
      }
      getTriggerSources(pre, filetype, uri, disabled = []) {
        if (!pre)
          return [];
        let character = pre[pre.length - 1];
        let languageIds = filetype.split(".");
        return this.sources.filter((source) => {
          let { filetypes, enable, documentSelector, name: name2 } = source;
          if (disabled.includes(name2))
            return false;
          if (!enable || filetypes && !intersect(filetypes, languageIds)) {
            return false;
          }
          if (documentSelector && languageIds.every((languageId) => workspace_default.match(documentSelector, { uri, languageId }) == 0)) {
            return false;
          }
          return this.checkTrigger(source, pre, character);
        });
      }
      addSource(source) {
        let { name: name2 } = source;
        if (this.names.includes(name2)) {
          logger95.warn(`Recreate source ${name2}`);
        }
        this.sourceMap.set(name2, source);
        return import_vscode_languageserver_protocol93.Disposable.create(() => {
          this.sourceMap.delete(name2);
        });
      }
      removeSource(source) {
        let name2 = typeof source == "string" ? source : source.name;
        this.sourceMap.delete(name2);
      }
      async refresh(name2) {
        for (let source of this.sources) {
          if (!name2 || source.name == name2) {
            if (typeof source.refresh === "function") {
              await Promise.resolve(source.refresh());
            }
          }
        }
      }
      toggleSource(name2) {
        if (!name2)
          return;
        let source = this.getSource(name2);
        if (!source)
          return;
        if (typeof source.toggle === "function") {
          source.toggle();
        }
      }
      sourceStats() {
        let res = [];
        let items = this.sources;
        for (let item of items) {
          res.push({
            name: item.name,
            priority: item.priority,
            triggerCharacters: item.triggerCharacters || [],
            shortcut: item.shortcut || "",
            filetypes: item.filetypes || [],
            filepath: item.filepath || "",
            type: item.sourceType == 0 /* Native */ ? "native" : item.sourceType == 1 /* Remote */ ? "remote" : "service",
            disabled: !item.enable
          });
        }
        return res;
      }
      onDocumentEnter(bufnr) {
        let { sources } = this;
        for (let s of sources) {
          if (s.enable && typeof s.onEnter == "function") {
            s.onEnter(bufnr);
          }
        }
      }
      createSource(config) {
        if (!config.name || !config.doComplete) {
          throw new Error(`name and doComplete required for createSource`);
        }
        let source = new Source(Object.assign({ sourceType: 2 /* Service */ }, config));
        return this.addSource(source);
      }
      dispose() {
        disposeAll(this.disposables);
      }
    };
    sources_default = new Sources();
  }
});

// src/languages.ts
var languages_exports = {};
__export(languages_exports, {
  default: () => languages_default
});
var import_vscode_languageserver_protocol94, logger96, Languages, languages_default;
var init_languages = __esm({
  "src/languages.ts"() {
    "use strict";
    import_vscode_languageserver_protocol94 = __toESM(require_main2());
    init_manager4();
    init_callHierarchyManager();
    init_codeActionManager();
    init_codeLensManager();
    init_declarationManager();
    init_definitionManager();
    init_documentColorManager();
    init_documentHighlightManager();
    init_documentLinkManager();
    init_documentSymbolManager();
    init_foldingRangeManager();
    init_formatManager();
    init_formatRangeManager();
    init_hoverManager();
    init_implementationManager();
    init_inlayHintManager();
    init_inlineValueManager();
    init_linkedEditingRangeManager();
    init_onTypeFormatManager();
    init_referenceManager();
    init_renameManager();
    init_selectionRangeManager();
    init_semanticTokensManager();
    init_semanticTokensRangeManager();
    init_signatureManager();
    init_typeDefinitionManager();
    init_typeHierarchyManager();
    init_workspaceSymbolsManager();
    init_util();
    logger96 = require_logger2()("languages");
    Languages = class {
      constructor() {
        this._onDidSemanticTokensRefresh = new import_vscode_languageserver_protocol94.Emitter();
        this._onDidInlayHintRefresh = new import_vscode_languageserver_protocol94.Emitter();
        this.onDidSemanticTokensRefresh = this._onDidSemanticTokensRefresh.event;
        this.onDidInlayHintRefresh = this._onDidInlayHintRefresh.event;
        this.onTypeFormatManager = new OnTypeFormatManager();
        this.documentLinkManager = new DocumentLinkManager();
        this.documentColorManager = new DocumentColorManager();
        this.foldingRangeManager = new FoldingRangeManager();
        this.renameManager = new RenameManager();
        this.formatManager = new FormatManager();
        this.codeActionManager = new CodeActionManager();
        this.workspaceSymbolsManager = new WorkspaceSymbolManager();
        this.formatRangeManager = new FormatRangeManager();
        this.hoverManager = new HoverManager();
        this.signatureManager = new SignatureManager();
        this.documentSymbolManager = new DocumentSymbolManager();
        this.documentHighlightManager = new DocumentHighlightManager();
        this.definitionManager = new DefinitionManager();
        this.declarationManager = new DeclarationManager();
        this.typeDefinitionManager = new TypeDefinitionManager();
        this.typeHierarchyManager = new TypeHierarchyManager();
        this.referenceManager = new ReferenceManager();
        this.implementationManager = new ImplementationManager();
        this.codeLensManager = new CodeLensManager();
        this.selectionRangeManager = new SelectionRangeManager();
        this.callHierarchyManager = new CallHierarchyManager();
        this.semanticTokensManager = new SemanticTokensManager();
        this.semanticTokensRangeManager = new SemanticTokensRangeManager();
        this.linkedEditingManager = new LinkedEditingRangeManager();
        this.inlayHintManager = new InlayHintManger();
        this.inlineValueManager = new InlineValueManager();
      }
      hasFormatProvider(doc) {
        if (this.formatManager.hasProvider(doc)) {
          return true;
        }
        if (this.formatRangeManager.hasProvider(doc)) {
          return true;
        }
        return false;
      }
      registerOnTypeFormattingEditProvider(selector, provider, triggerCharacters) {
        return this.onTypeFormatManager.register(selector, provider, triggerCharacters);
      }
      registerCompletionItemProvider(name2, shortcut, selector, provider, triggerCharacters = [], priority, allCommitCharacters) {
        selector = typeof selector == "string" ? [{ language: selector }] : selector;
        let sources = (init_sources2(), __toCommonJS(sources_exports)).default;
        sources.removeSource(name2);
        return sources.createLanguageSource(name2, shortcut, selector, provider, triggerCharacters, priority, allCommitCharacters);
      }
      registerCodeActionProvider(selector, provider, clientId, codeActionKinds) {
        return this.codeActionManager.register(selector, provider, clientId, codeActionKinds);
      }
      registerHoverProvider(selector, provider) {
        return this.hoverManager.register(selector, provider);
      }
      registerSelectionRangeProvider(selector, provider) {
        return this.selectionRangeManager.register(selector, provider);
      }
      registerSignatureHelpProvider(selector, provider, triggerCharacters) {
        return this.signatureManager.register(selector, provider, triggerCharacters);
      }
      registerDocumentSymbolProvider(selector, provider, metadata) {
        if (metadata)
          provider.meta = metadata;
        return this.documentSymbolManager.register(selector, provider);
      }
      registerFoldingRangeProvider(selector, provider) {
        return this.foldingRangeManager.register(selector, provider);
      }
      registerDocumentHighlightProvider(selector, provider) {
        return this.documentHighlightManager.register(selector, provider);
      }
      registerCodeLensProvider(selector, provider) {
        return this.codeLensManager.register(selector, provider);
      }
      registerDocumentLinkProvider(selector, provider) {
        return this.documentLinkManager.register(selector, provider);
      }
      registerDocumentColorProvider(selector, provider) {
        return this.documentColorManager.register(selector, provider);
      }
      registerDefinitionProvider(selector, provider) {
        return this.definitionManager.register(selector, provider);
      }
      registerDeclarationProvider(selector, provider) {
        return this.declarationManager.register(selector, provider);
      }
      registerTypeDefinitionProvider(selector, provider) {
        return this.typeDefinitionManager.register(selector, provider);
      }
      registerTypeHierarchyProvider(selector, provider) {
        return this.typeHierarchyManager.register(selector, provider);
      }
      registerImplementationProvider(selector, provider) {
        return this.implementationManager.register(selector, provider);
      }
      registerReferencesProvider(selector, provider) {
        return this.referenceManager.register(selector, provider);
      }
      registerRenameProvider(selector, provider) {
        return this.renameManager.register(selector, provider);
      }
      registerWorkspaceSymbolProvider(provider) {
        if (arguments.length > 1 && typeof arguments[1].provideWorkspaceSymbols === "function") {
          provider = arguments[1];
        }
        return this.workspaceSymbolsManager.register(provider);
      }
      registerDocumentFormatProvider(selector, provider, priority = 0) {
        return this.formatManager.register(selector, provider, priority);
      }
      registerDocumentRangeFormatProvider(selector, provider, priority = 0) {
        return this.formatRangeManager.register(selector, provider, priority);
      }
      registerCallHierarchyProvider(selector, provider) {
        return this.callHierarchyManager.register(selector, provider);
      }
      registerDocumentSemanticTokensProvider(selector, provider, legend) {
        let disposables = [];
        let timer = setTimeout(() => {
          this._onDidSemanticTokensRefresh.fire(selector);
        }, 500);
        disposables.push(import_vscode_languageserver_protocol94.Disposable.create(() => {
          clearTimeout(timer);
        }));
        provider.onDidChangeSemanticTokens && provider.onDidChangeSemanticTokens(() => {
          clearTimeout(timer);
          this._onDidSemanticTokensRefresh.fire(selector);
        }, null, disposables);
        disposables.push(this.semanticTokensManager.register(selector, provider, legend));
        return import_vscode_languageserver_protocol94.Disposable.create(() => {
          disposeAll(disposables);
        });
      }
      registerDocumentRangeSemanticTokensProvider(selector, provider, legend) {
        this._onDidSemanticTokensRefresh.fire(selector);
        return this.semanticTokensRangeManager.register(selector, provider, legend);
      }
      registerInlayHintsProvider(selector, provider) {
        let disposables = [];
        disposables.push(this.inlayHintManager.register(selector, provider));
        this._onDidInlayHintRefresh.fire(selector);
        if (typeof provider.onDidChangeInlayHints === "function") {
          provider.onDidChangeInlayHints(() => {
            this._onDidInlayHintRefresh.fire(selector);
          }, null, disposables);
        }
        return import_vscode_languageserver_protocol94.Disposable.create(() => {
          disposeAll(disposables);
          this._onDidInlayHintRefresh.fire(selector);
        });
      }
      registerInlineValuesProvider(selector, provider) {
        return this.inlineValueManager.register(selector, provider);
      }
      registerLinkedEditingRangeProvider(selector, provider) {
        return this.linkedEditingManager.register(selector, provider);
      }
      shouldTriggerSignatureHelp(document2, triggerCharacter) {
        return this.signatureManager.shouldTrigger(document2, triggerCharacter);
      }
      async getHover(document2, position, token) {
        return await this.hoverManager.provideHover(document2, position, token);
      }
      async getSignatureHelp(document2, position, token, context) {
        return await this.signatureManager.provideSignatureHelp(document2, position, token, context);
      }
      async getDefinition(document2, position, token) {
        return await this.definitionManager.provideDefinition(document2, position, token);
      }
      async getDefinitionLinks(document2, position, token) {
        return await this.definitionManager.provideDefinitionLinks(document2, position, token);
      }
      async getDeclaration(document2, position, token) {
        return await this.declarationManager.provideDeclaration(document2, position, token);
      }
      async getTypeDefinition(document2, position, token) {
        return await this.typeDefinitionManager.provideTypeDefinition(document2, position, token);
      }
      async getImplementation(document2, position, token) {
        return await this.implementationManager.provideImplementations(document2, position, token);
      }
      async getReferences(document2, context, position, token) {
        return await this.referenceManager.provideReferences(document2, position, context, token);
      }
      async getDocumentSymbol(document2, token) {
        return await this.documentSymbolManager.provideDocumentSymbols(document2, token);
      }
      getDocumentSymbolMetadata(document2) {
        return this.documentSymbolManager.getMetaData(document2);
      }
      async getSelectionRanges(document2, positions2, token) {
        return await this.selectionRangeManager.provideSelectionRanges(document2, positions2, token);
      }
      async getWorkspaceSymbols(query, token) {
        query = query || "";
        return await this.workspaceSymbolsManager.provideWorkspaceSymbols(query, token);
      }
      async resolveWorkspaceSymbol(symbol, token) {
        return await this.workspaceSymbolsManager.resolveWorkspaceSymbol(symbol, token);
      }
      async prepareRename(document2, position, token) {
        return await this.renameManager.prepareRename(document2, position, token);
      }
      async provideRenameEdits(document2, position, newName, token) {
        return await this.renameManager.provideRenameEdits(document2, position, newName, token);
      }
      async provideDocumentFormattingEdits(document2, options2, token) {
        let res = await this.formatManager.provideDocumentFormattingEdits(document2, options2, token);
        if (res == null) {
          let hasRangeFormatter = this.formatRangeManager.hasProvider(document2);
          if (!hasRangeFormatter)
            return null;
          let end = document2.positionAt(document2.getText().length);
          let range2 = import_vscode_languageserver_protocol94.Range.create(import_vscode_languageserver_protocol94.Position.create(0, 0), end);
          return await this.provideDocumentRangeFormattingEdits(document2, range2, options2, token);
        }
        return res;
      }
      async provideDocumentRangeFormattingEdits(document2, range2, options2, token) {
        return await this.formatRangeManager.provideDocumentRangeFormattingEdits(document2, range2, options2, token);
      }
      async getCodeActions(document2, range2, context, token) {
        return await this.codeActionManager.provideCodeActions(document2, range2, context, token);
      }
      async getDocumentHighLight(document2, position, token) {
        return await this.documentHighlightManager.provideDocumentHighlights(document2, position, token);
      }
      async getDocumentLinks(document2, token) {
        return await this.documentLinkManager.provideDocumentLinks(document2, token);
      }
      async resolveDocumentLink(link, token) {
        return await this.documentLinkManager.resolveDocumentLink(link, token);
      }
      async provideDocumentColors(document2, token) {
        return await this.documentColorManager.provideDocumentColors(document2, token);
      }
      async provideFoldingRanges(document2, context, token) {
        return await this.foldingRangeManager.provideFoldingRanges(document2, context, token);
      }
      async provideColorPresentations(color, document2, token) {
        return await this.documentColorManager.provideColorPresentations(color, document2, token);
      }
      async getCodeLens(document2, token) {
        return await this.codeLensManager.provideCodeLenses(document2, token);
      }
      async resolveCodeLens(codeLens, token) {
        return await this.codeLensManager.resolveCodeLens(codeLens, token);
      }
      async resolveCodeAction(codeAction, token) {
        return await this.codeActionManager.resolveCodeAction(codeAction, token);
      }
      async provideDocumentOnTypeEdits(character, document2, position, token) {
        return this.onTypeFormatManager.onCharacterType(character, document2, position, token);
      }
      canFormatOnType(character, document2) {
        return this.onTypeFormatManager.couldTrigger(document2, character) != null;
      }
      async prepareCallHierarchy(document2, position, token) {
        return this.callHierarchyManager.prepareCallHierarchy(document2, position, token);
      }
      async provideIncomingCalls(document2, item, token) {
        return this.callHierarchyManager.provideCallHierarchyIncomingCalls(document2, item, token);
      }
      async provideOutgoingCalls(document2, item, token) {
        return this.callHierarchyManager.provideCallHierarchyOutgoingCalls(document2, item, token);
      }
      getLegend(document2, range2) {
        if (range2)
          return this.semanticTokensRangeManager.getLegend(document2);
        return this.semanticTokensManager.getLegend(document2);
      }
      hasSemanticTokensEdits(document2) {
        return this.semanticTokensManager.hasSemanticTokensEdits(document2);
      }
      async provideDocumentSemanticTokens(document2, token) {
        return this.semanticTokensManager.provideDocumentSemanticTokens(document2, token);
      }
      async provideDocumentSemanticTokensEdits(document2, previousResultId, token) {
        return this.semanticTokensManager.provideDocumentSemanticTokensEdits(document2, previousResultId, token);
      }
      async provideDocumentRangeSemanticTokens(document2, range2, token) {
        return this.semanticTokensRangeManager.provideDocumentRangeSemanticTokens(document2, range2, token);
      }
      async provideInlayHints(document2, range2, token) {
        return this.inlayHintManager.provideInlayHints(document2, range2, token);
      }
      async resolveInlayHint(hint, token) {
        return this.inlayHintManager.resolveInlayHint(hint, token);
      }
      hasLinkedEditing(document2) {
        return this.linkedEditingManager.hasProvider(document2);
      }
      async provideLinkedEdits(document2, position, token) {
        return this.linkedEditingManager.provideLinkedEditingRanges(document2, position, token);
      }
      async provideInlineValues(document2, viewPort, context, token) {
        return this.inlineValueManager.provideInlineValues(document2, viewPort, context, token);
      }
      async prepareTypeHierarchy(document2, position, token) {
        return this.typeHierarchyManager.prepareTypeHierarchy(document2, position, token);
      }
      async provideTypeHierarchySupertypes(item, token) {
        return this.typeHierarchyManager.provideTypeHierarchySupertypes(item, token);
      }
      async provideTypeHierarchySubtypes(item, token) {
        return this.typeHierarchyManager.provideTypeHierarchySubtypes(item, token);
      }
      createDiagnosticCollection(owner) {
        return manager_default.create(owner);
      }
      hasProvider(id, document2) {
        switch (id) {
          case "formatOnType":
            return this.onTypeFormatManager.hasProvider(document2);
          case "rename":
            return this.renameManager.hasProvider(document2);
          case "onTypeEdit":
            return this.onTypeFormatManager.hasProvider(document2);
          case "documentLink":
            return this.documentLinkManager.hasProvider(document2);
          case "documentColor":
            return this.documentColorManager.hasProvider(document2);
          case "foldingRange":
            return this.foldingRangeManager.hasProvider(document2);
          case "format":
            return this.formatManager.hasProvider(document2) || this.formatRangeManager.hasProvider(document2);
          case "codeAction":
            return this.codeActionManager.hasProvider(document2);
          case "workspaceSymbols":
            return this.workspaceSymbolsManager.hasProvider();
          case "formatRange":
            return this.formatRangeManager.hasProvider(document2);
          case "hover":
            return this.hoverManager.hasProvider(document2);
          case "signature":
            return this.signatureManager.hasProvider(document2);
          case "documentSymbol":
            return this.documentSymbolManager.hasProvider(document2);
          case "documentHighlight":
            return this.documentHighlightManager.hasProvider(document2);
          case "definition":
            return this.definitionManager.hasProvider(document2);
          case "declaration":
            return this.declarationManager.hasProvider(document2);
          case "typeDefinition":
            return this.typeDefinitionManager.hasProvider(document2);
          case "reference":
            return this.referenceManager.hasProvider(document2);
          case "implementation":
            return this.implementationManager.hasProvider(document2);
          case "codeLens":
            return this.codeLensManager.hasProvider(document2);
          case "selectionRange":
            return this.selectionRangeManager.hasProvider(document2);
          case "callHierarchy":
            return this.callHierarchyManager.hasProvider(document2);
          case "semanticTokens":
            return this.semanticTokensManager.hasProvider(document2);
          case "semanticTokensRange":
            return this.semanticTokensRangeManager.hasProvider(document2);
          case "linkedEditing":
            return this.linkedEditingManager.hasProvider(document2);
          case "inlayHint":
            return this.inlayHintManager.hasProvider(document2);
          case "inlineValue":
            return this.inlineValueManager.hasProvider(document2);
          case "typeHierarchy":
            return this.typeHierarchyManager.hasProvider(document2);
          default:
            throw new Error(`Invalid provider name: ${String(id)}`);
        }
      }
    };
    languages_default = new Languages();
  }
});

// src/window.ts
function generateTabId() {
  return tab_global_id++;
}
function convertHighlightItem(item) {
  return [item.hlGroup, item.lnum, item.colStart, item.colEnd, item.combine ? 1 : 0, item.start_incl ? 1 : 0, item.end_incl ? 1 : 0];
}
function isSame(item, curr) {
  let arr = [item.hlGroup, item.lnum, item.colStart, item.colEnd];
  return equals(arr, curr.slice(0, 4));
}
var import_fs40, import_path38, import_vscode_languageserver_protocol95, logger97, PLUGIN_ROOT, tab_global_id, PROVIDER_NAMES, Window, window_default;
var init_window = __esm({
  "src/window.ts"() {
    "use strict";
    import_fs40 = __toESM(require("fs"));
    import_path38 = __toESM(require("path"));
    import_vscode_languageserver_protocol95 = __toESM(require_main2());
    init_esm();
    init_channels();
    init_terminals();
    init_ui();
    init_events();
    init_dialog();
    init_highligher();
    init_input();
    init_menu();
    init_notification();
    init_picker();
    init_progress();
    init_quickpick();
    init_status();
    init_types();
    init_util();
    init_fs();
    init_mutex();
    init_object();
    init_platform();
    init_workspace();
    logger97 = require_logger2()("window");
    PLUGIN_ROOT = import_path38.default.dirname(__dirname);
    tab_global_id = 3e3;
    PROVIDER_NAMES = [
      "formatOnType",
      "rename",
      "onTypeEdit",
      "documentLink",
      "documentColor",
      "foldingRange",
      "format",
      "codeAction",
      "formatRange",
      "hover",
      "signature",
      "documentSymbol",
      "documentHighlight",
      "definition",
      "declaration",
      "typeDefinition",
      "reference",
      "implementation",
      "codeLens",
      "selectionRange",
      "callHierarchy",
      "semanticTokens",
      "semanticTokensRange",
      "linkedEditing",
      "inlayHint",
      "inlineValue",
      "typeHierarchy"
    ];
    Window = class {
      constructor() {
        this.mutex = new Mutex();
        this.tabIds = [];
        this.terminalManager = new Terminals();
        this._onDidTabClose = new import_vscode_languageserver_protocol95.Emitter();
        this.onDidTabClose = this._onDidTabClose.event;
      }
      init(env) {
        for (let i = 1; i <= env.tabCount; i++) {
          this.tabIds.push(generateTabId());
        }
        events_default.on("TabNew", (nr) => {
          this.tabIds.splice(nr - 1, 0, generateTabId());
        });
        events_default.on("TabClosed", (nr) => {
          let id = this.tabIds[nr - 1];
          this.tabIds.splice(nr - 1, 1);
          if (id)
            this._onDidTabClose.fire(id);
        });
      }
      getTabNumber(id) {
        if (!this.tabIds.includes(id))
          return void 0;
        return this.tabIds.indexOf(id) + 1;
      }
      getTabId(nr) {
        return this.tabIds[nr - 1];
      }
      get nvim() {
        return workspace_default.nvim;
      }
      dispose() {
        var _a;
        this.terminalManager.dispose();
        (_a = this.statusLine) == null ? void 0 : _a.dispose();
      }
      get activeTextEditor() {
        return workspace_default.editors.activeTextEditor;
      }
      get visibleTextEditors() {
        return workspace_default.editors.visibleTextEditors;
      }
      get onDidChangeActiveTextEditor() {
        return workspace_default.editors.onDidChangeActiveTextEditor;
      }
      get onDidChangeVisibleTextEditors() {
        return workspace_default.editors.onDidChangeVisibleTextEditors;
      }
      get terminals() {
        return this.terminalManager.terminals;
      }
      get onDidOpenTerminal() {
        return this.terminalManager.onDidOpenTerminal;
      }
      get onDidCloseTerminal() {
        return this.terminalManager.onDidCloseTerminal;
      }
      async createTerminal(opts) {
        return await this.terminalManager.createTerminal(this.nvim, opts);
      }
      createFloatFactory(conf) {
        let preferences = workspace_default.getConfiguration("coc.preferences");
        let excludeImages = preferences.get("excludeImageLinksInMarkdownDocument", true);
        let c = workspace_default.getConfiguration("floatFactory");
        let defaults3 = c.get("floatConfig", {});
        return createFloatFactory(workspace_default.nvim, Object.assign({ excludeImages, maxWidth: 80 }, conf), defaults3);
      }
      showMessage(msg, messageType = "more") {
        let { messageLevel } = this;
        let hl = "Error";
        let level = 2 /* Error */;
        switch (messageType) {
          case "more":
            level = 0 /* More */;
            hl = "MoreMsg";
            break;
          case "warning":
            level = 1 /* Warning */;
            hl = "WarningMsg";
            break;
        }
        if (level >= messageLevel) {
          showMessage(this.nvim, msg, hl);
        }
      }
      async runTerminalCommand(cmd, cwd, keepfocus = false) {
        cwd = cwd || workspace_default.cwd;
        return await this.nvim.callAsync("coc#ui#run_terminal", { cmd, cwd, keepfocus: keepfocus ? 1 : 0 });
      }
      async openTerminal(cmd, opts = {}) {
        let bufnr = await this.nvim.call("coc#ui#open_terminal", __spreadValues({ cmd }, opts));
        return bufnr;
      }
      async showQuickpick(items, placeholder = "Choose by number") {
        return await this.showMenuPicker(items, { title: placeholder, position: "center" });
      }
      async showQuickPick(itemsOrItemsPromise, options2, token = import_vscode_languageserver_protocol95.CancellationToken.None) {
        this.checkDialog("showQuickPick");
        options2 = options2 || {};
        const items = await Promise.resolve(itemsOrItemsPromise);
        let isText = items.some((s) => typeof s === "string");
        if (token.isCancellationRequested)
          return void 0;
        return await this.mutex.use(() => {
          return new Promise((resolve3, reject) => {
            if (token.isCancellationRequested)
              return resolve3(void 0);
            let quickpick = new QuickPick(this.nvim, {
              items: items.map((o) => typeof o === "string" ? { label: o } : o),
              title: options2.title ?? "",
              canSelectMany: options2.canPickMany
            });
            quickpick.matchOnDescription = options2.matchOnDescription;
            quickpick.onDidFinish((items2) => {
              if (items2 == null)
                return resolve3(void 0);
              let arr = isText ? items2.map((o) => o.label) : items2;
              if (options2.canPickMany)
                return resolve3(arr);
              resolve3(arr[0]);
            });
            quickpick.show(this.dialogPreference).catch(reject);
          });
        });
      }
      async createQuickPick(config) {
        this.checkDialog("createQuickPick");
        return await this.mutex.use(async () => {
          let quickpick = new QuickPick(this.nvim, config);
          await quickpick.show(this.dialogPreference);
          return quickpick;
        });
      }
      async showMenuPicker(items, option, token) {
        return await this.mutex.use(async () => {
          if (token && token.isCancellationRequested)
            return -1;
          option = option || {};
          if (typeof option === "string")
            option = { title: option };
          let menu = new Menu(this.nvim, __spreadValues({ items }, option), token);
          let promise = new Promise((resolve3) => {
            menu.onDidClose((selected) => {
              resolve3(selected);
            });
          });
          await menu.show(this.dialogPreference);
          return await promise;
        });
      }
      async openLocalConfig() {
        let fsPath2 = await this.nvim.call("expand", ["%:p"]);
        let filetype = await this.nvim.eval("&filetype");
        if (!fsPath2 || !import_path38.default.isAbsolute(fsPath2)) {
          void this.showWarningMessage(`Current buffer doesn't have valid file path.`);
          return;
        }
        let folder = workspace_default.getWorkspaceFolder(URI2.file(fsPath2).toString());
        if (!folder) {
          let c = workspace_default.getConfiguration("coc.preferences");
          let patterns = c.get("rootPatterns", []);
          let w = workspace_default.getConfiguration("workspace");
          let ignored = w.get("ignoredFiletypes", []);
          let msg;
          if (ignored.includes(filetype))
            msg = `Filetype '${filetype}' is ignored for workspace folder resolve.`;
          if (!msg)
            msg = `Can't resolve workspace folder for file '${fsPath2}, consider create one of ${patterns.join(", ")} in your project root.'.`;
          void this.showWarningMessage(msg);
          return;
        }
        let root = URI2.parse(folder.uri).fsPath;
        let dir = import_path38.default.join(root, ".vim");
        if (!import_fs40.default.existsSync(dir)) {
          let res = await this.showPrompt(`Would you like to create folder'${root}/.vim'?`);
          if (!res)
            return;
          import_fs40.default.mkdirSync(dir);
        }
        let filepath = import_path38.default.join(dir, CONFIG_FILE_NAME);
        await this.nvim.call("coc#util#open_file", ["edit", filepath]);
      }
      async showPrompt(title) {
        return await this.mutex.use(() => {
          return showPrompt(this.nvim, title);
        });
      }
      async showDialog(config) {
        this.checkDialog("showDialog");
        return await this.mutex.use(async () => {
          let dialog = new Dialog(this.nvim, config);
          await dialog.show(this.dialogPreference);
          return dialog;
        });
      }
      async requestInput(title, defaultValue, option) {
        let { nvim } = this;
        const preferences = workspace_default.getConfiguration("coc.preferences");
        if (workspace_default.env.dialog && preferences.get("promptInput", true) && !isWindows) {
          return await this.mutex.use(async () => {
            let input = new InputBox(nvim, defaultValue ?? "");
            await input.show(title, Object.assign(this.inputPreference, option ?? {}));
            return await new Promise((resolve3) => {
              input.onDidFinish((text) => {
                resolve3(text);
              });
            });
          });
        } else {
          return await this.mutex.use(async () => {
            let res = await workspace_default.callAsync("input", [title + ": ", defaultValue || ""]);
            nvim.command("normal! :<C-u>", true);
            return res;
          });
        }
      }
      async createInputBox(title, defaultValue, option) {
        this.checkDialog("createInputBox");
        let input = new InputBox(this.nvim, defaultValue ?? "");
        await input.show(title, Object.assign(this.inputPreference, option));
        return input;
      }
      createStatusBarItem(priority = 0, option = {}) {
        if (!this.statusLine) {
          this.statusLine = new StatusLine(this.nvim);
        }
        return this.statusLine.createStatusBarItem(priority, option.progress || false);
      }
      createOutputChannel(name2) {
        return channels_default.create(name2, this.nvim);
      }
      showOutputChannel(name2, preserveFocus) {
        let config = workspace_default.getConfiguration("workspace");
        let command = config.get("openOutputCommand", "vs");
        channels_default.show(name2, command, preserveFocus);
      }
      async echoLines(lines, truncate = false) {
        let { nvim } = this;
        let cmdHeight = workspace_default.env.cmdheight;
        if (lines.length > cmdHeight && truncate) {
          lines = lines.slice(0, cmdHeight);
        }
        let maxLen = workspace_default.env.columns - 12;
        lines = lines.map((line) => {
          line = line.replace(/\n/g, " ");
          if (truncate)
            line = line.slice(0, maxLen);
          return line;
        });
        if (truncate && lines.length == cmdHeight) {
          let last = lines[lines.length - 1];
          lines[cmdHeight - 1] = `${last.length == maxLen ? last.slice(0, -4) : last} ...`;
        }
        await nvim.call("coc#ui#echo_lines", [lines]);
      }
      getCursorPosition() {
        return getCursorPosition(this.nvim);
      }
      async moveTo(position) {
        await moveTo(this.nvim, position, workspace_default.env.isVim);
      }
      getSelectedRange(mode) {
        return getSelection(this.nvim, mode);
      }
      async selectRange(range2) {
        await selectRange(this.nvim, range2, this.nvim.isVim);
      }
      getOffset() {
        return getOffset(this.nvim);
      }
      getCursorScreenPosition() {
        return getCursorScreenPosition(this.nvim);
      }
      async showPickerDialog(items, title, token) {
        this.checkDialog("showPickerDialog");
        return await this.mutex.use(async () => {
          if (token && token.isCancellationRequested) {
            return void 0;
          }
          let useString = typeof items[0] === "string";
          let picker = new Picker(this.nvim, {
            title,
            items: useString ? items.map((s) => {
              return { label: s };
            }) : items
          }, token);
          let promise = new Promise((resolve3) => {
            picker.onDidClose((selected) => {
              resolve3(selected);
            });
          });
          await picker.show(this.dialogPreference);
          let picked = await promise;
          let res = picked == void 0 ? void 0 : items.filter((_, i) => picked.includes(i));
          return res;
        });
      }
      async showInformationMessage(message, ...items) {
        let stack = Error().stack;
        return await this._showMessage("Info", message, items, stack);
      }
      async showWarningMessage(message, ...items) {
        let stack = Error().stack;
        return await this._showMessage("Warning", message, items, stack);
      }
      async showErrorMessage(message, ...items) {
        let stack = Error().stack;
        return await this._showMessage("Error", message, items, stack);
      }
      async showMessagePicker(title, content, hlGroup, items) {
        let texts = items.map((o) => typeof o === "string" ? o : o.title);
        let res = await this.showMenuPicker(texts, {
          position: "center",
          content,
          title: title.replace(/\r?\n/, " "),
          borderhighlight: hlGroup
        });
        return items[res];
      }
      async _showMessage(kind, message, items, stack) {
        if (!this.enableMessageDialog)
          return await this.showConfirm(message, items, kind);
        if (items.length > 0) {
          let source = this.parseSource(stack);
          return await this.showMessagePicker(`Choose action (${source})`, message, `Coc${kind}Float`, items);
        }
        await this.createNotification(kind.toLowerCase(), message, [], stack);
        return void 0;
      }
      async showNotification(config) {
        this.checkDialog("showNotification");
        let stack = Error().stack;
        let notification = new Notification(this.nvim, config);
        await notification.show(this.getNotificationPreference(stack));
      }
      async showConfirm(message, items, kind) {
        if (!items || items.length == 0) {
          let msgType = kind == "Info" ? "more" : kind == "Error" ? "error" : "warning";
          this.showMessage(message, msgType);
          return void 0;
        }
        let titles = typeof items[0] === "string" ? items.slice() : items.map((o) => o.title);
        let choices = titles.map((s, i) => `${i + 1}${s}`);
        let res = await this.nvim.callAsync("coc#util#with_callback", ["confirm", [message, choices.join("\n"), 0, kind]]);
        return items[res - 1];
      }
      async withProgress(options2, task) {
        this.checkDialog("withProgress");
        let stack = Error().stack;
        let progress = new ProgressNotification(this.nvim, {
          task,
          title: options2.title,
          cancellable: options2.cancellable
        });
        let config = workspace_default.getConfiguration("notification");
        let minWidth = config.get("minProgressWidth", 30);
        let promise = new Promise((resolve3) => {
          progress.onDidFinish(resolve3);
        });
        await progress.show(Object.assign(this.getNotificationPreference(stack, options2.source), { minWidth }));
        return await promise;
      }
      createTreeView(viewId, options2) {
        const BasicTreeView2 = (init_TreeView(), __toCommonJS(TreeView_exports)).default;
        return new BasicTreeView2(viewId, options2);
      }
      async diffHighlights(bufnr, ns, items, region, token) {
        let args = [bufnr, ns];
        if (Array.isArray(region))
          args.push(region[0], region[1] - 1);
        let curr = await this.nvim.call("coc#highlight#get_highlights", args);
        if (!curr || (token == null ? void 0 : token.isCancellationRequested))
          return null;
        items.sort((a, b) => a.lnum - b.lnum);
        let linesToRemove = [];
        let checkMarkers = workspace_default.has("nvim-0.5.1") || workspace_default.isVim;
        let removeMarkers = [];
        let newItems = [];
        let itemIndex = 0;
        let maxIndex = items.length - 1;
        let maxLnum = 0;
        let map = /* @__PURE__ */ new Map();
        curr.forEach((o) => {
          maxLnum = Math.max(maxLnum, o[1]);
          let arr = map.get(o[1]);
          if (arr) {
            arr.push(o);
          } else {
            map.set(o[1], [o]);
          }
        });
        if (curr.length > 0) {
          let start = Array.isArray(region) ? region[0] : 0;
          for (let i = start; i <= maxLnum; i++) {
            let exists = map.get(i) ?? [];
            let added = [];
            for (let j = itemIndex; j <= maxIndex; j++) {
              let o = items[j];
              if (o.lnum == i) {
                itemIndex = j + 1;
                added.push(o);
              } else {
                itemIndex = j;
                break;
              }
            }
            if (added.length == 0) {
              if (exists.length > 0) {
                if (checkMarkers) {
                  removeMarkers.push(...exists.map((o) => o[4]));
                } else {
                  linesToRemove.push(i);
                }
              }
            } else {
              if (exists.length == 0) {
                newItems.push(...added.map((o) => convertHighlightItem(o)));
              } else {
                if (checkMarkers) {
                  let skip = 0;
                  let min = Math.min(exists.length, added.length);
                  while (skip < min) {
                    if (isSame(added[skip], exists[skip])) {
                      skip++;
                    } else {
                      break;
                    }
                  }
                  removeMarkers.push(...exists.slice(skip).map((o) => o[4]));
                  newItems.push(...added.slice(skip).map((o) => convertHighlightItem(o)));
                } else {
                  if (added.length != exists.length || !added.every((o, i2) => isSame(o, exists[i2]))) {
                    linesToRemove.push(i);
                    newItems.push(...added.map((o) => convertHighlightItem(o)));
                  }
                }
              }
            }
          }
        }
        for (let i = itemIndex; i <= maxIndex; i++) {
          newItems.push(convertHighlightItem(items[i]));
        }
        return { remove: linesToRemove, add: newItems, removeMarkers };
      }
      async applyDiffHighlights(bufnr, ns, priority, diff, notify = false) {
        let { nvim } = this;
        let { remove, add, removeMarkers } = diff;
        if (remove.length === 0 && add.length === 0 && removeMarkers.length === 0)
          return;
        nvim.pauseNotification();
        if (removeMarkers.length) {
          nvim.call("coc#highlight#del_markers", [bufnr, ns, removeMarkers], true);
        }
        if (remove.length) {
          nvim.call("coc#highlight#clear", [bufnr, ns, remove], true);
        }
        if (add.length) {
          nvim.call("coc#highlight#set", [bufnr, ns, add, priority], true);
        }
        if (notify) {
          nvim.resumeNotification(true, true);
        } else {
          await nvim.resumeNotification(true);
        }
      }
      async bufferCheck() {
        let doc = await workspace_default.document;
        if (!doc.attached) {
          await this.showDialog({
            title: "Buffer check result",
            content: `Document not attached, ${doc.notAttachReason}`,
            highlight: "WarningMsg"
          });
          return;
        }
        let hi = new Highlighter();
        hi.addLine("Provider state", "Title");
        hi.addLine("");
        let languages = (init_languages(), __toCommonJS(languages_exports)).default;
        for (let name2 of PROVIDER_NAMES) {
          let exists = languages.hasProvider(name2, doc.textDocument);
          hi.addTexts([
            { text: "-", hlGroup: "Comment" },
            { text: " " },
            exists ? { text: "\u2713", hlGroup: "CocListFgGreen" } : { text: "\u2717", hlGroup: "CocListFgRed" },
            { text: " " },
            { text: name2, hlGroup: exists ? "Normal" : "CocFadeOut" }
          ]);
        }
        await this.showDialog({
          title: "Buffer check result",
          content: hi.content,
          highlights: hi.highlights
        });
      }
      createNotification(kind, message, items, stack) {
        return new Promise((resolve3, reject) => {
          let config = {
            kind,
            content: message,
            buttons: items.map((s, index) => {
              return { text: s, index };
            }),
            callback: (idx) => {
              resolve3(idx);
            }
          };
          let notification = new Notification(this.nvim, config);
          notification.show(this.getNotificationPreference(stack)).catch(reject);
        });
      }
      parseSource(stack, level = 2) {
        let line = stack.split(/\r?\n/).slice(level)[0];
        if (!line)
          return void 0;
        line = line.replace(/^\s*at\s*/, "");
        let filepath;
        if (line.endsWith(")")) {
          let ms = line.match(/(\((.*?):\d+:\d+\))$/);
          if (ms)
            filepath = ms[2];
        } else {
          let ms = line.match(/(.*?):\d+:\d+$/);
          if (ms)
            filepath = ms[1];
        }
        if (!filepath)
          return void 0;
        let arr = (init_extensions3(), __toCommonJS(extensions_exports)).default.getExtensionsInfo();
        let find = arr.find((o) => sameFile(o.filepath, filepath));
        if (find)
          return find.name.startsWith("single") ? import_path38.default.basename(find.filepath) : find.name;
        find = arr.find((o) => isParentFolder(o.directory, filepath));
        if (find)
          return find.name;
        if (isParentFolder(PLUGIN_ROOT, filepath))
          return "coc.nvim";
      }
      get dialogPreference() {
        let config = workspace_default.getConfiguration("dialog");
        return {
          rounded: config.get("rounded", true),
          maxWidth: config.get("maxWidth"),
          maxHeight: config.get("maxHeight"),
          floatHighlight: config.get("floatHighlight"),
          floatBorderHighlight: config.get("floatBorderHighlight"),
          pickerButtons: config.get("pickerButtons"),
          pickerButtonShortcut: config.get("pickerButtonShortcut"),
          confirmKey: config.get("confirmKey"),
          shortcutHighlight: config.get("shortcutHighlight")
        };
      }
      get inputPreference() {
        let config = workspace_default.getConfiguration("dialog");
        return {
          rounded: config.get("rounded", true),
          maxWidth: config.get("maxWidth", 80),
          highlight: config.get("floatHighlight"),
          borderhighlight: config.get("floatBorderHighlight")
        };
      }
      getNotificationPreference(stack, source) {
        if (!source)
          source = this.parseSource(stack);
        let config = workspace_default.getConfiguration("notification");
        let disabledList = config.get("disabledProgressSources", []);
        let disabled = Array.isArray(disabledList) && (disabledList.includes("*") || disabledList.includes(source));
        return {
          broder: config.get("border", true),
          focusable: config.get("focusable", true),
          marginRight: config.get("marginRight", 10),
          timeout: config.get("timeout", 10),
          maxWidth: config.get("maxWidth"),
          maxHeight: config.get("maxHeight"),
          highlight: config.get("highlightGroup"),
          winblend: config.get("winblend"),
          disabled,
          source
        };
      }
      checkDialog(name2) {
        if (workspace_default.env.dialog)
          return;
        throw new Error(`API window.${name2} requires vim >= 8.2.0750 or neovim >= 0.4.0, please upgrade your vim`);
      }
      get enableMessageDialog() {
        let config = workspace_default.getConfiguration("coc.preferences");
        return config.get("enableMessageDialog", false);
      }
      get messageLevel() {
        let config = workspace_default.getConfiguration("coc.preferences");
        let level = config.get("messageLevel", "more");
        switch (level) {
          case "error":
            return 2 /* Error */;
          case "warning":
            return 1 /* Warning */;
          default:
            return 0 /* More */;
        }
      }
    };
    window_default = new Window();
  }
});

// src/diagnostic/util.ts
function formatDiagnostic(format2, diagnostic) {
  let { source, code, severity, message } = diagnostic;
  let s = getSeverityName(severity)[0];
  const codeStr = code ? " " + code : "";
  return format2.replace("%source", source).replace("%code", codeStr).replace("%severity", s).replace("%message", message);
}
function getSeverityName(severity) {
  switch (severity) {
    case import_vscode_languageserver_protocol96.DiagnosticSeverity.Warning:
      return "Warning";
    case import_vscode_languageserver_protocol96.DiagnosticSeverity.Information:
      return "Information";
    case import_vscode_languageserver_protocol96.DiagnosticSeverity.Hint:
      return "Hint";
    default:
      return "Error";
  }
}
function getSeverityType(severity) {
  switch (severity) {
    case import_vscode_languageserver_protocol96.DiagnosticSeverity.Warning:
      return "W";
    case import_vscode_languageserver_protocol96.DiagnosticSeverity.Information:
      return "I";
    case import_vscode_languageserver_protocol96.DiagnosticSeverity.Hint:
      return "I";
    default:
      return "E";
  }
}
function severityLevel(level) {
  if (level == null)
    return void 0;
  switch (level) {
    case "hint":
      return import_vscode_languageserver_protocol96.DiagnosticSeverity.Hint;
    case "information":
      return import_vscode_languageserver_protocol96.DiagnosticSeverity.Information;
    case "warning":
      return import_vscode_languageserver_protocol96.DiagnosticSeverity.Warning;
    case "error":
      return import_vscode_languageserver_protocol96.DiagnosticSeverity.Error;
    default:
      return import_vscode_languageserver_protocol96.DiagnosticSeverity.Hint;
  }
}
function getNameFromSeverity(severity) {
  switch (severity) {
    case import_vscode_languageserver_protocol96.DiagnosticSeverity.Error:
      return "CocError";
    case import_vscode_languageserver_protocol96.DiagnosticSeverity.Warning:
      return "CocWarning";
    case import_vscode_languageserver_protocol96.DiagnosticSeverity.Information:
      return "CocInfo";
    case import_vscode_languageserver_protocol96.DiagnosticSeverity.Hint:
      return "CocHint";
    default:
      return "CocError";
  }
}
function getLocationListItem(bufnr, diagnostic, lines) {
  let { start, end } = diagnostic.range;
  let owner = diagnostic.source || "coc.nvim";
  let msg = diagnostic.message.split("\n")[0];
  let type = getSeverityName(diagnostic.severity).slice(0, 1).toUpperCase();
  return {
    bufnr,
    lnum: start.line + 1,
    end_lnum: end.line + 1,
    col: Array.isArray(lines) ? byteIndex(lines[start.line] ?? "", start.character) + 1 : start.character + 1,
    end_col: Array.isArray(lines) ? byteIndex(lines[end.line] ?? "", end.character) + 1 : end.character + 1,
    text: `[${owner}${diagnostic.code ? " " + diagnostic.code : ""}] ${msg} [${type}]`,
    type
  };
}
function sortDiagnostics(a, b) {
  if ((a.severity || 1) != (b.severity || 1)) {
    return (a.severity || 1) - (b.severity || 1);
  }
  let d = comparePosition(a.range.start, b.range.start);
  if (d != 0)
    return d;
  return a.source > b.source ? 1 : -1;
}
function getHighlightGroup(diagnostic) {
  let tags = diagnostic.tags || [];
  if (tags.includes(import_vscode_languageserver_protocol96.DiagnosticTag.Deprecated)) {
    return "CocDeprecatedHighlight" /* Deprecated */;
  }
  if (tags.includes(import_vscode_languageserver_protocol96.DiagnosticTag.Unnecessary)) {
    return "CocUnusedHighlight" /* Unused */;
  }
  switch (diagnostic.severity) {
    case import_vscode_languageserver_protocol96.DiagnosticSeverity.Warning:
      return "CocWarningHighlight" /* Warning */;
    case import_vscode_languageserver_protocol96.DiagnosticSeverity.Information:
      return "CocInfoHighlight" /* Information */;
    case import_vscode_languageserver_protocol96.DiagnosticSeverity.Hint:
      return "CocHintHighlight" /* Hint */;
    default:
      return "CocErrorHighlight" /* Error */;
  }
}
function adjustDiagnostics(diagnostics, edit2) {
  let res = [];
  let { range: range2 } = edit2;
  for (let diag of diagnostics) {
    let r = diag.range;
    if (rangeOverlap(range2, r))
      continue;
    if (comparePosition(r.start, range2.end) > 0) {
      let s = getPosition(r.start, edit2);
      let e = getPosition(r.end, edit2);
      if (s.line >= 0 && s.character >= 0 && e.line >= 0 && e.character >= 0) {
        diag.range = import_vscode_languageserver_protocol96.Range.create(s, e);
      }
    }
    res.push(diag);
  }
  return res;
}
var import_vscode_languageserver_protocol96;
var init_util3 = __esm({
  "src/diagnostic/util.ts"() {
    "use strict";
    import_vscode_languageserver_protocol96 = __toESM(require_main2());
    init_position();
    init_string();
    init_textedit();
  }
});

// src/diagnostic/buffer.ts
var import_debounce9, import_vscode_languageserver_protocol97, logger98, signGroup, NAMESPACE, hlGroups, delay, aleMethod, DiagnosticBuffer;
var init_buffer2 = __esm({
  "src/diagnostic/buffer.ts"() {
    "use strict";
    import_debounce9 = __toESM(require_debounce());
    import_vscode_languageserver_protocol97 = __toESM(require_main2());
    init_events();
    init_position();
    init_workspace();
    init_util3();
    logger98 = require_logger2()("diagnostic-buffer");
    signGroup = "CocDiagnostic";
    NAMESPACE = "diagnostic";
    hlGroups = ["CocErrorHighlight", "CocWarningHighlight", "CocInfoHighlight", "CocHintHighlight", "CocDeprecatedHighlight", "CocUnusedHighlight"];
    delay = global.__TEST__ ? 10 : 500;
    aleMethod = global.__TEST__ ? "MockAleResults" : "ale#other_source#ShowResults";
    DiagnosticBuffer = class {
      constructor(nvim, doc, config, onRefresh) {
        this.nvim = nvim;
        this.doc = doc;
        this.config = config;
        this.onRefresh = onRefresh;
        this.diagnosticsMap = /* @__PURE__ */ new Map();
        this._disposed = false;
        this._dirty = false;
        this._changeTs = 0;
        this.refreshHighlights = (0, import_debounce9.debounce)(this._refresh.bind(this), delay);
      }
      get dirty() {
        return this._dirty;
      }
      get bufnr() {
        return this.doc.bufnr;
      }
      get uri() {
        return this.doc.uri;
      }
      onChange(e) {
        let changes = e.contentChanges;
        if (changes.length > 0) {
          this._changeTs = Date.now();
          let edit2 = import_vscode_languageserver_protocol97.TextEdit.replace(changes[0].range, changes[0].text);
          for (let [collection, diagnostics] of this.diagnosticsMap.entries()) {
            if (diagnostics.length) {
              let arr = adjustDiagnostics(diagnostics, edit2);
              this.diagnosticsMap.set(collection, arr);
            }
          }
        }
        this.refreshHighlights();
      }
      onTextChange() {
        this._dirty = true;
        this.refreshHighlights.clear();
      }
      get displayByAle() {
        return this.config.displayByAle;
      }
      clearHighlight(collection) {
        this.buffer.clearNamespace(NAMESPACE + collection);
      }
      clearSigns(collection) {
        this.buffer.unplaceSign({ group: signGroup + collection });
      }
      get diagnostics() {
        let res = [];
        for (let diags of this.diagnosticsMap.values()) {
          res.push(...diags);
        }
        return res;
      }
      get buffer() {
        return this.nvim.createBuffer(this.bufnr);
      }
      refreshAle(collection, diagnostics) {
        let aleItems = diagnostics.map((o) => {
          let range2 = o.range;
          return {
            text: o.message,
            code: o.code,
            lnum: range2.start.line + 1,
            col: range2.start.character + 1,
            end_lnum: range2.end.line + 1,
            end_col: range2.end.character,
            type: getSeverityType(o.severity)
          };
        });
        this.nvim.call(aleMethod, [this.bufnr, "coc" + collection, aleItems], true);
      }
      async update(collection, diagnostics) {
        let { diagnosticsMap } = this;
        let curr = diagnosticsMap.get(collection) || [];
        if (!this._dirty && diagnostics.length == 0 && curr.length == 0)
          return;
        diagnosticsMap.set(collection, diagnostics);
        if (this._dirty || Date.now() - this._changeTs < delay) {
          this._dirty = true;
          return;
        }
        let info = await this.getDiagnosticInfo();
        if (this._dirty || !info || info.winid == -1) {
          this._dirty = true;
          return;
        }
        let map = /* @__PURE__ */ new Map();
        map.set(collection, diagnostics);
        this.refresh(map, info);
      }
      async reset(diagnostics, force) {
        this._changeTs = Date.now();
        let { diagnosticsMap } = this;
        for (let key of diagnosticsMap.keys()) {
          if (diagnostics[key] == null)
            diagnostics[key] = [];
        }
        for (let [key, value] of Object.entries(diagnostics)) {
          this.diagnosticsMap.set(key, value);
        }
        let info = await this.getDiagnosticInfo(force);
        if (!info) {
          this._dirty = true;
          return;
        }
        this.refresh(this.diagnosticsMap, info);
      }
      async getDiagnosticInfo(force) {
        let { refreshOnInsertMode } = this.config;
        let { nvim, bufnr } = this;
        let checkInsert = !refreshOnInsertMode;
        if (force) {
          checkInsert = false;
        } else {
          let disabledByInsert = events_default.insertMode && !refreshOnInsertMode;
          if (disabledByInsert)
            return void 0;
        }
        return await nvim.call("coc#util#diagnostic_info", [bufnr, checkInsert]);
      }
      refresh(diagnosticsMap, info) {
        let { nvim, displayByAle } = this;
        this._dirty = false;
        if (displayByAle) {
          nvim.pauseNotification();
          for (let [collection, diagnostics] of diagnosticsMap.entries()) {
            this.refreshAle(collection, diagnostics);
          }
          nvim.resumeNotification(true, true);
        } else {
          let emptyCollections = [];
          nvim.pauseNotification();
          for (let [collection, diagnostics] of diagnosticsMap.entries()) {
            if (diagnostics.length == 0)
              emptyCollections.push(collection);
            this.addSigns(collection, diagnostics);
            this.updateHighlights(collection, diagnostics);
          }
          this.showVirtualText(info.lnum, info.bufnr);
          this.updateLocationList(info.winid, info.locationlist);
          this.setDiagnosticInfo();
          nvim.resumeNotification(true, true);
          emptyCollections.forEach((name2) => {
            this.diagnosticsMap.delete(name2);
          });
          this.onRefresh(this.diagnostics);
        }
      }
      updateLocationList(winid, title) {
        if (!this.config.locationlistUpdate || winid == -1 || title !== "Diagnostics of coc")
          return;
        let items = this.toLocationListItems(this.diagnostics);
        this.nvim.call("setloclist", [winid, [], "r", { title: "Diagnostics of coc", items }], true);
      }
      toLocationListItems(diagnostics) {
        let { locationlistLevel } = this.config;
        let items = [];
        let lines = this.doc.textDocument.lines;
        diagnostics.sort(sortDiagnostics);
        for (let diagnostic of diagnostics) {
          if (locationlistLevel && diagnostic.severity && diagnostic.severity > locationlistLevel)
            continue;
          items.push(getLocationListItem(this.bufnr, diagnostic, lines));
        }
        return items;
      }
      addSigns(collection, diagnostics) {
        let { enableSign, signLevel } = this.config;
        if (!enableSign)
          return;
        let group = signGroup + collection;
        let signs = [];
        let signsMap = /* @__PURE__ */ new Map();
        for (let diagnostic of diagnostics) {
          let { range: range2, severity } = diagnostic;
          if (!severity || signLevel && severity > signLevel) {
            continue;
          }
          let line = range2.start.line;
          let exists = signsMap.get(line) || [];
          if (exists.includes(severity)) {
            continue;
          }
          exists.push(severity);
          signsMap.set(line, exists);
          let priority = this.config.signPriority + 4 - severity;
          signs.push({ name: getNameFromSeverity(severity), lnum: line + 1, priority });
        }
        this.nvim.call("coc#ui#update_signs", [this.bufnr, group, signs], true);
      }
      setDiagnosticInfo() {
        let lnums = [0, 0, 0, 0];
        let info = { error: 0, warning: 0, information: 0, hint: 0, lnums };
        for (let diagnostics of this.diagnosticsMap.values()) {
          for (let diagnostic of diagnostics) {
            let lnum = diagnostic.range.start.line + 1;
            switch (diagnostic.severity) {
              case import_vscode_languageserver_protocol97.DiagnosticSeverity.Warning:
                info.warning = info.warning + 1;
                lnums[1] = lnums[1] ? Math.min(lnums[1], lnum) : lnum;
                break;
              case import_vscode_languageserver_protocol97.DiagnosticSeverity.Information:
                info.information = info.information + 1;
                lnums[2] = lnums[2] ? Math.min(lnums[2], lnum) : lnum;
                break;
              case import_vscode_languageserver_protocol97.DiagnosticSeverity.Hint:
                info.hint = info.hint + 1;
                lnums[3] = lnums[3] ? Math.min(lnums[3], lnum) : lnum;
                break;
              default:
                lnums[0] = lnums[0] ? Math.min(lnums[0], lnum) : lnum;
                info.error = info.error + 1;
            }
          }
        }
        let buf = this.nvim.createBuffer(this.bufnr);
        buf.setVar("coc_diagnostic_info", info, true);
        this.nvim.call("coc#util#do_autocmd", ["CocDiagnosticChange"], true);
      }
      showVirtualText(lnum, bufnr) {
        let { config } = this;
        let { virtualText, virtualTextLevel } = config;
        if (!virtualText)
          return;
        let { virtualTextSrcId, virtualTextPrefix, virtualTextCurrentLineOnly } = this.config;
        let { diagnostics, buffer } = this;
        if (virtualTextCurrentLineOnly) {
          if (bufnr && this.bufnr != bufnr)
            return;
          diagnostics = diagnostics.filter((d) => {
            let { start, end } = d.range;
            return start.line <= lnum - 1 && end.line >= lnum - 1;
          });
        }
        diagnostics.sort(sortDiagnostics);
        buffer.clearNamespace(virtualTextSrcId);
        let map = /* @__PURE__ */ new Map();
        let opts = {};
        if (typeof config.virtualTextAlign === "string") {
          opts.text_align = config.virtualTextAlign;
        }
        if (typeof config.virtualTextWinCol === "number") {
          opts.virt_text_win_col = config.virtualTextWinCol;
        }
        for (let i = diagnostics.length - 1; i >= 0; i--) {
          let diagnostic = diagnostics[i];
          if (virtualTextLevel && diagnostic.severity && diagnostic.severity > virtualTextLevel) {
            continue;
          }
          let { line } = diagnostic.range.start;
          let highlight = getNameFromSeverity(diagnostic.severity) + "VirtualText";
          let msg = diagnostic.message.split(/\n/).map((l) => l.trim()).filter((l) => l.length > 0).slice(0, this.config.virtualTextLines).join(this.config.virtualTextLineSeparator);
          let arr = map.get(line) ?? [];
          arr.push([virtualTextPrefix + msg, highlight]);
          map.set(line, arr);
        }
        for (let [line, blocks] of map.entries()) {
          buffer.setVirtualText(virtualTextSrcId, line, blocks, opts);
        }
      }
      updateHighlights(collection, diagnostics) {
        if (!diagnostics.length) {
          this.clearHighlight(collection);
        } else {
          let items = this.getHighlightItems(diagnostics);
          let priority = this.config.highlightPriority;
          this.buffer.updateHighlights(NAMESPACE + collection, items, { priority });
        }
      }
      async _refresh() {
        if (!this._dirty)
          return;
        let info = await this.getDiagnosticInfo();
        let noHighlights = !info || info.winid == -1;
        if (noHighlights)
          return;
        this.refresh(this.diagnosticsMap, info);
      }
      getHighlightItems(diagnostics) {
        let doc = workspace_default.getDocument(this.uri);
        if (!doc)
          return [];
        let res = [];
        for (let diagnostic of diagnostics.slice(0, this.config.highlightLimit)) {
          let hlGroup = getHighlightGroup(diagnostic);
          doc.addHighlights(res, hlGroup, diagnostic.range);
        }
        res.sort((a, b) => {
          if (a.lnum != b.lnum)
            return a.lnum - b.lnum;
          if (a.colStart != b.colStart)
            return a.colStart - b.colStart;
          return hlGroups.indexOf(b.hlGroup) - hlGroups.indexOf(a.hlGroup);
        });
        return res;
      }
      clear() {
        let { nvim } = this;
        let collections = Array.from(this.diagnosticsMap.keys());
        this.refreshHighlights.clear();
        this.diagnosticsMap.clear();
        if (this.displayByAle) {
          for (let collection of collections) {
            this.nvim.call(aleMethod, [this.bufnr, collection, []], true);
          }
        } else {
          nvim.pauseNotification();
          this.buffer.deleteVar("coc_diagnostic_info");
          for (let collection of collections) {
            this.clearHighlight(collection);
            this.clearSigns(collection);
          }
          if (this.config.virtualText) {
            this.buffer.clearNamespace(this.config.virtualTextSrcId);
          }
          nvim.resumeNotification(true, true);
        }
      }
      getDiagnosticsAt(pos, checkCurrentLine) {
        let diagnostics = [];
        for (let diags of this.diagnosticsMap.values()) {
          if (checkCurrentLine) {
            diagnostics.push(...diags.filter((o) => lineInRange(pos.line, o.range)));
          } else {
            diagnostics.push(...diags.filter((o) => positionInRange(pos, o.range) == 0));
          }
        }
        diagnostics.sort(sortDiagnostics);
        return diagnostics;
      }
      async isEnabled() {
        if (this._disposed)
          return false;
        let buf = this.nvim.createBuffer(this.bufnr);
        let res = await buf.getVar("coc_diagnostic_disable");
        return res != 1;
      }
      dispose() {
        this.clear();
        this._disposed = true;
        this.refreshHighlights.clear();
      }
    };
  }
});

// src/diagnostic/collection.ts
var import_vscode_languageserver_protocol98, logger99, knownTags, DiagnosticCollection;
var init_collection = __esm({
  "src/diagnostic/collection.ts"() {
    "use strict";
    import_vscode_languageserver_protocol98 = __toESM(require_main2());
    init_esm();
    init_workspace();
    init_array();
    logger99 = require_logger2()("diagnostic-collection");
    knownTags = [import_vscode_languageserver_protocol98.DiagnosticTag.Deprecated, import_vscode_languageserver_protocol98.DiagnosticTag.Unnecessary];
    DiagnosticCollection = class {
      constructor(name2, onDispose) {
        this.name = name2;
        this.onDispose = onDispose;
        this.diagnosticsMap = /* @__PURE__ */ new Map();
        this._onDidDiagnosticsChange = new import_vscode_languageserver_protocol98.Emitter();
        this.onDidDiagnosticsChange = this._onDidDiagnosticsChange.event;
      }
      set(entries, diagnostics) {
        let diagnosticsPerFile = /* @__PURE__ */ new Map();
        if (!Array.isArray(entries)) {
          let doc = workspace_default.getDocument(entries);
          let uri = doc ? doc.uri : entries;
          diagnosticsPerFile.set(uri, diagnostics || []);
        } else {
          for (let item of entries) {
            let [uri, diagnostics2] = item;
            let doc = workspace_default.getDocument(uri);
            uri = doc ? doc.uri : uri;
            if (diagnostics2 == null) {
              diagnostics2 = [];
            } else {
              diagnostics2 = (diagnosticsPerFile.get(uri) || []).concat(diagnostics2);
            }
            diagnosticsPerFile.set(uri, diagnostics2);
          }
        }
        for (let item of diagnosticsPerFile) {
          let [uri, diagnostics2] = item;
          uri = URI2.parse(uri).toString();
          diagnostics2.forEach((o) => {
            o.range = o.range || import_vscode_languageserver_protocol98.Range.create(0, 0, 0, 0);
            o.message = o.message || "";
            o.source = o.source || this.name;
            if (!o.severity && Array.isArray(o.tags) && intersect(o.tags, knownTags)) {
              o.severity = import_vscode_languageserver_protocol98.DiagnosticSeverity.Hint;
            }
          });
          this.diagnosticsMap.set(uri, diagnostics2);
          this._onDidDiagnosticsChange.fire(uri);
        }
      }
      delete(uri) {
        this.diagnosticsMap.delete(uri);
        this._onDidDiagnosticsChange.fire(uri);
      }
      clear() {
        let uris = Array.from(this.diagnosticsMap.keys());
        uris = uris.filter((uri) => this.diagnosticsMap.get(uri).length > 0);
        this.diagnosticsMap.clear();
        for (let uri of uris) {
          this._onDidDiagnosticsChange.fire(uri);
        }
      }
      forEach(callback, thisArg) {
        for (let uri of this.diagnosticsMap.keys()) {
          let diagnostics = this.diagnosticsMap.get(uri);
          callback.call(thisArg, uri, diagnostics, this);
        }
      }
      entries() {
        return this.diagnosticsMap.entries();
      }
      get(uri) {
        let arr = this.diagnosticsMap.get(uri);
        return arr == null ? [] : arr.slice();
      }
      has(uri) {
        return this.diagnosticsMap.has(uri);
      }
      dispose() {
        this.clear();
        if (this.onDispose)
          this.onDispose();
        this._onDidDiagnosticsChange.dispose();
      }
    };
  }
});

// src/diagnostic/manager.ts
var import_debounce10, import_vscode_languageserver_protocol99, logger100, DiagnosticManager, manager_default;
var init_manager4 = __esm({
  "src/diagnostic/manager.ts"() {
    "use strict";
    import_debounce10 = __toESM(require_debounce());
    import_vscode_languageserver_protocol99 = __toESM(require_main2());
    init_esm();
    init_events();
    init_util();
    init_fs();
    init_position();
    init_string();
    init_window();
    init_workspace();
    init_buffer2();
    init_collection();
    init_util3();
    logger100 = require_logger2()("diagnostic-manager");
    DiagnosticManager = class {
      constructor() {
        this.enabled = true;
        this._onDidRefresh = new import_vscode_languageserver_protocol99.Emitter();
        this.onDidRefresh = this._onDidRefresh.event;
        this.collections = [];
        this.disposables = [];
      }
      init() {
        this.setConfiguration();
        this.nvim.createNamespace("coc-diagnostic-virtualText").then((id) => {
          this.config.virtualTextSrcId = id;
        }).logError();
        workspace_default.onDidChangeConfiguration(this.setConfiguration, this, this.disposables);
        this.floatFactory = window_default.createFloatFactory(Object.assign({ modes: ["n"] }, this.config.floatConfig));
        this.buffers = workspace_default.registerBufferSync((doc) => {
          let buf = new DiagnosticBuffer(this.nvim, doc, this.config, (diagnostics) => {
            this._onDidRefresh.fire({ diagnostics, uri: buf.uri, bufnr: buf.bufnr });
            if (buf.bufnr === workspace_default.bufnr && this.config.messageTarget === "float") {
              void this.getCurrentDiagnostics().then((diagnostics2) => {
                return this.showFloat(diagnostics2);
              });
            }
          });
          if (this.enabled) {
            let diagnostics = this.getDiagnostics(doc.uri);
            if (Object.keys(diagnostics).length > 0) {
              void buf.reset(diagnostics);
            }
          }
          return buf;
        });
        workspace_default.onDidCloseTextDocument((e) => {
          for (let collection of this.collections) {
            collection.delete(e.uri);
          }
        }, null, this.disposables);
        let messageTimer;
        events_default.on("CursorMoved", (bufnr) => {
          if (this.config.enableMessage != "always")
            return;
          if (messageTimer)
            clearTimeout(messageTimer);
          messageTimer = setTimeout(async () => {
            let buf = this.buffers.getItem(bufnr);
            if (!buf || buf.dirty)
              return;
            await this.echoMessage(true);
          }, this.config.messageDelay);
        }, null, this.disposables);
        let fn = (0, import_debounce10.default)(async (bufnr, cursor) => {
          if (!this.config.virtualTextCurrentLineOnly)
            return;
          if (events_default.insertMode && !this.config.refreshOnInsertMode)
            return;
          let buf = this.buffers.getItem(bufnr);
          if (buf) {
            let enabled = await buf.isEnabled();
            if (enabled)
              buf.showVirtualText(cursor[0]);
          }
        }, global.__TEST__ ? 10 : 100);
        this.disposables.push(import_vscode_languageserver_protocol99.Disposable.create(() => {
          fn.clear();
        }));
        events_default.on("CursorMoved", fn, null, this.disposables);
        events_default.on("InsertLeave", async () => {
          if (this.config.refreshOnInsertMode || !this.autoRefresh)
            return;
          for (let buf of this.buffers.items) {
            if (buf.dirty)
              buf.refreshHighlights();
          }
        }, null, this.disposables);
        events_default.on("BufWinEnter", (bufnr) => {
          let buf = this.buffers.getItem(bufnr);
          if (buf && buf.dirty)
            buf.refreshHighlights();
        }, null, this.disposables);
        this.clearTimers = () => {
          if (messageTimer)
            clearTimeout(messageTimer);
          messageTimer = void 0;
          fn.clear();
        };
        events_default.on("InsertEnter", this.clearTimers, this, this.disposables);
        let errorItems = workspace_default.configurations.errorItems;
        this.setConfigurationErrors(errorItems);
        workspace_default.configurations.onError((items) => {
          this.setConfigurationErrors(items);
        }, null, this.disposables);
      }
      defineSigns() {
        let { nvim } = this;
        let { enableHighlightLineNumber, enableSign } = this.config;
        if (!enableSign)
          return;
        nvim.pauseNotification();
        for (let kind of ["Error", "Warning", "Info", "Hint"]) {
          let signText = this.config[kind.toLowerCase() + "Sign"];
          let cmd = `sign define Coc${kind} linehl=Coc${kind}Line`;
          if (signText)
            cmd += ` texthl=Coc${kind}Sign text=${signText}`;
          if (enableHighlightLineNumber)
            cmd += ` numhl=Coc${kind}Sign`;
          nvim.command(cmd, true);
        }
        nvim.resumeNotification(false, true);
      }
      async setLocationlist(bufnr) {
        if (!this.enabled)
          throw new Error(`Diagnostic not enabled.`);
        let buf = this.buffers.getItem(bufnr);
        if (!buf)
          throw new Error(`buffer ${bufnr} not attached.`);
        let diagnostics = [];
        for (let diags of Object.values(this.getDiagnostics(buf.uri))) {
          diagnostics.push(...diags);
        }
        let items = buf.toLocationListItems(diagnostics);
        let curr = await this.nvim.call("getloclist", [0, { title: 1 }]);
        let action = curr.title && curr.title.indexOf("Diagnostics of coc") != -1 ? "r" : " ";
        await this.nvim.call("setloclist", [0, [], action, { title: "Diagnostics of coc", items }]);
      }
      setConfigurationErrors(errorItems) {
        let collection = this.create("config");
        if (errorItems == null ? void 0 : errorItems.length) {
          let fsPath2 = URI2.parse(errorItems[0].location.uri).fsPath;
          void window_default.showErrorMessage(`Error detected for config file ${fsPath2}, please check diagnostics list.`);
          let entries = /* @__PURE__ */ new Map();
          for (let item of errorItems) {
            let { uri } = item.location;
            let diagnostics = entries.get(uri) || [];
            diagnostics.push(import_vscode_languageserver_protocol99.Diagnostic.create(item.location.range, item.message, import_vscode_languageserver_protocol99.DiagnosticSeverity.Error));
            entries.set(uri, diagnostics);
          }
          collection.set(Array.from(entries));
        } else {
          collection.clear();
        }
      }
      create(name2) {
        let collection = this.getCollectionByName(name2);
        if (collection)
          return collection;
        collection = new DiagnosticCollection(name2, () => {
          let idx = this.collections.findIndex((o) => o == collection);
          if (idx !== -1)
            this.collections.splice(idx, 1);
        });
        this.collections.push(collection);
        collection.onDidDiagnosticsChange((uri) => {
          let buf = this.buffers.getItem(uri);
          if (!this.autoRefresh || !buf)
            return;
          void buf.update(name2, this.getDiagnosticsByCollection(uri, collection));
        });
        return collection;
      }
      getSortedRanges(uri, severity) {
        let collections = this.getCollections(uri);
        let res = [];
        let level = severity ? severityLevel(severity) : 0;
        for (let collection of collections) {
          let diagnostics = collection.get(uri);
          if (level) {
            diagnostics = diagnostics.filter((o) => o.severity == level);
          } else {
            let minLevel = this.config.level;
            if (minLevel && minLevel < import_vscode_languageserver_protocol99.DiagnosticSeverity.Hint) {
              diagnostics = diagnostics.filter((o) => {
                return o.severity && o.severity > minLevel ? false : true;
              });
            }
          }
          let ranges = diagnostics.map((o) => o.range);
          res.push(...ranges);
        }
        res.sort((a, b) => {
          if (a.start.line != b.start.line) {
            return a.start.line - b.start.line;
          }
          return a.start.character - b.start.character;
        });
        return res;
      }
      getDiagnostics(uri) {
        let res = {};
        let collections = this.getCollections(uri);
        for (let collection of collections) {
          if (!collection)
            continue;
          res[collection.name] = this.getDiagnosticsByCollection(uri, collection);
        }
        return res;
      }
      getDiagnosticsByCollection(uri, collection) {
        let { level, showUnused, showDeprecated } = this.config;
        let items = collection.get(uri) || [];
        if (items.length) {
          items = items.filter((d) => {
            var _a, _b;
            if (level && d.severity && d.severity > level) {
              return false;
            }
            if (!showUnused && ((_a = d.tags) == null ? void 0 : _a.includes(import_vscode_languageserver_protocol99.DiagnosticTag.Unnecessary))) {
              return false;
            }
            if (!showDeprecated && ((_b = d.tags) == null ? void 0 : _b.includes(import_vscode_languageserver_protocol99.DiagnosticTag.Deprecated))) {
              return false;
            }
            return true;
          });
          items.sort((a, b) => {
            return comparePosition(a.range.start, b.range.start);
          });
        }
        return items;
      }
      getDiagnosticsInRange(document2, range2) {
        let collections = this.getCollections(document2.uri);
        let res = [];
        for (let collection of collections) {
          let items = collection.get(document2.uri);
          if (!items)
            continue;
          for (let item of items) {
            if (rangeIntersect(item.range, range2)) {
              res.push(item);
            }
          }
        }
        return res;
      }
      async preview() {
        let diagnostics = await this.getCurrentDiagnostics();
        if (diagnostics.length == 0) {
          this.nvim.command("pclose", true);
          return;
        }
        let lines = [];
        for (let diagnostic of diagnostics) {
          let { source, code, severity, message } = diagnostic;
          let s = getSeverityName(severity)[0];
          lines.push(`[${source}${code ? " " + code : ""}] [${s}]`);
          lines.push(...message.split(/\r?\n/));
          lines.push("");
        }
        this.nvim.call("coc#ui#preview_info", [lines, "txt"], true);
      }
      async jumpPrevious(severity) {
        let buffer = await this.nvim.buffer;
        let item = this.buffers.getItem(buffer.id);
        if (!item)
          return;
        let curpos = await window_default.getCursorPosition();
        let ranges = this.getSortedRanges(item.uri, severity);
        let pos;
        for (let i = ranges.length - 1; i >= 0; i--) {
          let end = ranges[i].end;
          if (comparePosition(end, curpos) < 0) {
            pos = ranges[i].start;
            break;
          } else if (i == 0) {
            let wrapscan = await this.nvim.getOption("wrapscan");
            if (wrapscan)
              pos = ranges[ranges.length - 1].start;
          }
        }
        if (pos) {
          await window_default.moveTo(pos);
          if (this.config.enableMessage == "never")
            return;
          await this.echoMessage(false);
        }
      }
      async jumpNext(severity) {
        let buffer = await this.nvim.buffer;
        let item = this.buffers.getItem(buffer.id);
        if (!item)
          return;
        let curpos = await window_default.getCursorPosition();
        let ranges = this.getSortedRanges(item.uri, severity);
        let pos;
        for (let i = 0; i <= ranges.length - 1; i++) {
          let start = ranges[i].start;
          if (comparePosition(start, curpos) > 0) {
            pos = ranges[i].start;
            break;
          } else if (i == ranges.length - 1) {
            let wrapscan = await this.nvim.getOption("wrapscan");
            if (wrapscan)
              pos = ranges[0].start;
          }
        }
        if (pos) {
          await window_default.moveTo(pos);
          if (this.config.enableMessage == "never")
            return;
          await this.echoMessage(false);
        }
      }
      async getDiagnosticList() {
        let res = [];
        const { level } = this.config;
        for (let collection of this.collections) {
          for (let [uri, diagnostics] of collection.entries()) {
            if (diagnostics.length == 0)
              continue;
            let u = URI2.parse(uri);
            let doc = workspace_default.getDocument(uri);
            let lines = doc && doc.attached ? doc.textDocument.lines : void 0;
            if (!lines && u.scheme === "file") {
              try {
                const max = diagnostics.reduce((p, c) => {
                  return Math.max(c.range.end.line, p);
                }, 0);
                lines = await readFileLines(u.fsPath, 0, max);
              } catch (e) {
              }
            }
            for (let diagnostic of diagnostics) {
              if (diagnostic.severity && diagnostic.severity > level)
                continue;
              let { start, end } = diagnostic.range;
              let o = {
                file: u.fsPath,
                lnum: start.line + 1,
                end_lnum: end.line + 1,
                col: Array.isArray(lines) ? byteIndex(lines[start.line] ?? "", start.character) + 1 : start.character + 1,
                end_col: Array.isArray(lines) ? byteIndex(lines[end.line] ?? "", end.character) + 1 : end.character + 1,
                code: diagnostic.code,
                source: diagnostic.source || collection.name,
                message: diagnostic.message,
                severity: getSeverityName(diagnostic.severity),
                level: diagnostic.severity || 0,
                location: import_vscode_languageserver_protocol99.Location.create(uri, diagnostic.range)
              };
              res.push(o);
            }
          }
        }
        res.sort((a, b) => {
          if (a.level !== b.level) {
            return a.level - b.level;
          }
          if (a.file !== b.file) {
            return a.file > b.file ? 1 : -1;
          } else {
            if (a.lnum != b.lnum) {
              return a.lnum - b.lnum;
            }
            return a.col - b.col;
          }
        });
        return res;
      }
      getDiagnosticsAt(bufnr, cursor, atEnd = false, lastline = false) {
        let buffer = this.buffers.getItem(bufnr);
        if (!buffer)
          return [];
        let pos = import_vscode_languageserver_protocol99.Position.create(cursor[0], cursor[1]);
        let res = buffer.getDiagnosticsAt(pos, this.config.checkCurrentLine);
        if (this.config.checkCurrentLine || res.length)
          return res;
        if (atEnd) {
          pos = import_vscode_languageserver_protocol99.Position.create(cursor[0], cursor[1] + 1);
          res = buffer.getDiagnosticsAt(pos, false);
          if (res.length)
            return res;
        }
        if (lastline && cursor[1] == 0) {
          pos = import_vscode_languageserver_protocol99.Position.create(cursor[0] + 1, 0);
          res = buffer.getDiagnosticsAt(pos, false);
        }
        return res;
      }
      async getCurrentDiagnostics() {
        let [bufnr, cursor, eol, lastline] = await this.nvim.eval(`[bufnr("%"),coc#cursor#position(),col('.')==col('$')-1,line('.')==line('$')]`);
        return this.getDiagnosticsAt(bufnr, cursor, eol == 1, lastline == 1);
      }
      async echoMessage(truncate = false) {
        const config = this.config;
        if (!this.enabled || config.displayByAle)
          return;
        let useFloat = config.messageTarget == "float";
        let diagnostics = await this.getCurrentDiagnostics();
        if (config.messageLevel) {
          diagnostics = diagnostics.filter((diagnostic) => {
            return diagnostic.severity && diagnostic.severity <= config.messageLevel;
          });
        }
        if (useFloat) {
          await this.showFloat(diagnostics);
        } else {
          if (truncate && events_default.insertMode)
            return;
          const lines = [];
          diagnostics.forEach((diagnostic) => {
            lines.push(formatDiagnostic(config.format, diagnostic));
          });
          if (lines.length) {
            await this.nvim.command('echo ""');
            await window_default.echoLines(lines, truncate);
          }
        }
      }
      async showFloat(diagnostics) {
        if (this.config.messageTarget !== "float")
          return;
        let { config } = this;
        if (diagnostics.length == 0) {
          this.floatFactory.close();
          return;
        }
        if (events_default.insertMode)
          return;
        let ft = "";
        let docs = [];
        if (Object.keys(config.filetypeMap).length > 0) {
          let doc = workspace_default.getDocument(workspace_default.bufnr);
          let filetype = doc ? doc.filetype : "";
          const defaultFiletype = config.filetypeMap["default"] || "";
          ft = config.filetypeMap[filetype] || (defaultFiletype == "bufferType" ? filetype : defaultFiletype);
        }
        diagnostics.forEach((diagnostic) => {
          var _a;
          let filetype = "Error";
          if (ft === "") {
            switch (diagnostic.severity) {
              case import_vscode_languageserver_protocol99.DiagnosticSeverity.Hint:
                filetype = "Hint";
                break;
              case import_vscode_languageserver_protocol99.DiagnosticSeverity.Warning:
                filetype = "Warning";
                break;
              case import_vscode_languageserver_protocol99.DiagnosticSeverity.Information:
                filetype = "Info";
                break;
            }
          } else {
            filetype = ft;
          }
          docs.push({ filetype, content: formatDiagnostic(config.format, diagnostic) });
          if ((_a = diagnostic.codeDescription) == null ? void 0 : _a.href) {
            docs.push({ filetype: "txt", content: diagnostic.codeDescription.href });
          }
        });
        await this.floatFactory.show(docs);
      }
      async jumpRelated() {
        let diagnostics = await this.getCurrentDiagnostics();
        let diagnostic = diagnostics.find((o) => o.relatedInformation != null);
        let locations = diagnostic ? diagnostic.relatedInformation.map((o) => o.location) : [];
        if (locations.length == 1) {
          await workspace_default.jumpTo(locations[0].uri, locations[0].range.start);
        } else if (locations.length > 1) {
          await workspace_default.showLocations(locations);
        } else {
          void window_default.showWarningMessage("No related information found.");
        }
      }
      reset() {
        if (this.clearTimers) {
          this.clearTimers();
        }
        this.buffers.reset();
        for (let collection of this.collections) {
          collection.dispose();
        }
        this.collections = [];
      }
      dispose() {
        var _a;
        if (this.clearTimers) {
          this.clearTimers();
        }
        this.buffers.dispose();
        for (let collection of this.collections) {
          collection.dispose();
        }
        (_a = this.floatFactory) == null ? void 0 : _a.dispose();
        this.collections = [];
        disposeAll(this.disposables);
      }
      get nvim() {
        return workspace_default.nvim;
      }
      setConfiguration(event) {
        if (event && !event.affectsConfiguration("diagnostic"))
          return;
        let config = workspace_default.getConfiguration("diagnostic");
        let messageTarget = config.get("messageTarget", "float");
        if (messageTarget == "float" && !workspace_default.env.floating && !workspace_default.env.textprop) {
          messageTarget = "echo";
        }
        let enableHighlightLineNumber = config.get("enableHighlightLineNumber", true);
        if (!workspace_default.isNvim)
          enableHighlightLineNumber = false;
        this.config = Object.assign(this.config || {}, {
          floatConfig: config.get("floatConfig", {}),
          messageTarget,
          enableHighlightLineNumber,
          highlightLimit: config.get("highlightLimit", 1e3),
          highlightPriority: config.get("highlightPriority"),
          autoRefresh: config.get("autoRefresh", true),
          checkCurrentLine: config.get("checkCurrentLine", false),
          enableSign: workspace_default.env.sign && config.get("enableSign", true),
          locationlistUpdate: config.get("locationlistUpdate", true),
          enableMessage: config.get("enableMessage", "always"),
          messageDelay: config.get("messageDelay", 200),
          virtualText: config.get("virtualText", false),
          virtualTextAlign: config.get("virtualTextAlign", "after"),
          virtualTextWinCol: workspace_default.has("nvim-0.5.1") ? config.get("virtualTextWinCol", null) : null,
          virtualTextCurrentLineOnly: config.get("virtualTextCurrentLineOnly", true),
          virtualTextPrefix: config.get("virtualTextPrefix", " "),
          virtualTextLineSeparator: config.get("virtualTextLineSeparator", " \\ "),
          virtualTextLines: config.get("virtualTextLines", 3),
          displayByAle: config.get("displayByAle", false),
          level: severityLevel(config.get("level", "hint")),
          locationlistLevel: severityLevel(config.get("locationlistLevel")),
          signLevel: severityLevel(config.get("signLevel")),
          virtualTextLevel: severityLevel(config.get("virtualTextLevel")),
          messageLevel: severityLevel(config.get("messageLevel")),
          signPriority: config.get("signPriority", 10),
          errorSign: config.get("errorSign", ">>"),
          warningSign: config.get("warningSign", ">>"),
          infoSign: config.get("infoSign", ">>"),
          hintSign: config.get("hintSign", ">>"),
          refreshOnInsertMode: config.get("refreshOnInsertMode", false),
          filetypeMap: config.get("filetypeMap", {}),
          showUnused: config.get("showUnused", true),
          showDeprecated: config.get("showDeprecated", true),
          format: config.get("format", "[%source%code] [%severity] %message")
        });
        this.enabled = config.get("enable", true);
        this.defineSigns();
      }
      getCollectionByName(name2) {
        return this.collections.find((o) => o.name == name2);
      }
      getCollections(uri) {
        return this.collections.filter((c) => c.has(uri));
      }
      toggleDiagnostic(enable) {
        let enabled = enable == void 0 ? this.enabled : enable == 0;
        this.enabled = !enabled;
        for (let buf of this.buffers.items) {
          if (this.enabled) {
            void this.refreshBuffer(buf.uri);
          } else {
            buf.clear();
          }
        }
      }
      async toggleDiagnosticBuffer(bufnr, enable) {
        if (!this.enabled)
          return;
        bufnr = bufnr || workspace_default.bufnr;
        let buf = this.buffers.getItem(bufnr);
        if (buf) {
          let isEnabled = enable == void 0 ? await buf.isEnabled() : enable == 0;
          await this.nvim.call("setbufvar", [bufnr, "coc_diagnostic_disable", isEnabled ? 1 : 0]);
          if (isEnabled) {
            buf.clear();
          } else {
            void this.refreshBuffer(bufnr);
          }
        }
      }
      get autoRefresh() {
        return this.enabled && this.config.autoRefresh;
      }
      async refreshBuffer(uri, force) {
        let buf = this.buffers.getItem(uri);
        if (!buf)
          return false;
        await buf.reset(this.getDiagnostics(buf.uri), force);
        return true;
      }
      refresh(bufnr) {
        let items;
        if (!bufnr) {
          items = this.buffers.items;
        } else {
          let item = this.buffers.getItem(bufnr);
          items = item ? [item] : [];
        }
        for (let item of items) {
          void this.refreshBuffer(item.uri, true);
        }
      }
    };
    manager_default = new DiagnosticManager();
  }
});

// src/commands.ts
var import_vscode_languageserver_protocol100, logger101, CommandItem, CommandManager, commands_default;
var init_commands2 = __esm({
  "src/commands.ts"() {
    "use strict";
    import_vscode_languageserver_protocol100 = __toESM(require_main2());
    init_esm();
    init_manager4();
    init_manager3();
    init_util();
    init_window();
    init_workspace();
    init_events();
    logger101 = require_logger2()("commands");
    CommandItem = class {
      constructor(id, impl, thisArg, internal = false) {
        this.id = id;
        this.impl = impl;
        this.thisArg = thisArg;
        this.internal = internal;
      }
      execute(...args) {
        let { impl, thisArg } = this;
        return impl.apply(thisArg, args || []);
      }
      dispose() {
        this.thisArg = null;
        this.impl = null;
      }
    };
    CommandManager = class {
      constructor() {
        this.commands = /* @__PURE__ */ new Map();
        this.titles = /* @__PURE__ */ new Map();
        this.onCommandList = [];
      }
      init(nvim, plugin) {
        this.mru = workspace_default.createMru("commands");
        this.register({
          id: "vscode.open",
          execute: async (url) => {
            nvim.call("coc#ui#open_url", url.toString(), true);
          }
        }, true);
        this.register({
          id: "workbench.action.reloadWindow",
          execute: async () => {
            nvim.command("CocRestart", true);
          }
        }, true);
        this.register({
          id: "editor.action.insertSnippet",
          execute: async (edit2, ultisnip) => {
            const opts = ultisnip === true ? {} : ultisnip;
            return await manager_default3.insertSnippet(edit2.newText, true, edit2.range, import_vscode_languageserver_protocol100.InsertTextMode.adjustIndentation, opts ? opts : void 0);
          }
        }, true);
        this.register({
          id: "editor.action.doCodeAction",
          execute: async (action) => {
            await plugin.cocAction("doCodeAction", action);
          }
        }, true);
        this.register({
          id: "editor.action.triggerSuggest",
          execute: async () => {
            nvim.call("coc#refresh", [], true);
          }
        }, true);
        this.register({
          id: "editor.action.triggerParameterHints",
          execute: async () => {
            let doc = workspace_default.getDocument(workspace_default.bufnr);
            if (doc)
              await doc.synchronize();
            await plugin.cocAction("showSignatureHelp");
          }
        }, true);
        this.register({
          id: "editor.action.addRanges",
          execute: async (ranges) => {
            await plugin.cocAction("addRanges", ranges);
          }
        }, true);
        this.register({
          id: "editor.action.restart",
          execute: async () => {
            await wait(30);
            nvim.command("CocRestart", true);
          }
        }, true);
        this.register({
          id: "editor.action.showReferences",
          execute: async (_filepath, _position, references) => {
            await workspace_default.showLocations(references);
          }
        }, true);
        this.register({
          id: "editor.action.rename",
          execute: async (uri, position) => {
            await workspace_default.jumpTo(uri, position);
            await plugin.cocAction("rename");
          }
        }, true);
        this.register({
          id: "editor.action.format",
          execute: async () => {
            await plugin.cocAction("format");
          }
        }, true);
        this.register({
          id: "workspace.refactor",
          execute: async (locations) => {
            let locs = locations.filter((o) => import_vscode_languageserver_protocol100.Location.is(o));
            await plugin.getHandler().refactor.fromLocations(locs);
          }
        }, true);
        this.register({
          id: "workspace.clearWatchman",
          execute: async () => {
            let res = await window_default.runTerminalCommand("watchman watch-del-all");
            if (res.success)
              window_default.showMessage("Cleared watchman watching directories.");
          }
        }, false, "run watch-del-all for watchman to free up memory.");
        this.register({
          id: "workspace.workspaceFolders",
          execute: async () => {
            let folders = workspace_default.workspaceFolders;
            let lines = folders.map((folder) => URI2.parse(folder.uri).fsPath);
            await window_default.echoLines(lines);
          }
        }, false, "show opened workspaceFolders.");
        this.register({
          id: "workspace.renameCurrentFile",
          execute: async () => {
            await workspace_default.renameCurrent();
          }
        }, false, "change current filename to a new name and reload it.");
        this.register({
          id: "extensions.toggleAutoUpdate",
          execute: async () => {
            let config = workspace_default.getConfiguration("coc.preferences");
            let interval = config.get("extensionUpdateCheck", "daily");
            if (interval == "never") {
              config.update("extensionUpdateCheck", "daily", true);
              window_default.showMessage("Extension auto update enabled.", "more");
            } else {
              config.update("extensionUpdateCheck", "never", true);
              window_default.showMessage("Extension auto update disabled.", "more");
            }
          }
        }, false, "toggle auto update of extensions.");
        this.register({
          id: "workspace.diagnosticRelated",
          execute: () => manager_default.jumpRelated()
        }, false, "jump to related locations of current diagnostic.");
        this.register({
          id: "workspace.showOutput",
          execute: async (name2) => {
            if (name2) {
              window_default.showOutputChannel(name2);
            } else {
              let names = workspace_default.channelNames;
              if (names.length == 0)
                return;
              if (names.length == 1) {
                window_default.showOutputChannel(names[0]);
              } else {
                let idx = await window_default.showQuickpick(names);
                if (idx == -1)
                  return;
                let name3 = names[idx];
                window_default.showOutputChannel(name3);
              }
            }
          }
        }, false, "open output buffer to show output from languageservers or extensions.");
        this.register({
          id: "document.showIncomingCalls",
          execute: async () => {
            await plugin.cocAction("showIncomingCalls");
          }
        }, false, "show incoming calls in tree view.");
        this.register({
          id: "document.showOutgoingCalls",
          execute: async () => {
            await plugin.cocAction("showOutgoingCalls");
          }
        }, false, "show outgoing calls in tree view.");
        this.register({
          id: "document.echoFiletype",
          execute: async () => {
            let bufnr = await nvim.call("bufnr", "%");
            let doc = workspace_default.getDocument(bufnr);
            if (!doc)
              return;
            await window_default.echoLines([doc.filetype]);
          }
        }, false, "echo the mapped filetype of the current buffer");
        this.register({
          id: "document.renameCurrentWord",
          execute: async () => {
            let bufnr = await nvim.call("bufnr", "%");
            let doc = workspace_default.getDocument(bufnr);
            if (!doc)
              return;
            let edit2 = await plugin.cocAction("getWordEdit");
            if (!edit2) {
              window_default.showMessage("Invalid position", "warning");
              return;
            }
            let ranges = [];
            let { changes, documentChanges } = edit2;
            if (changes) {
              let edits = changes[doc.uri];
              if (edits)
                ranges = edits.map((e) => e.range);
            } else if (documentChanges) {
              for (let c of documentChanges) {
                if (import_vscode_languageserver_protocol100.TextDocumentEdit.is(c) && c.textDocument.uri == doc.uri) {
                  ranges = c.edits.map((e) => e.range);
                }
              }
            }
            if (ranges.length) {
              await plugin.cocAction("addRanges", ranges);
            }
          }
        }, false, "rename word under cursor in current buffer by use multiple cursors.");
        this.register({
          id: "document.jumpToNextSymbol",
          execute: async () => {
            let doc = await workspace_default.document;
            if (!doc)
              return;
            let ranges = await plugin.cocAction("symbolRanges");
            if (!ranges)
              return;
            let { textDocument } = doc;
            let offset = await window_default.getOffset();
            ranges.sort((a, b) => {
              if (a.start.line != b.start.line) {
                return a.start.line - b.start.line;
              }
              return a.start.character - b.start.character;
            });
            for (let i = 0; i <= ranges.length - 1; i++) {
              if (textDocument.offsetAt(ranges[i].start) > offset) {
                await window_default.moveTo(ranges[i].start);
                return;
              }
            }
            await window_default.moveTo(ranges[0].start);
          }
        }, false, "Jump to next symbol highlight position.");
        this.register({
          id: "workspace.undo",
          execute: async () => {
            await workspace_default.files.undoWorkspaceEdit();
          }
        }, false, "Undo previous workspace edit");
        this.register({
          id: "workspace.redo",
          execute: async () => {
            await workspace_default.files.redoWorkspaceEdit();
          }
        }, false, "Redo previous workspace edit");
        this.register({
          id: "workspace.inspectEdit",
          execute: async () => {
            await workspace_default.files.inspectEdit();
          }
        }, false, "Inspect previous workspace edit in new tab");
        this.register({
          id: "workspace.openLocation",
          execute: async (winid, loc, openCommand) => {
            if (winid)
              await nvim.call("win_gotoid", [winid]);
            await workspace_default.jumpTo(loc.uri, loc.range.start, openCommand);
          }
        }, true);
        this.register({
          id: "document.jumpToPrevSymbol",
          execute: async () => {
            let doc = await workspace_default.document;
            if (!doc)
              return;
            let ranges = await plugin.cocAction("symbolRanges");
            if (!ranges)
              return;
            let { textDocument } = doc;
            let offset = await window_default.getOffset();
            ranges.sort((a, b) => {
              if (a.start.line != b.start.line) {
                return a.start.line - b.start.line;
              }
              return a.start.character - b.start.character;
            });
            for (let i = ranges.length - 1; i >= 0; i--) {
              if (textDocument.offsetAt(ranges[i].end) < offset) {
                await window_default.moveTo(ranges[i].start);
                return;
              }
            }
            await window_default.moveTo(ranges[ranges.length - 1].start);
          }
        }, false, "Jump to previous symbol highlight position.");
        this.register({
          id: "document.checkBuffer",
          execute: async () => {
            await plugin.cocAction("bufferCheck");
          }
        }, false, "Check providers for current buffer.");
      }
      get commandList() {
        let res = [];
        for (let item of this.commands.values()) {
          if (!item.internal)
            res.push(item);
        }
        return res;
      }
      dispose() {
        for (const registration of this.commands.values()) {
          registration.dispose();
        }
        this.commands.clear();
      }
      execute(command) {
        return this.executeCommand(command.command, ...command.arguments ?? []);
      }
      register(command, internal = false, description) {
        for (const id of Array.isArray(command.id) ? command.id : [command.id]) {
          this.registerCommand(id, command.execute, command, internal);
          if (description)
            this.titles.set(id, description);
        }
        return command;
      }
      has(id) {
        return this.commands.has(id);
      }
      unregister(id) {
        let item = this.commands.get(id);
        if (!item)
          return;
        item.dispose();
        this.commands.delete(id);
      }
      registerCommand(id, impl, thisArg, internal = false) {
        if (id.startsWith("_"))
          internal = true;
        this.commands.set(id, new CommandItem(id, impl, thisArg, internal));
        return import_vscode_languageserver_protocol100.Disposable.create(() => {
          this.commands.delete(id);
        });
      }
      executeCommand(command, ...rest) {
        let cmd = this.commands.get(command);
        if (!cmd)
          throw new Error(`Command: ${command} not found`);
        return Promise.resolve(cmd.execute.apply(cmd, rest));
      }
      async fireCommand(id, ...args) {
        await events_default.fire("Command", [id]);
        let start = Date.now();
        let res = await this.executeCommand(id, ...args);
        if (args.length == 0) {
          await this.addRecent(id, events_default.lastChangeTs > start);
        }
        return res;
      }
      async addRecent(cmd, repeat2) {
        await this.mru.add(cmd);
        if (repeat2)
          await workspace_default.nvim.command(`silent! call repeat#set("\\<Plug>(coc-command-repeat)", -1)`);
      }
      async repeatCommand() {
        let mruList = await this.mru.load();
        let first = mruList[0];
        if (first) {
          await this.executeCommand(first);
          await workspace_default.nvim.command(`silent! call repeat#set("\\<Plug>(coc-command-repeat)", -1)`);
        }
      }
    };
    commands_default = new CommandManager();
  }
});

// src/main.ts
init_extensions();

// src/attach.ts
var import_neovim = __toESM(require_lib5());
var import_log4js = __toESM(require_log4js());
init_events();

// src/plugin.ts
var import_events54 = require("events");
var import_vscode_languageserver_protocol131 = __toESM(require_main2());
init_commands2();

// src/completion/index.ts
var import_vscode_languageserver_protocol103 = __toESM(require_main2());
init_esm();
init_events();
init_sources2();
init_util();
init_string();
init_workspace();

// src/completion/complete.ts
var import_unidecode2 = __toESM(require_unidecode());
var import_vscode_languageserver_protocol101 = __toESM(require_main2());
init_util();
init_fuzzy();
init_string();

// src/completion/match.ts
init_array();
init_fuzzy();
init_string();
function caseScore(input, curr, divide = 1) {
  if (input === curr)
    return 1 / divide;
  if (curr + 32 === input)
    return 0.5 / divide;
  return 0;
}
function matchScoreWithPositions(word, input) {
  if (input.length == 0 || word.length < input.length)
    return void 0;
  return nextScore(getCharCodes(word), 0, input, []);
}
function nextScore(codes, index, inputCodes, positions2) {
  if (inputCodes.length === 0)
    return [0, positions2];
  let len = codes.length;
  if (index >= len)
    return void 0;
  let input = inputCodes[0];
  let nextCodes = inputCodes.slice(1);
  if (!wordChar(input)) {
    let idx = findIndex(codes, input, index);
    if (idx == -1)
      return void 0;
    let score6 = idx == 0 ? 5 : 1;
    let next = nextScore(codes, idx + 1, nextCodes, [...positions2, idx]);
    return next === void 0 ? void 0 : [score6 + next[0], next[1]];
  }
  let isStart = positions2.length == 0;
  let score5 = caseScore(input, codes[index], isStart ? 0.2 : 1);
  if (score5 > 0) {
    let next = nextScore(codes, index + 1, nextCodes, [...positions2, index]);
    return next === void 0 ? void 0 : [score5 + next[0], next[1]];
  }
  let positionMap = /* @__PURE__ */ new Map();
  let word = getNextWord(codes, index + 1);
  if (word != null) {
    let score6 = caseScore(input, word[1], isStart ? 0.5 : 1);
    if (score6 > 0) {
      let ps = [...positions2, word[0]];
      if (score6 === 0.5)
        score6 = 0.75;
      let next = nextScore(codes, word[0] + 1, nextCodes, ps);
      if (next !== void 0)
        positionMap.set(score6 + next[0], next[1]);
    }
  }
  for (let i = index + 1; i < len; i++) {
    let score6 = caseScore(input, codes[i], isStart ? 1 : 10);
    if (score6 > 0) {
      let next = nextScore(codes, i + 1, nextCodes, [...positions2, i]);
      if (next !== void 0)
        positionMap.set(score6 + next[0], next[1]);
      break;
    }
  }
  if (positionMap.size == 0) {
    if (positions2.length > 0) {
      let last = positions2[positions2.length - 1];
      if (last > 0 && codes[last] !== input && codes[last - 1] === input) {
        let ps = positions2.slice();
        ps.splice(positions2.length - 1, 0, last - 1);
        let next = nextScore(codes, last + 1, nextCodes, ps);
        if (next === void 0)
          return void 0;
        return [0.5 + next[0], next[1]];
      }
    }
    return void 0;
  }
  let max = Math.max(...positionMap.keys());
  return [max, positionMap.get(max)];
}

// src/completion/complete.ts
var logger102 = require_logger2()("completion-complete");
var Complete = class {
  constructor(option, document2, config, sources, nvim) {
    this.option = option;
    this.document = document2;
    this.config = config;
    this.sources = sources;
    this.nvim = nvim;
    this.results = /* @__PURE__ */ new Map();
    this._input = "";
    this._completing = false;
    this.localBonus = /* @__PURE__ */ new Map();
    this.names = [];
    this.inputOffset = 0;
    this._onDidRefresh = new import_vscode_languageserver_protocol101.Emitter();
    this.onDidRefresh = this._onDidRefresh.event;
    this.tokenSource = new import_vscode_languageserver_protocol101.CancellationTokenSource();
    sources.sort((a, b) => b.priority - a.priority);
    this.names = sources.map((o) => o.name);
  }
  fireRefresh(waitTime) {
    if (this.timer)
      clearTimeout(this.timer);
    this.timer = setTimeout(() => {
      this._onDidRefresh.fire();
    }, waitTime);
  }
  get isCompleting() {
    return this._completing;
  }
  get input() {
    return this._input;
  }
  get isEmpty() {
    let empty = true;
    for (let res of this.results.values()) {
      if (res.items.length > 0) {
        empty = false;
        break;
      }
    }
    return empty;
  }
  getIncompleteSources() {
    let names = [];
    for (let [name2, result] of this.results.entries()) {
      if (result.isIncomplete) {
        names.push(name2);
      }
    }
    return names;
  }
  async doComplete() {
    var _a, _b;
    let token = this.tokenSource.token;
    let res = await Promise.all([
      this.nvim.call("coc#util#synname", []),
      this.nvim.call("coc#util#suggest_variables", [this.option.bufnr]),
      this.document.patchChange()
    ]);
    if (token.isCancellationRequested)
      return;
    this.option.synname = res[0];
    let variables = res[1];
    if (variables.disable) {
      logger102.warn("suggest cancelled by b:coc_suggest_disable");
      return true;
    }
    if ((_a = variables.disabled_sources) == null ? void 0 : _a.length) {
      this.sources = this.sources.filter((s) => !variables.disabled_sources.includes(s.name));
      if (this.sources.length === 0) {
        logger102.warn("suggest cancelled by b:coc_disabled_sources");
        return true;
      }
    }
    if ((_b = variables.blacklist) == null ? void 0 : _b.length) {
      if (variables.blacklist.includes(this.option.input)) {
        logger102.warn("suggest cancelled by b:coc_suggest_blacklist");
        return true;
      }
    }
    let { triggerCompletionWait, localityBonus } = this.config;
    await wait(Math.min(triggerCompletionWait ?? 0, 50));
    if (token.isCancellationRequested)
      return;
    let { colnr, linenr, col } = this.option;
    if (localityBonus) {
      let line = linenr - 1;
      this.localBonus = this.document.getLocalifyBonus(import_vscode_languageserver_protocol101.Position.create(line, col - 1), import_vscode_languageserver_protocol101.Position.create(line, colnr));
    }
    await this.completeSources(this.sources, false);
  }
  async completeSources(sources, isFilter) {
    let { timeout } = this.config;
    let { results, tokenSource } = this;
    let col = this.option.col;
    let names = sources.map((s) => s.name);
    let total = names.length;
    this._completing = true;
    let token = tokenSource.token;
    let timer;
    let tp = new Promise((resolve3) => {
      timer = setTimeout(() => {
        if (!tokenSource.token.isCancellationRequested) {
          names = names.filter((n) => !finished.includes(n));
          tokenSource.cancel();
          logger102.warn(`Complete timeout after ${timeout}ms`, names);
          this.nvim.setVar(`coc_timeout_sources`, names, true);
        }
        resolve3();
      }, typeof timeout === "number" ? timeout : 500);
    });
    const finished = [];
    await Promise.race([
      tp,
      Promise.all(sources.map((s) => this.completeSource(s, token).then(() => {
        finished.push(s.name);
        if (token.isCancellationRequested || isFilter)
          return;
        let colChanged = this.option.col !== col;
        if (colChanged)
          this.cancel();
        if (colChanged || finished.length === total) {
          this.fireRefresh(0);
        } else if (results.has(s.name)) {
          this.fireRefresh(16);
        }
      })))
    ]);
    clearTimeout(timer);
    this._completing = false;
  }
  async completeSource(source, token) {
    let opt = Object.assign({}, this.option);
    let { asciiMatch } = this.config;
    let { name: name2 } = source;
    try {
      if (typeof source.shouldComplete === "function") {
        let shouldRun = await Promise.resolve(source.shouldComplete(opt));
        if (!shouldRun || token.isCancellationRequested)
          return;
      }
      const priority = source.priority ?? 0;
      const start = Date.now();
      await new Promise((resolve3, reject) => {
        Promise.resolve(source.doComplete(opt, token)).then((result) => {
          if (token.isCancellationRequested) {
            resolve3(void 0);
            return;
          }
          let len = result ? result.items.length : 0;
          logger102.debug(`Source "${name2}" finished with ${len} items ${Date.now() - start}ms`);
          if (len > 0) {
            result.items.forEach((item) => {
              item.word = item.word ?? "";
              item.abbr = item.abbr ?? item.word;
              item.source = name2;
              item.priority = priority;
              item.filterText = asciiMatch ? (0, import_unidecode2.default)(item.filterText ?? item.word) : item.filterText ?? item.word;
              if (name2 !== "snippets")
                item.localBonus = this.localBonus.get(item.filterText) ?? 0;
            });
            this.setResult(name2, result);
          } else {
            this.results.delete(name2);
          }
          resolve3();
        }, (err) => {
          reject(err);
        });
      });
    } catch (err) {
      logger102.error("Complete error:", source.name, err);
    }
  }
  async completeInComplete(resumeInput, names) {
    let { document: document2 } = this;
    this.cancel();
    this.tokenSource = new import_vscode_languageserver_protocol101.CancellationTokenSource();
    let token = this.tokenSource.token;
    await document2.patchChange(true);
    if (token.isCancellationRequested)
      return void 0;
    let { input, colnr, linenr } = this.option;
    let character = resumeInput[resumeInput.length - 1];
    Object.assign(this.option, {
      input: resumeInput,
      line: document2.getline(linenr - 1),
      colnr: colnr + (resumeInput.length - input.length),
      triggerCharacter: !character || isWord(character) ? void 0 : character,
      triggerForInComplete: true
    });
    let sources = this.sources.filter((s) => names.includes(s.name));
    await this.completeSources(sources, true);
    if (token.isCancellationRequested)
      return void 0;
    return this.filterItems(resumeInput);
  }
  filterItems(input) {
    let { results, names, inputOffset } = this;
    if (inputOffset > 0)
      input = byteSlice(input, inputOffset);
    this._input = input;
    if (results.size == 0)
      return [];
    let len = input.length;
    let emptyInput = len == 0;
    let { maxItemCount, asciiMatch, defaultSortMethod, removeDuplicateItems } = this.config;
    let arr = [];
    let codes = getCharCodes(input);
    let words = /* @__PURE__ */ new Set();
    for (let name2 of names) {
      let result = results.get(name2);
      if (!result)
        continue;
      let snippetSource = name2 === "snippets";
      let items = result.items;
      for (let idx = 0; idx < items.length; idx++) {
        let item = items[idx];
        let { word, filterText, abbr, dup } = item;
        if (dup !== 1 && words.has(word))
          continue;
        if (filterText.length < len)
          continue;
        if (removeDuplicateItems && item.isSnippet !== true && words.has(word))
          continue;
        if (!emptyInput) {
          let positions2;
          let score5;
          if (item.kind && filterText === input) {
            score5 = 64;
            positions2 = Array.from({ length: filterText.length }, (x, i) => i);
          } else {
            let res = matchScoreWithPositions(filterText, codes);
            score5 = res == null ? 0 : res[0];
            if (res != null)
              positions2 = res[1];
          }
          if (score5 === 0)
            continue;
          if (filterText == (asciiMatch ? (0, import_unidecode2.default)(abbr) : abbr)) {
            item.positions = positions2;
          } else if (positions2 && positions2.length > 0) {
            let idx2 = abbr.indexOf(filterText.slice(0, positions2[positions2.length - 1] + 1));
            if (idx2 !== -1)
              item.positions = positions2.map((i) => i + idx2);
          }
          if (snippetSource && word === input) {
            item.score = 99;
          } else {
            item.score = score5 * (item.sourceScore || 1);
          }
        }
        words.add(word);
        arr.push(item);
      }
    }
    arr.sort((a, b) => {
      let sa = a.sortText;
      let sb = b.sortText;
      if (a.score !== b.score)
        return b.score - a.score;
      if (a.priority !== b.priority)
        return b.priority - a.priority;
      if (a.localBonus !== b.localBonus)
        return b.localBonus - a.localBonus;
      if (a.source === b.source && sa !== sb)
        return sa < sb ? -1 : 1;
      if (input.length === 0)
        return 0;
      switch (defaultSortMethod) {
        case "none":
          return 0;
        case "alphabetical":
          return a.filterText.localeCompare(b.filterText);
        case "length":
        default:
          return a.filterText.length - b.filterText.length;
      }
    });
    return this.limitCompleteItems(arr.slice(0, maxItemCount));
  }
  async filterResults(input) {
    if (this.timer)
      clearTimeout(this.timer);
    if (input !== this.option.input) {
      let names = this.getIncompleteSources();
      if (names.length) {
        return await this.completeInComplete(input, names);
      }
    }
    return this.filterItems(input);
  }
  limitCompleteItems(items) {
    let { highPrioritySourceLimit, lowPrioritySourceLimit } = this.config;
    if (!highPrioritySourceLimit && !lowPrioritySourceLimit)
      return items;
    let counts = /* @__PURE__ */ new Map();
    return items.filter((item) => {
      let { priority, source } = item;
      let isLow = priority < 90;
      let curr = counts.get(source) || 0;
      if (lowPrioritySourceLimit && isLow && curr == lowPrioritySourceLimit || highPrioritySourceLimit && !isLow && curr == highPrioritySourceLimit) {
        return false;
      }
      counts.set(source, curr + 1);
      return true;
    });
  }
  setResult(name2, result) {
    let { results } = this;
    let { line, colnr, col } = this.option;
    if (typeof result.startcol === "number" && result.startcol != col) {
      let { startcol } = result;
      if (startcol < col)
        this.inputOffset = col - startcol;
      this.option.col = startcol;
      this.option.input = byteSlice(line, startcol, colnr - 1);
      results.clear();
      results.set(name2, result);
    } else {
      results.set(name2, result);
    }
  }
  cancel() {
    let { tokenSource, timer } = this;
    if (timer)
      clearTimeout(timer);
    tokenSource.cancel();
    this._completing = false;
  }
  dispose() {
    this.cancel();
    this._onDidRefresh.dispose();
    this.sources = [];
    this.results.clear();
  }
};

// src/completion/floating.ts
var import_vscode_languageserver_protocol102 = __toESM(require_main2());
init_markdown();
init_sources2();
init_workspace();
var logger103 = require_logger2()("completion-floating");
var Floating = class {
  constructor(nvim) {
    this.nvim = nvim;
    this.excludeImages = true;
    this.excludeImages = workspace_default.getConfiguration("coc.preferences").get("excludeImageLinksInMarkdownDocument");
  }
  async resolveItem(item, floatConfig, opt) {
    let source = this.tokenSource = new import_vscode_languageserver_protocol102.CancellationTokenSource();
    let { token } = source;
    await this.doCompleteResolve(item, opt, source);
    if (token.isCancellationRequested)
      return;
    let docs = item.documentation ?? [];
    if (docs.length === 0 && typeof item.info === "string") {
      docs = [{ filetype: "txt", content: item.info }];
    }
    this.show(docs, Object.assign({}, floatConfig, { excludeImages: this.excludeImages }));
  }
  show(docs, config) {
    docs = docs.filter((o) => o.content.trim().length > 0);
    if (docs.length === 0) {
      this.close();
    } else {
      let { lines, codes, highlights } = parseDocuments(docs, { excludeImages: config.excludeImages });
      let opts = {
        codes,
        highlights,
        highlight: config.highlight ?? "CocFloating",
        maxWidth: config.maxWidth || 80,
        rounded: config.rounded ? 1 : 0,
        focusable: config.focusable === true ? 1 : 0
      };
      if (config.shadow)
        opts.shadow = 1;
      if (config.border)
        opts.border = [1, 1, 1, 1];
      if (config.borderhighlight)
        opts.borderhighlight = config.borderhighlight;
      if (typeof config.winblend === "number")
        opts.winblend = config.winblend;
      this.nvim.call("coc#dialog#create_pum_float", [lines, opts], true);
      this.nvim.redrawVim();
    }
  }
  doCompleteResolve(item, opt, tokenSource) {
    let source = sources_default.getSource(item.source);
    return new Promise((resolve3) => {
      if (source && typeof source.onCompleteResolve === "function") {
        let timer = setTimeout(() => {
          if (!tokenSource.token.isCancellationRequested) {
            tokenSource.cancel();
            this.close();
          }
          logger103.warn(`Resolve timeout after 500ms: ${source.name}`);
          resolve3();
        }, global.__TEST__ ? 100 : 500);
        Promise.resolve(source.onCompleteResolve(item, opt, tokenSource.token)).then(() => {
          clearTimeout(timer);
          resolve3();
        }, (e) => {
          logger103.error(`Error on complete resolve:`, e);
          clearTimeout(timer);
          resolve3();
        });
      } else {
        resolve3();
      }
    });
  }
  cancel() {
    if (this.tokenSource) {
      this.tokenSource.cancel();
      this.tokenSource = void 0;
    }
  }
  close() {
    this.nvim.call("coc#pum#close_detail", [], true);
  }
};

// src/completion/mru.ts
var logger104 = require_logger2()("completion-mru");
var MruLoader = class {
  constructor(selection) {
    this.selection = selection;
    this.max = 0;
    this.items = /* @__PURE__ */ new Map();
    this.itemsNoPrefex = /* @__PURE__ */ new Map();
  }
  getScore(input, item) {
    let key = toItemKey(item);
    if (input.length == 0)
      return this.itemsNoPrefex.get(key) ?? -1;
    if (this.selection === "recentlyUsedByPrefix")
      key = `${input}|${key}`;
    let map = this.selection === "recentlyUsed" ? this.itemsNoPrefex : this.items;
    return map.get(key) ?? -1;
  }
  add(prefix, item) {
    if (this.selection == "first" || ["around", "buffer", "word"].includes(item.source))
      return;
    let key = toItemKey(item);
    if (!item.word.toLowerCase().startsWith(prefix.toLowerCase())) {
      prefix = "";
    }
    let line = `${prefix}|${key}`;
    this.items.set(line, this.max);
    this.itemsNoPrefex.set(key, this.max);
    this.max += 1;
  }
};
function toItemKey(item) {
  let label = item.filterText;
  let source = item.source;
  let kind = item.kind ?? "";
  return `${label}|${source}|${kind}`;
}

// src/completion/pum.ts
var import_string_width2 = __toESM(require_string_width());
init_sources2();
init_string();

// src/completion/util.ts
init_sources2();
init_string();
var logger105 = require_logger2()("completion-util");
function toCompleteDoneItem(item) {
  if (!item)
    return {};
  return {
    word: item.word,
    abbr: item.abbr,
    kind: item.kind,
    source: item.source,
    isSnippet: item.isSnippet === true,
    menu: item.menu ?? `[${item.source}]`,
    user_data: typeof item.index === "number" ? `${item.source}:${item.index}` : item.user_data
  };
}
function shouldStop(bufnr, pretext, info, option) {
  let { pre } = info;
  if (pre.length === 0 || pre[pre.length - 1] === " " || pre.length < pretext.length)
    return true;
  if (option.bufnr != bufnr)
    return true;
  let text = byteSlice(option.line, 0, option.colnr - 1);
  if (option.linenr != info.lnum || !pre.startsWith(text))
    return true;
  return false;
}
function getFollowPart(option) {
  let { colnr, line } = option;
  let idx = characterIndex(line, colnr - 1);
  if (idx == line.length)
    return "";
  let part = line.slice(idx - line.length);
  return part.match(/^\S?[\w-]*/)[0];
}
function getInput(document2, pre, asciiCharactersOnly) {
  let len = 0;
  for (let i = pre.length - 1; i >= 0; i--) {
    let ch = pre[i];
    let word = document2.isWord(ch) && (asciiCharactersOnly ? ch.charCodeAt(0) < 255 : true);
    if (word) {
      len += 1;
    } else {
      break;
    }
  }
  return len == 0 ? "" : pre.slice(-len);
}
function getSources(option) {
  let { source } = option;
  if (source) {
    let s = sources_default.getSource(source);
    return s ? [s] : [];
  }
  return sources_default.getCompleteSources(option);
}
function getPrependWord(document2, remain) {
  let idx = 0;
  for (let i = 0; i < remain.length; i++) {
    if (document2.isWord(remain[i])) {
      idx = i + 1;
    } else {
      break;
    }
  }
  return idx == 0 ? "" : remain.slice(0, idx);
}
function shouldIndent(indentkeys = "", pretext) {
  if (!indentkeys || pretext.trim().includes(" "))
    return false;
  for (let part of indentkeys.split(",")) {
    if (part.indexOf("=") > -1) {
      let [pre, post] = part.split("=");
      let word = post.startsWith("~") ? post.slice(1) : post;
      if (pretext.length < word.length || pretext.length > word.length && !/^\s/.test(pretext.slice(-word.length - 1))) {
        continue;
      }
      let matched = post.startsWith("~") ? pretext.toLowerCase().endsWith(word) : pretext.endsWith(word);
      if (!matched) {
        continue;
      }
      if (pre == "") {
        return true;
      }
      if (pre == "0" && (pretext.length == word.length || /^\s*$/.test(pretext.slice(0, pretext.length - word.length)))) {
        return true;
      }
    }
  }
  return false;
}

// src/completion/pum.ts
var logger106 = require_logger2()("completion-pum");
var PopupMenu = class {
  constructor(nvim, config, mruLoader) {
    this.nvim = nvim;
    this.config = config;
    this.mruLoader = mruLoader;
    this._search = "";
  }
  get search() {
    return this._search;
  }
  get pumConfig() {
    let { floatConfig, pumFloatConfig, reversePumAboveCursor } = this.config;
    if (!pumFloatConfig)
      pumFloatConfig = floatConfig;
    let obj = {};
    if (typeof pumFloatConfig.highlight === "string")
      obj.highlight = pumFloatConfig.highlight;
    if (typeof pumFloatConfig.winblend === "number")
      obj.winblend = pumFloatConfig.winblend;
    if (pumFloatConfig.shadow)
      obj.shadow = pumFloatConfig.shadow;
    if (pumFloatConfig.border) {
      obj.border = [1, 1, 1, 1];
      obj.rounded = pumFloatConfig.rounded ? 1 : 0;
      obj.borderhighlight = pumFloatConfig.borderhighlight ?? "CocFloating";
    }
    obj.reverse = reversePumAboveCursor === true;
    return obj;
  }
  stringWidth(text) {
    return (0, import_string_width2.default)(text, { ambiguousIsNarrow: this.config.ambiguousIsNarrow });
  }
  show(items, search, option) {
    var _a;
    this._search = search;
    let { noselect, fixInsertedWord, enablePreselect, selection, virtualText } = this.config;
    let followPart = getFollowPart(option);
    if (followPart.length === 0)
      fixInsertedWord = false;
    let selectedIndex = enablePreselect ? items.findIndex((o) => o.preselect) : -1;
    let maxMru = -1;
    let abbrWidth = 0;
    let menuWidth = 0;
    let kindWidth = 0;
    let shortcutWidth = 0;
    let checkMru = selectedIndex == -1 && selection != "first";
    let labels = [];
    for (let i = 0; i < items.length; i++) {
      let item = items[i];
      if (checkMru) {
        let n = this.mruLoader.getScore(search, item);
        if (n > maxMru) {
          maxMru = n;
          selectedIndex = i;
        }
      }
      let shortcut = sources_default.getShortcut(item.source);
      let label = this.getLabel(item);
      labels.push(label);
      abbrWidth = Math.max(this.stringWidth(label.text), abbrWidth);
      if (item.kind)
        kindWidth = 1;
      if (item.menu)
        menuWidth = Math.max(this.stringWidth(item.menu), menuWidth);
      if (shortcut)
        shortcutWidth = Math.max(this.stringWidth(shortcut) + 2, shortcutWidth);
    }
    if (selectedIndex !== -1 && search.length > 0) {
      let item = items[selectedIndex];
      if (!((_a = item.word) == null ? void 0 : _a.startsWith(search))) {
        selectedIndex = -1;
      }
    }
    if (!noselect) {
      selectedIndex = selectedIndex == -1 ? 0 : selectedIndex;
    } else {
      if (selectedIndex > 0) {
        let [item] = items.splice(selectedIndex, 1);
        items.unshift(item);
      }
      selectedIndex == -1;
    }
    let opt = {
      input: search,
      index: selectedIndex,
      bufnr: option.bufnr,
      line: option.linenr,
      col: option.col,
      virtualText,
      words: items.map((o) => getWord2(fixInsertedWord, search, o.word, followPart))
    };
    let pumConfig = this.pumConfig;
    let lines = [];
    let highlights = [];
    let width = 0;
    let buildConfig = { border: !!pumConfig.border, menuWidth, abbrWidth, kindWidth, shortcutWidth };
    this.adjustAbbrWidth(buildConfig);
    for (let index = 0; index < items.length; index++) {
      let text = this.buildItem(items[index], labels[index], highlights, index, buildConfig);
      width = Math.max(width, this.stringWidth(text));
      lines.push(text);
    }
    let config = Object.assign({ width, highlights }, pumConfig);
    this.nvim.call("coc#pum#create", [lines, opt, config], true);
    this.nvim.redrawVim();
  }
  getLabel(item) {
    let { labelDetails } = item;
    let { snippetIndicator, labelMaxLength } = this.config;
    let abbr = item.abbr ?? "";
    let label = item.abbr ?? item.word;
    let hls = [];
    if (labelDetails) {
      let added = (labelDetails.detail ?? "") + (labelDetails.description ? ` ${labelDetails.description}` : "");
      if (label.length + added.length <= labelMaxLength) {
        let start = byteLength(label);
        hls.push({
          start,
          end: start + byteLength(added),
          hlGroup: "CocPumDetail"
        });
        label = label + added;
        item.detailRendered = true;
      }
    }
    if (item.isSnippet && !abbr.endsWith(snippetIndicator)) {
      label = label + snippetIndicator;
    }
    if (label.length > labelMaxLength) {
      label = label.slice(0, labelMaxLength - 1) + ".";
    }
    return { text: label, highlights: hls };
  }
  adjustAbbrWidth(config) {
    let { formatItems, pumwidth } = this.config;
    let len = 0;
    for (const item of formatItems) {
      if (item == "abbr") {
        len += config.abbrWidth + 1;
      } else if (item == "menu" && config.menuWidth) {
        len += config.menuWidth + 1;
      } else if (item == "kind" && config.kindWidth) {
        len += config.kindWidth + 1;
      } else if (item == "shortcut" && config.shortcutWidth) {
        len += config.shortcutWidth + 1;
      }
    }
    if (len < pumwidth) {
      config.abbrWidth = config.abbrWidth + pumwidth - len;
    }
  }
  buildItem(item, label, hls, index, config) {
    var _a;
    let { labelMaxLength, formatItems } = this.config;
    let text = config.border ? "" : " ";
    for (const name2 of formatItems) {
      switch (name2) {
        case "abbr": {
          let pre = byteLength(text);
          if (((_a = item.positions) == null ? void 0 : _a.length) > 0) {
            let positions2 = item.positions.filter((i) => i < labelMaxLength);
            let highlights = positionHighlights(item.abbr, positions2, pre, index);
            hls.push(...highlights);
          }
          let abbr = label.text;
          text += this.fillWidth(abbr, config.abbrWidth + 1);
          label.highlights.forEach((hl) => {
            hls.push({
              hlGroup: hl.hlGroup,
              lnum: index,
              colStart: pre + hl.start,
              colEnd: pre + hl.end
            });
          });
          if (item.deprecated) {
            hls.push({
              hlGroup: "CocPumDeprecated",
              lnum: index,
              colStart: pre,
              colEnd: pre + byteLength(abbr)
            });
          }
          break;
        }
        case "menu": {
          if (config.menuWidth > 0) {
            let pre = byteLength(text);
            text += this.fillWidth(item.menu ?? "", config.menuWidth + 1);
            if (item.menu) {
              hls.push({
                hlGroup: "CocPumMenu",
                lnum: index,
                colStart: pre,
                colEnd: pre + byteLength(item.menu)
              });
            }
          }
          break;
        }
        case "kind":
          if (config.kindWidth > 0) {
            let pre = byteLength(text);
            text += this.fillWidth(item.kind ?? "", config.kindWidth + 1);
            if (item.kind && item.kindHighlight) {
              hls.push({
                hlGroup: item.kindHighlight,
                lnum: index,
                colStart: pre,
                colEnd: pre + byteLength(item.kind)
              });
            }
          }
          break;
        case "shortcut":
          if (config.shortcutWidth > 0) {
            let pre = byteLength(text);
            let shortcut = sources_default.getShortcut(item.source);
            text += this.fillWidth(shortcut ? `[${shortcut}]` : "", config.shortcutWidth + 1);
            if (shortcut) {
              hls.push({
                hlGroup: "CocPumShortcut",
                lnum: index,
                colStart: pre,
                colEnd: pre + byteLength(shortcut) + 2
              });
            }
          }
          break;
      }
    }
    return text;
  }
  fillWidth(text, width) {
    let n = width - this.stringWidth(text);
    return n <= 0 ? text : text + " ".repeat(n);
  }
};
function getWord2(fixInsertedWord, search, word, followPart) {
  if (!fixInsertedWord || word.length <= followPart.length || !word.endsWith(followPart))
    return word;
  if (word.length < search.length + followPart.length)
    return word;
  return word.slice(0, word.length - followPart.length);
}
function positionHighlights(label, positions2, pre, line) {
  let hls = [];
  while (positions2.length > 0) {
    let start = positions2.shift();
    let end = start;
    while (positions2.length > 0) {
      let n = positions2[0];
      if (n - end == 1) {
        end = n;
        positions2.shift();
      } else {
        break;
      }
    }
    hls.push({
      hlGroup: "CocPumSearch",
      lnum: line,
      colStart: pre + byteIndex(label, start),
      colEnd: pre + byteIndex(label, end + 1)
    });
  }
  return hls;
}

// src/completion/index.ts
var logger107 = require_logger2()("completion");
var Completion = class {
  constructor() {
    this._activated = false;
    this.disposables = [];
    this.complete = null;
  }
  init() {
    this.nvim = workspace_default.nvim;
    this.getCompleteConfig();
    this.mru = new MruLoader(this.config.selection);
    this.pum = new PopupMenu(this.nvim, this.config, this.mru);
    workspace_default.onDidChangeConfiguration(this.getCompleteConfig, this, this.disposables);
    this.floating = new Floating(workspace_default.nvim);
    if (this.config.autoTrigger !== "none") {
      workspace_default.nvim.call("coc#ui#check_pum_keymappings", [], true);
    }
    events_default.on("CursorMovedI", (bufnr, cursor, hasInsert) => {
      var _a;
      if (this.triggerTimer)
        clearTimeout(this.triggerTimer);
      if (hasInsert || !this.option || bufnr !== this.option.bufnr)
        return;
      if (this.option.linenr === cursor[0]) {
        if (cursor[1] == this.option.colnr && cursor[1] === byteLength(this.pretext ?? "") + 1) {
          return;
        }
        let line = workspace_default.getDocument(bufnr).getline(cursor[0] - 1);
        let curr = characterIndex(line, cursor[1] - 1);
        let start = characterIndex(line, this.option.col);
        if (start < curr) {
          let text = line.substring(start, curr);
          if (this.selectedItem && text === this.selectedItem.word)
            return;
          if (!this.inserted && text == ((_a = this.complete) == null ? void 0 : _a.input))
            return;
        }
      }
      this.stop(true);
    }, null, this.disposables);
    events_default.on("InsertLeave", () => {
      this.stop(true);
    }, null, this.disposables);
    events_default.on("CompleteStop", (kind, pretext) => {
      this.stop(false, kind, pretext);
    }, null, this.disposables);
    events_default.on("InsertEnter", this.onInsertEnter, this, this.disposables);
    events_default.on("TextChangedI", this.onTextChangedI, this, this.disposables);
    events_default.on("TextChangedP", this.onTextChangedP, this, this.disposables);
    events_default.on("MenuPopupChanged", async (ev) => {
      var _a;
      if (!this.option)
        return;
      this.popupEvent = ev;
      this.floating.cancel();
      let item = this.selectedItem;
      if (!item || !ev.move && ((_a = this.complete) == null ? void 0 : _a.isCompleting))
        return;
      let config = this.config.floatConfig;
      await this.floating.resolveItem(item, config, this.option);
    }, null, this.disposables);
  }
  get option() {
    if (!this.complete)
      return null;
    return this.complete.option;
  }
  get isActivated() {
    return this._activated;
  }
  get inserted() {
    return this.popupEvent != null && this.popupEvent.inserted;
  }
  get document() {
    if (!this.option)
      return null;
    return workspace_default.getDocument(this.option.bufnr);
  }
  get selectedItem() {
    if (!this.popupEvent || !this.activeItems)
      return void 0;
    return this.activeItems[this.popupEvent.index];
  }
  getCompleteConfig(e) {
    if (e && !e.affectsConfiguration("suggest"))
      return;
    let suggest = workspace_default.getConfiguration("suggest");
    function getConfig(key, defaultValue) {
      return suggest.get(key, defaultValue);
    }
    this.config = Object.assign(this.config ?? {}, {
      ambiguousIsNarrow: workspace_default.env.ambiguousIsNarrow,
      pumwidth: workspace_default.env.pumwidth || 15,
      noselect: getConfig("noselect", false),
      enablePreselect: getConfig("enablePreselect", true),
      formatItems: getConfig("formatItems", ["abbr", "menu", "kind", "shortcut"]),
      autoTrigger: getConfig("autoTrigger", "always"),
      virtualText: getConfig("virtualText", false),
      selection: getConfig("selection", "first"),
      floatConfig: getConfig("floatConfig", {}),
      pumFloatConfig: getConfig("pumFloatConfig", null),
      defaultSortMethod: getConfig("defaultSortMethod", "length"),
      removeDuplicateItems: getConfig("removeDuplicateItems", false),
      acceptSuggestionOnCommitCharacter: getConfig("acceptSuggestionOnCommitCharacter", false),
      triggerCompletionWait: getConfig("triggerCompletionWait", 0),
      labelMaxLength: getConfig("labelMaxLength", 200),
      triggerAfterInsertEnter: getConfig("triggerAfterInsertEnter", false),
      maxItemCount: getConfig("maxCompleteItemCount", 50),
      timeout: getConfig("timeout", 500),
      minTriggerInputLength: getConfig("minTriggerInputLength", 1),
      snippetIndicator: getConfig("snippetIndicator", "~"),
      fixInsertedWord: getConfig("fixInsertedWord", true),
      localityBonus: getConfig("localityBonus", true),
      highPrioritySourceLimit: getConfig("highPrioritySourceLimit", null),
      lowPrioritySourceLimit: getConfig("lowPrioritySourceLimit", null),
      ignoreRegexps: getConfig("ignoreRegexps", []),
      asciiMatch: getConfig("asciiMatch", true),
      asciiCharactersOnly: getConfig("asciiCharactersOnly", false),
      reversePumAboveCursor: getConfig("reversePumAboveCursor", false)
    });
  }
  async startCompletion(option, sourceList) {
    let doc = workspace_default.getAttachedDocument(option.bufnr);
    option.filetype = doc.filetype;
    logger107.debug("trigger completion with", option);
    this.stop(true);
    this.pretext = byteSlice(option.line, 0, option.colnr - 1);
    sourceList = sourceList ?? getSources(option);
    if (!sourceList || sourceList.length === 0)
      return;
    let complete = this.complete = new Complete(option, doc, this.config, sourceList, this.nvim);
    this._activated = true;
    events_default.completing = true;
    complete.onDidRefresh(async () => {
      if (this.triggerTimer != null) {
        clearTimeout(this.triggerTimer);
      }
      if (complete.isEmpty) {
        this.stop(false);
        return;
      }
      if (this.inserted)
        return;
      await this.filterResults();
    });
    let shouldStop2 = await complete.doComplete();
    if (shouldStop2)
      this.stop(false);
  }
  showCompletion(items, search) {
    let { option } = this;
    if (!option)
      return;
    if (items.length == 0) {
      this.stop(true);
    } else {
      this.activeItems = items;
      this.pum.show(items, search, option);
    }
  }
  async onTextChangedP(bufnr, info) {
    if (this.option && bufnr === this.option.bufnr) {
      this.pretext = info.pre;
    }
  }
  async onTextChangedI(bufnr, info) {
    if (!workspace_default.isAttached(bufnr))
      return;
    let { option } = this;
    if (!info.insertChar && option) {
      let pre = byteSlice(option.line, 0, option.col);
      if (this.selectedItem) {
        if (pre + this.popupEvent.word == info.pre) {
          this.pretext = info.pre;
          return;
        }
      } else if (pre + this.pum.search == info.pre) {
        return;
      }
    }
    if (option && info.pre.match(/^\s*/)[0] !== option.line.match(/^\s*/)[0]) {
      await this.triggerCompletion(this.document, info);
      return;
    }
    if (option && shouldStop(bufnr, this.pretext, info, option)) {
      this.stop(true);
      if (!info.insertChar)
        return;
    }
    if (info.pre === this.pretext)
      return;
    if (this.triggerTimer)
      clearTimeout(this.triggerTimer);
    let pretext = this.pretext = info.pre;
    let doc = workspace_default.getDocument(bufnr);
    if (info.insertChar && this.config.acceptSuggestionOnCommitCharacter && this.selectedItem) {
      let last = pretext.slice(-1);
      let resolvedItem = this.selectedItem;
      if (sources_default.shouldCommit(resolvedItem, last)) {
        logger107.debug("commit by commit character.");
        let { linenr, col, line, colnr } = this.option;
        this.stop(true);
        let { word } = resolvedItem;
        let newLine = `${line.slice(0, col)}${word}${info.insertChar}${line.slice(colnr - 1)}`;
        await this.nvim.call("coc#util#setline", [linenr, newLine]);
        let curcol = col + word.length + 2;
        await this.nvim.call("cursor", [linenr, curcol]);
        await doc.patchChange();
        return;
      }
    }
    if (info.insertChar && !isWord(info.insertChar)) {
      let disabled = doc.getVar("disabled_sources", []);
      let triggerSources = sources_default.getTriggerSources(pretext, doc.filetype, doc.uri, disabled);
      if (triggerSources.length > 0) {
        await this.triggerCompletion(doc, info, triggerSources);
        return;
      }
    }
    if (!this.complete) {
      if (!info.insertChar)
        return;
      await this.triggerCompletion(doc, info);
      return;
    }
    if (info.insertChar && this.complete.isEmpty) {
      this.triggerTimer = setTimeout(async () => {
        await this.triggerCompletion(doc, info);
      }, 200);
      return;
    }
    await this.filterResults();
  }
  async triggerCompletion(doc, info, sources) {
    let { minTriggerInputLength, asciiCharactersOnly, autoTrigger } = this.config;
    if (autoTrigger === "none")
      return false;
    let { pre } = info;
    if (!sources) {
      let shouldTrigger = this.shouldTrigger(doc, pre);
      if (!shouldTrigger)
        return false;
    }
    let input = getInput(doc, pre, asciiCharactersOnly);
    let option = {
      input,
      line: info.line,
      filetype: doc.filetype,
      linenr: info.lnum,
      col: info.col - 1 - byteLength(input),
      colnr: info.col,
      bufnr: doc.bufnr,
      word: input + getPrependWord(doc, info.line.slice(pre.length)),
      changedtick: info.changedtick,
      indentkeys: doc.indentkeys,
      synname: "",
      filepath: doc.schema === "file" ? URI2.parse(doc.uri).fsPath : "",
      triggerCharacter: pre.length ? pre.slice(-1) : void 0
    };
    if (sources == null && input.length < minTriggerInputLength) {
      logger107.warn(`Suggest not triggered with input "${input}", minimal trigger input length: ${minTriggerInputLength}`);
      return false;
    }
    if (this.config.ignoreRegexps.length > 0 && option.input.length > 0) {
      const ignore = this.config.ignoreRegexps.some((regexp) => {
        if (new RegExp(regexp).test(option.input)) {
          logger107.warn(`Suggest disabled by ignore regexp: ${regexp}`);
          return true;
        }
      });
      if (ignore)
        return false;
    }
    await this.startCompletion(option, sources);
    return true;
  }
  stop(close, kind = "", pretext) {
    var _a;
    if (!this._activated)
      return;
    let inserted = kind === "confirm" || ((_a = this.popupEvent) == null ? void 0 : _a.inserted) && kind != "cancel";
    this._activated = false;
    pretext = pretext ?? this.pretext;
    let doc = this.document;
    let input = this.complete.input;
    let option = this.complete.option;
    let item = this.selectedItem;
    events_default.completing = false;
    this.cancel();
    let indent = false;
    void events_default.fire("CompleteDone", [toCompleteDoneItem(item)]);
    if (item && inserted) {
      this.mru.add(input, item);
      indent = pretext && shouldIndent(option.indentkeys, pretext);
    }
    if (close)
      this.nvim.call("coc#pum#_close", [], true);
    if (!doc || !doc.attached)
      return;
    doc._forceSync();
    if (kind == "confirm" && item) {
      void this.confirmCompletion(item, option).then(() => {
        if (indent)
          this.nvim.call("coc#complete_indent", [], true);
      });
    }
  }
  async confirmCompletion(item, option) {
    let source = new import_vscode_languageserver_protocol103.CancellationTokenSource();
    let { token } = source;
    await this.floating.doCompleteResolve(item, option, source);
    if (token.isCancellationRequested)
      return;
    await this.doCompleteDone(item, option);
  }
  async doCompleteDone(item, opt) {
    let source = sources_default.getSource(item.source);
    if (source && typeof source.onCompleteDone === "function") {
      await Promise.resolve(source.onCompleteDone(item, opt));
    }
  }
  async onInsertEnter(bufnr) {
    if (!this.config.triggerAfterInsertEnter || this.config.autoTrigger !== "always")
      return;
    if (!workspace_default.isAttached(bufnr))
      return;
    let change = await this.nvim.call("coc#util#change_info");
    change.pre = byteSlice(change.line, 0, change.col - 1);
    if (!change.pre)
      return;
    let doc = workspace_default.getDocument(bufnr);
    await this.triggerCompletion(doc, change);
  }
  shouldTrigger(doc, pre) {
    let { autoTrigger } = this.config;
    if (autoTrigger == "none")
      return false;
    if (sources_default.shouldTrigger(pre, doc.filetype, doc.uri))
      return true;
    if (autoTrigger !== "always")
      return false;
    return true;
  }
  getResumeInput() {
    let { option, pretext, document: document2 } = this;
    if (!option || !document2)
      return null;
    let buf = Buffer.from(pretext, "utf8");
    if (buf.length < option.colnr - 1)
      return null;
    let pre = byteSlice(option.line, 0, option.colnr - 1);
    if (!pretext.startsWith(pre))
      return null;
    let remain = pretext.slice(pre.length);
    if (remain.includes(" "))
      return null;
    return buf.slice(option.col).toString("utf8");
  }
  async filterResults() {
    let { complete } = this;
    let search = this.getResumeInput();
    if (search == null) {
      this.stop(true);
      return;
    }
    let items = await complete.filterResults(search);
    if (items === void 0)
      return;
    if (items.length == 0) {
      if (!complete.isCompleting)
        this.stop(true);
      return;
    }
    this.showCompletion(items, search);
  }
  cancel() {
    if (this.complete != null) {
      this.complete.dispose();
      this.complete = null;
    }
    if (this.triggerTimer != null) {
      clearTimeout(this.triggerTimer);
      this.triggerTimer = null;
    }
    this.floating.cancel();
    this.pretext = void 0;
    this.activeItems = void 0;
    this.popupEvent = void 0;
  }
  dispose() {
    disposeAll(this.disposables);
  }
};
var completion_default = new Completion();

// src/plugin.ts
init_channels();

// src/cursors/index.ts
var import_vscode_languageserver_protocol106 = __toESM(require_main2());
init_position();
init_window();
init_workspace();

// src/cursors/session.ts
var import_fast_diff3 = __toESM(require_diff());
var import_vscode_languageserver_protocol105 = __toESM(require_main2());
init_main3();
init_util();
init_position();
init_textedit();
init_window();
init_workspace();

// src/cursors/textRange.ts
init_main();
init_position();
init_textedit();

// src/cursors/util.ts
var import_vscode_languageserver_protocol104 = __toESM(require_main2());
init_object();
init_textedit();
function splitRange(doc, range2) {
  let splited = [];
  for (let i = range2.start.line; i <= range2.end.line; i++) {
    let curr = doc.getline(i) || "";
    let sc = i == range2.start.line ? range2.start.character : 0;
    let ec = i == range2.end.line ? range2.end.character : curr.length;
    if (sc == ec)
      continue;
    splited.push(import_vscode_languageserver_protocol104.Range.create(i, sc, i, ec));
  }
  return splited;
}
function getVisualRanges(doc, range2) {
  let { start, end } = getWellformedRange2(range2);
  let sc = start.character < end.character ? start.character : end.character;
  let ec = start.character < end.character ? end.character : start.character;
  let ranges = [];
  for (let i = start.line; i <= end.line; i++) {
    let line = doc.getline(i);
    ranges.push(import_vscode_languageserver_protocol104.Range.create(i, sc, i, Math.min(line.length, ec)));
  }
  return ranges;
}
function isSurrondChange(change) {
  return Array.isArray(change["prepend"]) && Array.isArray(change["append"]);
}
function getDelta(change) {
  if (isSurrondChange(change)) {
    return change.append[1].length + change.prepend[1].length - change.append[0] - change.prepend[0];
  }
  return change.insert.length - change.remove;
}
function getChange(r, range2, newText) {
  let text = r.text;
  if (equals(r.range, range2)) {
    let idx = text.indexOf(newText);
    if (idx !== -1) {
      let prepend = [idx, ""];
      let append = [text.length - newText.length - idx, ""];
      return { prepend, append };
    }
    idx = newText.indexOf(text);
    if (idx !== -1) {
      let prepend = [0, newText.slice(0, idx)];
      let append = [0, newText.slice(-(newText.length - text.length - idx))];
      return { prepend, append };
    }
  }
  if (equals(r.range.end, range2.end)) {
    let remove2 = range2.end.character - range2.start.character;
    return { offset: remove2, remove: remove2, insert: newText, fromEnd: true };
  }
  let remove = range2.end.character - range2.start.character;
  let offset = range2.start.character - r.range.start.character;
  return { offset, remove, insert: newText };
}
function getBeforeCount(textRange, ranges, exclude) {
  let n = 0;
  for (let idx = 0; idx < ranges.length; idx++) {
    const r = ranges[idx];
    if (r.position.line < textRange.position.line || r === exclude)
      continue;
    if (r.isBefore(textRange)) {
      n++;
      continue;
    }
    break;
  }
  return n;
}

// src/cursors/textRange.ts
var logger108 = require_logger2()("cursors-range");
var TextRange = class {
  constructor(line, character, text) {
    this.start = Position.create(line, character);
    this._text = text;
    this.end = getEnd(this.start, this._text);
  }
  get position() {
    return this.start;
  }
  get line() {
    return this.start.line;
  }
  get text() {
    return this._text;
  }
  get range() {
    return Range.create(this.start, this.end);
  }
  get textEdit() {
    return {
      range: this.range,
      newText: this.text
    };
  }
  applyChange(change) {
    if (isSurrondChange(change)) {
      this.applySurrondChange(change);
    } else {
      this.applyTextChange(change);
    }
  }
  applySurrondChange(change) {
    let { prepend, append } = change;
    let len = this._text.length;
    let text = this._text.substring(prepend[0], len - append[0]);
    this._text = `${prepend[1]}${text}${append[1]}`;
  }
  applyTextChange(change) {
    let { text } = this;
    let { offset, remove, fromEnd, insert } = change;
    if (fromEnd)
      offset = -offset;
    let pre = text.slice(0, fromEnd && offset == 0 ? text.length : offset);
    let after = text.slice(pre.length);
    if (remove)
      after = after.slice(remove);
    this._text = `${pre}${insert || ""}${after}`;
  }
  move(delta) {
    if (delta != 0) {
      let { line, character } = this.start;
      this.start = Position.create(line, character + delta);
    }
    this.end = getEnd(this.start, this._text);
  }
  adjustFromEdit(edit2) {
    let changed = getChangedPosition(this.start, edit2);
    if (changed.line || changed.character) {
      let { line, character } = this.start;
      this.start = Position.create(line + changed.line, character + changed.character);
      this.end = getEnd(this.start, this._text);
    }
    return changed.character;
  }
  isBefore(range2) {
    let { position } = range2;
    let { line, character } = this.start;
    return position.line == line && position.character > character;
  }
};

// src/cursors/session.ts
var logger109 = require_logger2()("cursors-session");
var CursorSession = class {
  constructor(nvim, doc) {
    this.nvim = nvim;
    this.doc = doc;
    this._onDidCancel = new import_vscode_languageserver_protocol105.Emitter();
    this._onDidUpdate = new import_vscode_languageserver_protocol105.Emitter();
    this.onDidCancel = this._onDidCancel.event;
    this.onDidUpdate = this._onDidUpdate.event;
    this.disposables = [];
    this.ranges = [];
    this.activated = true;
    this.changing = false;
    doc.buffer.setVar("coc_cursors_activated", 1, true);
    this.loadConfig();
    let { cancelKey, nextKey, previousKey } = this.config;
    this.disposables.push(workspace_default.registerLocalKeymap("n", cancelKey, () => {
      this.cancel();
    }));
    this.disposables.push(workspace_default.registerLocalKeymap("n", nextKey, async () => {
      let ranges = this.ranges.map((o) => o.range);
      let curr = await window_default.getCursorPosition();
      for (let r of ranges) {
        if (comparePosition(r.start, curr) > 0) {
          await window_default.moveTo(r.start);
          return;
        }
      }
      let wrap = this.config.wrapscan;
      if (ranges.length && wrap)
        await window_default.moveTo(ranges[0].start);
    }));
    this.disposables.push(workspace_default.registerLocalKeymap("n", previousKey, async () => {
      let ranges = this.ranges.map((o) => o.range);
      let curr = await window_default.getCursorPosition();
      for (let i = ranges.length - 1; i >= 0; i--) {
        let r = ranges[i];
        if (comparePosition(r.end, curr) < 0) {
          await window_default.moveTo(r.start);
          return;
        }
      }
      let wrap = this.config.wrapscan;
      if (ranges.length && wrap)
        await window_default.moveTo(ranges[ranges.length - 1].start);
    }));
    this.doc.onDocumentChange(async (e) => {
      await this.onChange(e);
      if (this.activated && !this.changing) {
        this._onDidUpdate.fire();
      }
    }, this, this.disposables);
  }
  loadConfig() {
    let config = workspace_default.getConfiguration("cursors", this.doc.uri);
    this.config = {
      nextKey: config.get("nextKey", "<C-n>"),
      previousKey: config.get("previousKey", "<C-p>"),
      cancelKey: config.get("cancelKey", "<esc>"),
      wrapscan: config.get("wrapscan", true)
    };
  }
  addRange(range2) {
    let { ranges } = this;
    let idx = ranges.findIndex((o) => rangeIntersect(o.range, range2));
    if (idx !== -1) {
      ranges.splice(idx, 1);
    } else {
      this.createRange(range2);
      ranges.sort((a, b) => comparePosition(a.range.start, b.range.start));
    }
    if (this.ranges.length == 0) {
      this.cancel();
    } else {
      this.doHighlights();
    }
  }
  addRanges(ranges) {
    this.doc._forceSync();
    this.ranges = this.ranges.filter((r) => {
      return !ranges.some((range2) => rangeOverlap(range2, r.range));
    });
    for (let range2 of ranges) {
      this.createRange(range2);
    }
    this.ranges.sort((a, b) => comparePosition(a.range.start, b.range.start));
    this.doHighlights();
    return true;
  }
  createRange(range2) {
    let { textDocument } = this.doc;
    let { line, character } = range2.start;
    let text = textDocument.getText(range2);
    this.ranges.push(new TextRange(line, character, text));
  }
  async onChange(e) {
    if (!this.activated || this.changing)
      return;
    if (e.contentChanges.length === 0) {
      this.doHighlights();
      return;
    }
    let change = e.contentChanges[0];
    let { text, range: range2 } = change;
    let affected = this.ranges.filter((r) => {
      if (!rangeIntersect(range2, r.range))
        return false;
      if (rangeAdjacent(range2, r.range)) {
        if (text.includes("\n") || !emptyRange(range2))
          return false;
      }
      return true;
    });
    if (emptyRange(range2) && affected.length > 0) {
      affected = affected.slice(0, 1);
    }
    if (affected.length == 0) {
      logger109.debug("no affected ranges");
      this.ranges.forEach((r) => {
        r.adjustFromEdit({ range: range2, newText: text });
      });
      this.doHighlights();
    } else if (affected.length == 1 && rangeInRange(range2, affected[0].range)) {
      logger109.debug("affected single range");
      if (text.includes("\n")) {
        this.cancel();
        return;
      }
      await this.applySingleEdit(affected[0], { range: range2, newText: text });
    } else if (!text.length || !this.validChange(range2, text)) {
      logger109.debug("filter affected ranges.");
      let ranges = this.ranges.filter((r) => !affected.includes(r));
      if (ranges.length > 0) {
        this.ranges = ranges;
        ranges.forEach((r) => {
          r.adjustFromEdit({ range: range2, newText: text });
        });
        this.doHighlights();
      } else {
        this.cancel();
      }
    } else {
      logger109.debug("Check undo & redo");
      let first = this.ranges[0];
      let last = this.ranges[this.ranges.length - 1];
      let originalLines = e.originalLines.slice(first.line, last.line + 1);
      let newLines = this.doc.textDocument.lines.slice(first.line, last.line + 1);
      this.applyComposedEdit(originalLines, newLines);
    }
  }
  validChange(range2, text) {
    if (lineCountChange(import_vscode_languageserver_protocol105.TextEdit.replace(range2, text)) != 0)
      return false;
    if (!rangeInRange(range2, this.range))
      return false;
    let first = this.ranges[0];
    let last = this.ranges[this.ranges.length - 1];
    if (range2.start.line != first.position.line || range2.end.line != last.position.line)
      return false;
    return true;
  }
  get range() {
    let first = this.ranges[0];
    let last = this.ranges[this.ranges.length - 1];
    return import_vscode_languageserver_protocol105.Range.create(first.position, last.range.end);
  }
  doHighlights() {
    let { nvim, ranges, doc } = this;
    let buffer = doc.buffer;
    let items = [];
    ranges.forEach((r) => {
      doc.addHighlights(items, "CocCursorRange", r.range, {
        combine: false,
        start_incl: true,
        end_incl: true
      });
    });
    items.sort((a, b) => {
      if (a.lnum != b.lnum)
        return a.lnum - b.lnum;
      if (a.colStart != b.colStart)
        return a.colStart - b.colStart;
      return 0;
    });
    buffer.updateHighlights("cursors", items, { priority: 4096 });
    nvim.redrawVim();
  }
  get currentRanges() {
    return this.ranges.map((r) => r.range);
  }
  cancel() {
    if (!this.activated)
      return;
    logger109.debug("cursors cancel");
    let { nvim, doc } = this;
    let buffer = doc.buffer;
    this.activated = false;
    this.ranges = [];
    nvim.pauseNotification();
    buffer.clearNamespace("cursors");
    buffer.setVar("coc_cursors_activated", 0, true);
    nvim.resumeNotification(true, true);
    this._onDidUpdate.fire();
    this._onDidCancel.fire();
  }
  dispose() {
    if (!this.doc)
      return;
    this._onDidCancel.dispose();
    this._onDidUpdate.dispose();
    disposeAll(this.disposables);
    this.ranges = [];
    this.doc = null;
  }
  async applySingleEdit(textRange, edit2) {
    let { doc, ranges } = this;
    let after = ranges.filter((r) => r !== textRange && r.position.line == textRange.position.line);
    after.forEach((r) => r.adjustFromEdit(edit2));
    let change = getChange(textRange, edit2.range, edit2.newText);
    let delta = getDelta(change);
    ranges.forEach((r) => r.applyChange(change));
    let edits = ranges.filter((r) => r !== textRange).map((o) => o.textEdit);
    this.changing = true;
    await doc.applyEdits(edits, true, true);
    this.changing = false;
    if (delta != 0) {
      for (let r of ranges) {
        let n = getBeforeCount(r, this.ranges, textRange);
        r.move(n * delta);
      }
    }
    this.doHighlights();
  }
  applyComposedEdit(originalLines, newLines) {
    let diffs = (0, import_fast_diff3.default)(originalLines[0], newLines[0]);
    let first = this.ranges[0];
    let s = first.position.character;
    let firstLine = first.position.line;
    let len = first.text.length;
    let diff = diffs[0];
    if (s > 0 && (diff[0] != import_fast_diff3.default.EQUAL || !diff[1].startsWith(originalLines[0].slice(0, s)))) {
      this.cancel();
      return false;
    }
    let used = 0;
    let invalid = false;
    let changes = [];
    for (let i = 0; i < diffs.length; i++) {
      let [kind, text] = diffs[i];
      if (i == 0 && s > 0) {
        text = text.slice(s);
      }
      if (kind == import_fast_diff3.default.EQUAL) {
        used += text.length;
        if (used > len)
          break;
      } else if (kind == import_fast_diff3.default.DELETE) {
        let offset = used;
        used += text.length;
        if (used > len) {
          invalid = true;
          break;
        }
        changes.push({ offset, remove: text });
      } else {
        let prev = diffs[i - 1];
        if (prev && prev[0] == import_fast_diff3.default.DELETE) {
          changes[changes.length - 1].add = text;
        } else {
          changes.push({ offset: used, add: text });
        }
      }
    }
    if (invalid || !changes.length) {
      this.cancel();
      return false;
    }
    let doc = TextDocument2.create("file:///1", "", 0, originalLines.join("\n"));
    let change;
    if (changes.length == 1) {
      change = {
        offset: changes[0].offset,
        remove: changes[0].remove ? changes[0].remove.length : 0,
        insert: changes[0].add ?? ""
      };
    } else if (surrondChanges(changes, len)) {
      change = {
        prepend: [changes[0].remove ? changes[0].remove.length : 0, changes[0].add ?? ""],
        append: [changes[1].remove ? changes[1].remove.length : 0, changes[1].add ?? ""]
      };
    } else {
      let text = first.text;
      let oldText = "";
      let newText = "";
      let offset = changes[0].offset;
      for (let c of changes) {
        if (c.offset > offset + oldText.length) {
          let s2 = text.slice(offset + oldText.length, c.offset);
          oldText += s2;
          newText += s2;
        }
        if (c.add) {
          newText += c.add;
        }
        if (c.remove) {
          oldText += c.remove;
        }
      }
      change = {
        offset,
        remove: oldText.length,
        insert: newText
      };
    }
    let edits = this.ranges.map((o) => {
      let line = o.position.line - firstLine;
      let { start, end } = o.range;
      let range2 = import_vscode_languageserver_protocol105.Range.create(line, start.character, line, end.character);
      o.applyChange(change);
      return import_vscode_languageserver_protocol105.TextEdit.replace(range2, o.text);
    });
    let content = TextDocument2.applyEdits(doc, edits);
    if (content !== newLines.join("\n")) {
      this.cancel();
      return false;
    }
    let delta = getDelta(change);
    if (delta != 0) {
      for (let r of this.ranges) {
        let n = getBeforeCount(r, this.ranges);
        r.move(n * delta);
      }
    }
    this.doHighlights();
    return true;
  }
};
function surrondChanges(changes, len) {
  if (changes.length != 2 || changes[0].offset != 0)
    return false;
  let end = changes[1].offset + (changes[1].remove ? changes[1].remove.length : 0);
  if (end !== len)
    return false;
  return true;
}

// src/cursors/index.ts
var logger110 = require_logger2()("cursors");
var Cursors = class {
  constructor(nvim) {
    this.nvim = nvim;
    this.sessionsMap = /* @__PURE__ */ new Map();
    this.disposables = [];
    workspace_default.onDidCloseTextDocument((e) => {
      let session = this.getSession(e.bufnr);
      if (!session)
        return;
      this.sessionsMap.delete(e.bufnr);
      session.cancel();
    }, null, this.disposables);
  }
  cancel(uri) {
    let doc = workspace_default.getDocument(uri);
    if (!doc)
      return;
    let session = this.getSession(doc.bufnr);
    if (session)
      session.cancel();
  }
  getSession(bufnr) {
    return this.sessionsMap.get(bufnr);
  }
  async isActivated() {
    let bufnr = await this.nvim.call("bufnr", ["%"]);
    return this.sessionsMap.get(bufnr) != null;
  }
  async select(bufnr, kind, mode) {
    let doc = workspace_default.getAttachedDocument(bufnr);
    let { nvim } = this;
    let session = this.createSession(doc);
    let pos = await window_default.getCursorPosition();
    let range2;
    if (kind == "operator") {
      await nvim.command(`normal! ${mode == "line" ? `'[` : "`["}`);
      let start = await window_default.getCursorPosition();
      await nvim.command(`normal! ${mode == "line" ? `']` : "`]"}`);
      let end = await window_default.getCursorPosition();
      await window_default.moveTo(pos);
      let relative = comparePosition(start, end);
      if (relative == 0)
        return;
      if (relative >= 0)
        [start, end] = [end, start];
      let line = doc.getline(end.line);
      if (end.character < line.length) {
        end.character = end.character + 1;
      }
      let ranges = splitRange(doc, import_vscode_languageserver_protocol106.Range.create(start, end));
      session.addRanges(ranges);
    } else if (kind == "word") {
      range2 = doc.getWordRangeAtPosition(pos);
      if (!range2) {
        let line = doc.getline(pos.line);
        if (pos.character == line.length) {
          range2 = import_vscode_languageserver_protocol106.Range.create(pos.line, Math.max(0, line.length - 1), pos.line, line.length);
        } else {
          range2 = import_vscode_languageserver_protocol106.Range.create(pos.line, pos.character, pos.line, pos.character + 1);
        }
      }
      session.addRange(range2);
      await nvim.command(`silent! call repeat#set("\\<Plug>(coc-cursors-${kind})", -1)`);
    } else if (kind == "position") {
      let line = doc.getline(pos.line);
      if (pos.character >= line.length) {
        range2 = import_vscode_languageserver_protocol106.Range.create(pos.line, line.length - 1, pos.line, line.length);
      } else {
        range2 = import_vscode_languageserver_protocol106.Range.create(pos.line, pos.character, pos.line, pos.character + 1);
      }
      session.addRange(range2);
      await nvim.command(`silent! call repeat#set("\\<Plug>(coc-cursors-${kind})", -1)`);
    } else if (kind == "range") {
      await nvim.call("eval", 'feedkeys("\\<esc>", "in")');
      let range3 = await window_default.getSelectedRange(mode);
      if (!range3)
        return;
      let ranges = mode == "" ? getVisualRanges(doc, range3) : splitRange(doc, range3);
      for (let r of ranges) {
        session.addRange(r);
      }
    } else {
      throw new Error(`select kind "${kind}" not supported`);
    }
  }
  createSession(doc) {
    let { bufnr } = doc;
    let session = this.getSession(bufnr);
    if (session)
      return session;
    session = new CursorSession(this.nvim, doc);
    this.sessionsMap.set(bufnr, session);
    session.onDidCancel(() => {
      session.dispose();
      this.sessionsMap.delete(bufnr);
    });
    return session;
  }
  async addRanges(ranges) {
    let { nvim } = this;
    let bufnr = await nvim.call("bufnr", ["%"]);
    let doc = workspace_default.getAttachedDocument(bufnr);
    let session = this.createSession(doc);
    return session.addRanges(ranges);
  }
  reset() {
    for (let session of this.sessionsMap.values()) {
      session.cancel();
    }
    this.sessionsMap.clear();
  }
};

// src/plugin.ts
init_manager4();
init_events();
init_extensions3();

// src/handler/index.ts
var import_vscode_languageserver_protocol130 = __toESM(require_main2());
init_events();
init_languages();
init_util();
init_window();
init_workspace();

// src/handler/codeActions.ts
var import_vscode_languageserver_protocol107 = __toESM(require_main2());
init_commands2();
init_manager4();
init_languages();
init_window();
init_workspace();
var logger111 = require_logger2()("handler-codeActions");
var CodeActions = class {
  constructor(nvim, handler) {
    this.nvim = nvim;
    this.handler = handler;
    handler.addDisposable(commands_default.registerCommand("editor.action.organizeImport", async (bufnr) => {
      await this.organizeImport(bufnr);
    }));
    commands_default.titles.set("editor.action.organizeImport", "run organize import code action.");
  }
  async codeActionRange(start, end, only) {
    let { doc } = await this.handler.getCurrentState();
    await doc.synchronize();
    let line = doc.getline(end - 1);
    let range2 = import_vscode_languageserver_protocol107.Range.create(start - 1, 0, end - 1, line.length);
    let codeActions = await this.getCodeActions(doc, range2, only ? [only] : null);
    codeActions = codeActions.filter((o) => !o.disabled);
    if (!codeActions || codeActions.length == 0) {
      window_default.showMessage(`No${only ? " " + only : ""} code action available`, "warning");
      return;
    }
    let idx = await window_default.showMenuPicker(codeActions.map((o) => o.title), "Choose action");
    let action = codeActions[idx];
    if (action)
      await this.applyCodeAction(action);
  }
  async organizeImport(bufnr) {
    let { doc } = await this.handler.getCurrentState();
    if (bufnr && doc.bufnr != bufnr)
      return;
    await doc.synchronize();
    let actions = await this.getCodeActions(doc, void 0, [import_vscode_languageserver_protocol107.CodeActionKind.SourceOrganizeImports]);
    if (actions && actions.length) {
      await this.applyCodeAction(actions[0]);
      return;
    }
    throw new Error("Organize import action not found.");
  }
  async getCodeActions(doc, range2, only) {
    range2 = range2 || import_vscode_languageserver_protocol107.Range.create(0, 0, doc.lineCount, 0);
    let diagnostics = manager_default.getDiagnosticsInRange(doc.textDocument, range2);
    let context = { diagnostics };
    if (only && Array.isArray(only))
      context.only = only;
    let codeActions = await this.handler.withRequestToken("code action", (token) => {
      return languages_default.getCodeActions(doc.textDocument, range2, context, token);
    });
    if (!codeActions || codeActions.length == 0)
      return [];
    codeActions.sort((a, b) => {
      if (a.isPreferred && !b.isPreferred)
        return -1;
      if (b.isPreferred && !a.isPreferred)
        return 1;
      if (a.disabled && !b.disabled)
        return 1;
      if (b.disabled && !a.disabled)
        return -1;
      return 0;
    });
    return codeActions;
  }
  get floatActions() {
    if (!workspace_default.floatSupported)
      return false;
    let config = workspace_default.getConfiguration("coc.preferences");
    return config.get("floatActions", true);
  }
  async doCodeAction(mode, only) {
    let { doc } = await this.handler.getCurrentState();
    let range2;
    if (mode)
      range2 = await window_default.getSelectedRange(mode);
    await doc.synchronize();
    let codeActions = await this.getCodeActions(doc, range2, Array.isArray(only) ? only : null);
    if (typeof only == "string") {
      codeActions = codeActions.filter((o) => o.title == only || o.command && o.command.title == only);
    } else if (Array.isArray(only)) {
      codeActions = codeActions.filter((o) => only.some((k) => o.kind && o.kind.startsWith(k)));
    }
    if (!codeActions || codeActions.length == 0) {
      window_default.showMessage(`No${only ? " " + only : ""} code action available`, "warning");
      return;
    }
    if (only && codeActions.length == 1 && !codeActions[0].disabled) {
      await this.applyCodeAction(codeActions[0]);
      return;
    }
    if (!this.floatActions)
      codeActions = codeActions.filter((o) => !o.disabled);
    let idx = this.floatActions ? await window_default.showMenuPicker(codeActions.map((o) => {
      return { text: o.title, disabled: o.disabled };
    }), "Choose action") : await window_default.showQuickpick(codeActions.map((o) => o.title));
    let action = codeActions[idx];
    if (action)
      await this.applyCodeAction(action);
  }
  async getCurrentCodeActions(mode, only) {
    let { doc } = await this.handler.getCurrentState();
    let range2;
    if (mode)
      range2 = await window_default.getSelectedRange(mode);
    let codeActions = await this.getCodeActions(doc, range2, only);
    return codeActions.filter((o) => !o.disabled);
  }
  async doQuickfix() {
    let actions = await this.getCurrentCodeActions("currline", [import_vscode_languageserver_protocol107.CodeActionKind.QuickFix]);
    if (!actions || actions.length == 0) {
      throw new Error("No quickfix action available");
    }
    await this.applyCodeAction(actions[0]);
    this.nvim.command(`silent! call repeat#set("\\<Plug>(coc-fix-current)", -1)`, true);
  }
  async applyCodeAction(action) {
    if (action.disabled) {
      throw new Error(`Action "${action.title}" is disabled: ${action.disabled.reason}`);
    }
    if (!action.providerId) {
      throw new Error("providerId not found with codeAction");
    }
    let resolved = await this.handler.withRequestToken("resolve codeAction", (token) => {
      return languages_default.resolveCodeAction(action, token);
    });
    let { edit: edit2, command } = resolved;
    if (edit2)
      await workspace_default.applyEdit(edit2);
    if (command)
      await commands_default.execute(command);
  }
};

// src/handler/codelens/index.ts
init_events();
init_util();
init_workspace();

// src/handler/codelens/buffer.ts
var import_debounce11 = __toESM(require_debounce());
var import_vscode_languageserver_protocol108 = __toESM(require_main2());
init_commands2();
init_languages();
init_window();
init_workspace();
var logger112 = require_logger2()("codelens-buffer");
var CodeLensBuffer = class {
  constructor(nvim, document2, config) {
    this.nvim = nvim;
    this.document = document2;
    this.config = config;
    this.resolveCodeLens = (0, import_debounce11.default)(() => {
      void this._resolveCodeLenses();
    }, global.__TEST__ ? 20 : 200);
    this.debounceFetch = (0, import_debounce11.default)(() => {
      void this.fetchCodeLenses();
    }, global.__TEST__ ? 20 : 100);
    this.debounceFetch();
  }
  get bufnr() {
    return this.document.bufnr;
  }
  onChange(e) {
    if (e.contentChanges.length === 0 && this.codeLenses != null) {
      void this._resolveCodeLenses();
    } else {
      this.cancel();
      this.debounceFetch();
    }
  }
  get currentCodeLens() {
    var _a;
    return (_a = this.codeLenses) == null ? void 0 : _a.codeLenses;
  }
  get enabled() {
    var _a;
    if (!((_a = this.document) == null ? void 0 : _a.attached))
      return false;
    return this.config.enabled && languages_default.hasProvider("codeLens", this.document.textDocument);
  }
  async forceFetch() {
    if (!this.enabled)
      return;
    await this.document.synchronize();
    this.cancel();
    await this.fetchCodeLenses();
  }
  async fetchCodeLenses() {
    var _a;
    if (!this.enabled)
      return;
    let noFetch = ((_a = this.codeLenses) == null ? void 0 : _a.version) == this.document.version;
    if (!noFetch) {
      let { textDocument } = this.document;
      let version2 = textDocument.version;
      let tokenSource = this.tokenSource = new import_vscode_languageserver_protocol108.CancellationTokenSource();
      let token = tokenSource.token;
      if (token.isCancellationRequested)
        return;
      let codeLenses = await languages_default.getCodeLens(textDocument, token);
      codeLenses = Array.isArray(codeLenses) ? codeLenses.filter((o) => o != null) : [];
      this.tokenSource = void 0;
      if (token.isCancellationRequested || codeLenses.length == 0)
        return;
      this.codeLenses = { version: version2, codeLenses };
    }
    await this._resolveCodeLenses();
  }
  async _resolveCodeLenses() {
    if (!this.enabled || !this.codeLenses || this.isChanged)
      return;
    let { codeLenses } = this.codeLenses;
    let [bufnr, start, end, total] = await this.nvim.eval(`[bufnr('%'),line('w0'),line('w$'),line('$')]`);
    if (this.isChanged || bufnr != this.bufnr)
      return;
    if (this.resolveTokenSource)
      this.resolveTokenSource.cancel();
    codeLenses = codeLenses.filter((o) => {
      let lnum = o.range.start.line + 1;
      return lnum >= start && lnum <= end;
    });
    if (codeLenses.length) {
      let tokenSource = this.resolveTokenSource = new import_vscode_languageserver_protocol108.CancellationTokenSource();
      let token = tokenSource.token;
      await Promise.all(codeLenses.map((codeLens) => languages_default.resolveCodeLens(codeLens, token)));
      this.resolveTokenSource = void 0;
      if (token.isCancellationRequested || this.isChanged)
        return;
    }
    if (end == total)
      end = -1;
    this.nvim.pauseNotification();
    this.clear(start - 1, end);
    this.setVirtualText(codeLenses);
    this.nvim.resumeNotification(false, true);
  }
  get isChanged() {
    if (!this.codeLenses || this.document.dirty)
      return true;
    let { version: version2 } = this.codeLenses;
    return this.document.textDocument.version !== version2;
  }
  setVirtualText(codeLenses) {
    let { document: document2 } = this;
    if (!document2 || !codeLenses.length)
      return;
    let list2 = /* @__PURE__ */ new Map();
    let { position } = this.config;
    for (let codeLens of codeLenses) {
      let { range: range2, command } = codeLens;
      if (!command)
        continue;
      let { line } = range2.start;
      if (list2.has(line)) {
        list2.get(line).push(codeLens);
      } else {
        list2.set(line, [codeLens]);
      }
    }
    for (let lnum of list2.keys()) {
      let codeLenses2 = list2.get(lnum);
      let commands = codeLenses2.map((codeLens) => codeLens.command);
      commands = commands.filter((c) => c && c.title);
      let chunks = [];
      let n_commands = commands.length;
      for (let i = 0; i < n_commands; i++) {
        let c = commands[i];
        chunks.push([c.title.replace(/(\r\n|\r|\n|\s)+/g, " "), "CocCodeLens"]);
        if (i != n_commands - 1) {
          chunks.push([this.config.subseparator, "CocCodeLens"]);
        }
      }
      if (this.config.separator) {
        chunks.unshift([`${this.config.separator} `, "CocCodeLens"]);
      }
      let { srcId: srcId2 } = this.config;
      if (workspace_default.has("nvim-0.6.0")) {
        let buf = this.document.buffer;
        let line = document2.getline(lnum);
        if (position == "top") {
          let indent = line.match(/^\s*/)[0];
          if (indent.length > 0)
            chunks.unshift([indent, "Normal"]);
          buf.setExtMark(srcId2, lnum, 0, {
            virt_lines: [chunks],
            virt_lines_above: true
          });
        } else {
          buf.setExtMark(srcId2, lnum, 0, {
            hl_mode: "combine",
            virt_text: chunks,
            virt_text_pos: position
          });
        }
      } else {
        this.nvim.call("nvim_buf_set_virtual_text", [this.bufnr, srcId2, lnum, chunks, {}], true);
      }
    }
  }
  clear(start = 0, end = -1) {
    let { srcId: srcId2 } = this.config;
    if (!srcId2)
      return;
    let buf = this.nvim.createBuffer(this.bufnr);
    buf.clearNamespace(srcId2, start, end);
  }
  async doAction(line) {
    var _a;
    let commands = getCommands(line, (_a = this.codeLenses) == null ? void 0 : _a.codeLenses);
    if (commands.length == 1) {
      await commands_default.execute(commands[0]);
    } else if (commands.length > 1) {
      let res = await window_default.showMenuPicker(commands.map((c) => c.title));
      if (res != -1)
        await commands_default.execute(commands[res]);
    }
  }
  cancel() {
    this.resolveCodeLens.clear();
    this.debounceFetch.clear();
    if (this.resolveTokenSource) {
      this.resolveTokenSource.cancel();
      this.resolveTokenSource.dispose();
      this.resolveTokenSource = null;
    }
    if (this.tokenSource) {
      this.tokenSource.cancel();
      this.tokenSource.dispose();
      this.tokenSource = null;
    }
  }
  dispose() {
    this.cancel();
    this.codeLenses = void 0;
  }
};
function getCommands(line, codeLenses) {
  if (!(codeLenses == null ? void 0 : codeLenses.length))
    return [];
  let commands = [];
  for (let codeLens of codeLenses) {
    let { range: range2, command } = codeLens;
    if (!command)
      continue;
    if (line == range2.start.line) {
      commands.push(command);
    }
  }
  return commands;
}

// src/handler/codelens/index.ts
var logger113 = require_logger2()("codelens");
var CodeLensManager2 = class {
  constructor(nvim) {
    this.nvim = nvim;
    this.disposables = [];
    this.setConfiguration();
    this.nvim.createNamespace("coc-codelens").then((id) => {
      this.config.srcId = id;
    }).logError();
    workspace_default.onDidChangeConfiguration(this.setConfiguration, this, this.disposables);
    this.buffers = workspace_default.registerBufferSync((doc) => {
      if (doc.buftype != "")
        return void 0;
      return new CodeLensBuffer(nvim, doc, this.config);
    });
    this.disposables.push(this.buffers);
    this.listen();
  }
  listen() {
    events_default.on("CursorMoved", (bufnr) => {
      let buf = this.buffers.getItem(bufnr);
      if (buf)
        buf.resolveCodeLens();
    }, null, this.disposables);
    events_default.on("CursorHold", async (bufnr) => {
      let buf = this.buffers.getItem(bufnr);
      if (buf)
        await buf.forceFetch();
    }, this, this.disposables);
  }
  async checkProvider() {
    for (let buf of this.buffers.items) {
      await buf.forceFetch();
    }
  }
  setConfiguration(e) {
    if (e && !e.affectsConfiguration("codeLens"))
      return;
    let config = workspace_default.getConfiguration("codeLens");
    let enable = this.nvim.hasFunction("nvim_buf_set_virtual_text") && config.get("enable", false);
    this.config = Object.assign(this.config || {}, {
      enabled: enable,
      position: config.get("position", "top"),
      separator: config.get("separator", "\u2023"),
      subseparator: config.get("subseparator", " ")
    });
  }
  async doAction() {
    let [bufnr, line] = await this.nvim.eval(`[bufnr("%"),line(".")-1]`);
    let buf = this.buffers.getItem(bufnr);
    await (buf == null ? void 0 : buf.doAction(line));
  }
  dispose() {
    disposeAll(this.disposables);
  }
};

// src/handler/colors/index.ts
var import_vscode_languageserver_protocol110 = __toESM(require_main2());
init_commands2();
init_extensions3();
init_languages();
init_util();

// src/util/color.ts
function pad(str) {
  return str.length == 1 ? `0${str}` : str;
}
function toHexString(color) {
  let c = toHexColor(color);
  return `${pad(c.red.toString(16))}${pad(c.green.toString(16))}${pad(c.blue.toString(16))}`;
}
function toHexColor(color) {
  let { red, green, blue: blue2 } = color;
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue2 * 255)
  };
}
function isDark(color) {
  let rgb = [color.red, color.green, color.blue];
  let lum = [];
  for (let i = 0; i < rgb.length; i++) {
    let chan = rgb[i];
    lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
  }
  let luma = 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
  return luma <= 0.5;
}

// src/handler/colors/index.ts
init_window();
init_workspace();

// src/handler/colors/colorBuffer.ts
var import_debounce12 = __toESM(require_debounce());
var import_vscode_languageserver_protocol109 = __toESM(require_main2());
init_languages();
init_position();
init_window();
init_workspace();
var logger114 = require_logger2()("colors-buffer");
var NAMESPACE2 = "color";
var ColorBuffer = class {
  constructor(nvim, bufnr, config, usedColors) {
    this.nvim = nvim;
    this.bufnr = bufnr;
    this.config = config;
    this.usedColors = usedColors;
    this._colors = [];
    this.highlight = (0, import_debounce12.default)(() => {
      this.doHighlight().logError();
    }, global.hasOwnProperty("__TEST__") ? 10 : 300);
    this.highlight();
  }
  get enabled() {
    let { filetypes } = this.config;
    let doc = workspace_default.getDocument(this.bufnr);
    if (!doc)
      return false;
    if (filetypes.includes("*"))
      return true;
    if (!languages_default.hasProvider("documentColor", doc.textDocument))
      return false;
    return filetypes.includes(doc.filetype);
  }
  onChange() {
    this.cancel();
    this.highlight();
  }
  get buffer() {
    return this.nvim.createBuffer(this.bufnr);
  }
  get colors() {
    return this._colors;
  }
  hasColor() {
    return this._colors.length > 0;
  }
  async doHighlight() {
    if (!this.enabled)
      return;
    let { nvim } = this;
    let doc = workspace_default.getDocument(this.bufnr);
    this.tokenSource = new import_vscode_languageserver_protocol109.CancellationTokenSource();
    let { token } = this.tokenSource;
    let colors;
    colors = await languages_default.provideDocumentColors(doc.textDocument, token);
    if (token.isCancellationRequested)
      return;
    colors = colors || [];
    colors.sort((a, b) => comparePosition(a.range.start, b.range.start));
    this._colors = colors;
    let items = [];
    colors.forEach((o) => {
      let hlGroup = getHighlightGroup2(o.color);
      doc.addHighlights(items, hlGroup, o.range, { combine: false });
    });
    let diff = await window_default.diffHighlights(this.bufnr, NAMESPACE2, items);
    if (token.isCancellationRequested || !diff)
      return;
    nvim.pauseNotification();
    this.defineColors(colors);
    nvim.resumeNotification(false, true);
    await window_default.applyDiffHighlights(this.bufnr, NAMESPACE2, this.config.highlightPriority, diff, true);
  }
  defineColors(colors) {
    for (let color of colors) {
      let hex = toHexString(color.color);
      if (!this.usedColors.has(hex)) {
        this.nvim.command(`hi BG${hex} guibg=#${hex} guifg=#${isDark(color.color) ? "ffffff" : "000000"}`, true);
        this.usedColors.add(hex);
      }
    }
  }
  hasColorAtPosition(position) {
    return this.colors.some((o) => positionInRange(position, o.range) == 0);
  }
  clearHighlight() {
    this.highlight.clear();
    this._colors = [];
    this.buffer.clearNamespace("color");
  }
  cancel() {
    if (this.tokenSource) {
      this.tokenSource.cancel();
      this.tokenSource.dispose();
      this.tokenSource = null;
    }
  }
  dispose() {
    this._colors = [];
    this.highlight.clear();
    this.cancel();
  }
};
function getHighlightGroup2(color) {
  return `BG${toHexString(color)}`;
}

// src/handler/colors/index.ts
var logger115 = require_logger2()("colors-index");
var Colors = class {
  constructor(nvim, handler) {
    this.nvim = nvim;
    this.handler = handler;
    this.disposables = [];
    this.setConfiguration();
    let usedColors = /* @__PURE__ */ new Set();
    this.highlighters = workspace_default.registerBufferSync((doc) => {
      return new ColorBuffer(this.nvim, doc.bufnr, this.config, usedColors);
    });
    extensions_default.onDidActiveExtension(() => {
      this.highlightAll();
    }, null, this.disposables);
    workspace_default.onDidChangeConfiguration(this.setConfiguration, this, this.disposables);
    this.disposables.push(commands_default.registerCommand("editor.action.pickColor", () => {
      return this.pickColor();
    }));
    commands_default.titles.set("editor.action.pickColor", "pick color from system color picker when possible.");
    this.disposables.push(commands_default.registerCommand("editor.action.colorPresentation", () => {
      return this.pickPresentation();
    }));
    commands_default.titles.set("editor.action.colorPresentation", "change color presentation.");
  }
  setConfiguration(e) {
    if (!e || e.affectsConfiguration("colors")) {
      let c = workspace_default.getConfiguration("colors");
      this.config = Object.assign(this.config || {}, {
        filetypes: c.get("filetypes", []),
        highlightPriority: c.get("highlightPriority", 1e3)
      });
    }
  }
  async pickPresentation() {
    let { doc } = await this.handler.getCurrentState();
    this.handler.checkProvier("documentColor", doc.textDocument);
    let info = await this.getColorInformation(doc.bufnr);
    if (!info)
      return window_default.showMessage("Color not found at current position", "warning");
    let tokenSource = new import_vscode_languageserver_protocol110.CancellationTokenSource();
    let presentations = await languages_default.provideColorPresentations(info, doc.textDocument, tokenSource.token);
    if (!(presentations == null ? void 0 : presentations.length))
      return;
    let res = await window_default.showMenuPicker(presentations.map((o) => o.label), "choose color:");
    if (res == -1)
      return;
    let presentation = presentations[res];
    let { textEdit, additionalTextEdits, label } = presentation;
    if (!textEdit)
      textEdit = { range: info.range, newText: label };
    await doc.applyEdits([textEdit]);
    if (additionalTextEdits) {
      await doc.applyEdits(additionalTextEdits);
    }
  }
  async pickColor() {
    let { doc } = await this.handler.getCurrentState();
    this.handler.checkProvier("documentColor", doc.textDocument);
    let info = await this.getColorInformation(doc.bufnr);
    if (!info)
      return window_default.showMessage("Color not found at current position", "warning");
    let { color } = info;
    let colorArr = [(color.red * 255).toFixed(0), (color.green * 255).toFixed(0), (color.blue * 255).toFixed(0)];
    let res = await this.nvim.call("coc#color#pick_color", [colorArr]);
    if (!res)
      return;
    let hex = toHexString({
      red: res[0] / 65535,
      green: res[1] / 65535,
      blue: res[2] / 65535,
      alpha: 1
    });
    await doc.applyEdits([{
      range: info.range,
      newText: `#${hex}`
    }]);
  }
  isEnabled(bufnr) {
    let highlighter = this.highlighters.getItem(bufnr);
    return highlighter != null && highlighter.enabled === true;
  }
  clearHighlight(bufnr) {
    let highlighter = this.highlighters.getItem(bufnr);
    if (highlighter)
      highlighter.clearHighlight();
  }
  hasColor(bufnr) {
    let highlighter = this.highlighters.getItem(bufnr);
    if (!highlighter)
      return false;
    return highlighter.hasColor();
  }
  hasColorAtPosition(bufnr, position) {
    let highlighter = this.highlighters.getItem(bufnr);
    if (!highlighter)
      return false;
    return highlighter.hasColorAtPosition(position);
  }
  highlightAll() {
    for (let buf of this.highlighters.items) {
      buf.highlight();
    }
  }
  async doHighlight(bufnr) {
    let highlighter = this.highlighters.getItem(bufnr);
    if (highlighter)
      await highlighter.doHighlight();
  }
  async getColorInformation(bufnr) {
    let highlighter = this.highlighters.getItem(bufnr);
    if (!highlighter)
      return null;
    let position = await window_default.getCursorPosition();
    for (let info of highlighter.colors) {
      let { range: range2 } = info;
      let { start, end } = range2;
      if (position.line == start.line && position.character >= start.character && position.character <= end.character) {
        return info;
      }
    }
    return null;
  }
  dispose() {
    this.highlighters.dispose();
    disposeAll(this.disposables);
  }
};

// src/handler/commands.ts
init_commands2();
init_manager2();
var logger116 = require_logger2()("handler-commands");
var Commands = class {
  constructor(nvim, env) {
    this.nvim = nvim;
    this.env = env;
    for (let item of env.vimCommands) {
      this.addVimCommand(item);
    }
  }
  addVimCommand(cmd) {
    let id = `vim.${cmd.id}`;
    commands_default.registerCommand(id, () => {
      this.nvim.command(cmd.cmd, true);
      this.nvim.redrawVim();
    });
    if (cmd.title)
      commands_default.titles.set(id, cmd.title);
  }
  getCommandList() {
    return commands_default.commandList.map((o) => o.id);
  }
  async repeat() {
    await commands_default.repeatCommand();
  }
  async runCommand(id, ...args) {
    if (id)
      return await commands_default.fireCommand(id, ...args);
    await manager_default2.start(["commands"]);
  }
  getCommands() {
    let list2 = commands_default.commandList;
    let res = [];
    let { titles } = commands_default;
    for (let item of list2) {
      res.push({
        id: item.id,
        title: titles.get(item.id) || ""
      });
    }
    return res;
  }
};

// src/handler/fold.ts
init_languages();
var FoldHandler = class {
  constructor(nvim, handler) {
    this.nvim = nvim;
    this.handler = handler;
  }
  async fold(kind) {
    let { doc, winid } = await this.handler.getCurrentState();
    this.handler.checkProvier("foldingRange", doc.textDocument);
    await doc.synchronize();
    let win = this.nvim.createWindow(winid);
    let foldlevel = await this.nvim.eval("&foldlevel");
    let ranges = await this.handler.withRequestToken("foldingrange", (token) => {
      return languages_default.provideFoldingRanges(doc.textDocument, {}, token);
    }, true);
    if (!ranges || !ranges.length)
      return false;
    if (kind)
      ranges = ranges.filter((o) => o.kind == kind);
    ranges.sort((a, b) => b.startLine - a.startLine);
    this.nvim.pauseNotification();
    win.setOption("foldmethod", "manual", true);
    this.nvim.command("normal! zE", true);
    for (let range2 of ranges) {
      let { startLine, endLine } = range2;
      let cmd = `${startLine + 1}, ${endLine + 1}fold`;
      this.nvim.command(cmd, true);
    }
    win.setOption("foldenable", true, true);
    win.setOption("foldlevel", foldlevel, true);
    await this.nvim.resumeNotification(true);
    return true;
  }
};

// src/handler/format.ts
var import_vscode_languageserver_protocol111 = __toESM(require_main2());
init_commands2();
init_events();
init_languages();
init_manager3();
init_string();
init_window();
init_workspace();
var logger117 = require_logger2()("handler-format");
var pairs = /* @__PURE__ */ new Map([
  ["<", ">"],
  [">", "<"],
  ["{", "}"],
  ["[", "]"],
  ["(", ")"]
]);
var FormatHandler = class {
  constructor(nvim, handler) {
    this.nvim = nvim;
    this.handler = handler;
    this.loadPreferences();
    handler.addDisposable(workspace_default.onDidChangeConfiguration(this.loadPreferences, this));
    handler.addDisposable(workspace_default.onWillSaveTextDocument((event) => {
      let { languageId } = event.document;
      let filetypes = this.preferences.formatOnSaveFiletypes;
      if (filetypes.includes(languageId) || filetypes.includes("*")) {
        let willSaveWaitUntil = async () => {
          if (!languages_default.hasFormatProvider(event.document)) {
            logger117.warn(`Format provider not found for ${event.document.uri}`);
            return void 0;
          }
          let options2 = await workspace_default.getFormatOptions(event.document.uri);
          let tokenSource = new import_vscode_languageserver_protocol111.CancellationTokenSource();
          let timer;
          const tp = new Promise((c) => {
            timer = setTimeout(() => {
              logger117.warn(`Format on save ${event.document.uri} timeout after 0.5s`);
              tokenSource.cancel();
              c(void 0);
            }, 500);
          });
          const provideEdits = languages_default.provideDocumentFormattingEdits(event.document, options2, tokenSource.token);
          let textEdits = await Promise.race([tp, provideEdits]);
          clearTimeout(timer);
          return Array.isArray(textEdits) ? textEdits : void 0;
        };
        event.waitUntil(willSaveWaitUntil());
      }
    }));
    let enterTs;
    let enterBufnr;
    handler.addDisposable(events_default.on("Enter", async (bufnr) => {
      enterTs = Date.now();
      enterBufnr = bufnr;
    }));
    handler.addDisposable(events_default.on("CursorMovedI", async (bufnr) => {
      if (bufnr == enterBufnr && Date.now() - enterTs < 100) {
        enterBufnr = void 0;
        await this.handleEnter(bufnr);
      }
    }));
    handler.addDisposable(events_default.on("TextInsert", async (bufnr, info, character) => {
      if (!events_default.pumvisible)
        await this.tryFormatOnType(character, bufnr);
    }));
    handler.addDisposable(commands_default.registerCommand("editor.action.formatDocument", async (uri) => {
      const doc = uri ? workspace_default.getDocument(uri) : (await this.handler.getCurrentState()).doc;
      await this.documentFormat(doc);
    }));
    commands_default.titles.set("editor.action.formatDocument", "Format Document");
  }
  loadPreferences(e) {
    if (!e || e.affectsConfiguration("coc.preferences")) {
      let config = workspace_default.getConfiguration("coc.preferences");
      this.preferences = {
        formatOnType: config.get("formatOnType", false),
        formatOnSaveFiletypes: config.get("formatOnSaveFiletypes", []),
        formatOnTypeFiletypes: config.get("formatOnTypeFiletypes", []),
        bracketEnterImprove: config.get("bracketEnterImprove", true)
      };
    }
  }
  async tryFormatOnType(ch, bufnr, newLine = false) {
    if (!ch || isWord(ch) || !this.preferences.formatOnType)
      return;
    if (manager_default3.getSession(bufnr) != null)
      return;
    let doc = workspace_default.getDocument(bufnr);
    if (!doc || !doc.attached || doc.isCommandLine)
      return;
    const filetypes = this.preferences.formatOnTypeFiletypes;
    if (filetypes.length && !filetypes.includes(doc.filetype) && !filetypes.includes("*")) {
      return;
    }
    if (!languages_default.hasProvider("formatOnType", doc.textDocument)) {
      logger117.warn(`Format on type provider not found for buffer: ${doc.uri}`);
      return;
    }
    if (!languages_default.canFormatOnType(ch, doc.textDocument))
      return;
    let position;
    let edits = await this.handler.withRequestToken("Format on type", async (token) => {
      position = await window_default.getCursorPosition();
      let origLine = doc.getline(position.line - 1);
      if (newLine && /^\s*$/.test(origLine))
        return;
      await doc.synchronize();
      return await languages_default.provideDocumentOnTypeEdits(ch, doc.textDocument, position, token);
    });
    if (!edits || !edits.length)
      return;
    await doc.applyEdits(edits, false, true);
  }
  async formatCurrentBuffer() {
    let { doc } = await this.handler.getCurrentState();
    return await this.documentFormat(doc);
  }
  async formatCurrentRange(mode) {
    let { doc } = await this.handler.getCurrentState();
    return await this.documentRangeFormat(doc, mode);
  }
  async documentFormat(doc) {
    await doc.synchronize();
    if (!languages_default.hasFormatProvider(doc.textDocument)) {
      throw new Error(`Format provider not found for buffer: ${doc.bufnr}`);
    }
    let options2 = await workspace_default.getFormatOptions(doc.uri);
    let textEdits = await this.handler.withRequestToken("format", (token) => {
      return languages_default.provideDocumentFormattingEdits(doc.textDocument, options2, token);
    });
    if (textEdits && textEdits.length > 0) {
      await doc.applyEdits(textEdits, false, true);
      return true;
    }
    return false;
  }
  async handleEnter(bufnr) {
    let { nvim } = this;
    let { bracketEnterImprove } = this.preferences;
    await this.tryFormatOnType("\n", bufnr);
    if (bracketEnterImprove) {
      let line = await nvim.call("line", ".") - 1;
      let doc = workspace_default.getDocument(bufnr);
      if (!doc)
        return;
      await doc.patchChange();
      let pre = doc.getline(line - 1);
      let curr = doc.getline(line);
      let prevChar = pre[pre.length - 1];
      if (prevChar && pairs.has(prevChar)) {
        let nextChar = curr.trim()[0];
        if (nextChar && pairs.get(prevChar) == nextChar) {
          let edits = [];
          let opts = await workspace_default.getFormatOptions(doc.uri);
          let space = opts.insertSpaces ? " ".repeat(opts.tabSize) : "	";
          let currIndent = curr.match(/^\s*/)[0];
          let pos = import_vscode_languageserver_protocol111.Position.create(line - 1, pre.length);
          if (doc.filetype == "vim") {
            let newText = "\n" + currIndent + space;
            edits.push({ range: import_vscode_languageserver_protocol111.Range.create(line, currIndent.length, line, currIndent.length), newText: "  \\ " });
            newText = newText + "\\ ";
            edits.push({ range: import_vscode_languageserver_protocol111.Range.create(pos, pos), newText });
            await doc.applyEdits(edits);
            await window_default.moveTo(import_vscode_languageserver_protocol111.Position.create(line, newText.length - 1));
          } else {
            await nvim.eval(`feedkeys("\\<Esc>O", 'in')`);
          }
        }
      }
    }
  }
  async documentRangeFormat(doc, mode) {
    this.handler.checkProvier("formatRange", doc.textDocument);
    await doc.synchronize();
    let range2;
    if (mode) {
      range2 = await window_default.getSelectedRange(mode);
      if (!range2)
        return -1;
    } else {
      let [lnum, count, mode2] = await this.nvim.eval("[v:lnum,v:count,mode()]");
      if (count == 0 || mode2 == "i" || mode2 == "R")
        return -1;
      range2 = import_vscode_languageserver_protocol111.Range.create(lnum - 1, 0, lnum - 1 + count, 0);
    }
    let options2 = await workspace_default.getFormatOptions(doc.uri);
    let textEdits = await this.handler.withRequestToken("Format range", (token) => {
      return languages_default.provideDocumentRangeFormattingEdits(doc.textDocument, range2, options2, token);
    });
    if (textEdits && textEdits.length > 0) {
      await doc.applyEdits(textEdits, false, true);
      return 0;
    }
    return -1;
  }
};

// src/handler/highlights.ts
var import_vscode_languageserver_protocol112 = __toESM(require_main2());
init_events();
init_languages();
init_util();
init_workspace();
var logger118 = require_logger2()("documentHighlight");
var Highlights = class {
  constructor(nvim, handler) {
    this.nvim = nvim;
    this.handler = handler;
    this.disposables = [];
    this.highlights = /* @__PURE__ */ new Map();
    events_default.on(["CursorMoved", "CursorMovedI"], () => {
      this.cancel();
      this.clearHighlights();
    }, null, this.disposables);
    this.getConfiguration();
    workspace_default.onDidChangeConfiguration(this.getConfiguration, this, this.disposables);
  }
  getConfiguration(e) {
    let config = workspace_default.getConfiguration("documentHighlight");
    if (!e || e.affectsConfiguration("documentHighlight")) {
      this.config = Object.assign(this.config || {}, {
        priority: config.get("priority", -1),
        timeout: config.get("timeout", 300)
      });
    }
  }
  isEnabled(bufnr, cursors) {
    let doc = workspace_default.getDocument(bufnr);
    if (!doc || !doc.attached || cursors)
      return false;
    if (!languages_default.hasProvider("documentHighlight", doc.textDocument))
      return false;
    return true;
  }
  clearHighlights() {
    if (this.highlights.size == 0)
      return;
    for (let winid of this.highlights.keys()) {
      let win = this.nvim.createWindow(winid);
      win.clearMatchGroup("^CocHighlight");
    }
    this.highlights.clear();
  }
  async highlight() {
    let { nvim } = this;
    this.cancel();
    let [bufnr, winid, pos, cursors] = await nvim.eval(`[bufnr("%"),win_getid(),coc#cursor#position(),get(b:,'coc_cursors_activated',0)]`);
    if (!this.isEnabled(bufnr, cursors))
      return;
    let doc = workspace_default.getDocument(bufnr);
    let highlights = await this.getHighlights(doc, import_vscode_languageserver_protocol112.Position.create(pos[0], pos[1]));
    if (!highlights)
      return;
    let groups = {};
    for (let hl of highlights) {
      if (!hl.range)
        continue;
      let hlGroup = hl.kind == import_vscode_languageserver_protocol112.DocumentHighlightKind.Text ? "CocHighlightText" : hl.kind == import_vscode_languageserver_protocol112.DocumentHighlightKind.Read ? "CocHighlightRead" : "CocHighlightWrite";
      groups[hlGroup] = groups[hlGroup] || [];
      groups[hlGroup].push(hl.range);
    }
    let win = nvim.createWindow(winid);
    nvim.pauseNotification();
    win.clearMatchGroup("^CocHighlight");
    for (let hlGroup of Object.keys(groups)) {
      win.highlightRanges(hlGroup, groups[hlGroup], this.config.priority, true);
    }
    nvim.resumeNotification(true, true);
    this.highlights.set(winid, highlights);
  }
  async getSymbolsRanges() {
    let { doc, position } = await this.handler.getCurrentState();
    this.handler.checkProvier("documentHighlight", doc.textDocument);
    let highlights = await this.getHighlights(doc, position);
    if (!highlights)
      return null;
    return highlights.map((o) => o.range);
  }
  hasHighlights(winid) {
    return this.highlights.get(winid) != null;
  }
  async getHighlights(doc, position) {
    let line = doc.getline(position.line);
    let ch = line[position.character];
    if (!ch || !doc.isWord(ch))
      return null;
    await doc.synchronize();
    this.cancel();
    let source = this.tokenSource = new import_vscode_languageserver_protocol112.CancellationTokenSource();
    let timer = this.timer = setTimeout(() => {
      if (source.token.isCancellationRequested)
        return;
      source.cancel();
    }, this.config.timeout);
    let highlights = await languages_default.getDocumentHighLight(doc.textDocument, position, source.token);
    clearTimeout(timer);
    if (source.token.isCancellationRequested)
      return null;
    return highlights;
  }
  cancel() {
    if (this.tokenSource) {
      this.tokenSource.cancel();
      this.tokenSource.dispose();
      this.tokenSource = null;
    }
  }
  dispose() {
    if (this.timer)
      clearTimeout(this.timer);
    this.cancel();
    this.highlights.clear();
    disposeAll(this.disposables);
  }
};

// src/handler/hover.ts
var import_fs43 = __toESM(require("fs"));
var import_vscode_languageserver_protocol113 = __toESM(require_main2());
init_esm();
init_languages();
init_util();
init_fs();
init_workspace();
init_window();
var logger119 = require_logger2()("handler-hover");
var HoverHandler = class {
  constructor(nvim, handler) {
    this.nvim = nvim;
    this.handler = handler;
    this.disposables = [];
    this.documentLines = [];
    this.hasProvider = false;
    this.loadConfiguration();
    workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
    this.hoverFactory = window_default.createFloatFactory(Object.assign({
      modes: ["n"],
      autoHide: this.config.autoHide
    }, this.config.floatConfig));
    this.disposables.push(this.hoverFactory);
  }
  registerProvider() {
    if (this.hasProvider)
      return;
    this.hasProvider = true;
    let { nvim } = this;
    let provider = {
      onDidChange: null,
      provideTextDocumentContent: async () => {
        nvim.pauseNotification();
        nvim.command("setlocal conceallevel=2 nospell nofoldenable wrap", true);
        nvim.command("setlocal bufhidden=wipe nobuflisted", true);
        nvim.command("setfiletype markdown", true);
        nvim.command(`if winnr('j') != winnr('k') | exe "normal! z${Math.min(this.documentLines.length, this.config.previewMaxHeight)}\\<cr> | endif"`, true);
        await nvim.resumeNotification();
        return this.documentLines.join("\n");
      }
    };
    this.disposables.push(workspace_default.registerTextDocumentContentProvider("coc", provider));
  }
  loadConfiguration(e) {
    if (!e || e.affectsConfiguration("hover")) {
      let config = workspace_default.getConfiguration("hover");
      this.config = {
        floatConfig: config.get("floatConfig", {}),
        autoHide: config.get("autoHide", true),
        target: config.get("target", "float"),
        previewMaxHeight: config.get("previewMaxHeight", 12)
      };
      if (this.config.target == "preview") {
        this.registerProvider();
      }
    }
  }
  async onHover(hoverTarget) {
    let { doc, position, winid } = await this.handler.getCurrentState();
    if (hoverTarget == "preview")
      this.registerProvider();
    this.handler.checkProvier("hover", doc.textDocument);
    await doc.synchronize();
    let hovers = await this.handler.withRequestToken("hover", (token) => {
      return languages_default.getHover(doc.textDocument, position, token);
    }, true);
    if (hovers == null || !hovers.length)
      return false;
    let hover = hovers.find((o) => import_vscode_languageserver_protocol113.Range.is(o.range));
    if (hover == null ? void 0 : hover.range) {
      let win = this.nvim.createWindow(winid);
      win.highlightRanges("CocHoverRange", [hover.range], 99, true);
      this.timer = setTimeout(() => {
        win.clearMatchGroup("CocHoverRange");
        this.nvim.redrawVim();
      }, 500);
    }
    await this.previewHover(hovers, hoverTarget);
    return true;
  }
  async definitionHover(hoverTarget) {
    const { doc, position, winid } = await this.handler.getCurrentState();
    if (hoverTarget == "preview")
      this.registerProvider();
    this.handler.checkProvier("hover", doc.textDocument);
    await doc.synchronize();
    const hovers = await this.handler.withRequestToken("hover", (token) => {
      return languages_default.getHover(doc.textDocument, position, token);
    }, true);
    if (!(hovers == null ? void 0 : hovers.length))
      return false;
    const defs = await this.handler.withRequestToken("definitionHover", (token) => {
      return languages_default.getDefinitionLinks(doc.textDocument, position, token);
    }, false);
    if (defs == null ? void 0 : defs.length) {
      for (const def of defs) {
        if (!def.targetRange)
          continue;
        const { start, end } = def.targetRange;
        const endLine = end.line - start.line >= 100 ? start.line + 100 : end.character == 0 ? end.line - 1 : end.line;
        let lines = await readLines(def.targetUri, start.line, endLine);
        if (lines.length) {
          let indent = lines[0].match(/^\s*/)[0];
          if (indent)
            lines = lines.map((l) => l.startsWith(indent) ? l.substring(indent.length) : l);
          hovers.push({ content: lines.join("\n"), filetype: doc.filetype });
        }
      }
    }
    let hover = hovers.find((o) => import_vscode_languageserver_protocol113.Hover.is(o) && import_vscode_languageserver_protocol113.Range.is(o.range));
    if (hover == null ? void 0 : hover.range) {
      let win = this.nvim.createWindow(winid);
      win.highlightRanges("CocHoverRange", [hover.range], 99, true);
      this.timer = setTimeout(() => {
        win.clearMatchGroup("CocHoverRange");
        this.nvim.redrawVim();
      }, 500);
    }
    await this.previewHover(hovers, hoverTarget);
    return true;
  }
  async previewHover(hovers, target) {
    let docs = [];
    target = target || this.config.target;
    let isPreview = target === "preview";
    for (let hover of hovers) {
      if (isDocumentation(hover)) {
        docs.push(hover);
        continue;
      }
      let { contents } = hover;
      if (Array.isArray(contents)) {
        for (let item of contents) {
          if (typeof item === "string") {
            addDocument(docs, item, "markdown", isPreview);
          } else {
            addDocument(docs, item.value, item.language, isPreview);
          }
        }
      } else if (import_vscode_languageserver_protocol113.MarkedString.is(contents)) {
        if (typeof contents == "string") {
          addDocument(docs, contents, "markdown", isPreview);
        } else {
          addDocument(docs, contents.value, contents.language, isPreview);
        }
      } else if (import_vscode_languageserver_protocol113.MarkupContent.is(contents)) {
        addDocument(docs, contents.value, isMarkdown(contents) ? "markdown" : "txt", isPreview);
      }
    }
    if (target == "float") {
      await this.hoverFactory.show(docs);
      return;
    }
    let lines = docs.reduce((p, c) => {
      let arr = c.content.split(/\r?\n/);
      if (p.length > 0)
        p.push("");
      p.push(...arr);
      return p;
    }, []);
    if (target == "echo") {
      const msg = lines.join("\n").trim();
      await this.nvim.call("coc#ui#echo_hover", [msg]);
    } else {
      this.documentLines = lines;
      await this.nvim.command(`noswapfile pedit coc://document`);
    }
  }
  async getHover() {
    let result = [];
    let { doc, position } = await this.handler.getCurrentState();
    this.handler.checkProvier("hover", doc.textDocument);
    await doc.synchronize();
    let tokenSource = new import_vscode_languageserver_protocol113.CancellationTokenSource();
    let hovers = await languages_default.getHover(doc.textDocument, position, tokenSource.token);
    if (Array.isArray(hovers)) {
      for (let h of hovers) {
        let { contents } = h;
        if (Array.isArray(contents)) {
          contents.forEach((c) => {
            result.push(typeof c === "string" ? c : c.value);
          });
        } else if (import_vscode_languageserver_protocol113.MarkupContent.is(contents)) {
          result.push(contents.value);
        } else {
          result.push(typeof contents === "string" ? contents : contents.value);
        }
      }
    }
    result = result.filter((s) => s != null && s.length > 0);
    return result;
  }
  dispose() {
    if (this.timer)
      clearTimeout(this.timer);
    disposeAll(this.disposables);
  }
};
function addDocument(docs, text, filetype, isPreview = false) {
  let content = text.trim();
  if (!content.length)
    return;
  if (isPreview && filetype !== "markdown") {
    content = "``` " + filetype + "\n" + content + "\n```";
  }
  docs.push({ content, filetype });
}
function isDocumentation(obj) {
  if (!obj)
    return false;
  return typeof obj.filetype === "string" && typeof obj.content === "string";
}
async function readLines(uri, start, end) {
  let doc = workspace_default.getDocument(uri);
  if (doc)
    return doc.getLines(start, end + 1);
  let fsPath2 = URI2.parse(uri).fsPath;
  if (!import_fs43.default.existsSync(fsPath2))
    return [];
  return await readFileLines(fsPath2, start, end);
}

// src/handler/links.ts
var import_vscode_languageserver_protocol114 = __toESM(require_main2());
init_events();
init_languages();
init_util();
init_position();
init_window();
init_workspace();
var logger120 = require_logger2()("handler-links");
var regex2 = /CocAction(Async)?\(["']openLink["']\)/;
var Links = class {
  constructor(nvim, handler) {
    this.nvim = nvim;
    this.handler = handler;
    this.disposables = [];
    this.setConfiguration();
    workspace_default.onDidChangeConfiguration(this.setConfiguration, this, this.disposables);
    this.floatFactory = window_default.createFloatFactory({});
    events_default.on("CursorHold", async () => {
      if (!this._tooltip)
        return;
      if (!nvim.hasFunction("nvim_get_keymap"))
        return;
      await this.showTooltip();
    }, null, this.disposables);
    events_default.on(["CursorMoved", "InsertEnter"], () => {
      this.cancel();
    }, null, this.disposables);
  }
  setConfiguration(e) {
    if (!e || e.affectsConfiguration("links")) {
      let config = workspace_default.getConfiguration("links");
      this._tooltip = config.get("tooltip", false);
    }
  }
  async showTooltip() {
    let { nvim, floatFactory } = this;
    let obj = await nvim.getKeymap("n");
    let find = obj.find((o) => regex2.test(o.rhs));
    let key = find ? find.lhs : void 0;
    let link = await this.getCurrentLink();
    if (!link || !link.target)
      return;
    let text = "";
    if (link.tooltip)
      text = link.tooltip + " ";
    if (key)
      text += `Press "${key}" to open link`;
    if (!text.length)
      return;
    let doc = { content: text, filetype: "txt" };
    await floatFactory.show([doc]);
  }
  async getLinks() {
    let { doc } = await this.handler.getCurrentState();
    if (!languages_default.hasProvider("documentLink", doc.textDocument))
      return [];
    let tokenSource = this.tokenSource = new import_vscode_languageserver_protocol114.CancellationTokenSource();
    let links2 = await languages_default.getDocumentLinks(doc.textDocument, tokenSource.token);
    return tokenSource.token.isCancellationRequested ? [] : links2;
  }
  async openLink(link) {
    if (!link.target)
      throw new Error(`Failed to resolve link target`);
    await workspace_default.openResource(link.target);
  }
  async getCurrentLink() {
    let links2 = await this.getLinks();
    let pos = await window_default.getCursorPosition();
    if (links2 && links2.length) {
      for (let link2 of links2) {
        if (positionInRange(pos, link2.range) == 0) {
          if (!link2.target) {
            let tokenSource = this.tokenSource = this.tokenSource || new import_vscode_languageserver_protocol114.CancellationTokenSource();
            link2 = await languages_default.resolveDocumentLink(link2, this.tokenSource.token);
            if (!link2.target || tokenSource.token.isCancellationRequested)
              continue;
          }
          return link2;
        }
      }
    }
    let line = await this.nvim.call("getline", ["."]);
    let regex3 = /\w+?:\/\/[^)\]'" ]+/g;
    let arr;
    let link;
    while ((arr = regex3.exec(line)) !== null) {
      let start = arr.index;
      if (start <= pos.character && start + arr[0].length >= pos.character) {
        link = import_vscode_languageserver_protocol114.DocumentLink.create(import_vscode_languageserver_protocol114.Range.create(pos.line, start, pos.line, start + arr[0].length), arr[0]);
        break;
      }
    }
    return link;
  }
  async openCurrentLink() {
    let link = await this.getCurrentLink();
    if (link) {
      await this.openLink(link);
      return true;
    }
    return false;
  }
  cancel() {
    if (this.tokenSource) {
      this.tokenSource.cancel();
      this.tokenSource = null;
    }
  }
  dispose() {
    var _a;
    (_a = this.floatFactory) == null ? void 0 : _a.dispose();
    disposeAll(this.disposables);
  }
};

// src/handler/locations.ts
var import_vscode_languageserver_protocol115 = __toESM(require_main2());
init_esm();
init_languages();
init_services();
init_workspace();
var logger121 = require_logger2()("handler-hover");
var LocationsHandler = class {
  constructor(nvim, handler) {
    this.nvim = nvim;
    this.handler = handler;
  }
  async request(method, fn) {
    let { doc, position } = await this.handler.getCurrentState();
    this.handler.checkProvier(method, doc.textDocument);
    await doc.synchronize();
    return await this.handler.withRequestToken(method, (token) => {
      return fn(doc.textDocument, position, token);
    }, true);
  }
  async definitions() {
    const { doc, position } = await this.handler.getCurrentState();
    this.handler.checkProvier("definition", doc.textDocument);
    await doc.synchronize();
    const tokenSource = new import_vscode_languageserver_protocol115.CancellationTokenSource();
    return languages_default.getDefinition(doc.textDocument, position, tokenSource.token);
  }
  async declarations() {
    const { doc, position } = await this.handler.getCurrentState();
    this.handler.checkProvier("declaration", doc.textDocument);
    await doc.synchronize();
    const tokenSource = new import_vscode_languageserver_protocol115.CancellationTokenSource();
    return languages_default.getDeclaration(doc.textDocument, position, tokenSource.token);
  }
  async typeDefinitions() {
    const { doc, position } = await this.handler.getCurrentState();
    this.handler.checkProvier("typeDefinition", doc.textDocument);
    await doc.synchronize();
    const tokenSource = new import_vscode_languageserver_protocol115.CancellationTokenSource();
    return languages_default.getTypeDefinition(doc.textDocument, position, tokenSource.token);
  }
  async implementations() {
    const { doc, position } = await this.handler.getCurrentState();
    this.handler.checkProvier("implementation", doc.textDocument);
    await doc.synchronize();
    const tokenSource = new import_vscode_languageserver_protocol115.CancellationTokenSource();
    return languages_default.getImplementation(doc.textDocument, position, tokenSource.token);
  }
  async references(excludeDeclaration) {
    const { doc, position } = await this.handler.getCurrentState();
    this.handler.checkProvier("reference", doc.textDocument);
    await doc.synchronize();
    const tokenSource = new import_vscode_languageserver_protocol115.CancellationTokenSource();
    return languages_default.getReferences(doc.textDocument, { includeDeclaration: !excludeDeclaration }, position, tokenSource.token);
  }
  async gotoDefinition(openCommand) {
    let definition = await this.request("definition", (doc, position, token) => {
      return languages_default.getDefinition(doc, position, token);
    });
    await this.handleLocations(definition, openCommand);
    return definition ? definition.length > 0 : false;
  }
  async gotoDeclaration(openCommand) {
    let definition = await this.request("declaration", (doc, position, token) => {
      return languages_default.getDeclaration(doc, position, token);
    });
    await this.handleLocations(definition, openCommand);
    return definition ? Array.isArray(definition) ? definition.length > 0 : true : false;
  }
  async gotoTypeDefinition(openCommand) {
    let definition = await this.request("typeDefinition", (doc, position, token) => {
      return languages_default.getTypeDefinition(doc, position, token);
    });
    await this.handleLocations(definition, openCommand);
    return definition ? definition.length > 0 : false;
  }
  async gotoImplementation(openCommand) {
    let definition = await this.request("implementation", (doc, position, token) => {
      return languages_default.getImplementation(doc, position, token);
    });
    await this.handleLocations(definition, openCommand);
    return definition ? definition.length > 0 : false;
  }
  async gotoReferences(openCommand, includeDeclaration = true) {
    let definition = await this.request("reference", (doc, position, token) => {
      return languages_default.getReferences(doc, { includeDeclaration }, position, token);
    });
    await this.handleLocations(definition, openCommand);
    return definition ? definition.length > 0 : false;
  }
  async getTagList() {
    let { doc, position } = await this.handler.getCurrentState();
    let word = await this.nvim.call("expand", "<cword>");
    if (!word)
      return null;
    if (!languages_default.hasProvider("definition", doc.textDocument))
      return null;
    let tokenSource = new import_vscode_languageserver_protocol115.CancellationTokenSource();
    let definitions = await languages_default.getDefinition(doc.textDocument, position, tokenSource.token);
    if (!definitions || !definitions.length)
      return null;
    return definitions.map((location) => {
      let parsedURI = URI2.parse(location.uri);
      const filename = parsedURI.scheme == "file" ? parsedURI.fsPath : parsedURI.toString();
      return {
        name: word,
        cmd: `keepjumps ${location.range.start.line + 1} | normal ${location.range.start.character + 1}|`,
        filename
      };
    });
  }
  async findLocations(id, method, params, openCommand) {
    let { doc, position } = await this.handler.getCurrentState();
    params = params || {};
    Object.assign(params, {
      textDocument: { uri: doc.uri },
      position
    });
    let res = await services_default.sendRequest(id, method, params);
    res = res || [];
    let locations = [];
    if (Array.isArray(res)) {
      locations = res;
    } else if (res.hasOwnProperty("location") && res.hasOwnProperty("children")) {
      let getLocation2 = (item) => {
        locations.push(item.location);
        if (item.children && item.children.length) {
          for (let loc of item.children) {
            getLocation2(loc);
          }
        }
      };
      getLocation2(res);
    }
    await this.handleLocations(locations, openCommand);
    return locations ? locations.length > 0 : false;
  }
  async handleLocations(definition, openCommand) {
    if (!definition)
      return;
    let locations = Array.isArray(definition) ? definition : [definition];
    locations = locations.map((o) => import_vscode_languageserver_protocol115.LocationLink.is(o) ? import_vscode_languageserver_protocol115.Location.create(o.targetUri, o.targetRange) : o);
    let len = locations.length;
    if (len == 0)
      return;
    if (len == 1 && openCommand !== false) {
      let { uri, range: range2 } = locations[0];
      await workspace_default.jumpTo(uri, range2.start, openCommand);
    } else {
      await workspace_default.showLocations(locations);
    }
  }
  dispose() {
  }
};

// src/handler/refactor/index.ts
var import_vscode_languageserver_protocol117 = __toESM(require_main2());
init_esm();
init_events();
init_languages();
init_util();
init_fs();
init_textedit();
init_workspace();

// src/handler/refactor/buffer.ts
var import_fast_diff4 = __toESM(require_diff());
var import_path39 = __toESM(require("path"));
var import_vscode_languageserver_protocol116 = __toESM(require_main2());
init_main3();
init_esm();
init_highligher();
init_util();
init_fs();
init_lodash();
init_mutex();
init_object();
init_position();
init_string();
init_textedit();
init_window();
init_workspace();

// src/handler/refactor/changes.ts
init_object();
var Changes = class {
  constructor() {
    this.stack = [];
  }
  add(infos) {
    let map = /* @__PURE__ */ new Map();
    for (let info of infos) {
      map.set(info.lnum, info);
    }
    this.stack.push(map);
  }
  checkInsert(lnums) {
    if (!this.stack.length)
      return void 0;
    let last = this.stack[this.stack.length - 1];
    let arr = Array.from(last.keys()).sort((a, b) => a - b);
    if (!equals(arr, lnums))
      return void 0;
    this.stack.pop();
    return Array.from(last.values());
  }
};

// src/handler/refactor/buffer.ts
var logger122 = require_logger2()("handler-refactorBuffer");
var SEPARATOR = "\u3000";
var RefactorBuffer = class {
  constructor(bufnr, srcId2, nvim, config, opts) {
    this.bufnr = bufnr;
    this.srcId = srcId2;
    this.nvim = nvim;
    this.config = config;
    this.opts = opts;
    this._disposed = false;
    this._fileItems = [];
    this.mutex = new Mutex();
    this.disposables = [];
    this.matchIds = /* @__PURE__ */ new Set();
    this.changing = false;
    this.changes = new Changes();
    this.disposables.push(workspace_default.registerLocalKeymap("n", "<CR>", this.splitOpen.bind(this), true));
    if (config.showMenu) {
      this.disposables.push(workspace_default.registerLocalKeymap("n", config.showMenu, this.showMenu.bind(this), true));
    }
    workspace_default.onDidChangeTextDocument(this.onDocumentChange, this, this.disposables);
  }
  async showMenu() {
    let res = await window_default.showMenuPicker(["Tab open", "Remove block"]);
    if (res == -1)
      return;
    let fileRange = await this.searchCurrentRange();
    if (!fileRange)
      return;
    if (res == 0) {
      let before = await this.nvim.eval(`strpart(getline('.'), 0 ,col('.') - 1)`);
      let character = before.length;
      let bufname = this.getAbsolutePath(fileRange.filepath);
      this.nvim.call("coc#util#jump", ["tabe", bufname, [fileRange.line, character]], true);
    }
    if (res == 1) {
      let range2 = this.getDeleteRange(fileRange);
      await this.document.applyEdits([import_vscode_languageserver_protocol116.TextEdit.del(range2)]);
    }
  }
  get fileItems() {
    return this._fileItems;
  }
  getFileItem(uri) {
    let filepath = URI2.parse(uri).fsPath;
    return this._fileItems.find((o) => sameFile(o.filepath, filepath));
  }
  getFileRange(lnum) {
    for (let item of this._fileItems) {
      for (let r of item.ranges) {
        if (r.lnum == lnum) {
          return Object.assign(omit(r, ["highlights"]), { filepath: item.filepath });
        }
      }
    }
    throw new Error(`File range not found at lnum: ${lnum}`);
  }
  onChange(e) {
    if (this.changing)
      return;
    if (e.contentChanges.length === 0) {
      this.highlightLineNr();
      this.nvim.redrawVim();
      return;
    }
    let { nvim } = this;
    e = fixChangeParams(e);
    let change = e.contentChanges[0];
    let { original } = e;
    if (change.range.end.line > 2) {
      nvim.call("setbufvar", [e.bufnr, "&modified", 1], true);
    }
    let { range: range2, text } = change;
    let lineChange = lineCountChange(import_vscode_languageserver_protocol116.TextEdit.replace(range2, text));
    if (lineChange == 0)
      return;
    let edits = [import_vscode_languageserver_protocol116.TextEdit.replace(range2, text)];
    let addRanges = [];
    if (!emptyRange(range2) && !text.includes("\u3000")) {
      let sl = range2.start.line;
      let lnums = [];
      let lines = original.split(/\r?\n/);
      for (let i = 0; i < lines.length; i++) {
        let line = lines[i];
        if (line.length > 1 && line.includes("\u3000")) {
          lnums.push(sl + i + 1);
        }
      }
      if (lnums.length) {
        let infos = lnums.map((lnum) => {
          return this.getFileRange(lnum);
        });
        for (let item of this._fileItems) {
          item.ranges = item.ranges.filter((o) => !lnums.includes(o.lnum));
        }
        this.changes.add(infos);
      }
    } else if (emptyRange(range2) && text.includes("\u3000")) {
      let lines = text.split(/\r?\n/);
      let lnums = [];
      let sl = range2.start.line;
      for (let i = 0; i < lines.length; i++) {
        let line = lines[i];
        if (line.length > 1 && line.includes("\u3000")) {
          lnums.push(sl + i + 1);
        }
      }
      if (lnums.length) {
        let res = this.changes.checkInsert(lnums);
        if (res)
          addRanges = res;
      }
    } else if (text.includes("\u3000")) {
      edits = this.diffChanges(original, text);
      edits.forEach((e2) => {
        e2.range = adjustRangePosition(e2.range, range2.start);
      });
    }
    this.adjustLnums(edits);
    nvim.pauseNotification();
    this.highlightLineNr();
    nvim.resumeNotification(true, true);
    if (addRanges.length) {
      addRanges.forEach((info) => {
        let item = this._fileItems.find((o) => o.filepath == info.filepath);
        item.ranges.push(info);
      });
    }
  }
  diffChanges(original, text) {
    let edits = [];
    let diffs = (0, import_fast_diff4.default)(original, text);
    let offset = 0;
    let orig = TextDocument2.create("file:///1", "", 0, original);
    for (let i = 0; i < diffs.length; i++) {
      let diff = diffs[i];
      let pos = orig.positionAt(offset);
      if (diff[0] == import_fast_diff4.default.EQUAL) {
        offset = offset + diff[1].length;
      } else if (diff[0] == import_fast_diff4.default.DELETE) {
        let end = orig.positionAt(offset + diff[1].length);
        if (diffs[i + 1] && diffs[i + 1][0] == import_fast_diff4.default.INSERT) {
          let text2 = diffs[i + 1][1];
          edits.push(import_vscode_languageserver_protocol116.TextEdit.replace(import_vscode_languageserver_protocol116.Range.create(pos, end), text2));
          i = i + 1;
        } else {
          edits.push(import_vscode_languageserver_protocol116.TextEdit.replace(import_vscode_languageserver_protocol116.Range.create(pos, end), ""));
        }
        offset = offset + diff[1].length;
      } else if (diff[0] == import_fast_diff4.default.INSERT) {
        edits.push(import_vscode_languageserver_protocol116.TextEdit.insert(pos, diff[1]));
      }
    }
    return edits;
  }
  async onDocumentChange(e) {
    if (this.changing || e.contentChanges.length === 0)
      return;
    let { uri } = e.textDocument;
    let fileItem = this.getFileItem(uri);
    if (!fileItem)
      return;
    let { range: range2, text } = e.contentChanges[0];
    let lineChange = lineCountChange(import_vscode_languageserver_protocol116.TextEdit.replace(range2, text));
    let edits = [];
    let deleteIndexes = [];
    for (let i = 0; i < fileItem.ranges.length; i++) {
      let r = fileItem.ranges[i];
      if (range2.start.line >= r.start + r.lines.length)
        continue;
      if (range2.end.line < r.start) {
        r.start = r.start + lineChange;
        continue;
      }
      let textDocument = workspace_default.getDocument(uri).textDocument;
      let end = r.start + r.lines.length + lineChange;
      let newLines = textDocument.lines.slice(r.start, end);
      if (!newLines.length) {
        deleteIndexes.push(i);
        let replaceRange = this.getDeleteRange(r);
        edits.push(import_vscode_languageserver_protocol116.TextEdit.replace(replaceRange, ""));
      } else {
        r.lines = newLines;
        let replaceRange = this.getReplaceRange(r);
        edits.push(import_vscode_languageserver_protocol116.TextEdit.replace(replaceRange, newLines.join("\n")));
      }
    }
    if (deleteIndexes.length) {
      fileItem.ranges = fileItem.ranges.filter((_, i) => !deleteIndexes.includes(i));
    }
    this._fileItems = this._fileItems.filter((o) => o.ranges && o.ranges.length > 0);
    if (edits.length) {
      this.adjustLnums(edits);
      this.changing = true;
      await this.document.applyEdits(edits);
      this.changing = false;
    }
    this.nvim.pauseNotification();
    this.highlightLineNr();
    this.buffer.setOption("modified", false, true);
    await this.nvim.resumeNotification(true);
  }
  adjustLnums(edits) {
    for (let item of this._fileItems) {
      for (let fileRange of item.ranges) {
        let line = fileRange.lnum - 1;
        fileRange.lnum += getChangedLineCount(import_vscode_languageserver_protocol116.Position.create(line, 0), edits);
      }
    }
  }
  async getFileChanges() {
    let changes = [];
    let lines = await this.buffer.lines;
    lines.push(SEPARATOR);
    let arr = [];
    let fsPath2;
    let lnum;
    for (let i = 0; i < lines.length; i++) {
      let line = lines[i];
      if (line.startsWith(SEPARATOR)) {
        if (fsPath2) {
          changes.push({
            filepath: fsPath2,
            lines: arr.slice(),
            lnum
          });
          fsPath2 = void 0;
          arr = [];
        }
        if (line.length > 1) {
          let ms = line.match(/^\u3000(.*)/);
          if (ms) {
            fsPath2 = this.getAbsolutePath(ms[1].replace(/\s+$/, ""));
            lnum = i + 1;
            arr = [];
          }
        }
      } else {
        arr.push(line);
      }
    }
    return changes;
  }
  async splitOpen() {
    let { nvim } = this;
    let win = nvim.createWindow(this.opts.fromWinid);
    let valid = await win.valid;
    let before = await nvim.eval(`strpart(getline('.'), 0 ,col('.') - 1)`);
    let character = before.length;
    let fileRange = await this.searchCurrentRange();
    if (fileRange) {
      let bufname = this.getAbsolutePath(fileRange.filepath);
      nvim.pauseNotification();
      if (valid) {
        nvim.call("win_gotoid", [this.opts.fromWinid], true);
        this.nvim.call("coc#util#jump", ["edit", bufname, [fileRange.line, character]], true);
      } else {
        this.nvim.call("coc#util#jump", ["belowright vs", bufname, [fileRange.line, character]], true);
      }
      nvim.command("normal! zz", true);
      await nvim.resumeNotification(true);
      if (!valid) {
        this.opts.fromWinid = await nvim.call("win_getid");
      }
    }
  }
  async searchCurrentRange() {
    let { nvim } = this;
    let lines = await nvim.eval('getline(1,line("."))');
    let len = lines.length;
    for (let i = 0; i < len; i++) {
      let line = lines[len - i - 1];
      let ms = line.match(/^\u3000(.+)/);
      if (ms) {
        let r = this.getFileRange(len - i);
        return Object.assign({ line: r.start + (i == 0 ? 1 : i) - 1 }, r);
      }
    }
    return void 0;
  }
  async addFileItems(items) {
    if (this._disposed)
      return;
    let { cwd } = this.opts;
    let { document: document2 } = this;
    const release = await this.mutex.acquire();
    try {
      await document2.synchronize();
      let count = document2.lineCount;
      let highligher = new Highlighter();
      let hlRanges = [];
      for (let item of items) {
        let ranges = [];
        for (let range2 of item.ranges) {
          highligher.addLine(SEPARATOR);
          highligher.addLine(SEPARATOR);
          let lnum = count + highligher.length;
          highligher.addText(`${isParentFolder(cwd, item.filepath) ? import_path39.default.relative(cwd, item.filepath) : item.filepath}`);
          let n = String(range2.start + 1).length + String(range2.end).length + 4;
          if (!this.srcId)
            highligher.addText(" ".repeat(n));
          let base = 0 - highligher.length - count;
          if (range2.highlights) {
            hlRanges.push(...range2.highlights.map((r) => adjustRange(r, base)));
          }
          let { lines, start, end, highlights } = range2;
          if (!lines) {
            lines = await this.getLines(item.filepath, start, end);
          }
          ranges.push({ lines, lnum, start, highlights });
          highligher.addLines(lines);
        }
        if (ranges.length) {
          let newItem = { filepath: item.filepath, ranges };
          let fileItem = this._fileItems.find((o) => o.filepath == item.filepath);
          if (fileItem) {
            fileItem.ranges.push(...newItem.ranges);
          } else {
            this._fileItems.push(newItem);
          }
        }
      }
      let { nvim, buffer } = this;
      this.changing = true;
      nvim.pauseNotification();
      highligher.render(buffer, count);
      this.highlightLineNr();
      buffer.setOption("modified", false, true);
      buffer.setOption("undolevels", 1e3, true);
      if (count == 2 && hlRanges.length) {
        let pos = hlRanges[0].start;
        nvim.call("coc#cursor#move_to", [pos.line, pos.character], true);
      }
      await nvim.resumeNotification(true);
      await document2.patchChange();
      this.changing = false;
      await window_default.cursors.addRanges(hlRanges);
    } catch (e) {
      this.changing = false;
      logger122.error(`Error on add file item:`, e);
    }
    release();
  }
  findRange(filepath, lnum) {
    let item = this.fileItems.find((o) => sameFile(this.getAbsolutePath(o.filepath), filepath));
    let range2 = item.ranges.find((o) => o.lnum == lnum);
    if (!range2)
      throw new Error(`File range not found at lnum: ${lnum}`);
    return range2;
  }
  async save() {
    let { nvim } = this;
    let doc = this.document;
    let { buffer } = doc;
    await doc.patchChange();
    let changes = await this.getFileChanges();
    if (!changes)
      return;
    changes.sort((a, b) => a.lnum - b.lnum);
    let fileChanges = [];
    for (let i = 0; i < changes.length; i++) {
      let change = changes[i];
      let range2 = this.findRange(change.filepath, change.lnum);
      if (equals(range2.lines, change.lines))
        continue;
      fileChanges.push(Object.assign({ start: range2.start, end: range2.start + range2.lines.length }, change));
      range2.lines = change.lines;
    }
    if (fileChanges.length == 0) {
      await window_default.showInformationMessage("No change.");
      await buffer.setOption("modified", false);
      return false;
    }
    let changeMap = {};
    for (let change of fileChanges) {
      let uri = URI2.file(change.filepath).toString();
      let edits = changeMap[uri] || [];
      edits.push({
        range: import_vscode_languageserver_protocol116.Range.create(change.start, 0, change.end, 0),
        newText: change.lines.join("\n") + "\n"
      });
      changeMap[uri] = edits;
    }
    this.changing = true;
    await workspace_default.applyEdit({ changes: changeMap });
    this.changing = false;
    for (let item of this.fileItems) {
      let uri = URI2.file(this.getAbsolutePath(item.filepath)).toString();
      let edits = changeMap[uri];
      if (edits && edits.length > 0) {
        item.ranges.forEach((r) => {
          r.start += getChangedLineCount(import_vscode_languageserver_protocol116.Position.create(r.start, 0), edits);
        });
      }
    }
    nvim.pauseNotification();
    buffer.setOption("modified", false, true);
    if (this.config.saveToFile) {
      nvim.command("silent noa wa", true);
    }
    this.highlightLineNr();
    await nvim.resumeNotification();
    return true;
  }
  async getLines(fsPath2, start, end) {
    let uri = URI2.file(fsPath2).toString();
    let doc = workspace_default.getDocument(uri);
    if (doc)
      return doc.getLines(start, end);
    return await readFileLines(fsPath2, start, end - 1);
  }
  getAbsolutePath(filepath) {
    if (import_path39.default.isAbsolute(filepath))
      return filepath;
    return import_path39.default.join(this.opts.cwd, filepath);
  }
  highlightLineNr() {
    let { fileItems, nvim, srcId: srcId2, bufnr } = this;
    let { winid, cwd } = this.opts;
    let info = {};
    if (srcId2) {
      nvim.call("nvim_buf_clear_namespace", [bufnr, srcId2, 0, -1], true);
      for (let item of fileItems) {
        for (let range2 of item.ranges) {
          let end = range2.start + range2.lines.length;
          let text = `${range2.start + 1}:${end}`;
          info[range2.lnum] = [range2.start + 1, end];
          nvim.call("nvim_buf_set_virtual_text", [bufnr, srcId2, range2.lnum - 1, [[text, "LineNr"]], {}], true);
        }
      }
    } else {
      if (this.matchIds.size) {
        nvim.call("coc#highlight#clear_matches", [winid, Array.from(this.matchIds)], true);
        this.matchIds.clear();
      }
      let id = 2e3;
      for (let item of fileItems) {
        let filename = `${cwd ? import_path39.default.relative(cwd, item.filepath) : item.filepath}`;
        let col = byteLength(filename) + 1;
        for (let range2 of item.ranges) {
          let end = range2.start + range2.lines.length;
          let text = `:${range2.start + 1}:${end}`;
          for (let i = 0; i < text.length; i++) {
            let ch = text[i];
            this.matchIds.add(id);
            info[range2.lnum] = [range2.start + 1, end];
            nvim.call("matchaddpos", ["Conceal", [[range2.lnum, col + i]], 99, id, { conceal: ch, window: winid }], true);
            id++;
          }
        }
      }
    }
    this.buffer.setVar("line_infos", info, true);
  }
  getDeleteRange(r) {
    let { document: document2 } = this;
    let start = r.lnum - 1;
    let end;
    let total = document2.lineCount;
    for (let i = start; i < total; i++) {
      if (i + 1 == total) {
        end = import_vscode_languageserver_protocol116.Position.create(total, 0);
        break;
      }
      let line = document2.getline(i);
      if (line === SEPARATOR) {
        end = import_vscode_languageserver_protocol116.Position.create(i + 1, 0);
        break;
      }
      if (i != start && line.startsWith(SEPARATOR)) {
        end = import_vscode_languageserver_protocol116.Position.create(i, 0);
        break;
      }
    }
    return import_vscode_languageserver_protocol116.Range.create(import_vscode_languageserver_protocol116.Position.create(start, 0), end);
  }
  getReplaceRange(r) {
    let { document: document2 } = this;
    let start = r.lnum;
    let end;
    let total = document2.lineCount;
    for (let i = start; i < total; i++) {
      let line = document2.getline(i);
      if (i + 1 == total) {
        end = import_vscode_languageserver_protocol116.Position.create(i, line.length);
        break;
      }
      let next = document2.getline(i + 1);
      if (next.startsWith("\u3000")) {
        end = import_vscode_languageserver_protocol116.Position.create(i, line.length);
        break;
      }
    }
    return import_vscode_languageserver_protocol116.Range.create(import_vscode_languageserver_protocol116.Position.create(start, 0), end);
  }
  get valid() {
    return this.buffer.valid;
  }
  get buffer() {
    return this.nvim.createBuffer(this.bufnr);
  }
  get document() {
    return workspace_default.getDocument(this.bufnr);
  }
  dispose() {
    this._disposed = true;
    disposeAll(this.disposables);
  }
};
function adjustRange(range2, offset) {
  let { start, end } = range2;
  return import_vscode_languageserver_protocol116.Range.create(start.line - offset, start.character, end.line - offset, end.character);
}
function fixChangeParams(e) {
  let { contentChanges, bufnr, textDocument, original, originalLines } = e;
  let { range: range2, text } = contentChanges[0];
  let changes = [{ range: range2, text }];
  if (!original) {
    if (emptyRange(range2) && range2.start.character != 0) {
      let lines = text.split(/\r?\n/);
      let last = lines[lines.length - 1];
      let before = originalLines[range2.start.line].slice(0, range2.start.character);
      if (last.startsWith(SEPARATOR) && before == last) {
        changes[0].text = before + lines.slice(0, -1).join("\n") + "\n";
        let { start, end } = range2;
        changes[0].range = import_vscode_languageserver_protocol116.Range.create(start.line, 0, end.line, 0);
      }
    }
  } else {
    let lines = original.split(/\r?\n/);
    let last = lines[lines.length - 1];
    if (last.startsWith(SEPARATOR)) {
      let before = originalLines[range2.start.line].slice(0, range2.start.character);
      if (before == last) {
        original = before + lines.slice(0, -1).join("\n") + "\n";
        let { start, end } = range2;
        changes[0].range = import_vscode_languageserver_protocol116.Range.create(start.line, 0, end.line, 0);
      }
    }
    let prev = originalLines[range2.start.line - 1];
    let nest = lines.length > 1 ? lines[lines.length - 2] : "";
    if (last == "" && nest.startsWith(SEPARATOR) && prev == nest && range2.start.character == 0 && range2.end.character == 0) {
      original = prev + "\n" + lines.slice(0, -2).join("\n") + "\n";
      let { start, end } = range2;
      changes[0].range = import_vscode_languageserver_protocol116.Range.create(start.line - 1, 0, end.line - 1, 0);
    }
  }
  return { contentChanges: changes, bufnr, textDocument, original, originalLines };
}

// src/handler/refactor/search.ts
var import_child_process7 = require("child_process");
var import_events43 = require("events");
var import_path40 = __toESM(require("path"));
var import_readline5 = __toESM(require("readline"));
init_main();
init_highligher();
init_ansiparse();
init_mutex();
init_window();
var logger123 = require_logger2()("handler-search");
var defaultArgs = ["--color", "ansi", "--colors", "path:fg:black", "--colors", "line:fg:green", "--colors", "match:fg:red", "--no-messages", "--heading", "-n"];
var controlCode2 = "\x1B";
var Task2 = class extends import_events43.EventEmitter {
  start(cmd, args, cwd) {
    this.process = (0, import_child_process7.spawn)(cmd, args, { cwd });
    this.process.on("error", (e) => {
      this.emit("error", e.message);
    });
    const rl = import_readline5.default.createInterface(this.process.stdout);
    let start;
    let fileItem;
    let lines = [];
    let highlights = [];
    let create = true;
    rl.on("line", (content) => {
      if (content.includes(controlCode2)) {
        let items = ansiparse(content);
        if (items.length == 0)
          return;
        if (items[0].foreground == "black") {
          fileItem = { filepath: import_path40.default.join(cwd, items[0].text), ranges: [] };
          return;
        }
        let normalLine = items[0].foreground == "green";
        if (normalLine) {
          let lnum = parseInt(items[0].text, 10) - 1;
          let padlen2 = items[0].text.length + 1;
          if (create) {
            start = lnum;
            create = false;
          }
          let line = "";
          for (let item of items) {
            if (item.foreground == "red") {
              let l = lnum - start;
              let c = line.length - padlen2;
              highlights.push(Range.create(l, c, l, c + item.text.length));
            }
            line += item.text;
          }
          let currline = line.slice(padlen2);
          lines.push(currline);
        }
      } else {
        let fileEnd = content.trim().length == 0;
        if (fileItem && (fileEnd || content.trim() == "--")) {
          fileItem.ranges.push({ lines, highlights, start });
        }
        if (fileEnd) {
          this.emit("item", fileItem);
          fileItem = null;
        }
        lines = [];
        highlights = [];
        create = true;
      }
    });
    rl.on("close", () => {
      if (fileItem) {
        if (lines.length) {
          fileItem.ranges.push({ lines, highlights, start });
        }
        this.emit("item", fileItem);
      }
      lines = highlights = fileItem = null;
      this.emit("end");
    });
  }
  dispose() {
    if (this.process) {
      this.process.kill();
    }
  }
};
var Search = class {
  constructor(nvim, cmd = "rg") {
    this.nvim = nvim;
    this.cmd = cmd;
  }
  run(args, cwd, refactorBuf) {
    let { nvim, cmd } = this;
    let { afterContext, beforeContext } = refactorBuf.config;
    let argList = ["-A", afterContext.toString(), "-B", beforeContext.toString()].concat(defaultArgs, args);
    let p = getPathFromArgs(args);
    if (p)
      argList.pop();
    argList.push("--", p ? import_path40.default.isAbsolute(p) ? p : `./${p.replace(/^\.\//, "")}` : "./");
    this.task = new Task2();
    this.task.start(cmd, argList, cwd);
    let mutex = new Mutex();
    let files = 0;
    let matches = 0;
    let start = Date.now();
    let fileItems = [];
    const addFileItems = async () => {
      if (fileItems.length == 0)
        return;
      let items = fileItems.slice();
      fileItems = [];
      const release = await mutex.acquire();
      try {
        await refactorBuf.addFileItems(items);
      } catch (e) {
        logger123.error(e);
      }
      release();
    };
    return new Promise((resolve3, reject) => {
      let interval = setInterval(addFileItems, 300);
      this.task.on("item", async (fileItem) => {
        files++;
        matches = matches + fileItem.ranges.reduce((p2, r) => p2 + r.highlights.length, 0);
        fileItems.push(fileItem);
      });
      this.task.on("error", (message) => {
        clearInterval(interval);
        window_default.showMessage(`Error on command "${cmd}": ${message}`, "error");
        this.task = null;
        reject(new Error(message));
      });
      this.task.on("end", async () => {
        clearInterval(interval);
        try {
          await addFileItems();
          const release = await mutex.acquire();
          release();
          this.task.removeAllListeners();
          this.task = null;
          let buf = refactorBuf.buffer;
          if (buf) {
            nvim.pauseNotification();
            if (files == 0) {
              buf.setLines(["No match found"], { start: 1, end: 2, strictIndexing: false }, true);
              buf.addHighlight({ line: 1, srcId: -1, colEnd: -1, colStart: 0, hlGroup: "Error" });
              buf.setOption("modified", false, true);
            } else {
              let highligher = new Highlighter();
              highligher.addText("Files", "MoreMsg");
              highligher.addText(": ");
              highligher.addText(`${files} `, "Number");
              highligher.addText("Matches", "MoreMsg");
              highligher.addText(": ");
              highligher.addText(`${matches} `, "Number");
              highligher.addText("Duration", "MoreMsg");
              highligher.addText(": ");
              highligher.addText(`${Date.now() - start}ms`, "Number");
              highligher.render(buf, 1, 2);
            }
            buf.setOption("modified", false, true);
            nvim.resumeNotification(false, true);
          }
        } catch (e) {
          reject(e);
          return;
        }
        resolve3();
      });
    });
  }
  abort() {
    var _a;
    (_a = this.task) == null ? void 0 : _a.dispose();
  }
};
function getPathFromArgs(args) {
  if (args.length < 2)
    return void 0;
  let len = args.length;
  if (args[len - 1].startsWith("-"))
    return void 0;
  if (args[len - 2].startsWith("-"))
    return void 0;
  return args[len - 1];
}

// src/handler/refactor/index.ts
var logger124 = require_logger2()("handler-refactor");
var name = "__coc_refactor__";
var refactorId = 0;
var Refactor = class {
  constructor(nvim, handler) {
    this.nvim = nvim;
    this.handler = handler;
    this.buffers = /* @__PURE__ */ new Map();
    this.disposables = [];
    this._onCreate = new import_vscode_languageserver_protocol117.Emitter();
    this.onCreate = this._onCreate.event;
    this.setConfiguration();
    workspace_default.onDidChangeConfiguration(this.setConfiguration, this, this.disposables);
    events_default.on("BufUnload", (bufnr) => {
      let buf = this.buffers.get(bufnr);
      if (buf) {
        buf.dispose();
        this.buffers.delete(bufnr);
      }
    }, null, this.disposables);
    workspace_default.onDidChangeTextDocument((e) => {
      let buf = this.buffers.get(e.bufnr);
      if (buf)
        buf.onChange(e);
    }, null, this.disposables);
  }
  async init() {
    if (workspace_default.isNvim && this.nvim.hasFunction("nvim_create_namespace")) {
      this.srcId = await this.nvim.createNamespace("coc-refactor");
    }
  }
  has(bufnr) {
    return this.buffers.has(bufnr);
  }
  setConfiguration(e) {
    if (e && !e.affectsConfiguration("refactor"))
      return;
    let config = workspace_default.getConfiguration("refactor");
    this.config = Object.assign(this.config || {}, {
      afterContext: config.get("afterContext", 3),
      beforeContext: config.get("beforeContext", 3),
      openCommand: config.get("openCommand", "edit"),
      saveToFile: config.get("saveToFile", true),
      showMenu: config.get("showMenu", "<Tab>")
    });
  }
  async doRefactor() {
    let { doc, position } = await this.handler.getCurrentState();
    if (!languages_default.hasProvider("rename", doc.textDocument)) {
      throw new Error(`Rename provider not found for current buffer`);
    }
    await doc.synchronize();
    let edit2 = await this.handler.withRequestToken("refactor", async (token) => {
      let res = await languages_default.prepareRename(doc.textDocument, position, token);
      if (token.isCancellationRequested)
        return null;
      if (res === false)
        throw new Error(`Provider returns null on prepare, unable to rename at current position`);
      let edit3 = await languages_default.provideRenameEdits(doc.textDocument, position, "NewName", token);
      if (token.isCancellationRequested)
        return null;
      if (!edit3)
        throw new Error("Provider returns null for rename edits.");
      return edit3;
    });
    if (edit2) {
      await this.fromWorkspaceEdit(edit2, doc.filetype);
    }
  }
  async search(args) {
    let buf = await this.createRefactorBuffer();
    let cwd = await this.nvim.call("getcwd", []);
    let search = new Search(this.nvim);
    await search.run(args, cwd, buf);
  }
  async save(bufnr) {
    let buf = this.buffers.get(bufnr);
    if (buf)
      return await buf.save();
  }
  getBuffer(bufnr) {
    return this.buffers.get(bufnr);
  }
  async createRefactorBuffer(filetype, conceal = false) {
    let { nvim } = this;
    let [fromWinid, cwd] = await nvim.eval("[win_getid(),getcwd()]");
    let { openCommand } = this.config;
    nvim.pauseNotification();
    nvim.command(`${openCommand} ${name}${refactorId++}`, true);
    nvim.command(`setl buftype=acwrite nobuflisted bufhidden=wipe nofen wrap conceallevel=2 concealcursor=n`, true);
    nvim.command(`setl undolevels=-1 nolist nospell noswapfile foldmethod=expr foldexpr=coc#util#refactor_foldlevel(v:lnum)`, true);
    nvim.command(`setl foldtext=coc#util#refactor_fold_text(v:foldstart)`, true);
    nvim.call("setline", [1, ["Save current buffer to make changes", SEPARATOR]], true);
    nvim.call("matchadd", ["Comment", "\\%1l"], true);
    nvim.call("matchadd", ["Conceal", "^\\%u3000"], true);
    nvim.call("matchadd", ["Label", "^\\%u3000\\zs\\S\\+"], true);
    nvim.command("setl nomod", true);
    if (filetype)
      nvim.command(`runtime! syntax/${filetype}.vim`, true);
    nvim.call("coc#util#do_autocmd", ["CocRefactorOpen"], true);
    await nvim.resumeNotification();
    let [bufnr, win] = await nvim.eval('[bufnr("%"),win_getid()]');
    let opts = { fromWinid, winid: win, cwd };
    await workspace_default.document;
    let buf = new RefactorBuffer(bufnr, conceal ? void 0 : this.srcId, this.nvim, this.config, opts);
    this.buffers.set(bufnr, buf);
    return buf;
  }
  async fromLines(lines) {
    let buf = await this.createRefactorBuffer();
    await buf.buffer.setLines(lines, { start: 0, end: -1, strictIndexing: false });
    return buf;
  }
  async fromLocations(locations, filetype) {
    if (!locations || locations.length == 0)
      return void 0;
    let changes = {};
    let edit2 = { changes };
    for (let location of locations) {
      let edits = changes[location.uri] || [];
      edits.push({ range: location.range, newText: "" });
      changes[location.uri] = edits;
    }
    return await this.fromWorkspaceEdit(edit2, filetype);
  }
  async fromWorkspaceEdit(edit2, filetype) {
    if (!edit2 || emptyWorkspaceEdit(edit2))
      return void 0;
    let items = [];
    let { beforeContext, afterContext } = this.config;
    let { changes, documentChanges } = edit2;
    if (!changes) {
      changes = {};
      for (let change of documentChanges || []) {
        if (import_vscode_languageserver_protocol117.TextDocumentEdit.is(change)) {
          let { textDocument, edits } = change;
          changes[textDocument.uri] = edits;
        }
      }
    }
    for (let key of Object.keys(changes)) {
      let max = await this.getLineCount(key);
      let edits = changes[key];
      let ranges = [];
      let start = null;
      let end = null;
      let highlights = [];
      edits.sort((a, b) => a.range.start.line - b.range.start.line);
      for (let edit3 of edits) {
        let { line } = edit3.range.start;
        let s = Math.max(0, line - beforeContext);
        if (start != null && s < end) {
          end = Math.min(max, line + afterContext + 1);
          highlights.push(adjustRange2(edit3.range, start));
        } else {
          if (start != null)
            ranges.push({ start, end, highlights });
          start = s;
          end = Math.min(max, line + afterContext + 1);
          highlights = [adjustRange2(edit3.range, start)];
        }
      }
      if (start != null)
        ranges.push({ start, end, highlights });
      items.push({
        ranges,
        filepath: URI2.parse(key).fsPath
      });
    }
    let buf = await this.createRefactorBuffer(filetype);
    await buf.addFileItems(items);
    return buf;
  }
  async getLineCount(uri) {
    let doc = workspace_default.getDocument(uri);
    if (doc)
      return doc.lineCount;
    return await getFileLineCount(URI2.parse(uri).fsPath);
  }
  reset() {
    for (let buf of this.buffers.values()) {
      buf.dispose();
    }
    this.buffers.clear();
  }
  dispose() {
    this._onCreate.dispose();
    this.buffers.clear();
    disposeAll(this.disposables);
  }
};
function adjustRange2(range2, offset) {
  let { start, end } = range2;
  return import_vscode_languageserver_protocol117.Range.create(start.line - offset, start.character, end.line - offset, end.character);
}

// src/handler/rename.ts
var import_vscode_languageserver_protocol118 = __toESM(require_main2());
init_languages();
init_position();
init_window();
init_workspace();
var logger125 = require_logger2()("handler-rename");
var Rename = class {
  constructor(nvim, handler) {
    this.nvim = nvim;
    this.handler = handler;
  }
  async getWordEdit() {
    let { doc, position } = await this.handler.getCurrentState();
    let range2 = doc.getWordRangeAtPosition(position);
    if (!range2 || emptyRange(range2))
      return null;
    let curname = doc.textDocument.getText(range2);
    if (languages_default.hasProvider("rename", doc.textDocument)) {
      await doc.synchronize();
      let requestTokenSource = new import_vscode_languageserver_protocol118.CancellationTokenSource();
      let res = await languages_default.prepareRename(doc.textDocument, position, requestTokenSource.token);
      if (res !== false) {
        let newName = curname.startsWith("a") ? "b" : "a";
        let edit2 = await languages_default.provideRenameEdits(doc.textDocument, position, newName, requestTokenSource.token);
        if (edit2)
          return edit2;
      }
    }
    window_default.showMessage("Rename provider not found, extract word ranges from current buffer", "more");
    let ranges = doc.getSymbolRanges(curname);
    return {
      changes: {
        [doc.uri]: ranges.map((r) => ({ range: r, newText: curname }))
      }
    };
  }
  async rename(newName) {
    let { doc, position } = await this.handler.getCurrentState();
    this.handler.checkProvier("rename", doc.textDocument);
    await doc.synchronize();
    let token = new import_vscode_languageserver_protocol118.CancellationTokenSource().token;
    let res = await languages_default.prepareRename(doc.textDocument, position, token);
    if (res === false) {
      void window_default.showWarningMessage("Invalid position for rename");
      return false;
    }
    let curname;
    if (!newName) {
      if (import_vscode_languageserver_protocol118.Range.is(res)) {
        curname = doc.textDocument.getText(res);
        await window_default.moveTo(res.start);
      } else if (res && typeof res.placeholder === "string") {
        curname = res.placeholder;
      } else {
        curname = await this.nvim.eval('expand("<cword>")');
      }
      const config = workspace_default.getConfiguration("coc.preferences");
      newName = await window_default.requestInput("New name", config.get("renameFillCurrent", true) ? curname : void 0);
    }
    if (newName === "")
      void window_default.showWarningMessage("Empty word, rename canceled");
    if (!newName)
      return false;
    let edit2 = await languages_default.provideRenameEdits(doc.textDocument, position, newName, token);
    if (token.isCancellationRequested || !edit2)
      return false;
    await workspace_default.applyEdit(edit2);
    this.nvim.redrawVim();
    return true;
  }
};

// src/handler/workspace.ts
init_esm();
var import_fs47 = __toESM(require("fs"));
var import_path41 = __toESM(require("path"));
init_extensions3();
init_types();
init_workspace();
init_manager3();
var logger126 = require_logger2()("handler-workspace");
var WorkspaceHandler = class {
  constructor(nvim, handler) {
    this.nvim = nvim;
    this.handler = handler;
  }
  async openLog() {
    let file = logger126.logfile;
    await workspace_default.jumpTo(URI2.file(file).toString());
  }
  async doAutocmd(id, args) {
    await workspace_default.autocmds.doAutocmd(id, args);
  }
  async getConfiguration(key) {
    let document2 = await workspace_default.document;
    return workspace_default.getConfiguration(key, document2 ? document2.uri : void 0);
  }
  getRootPatterns(bufnr) {
    let doc = workspace_default.getDocument(bufnr);
    if (!doc)
      return null;
    return {
      buffer: workspace_default.workspaceFolderControl.getRootPatterns(doc, 0 /* Buffer */),
      server: workspace_default.workspaceFolderControl.getRootPatterns(doc, 1 /* LanguageServer */) || [],
      global: workspace_default.workspaceFolderControl.getRootPatterns(doc, 2 /* Global */)
    };
  }
  async ensureDocument() {
    let doc = await workspace_default.document;
    return doc && !doc.isCommandLine && doc.attached;
  }
  async doKeymap(key, defaultReturn = "", pressed) {
    return await workspace_default.keymaps.doKeymap(key, defaultReturn, pressed);
  }
  async snippetCheck(checkExpand, checkJump) {
    if (checkExpand && !extensions_default.has("coc-snippets")) {
      this.nvim.echoError("coc-snippets required for check expand status!");
      return false;
    }
    if (checkJump) {
      let jumpable = manager_default3.jumpable();
      if (jumpable)
        return true;
    }
    if (checkExpand) {
      let api = extensions_default.getExtensionApi("coc-snippets");
      if (api && api.hasOwnProperty("expandable")) {
        let expandable = await Promise.resolve(api.expandable());
        if (expandable)
          return true;
      }
    }
    return false;
  }
  async showInfo() {
    let lines = [];
    let version2 = workspace_default.version + (true ? "-a09d279b 2022-09-01 00:35:22 +0800" : "");
    lines.push("## versions");
    lines.push("");
    let out = await this.nvim.call("execute", ["version"]);
    let first = out.trim().split(/\r?\n/, 2)[0].replace(/\(.*\)/, "").trim();
    lines.push("vim version: " + first + `${workspace_default.isVim ? " " + workspace_default.env.version : ""}`);
    lines.push("node version: " + process.version);
    lines.push("coc.nvim version: " + version2);
    lines.push("coc.nvim directory: " + import_path41.default.dirname(__dirname));
    lines.push("term: " + (process.env.TERM_PROGRAM || process.env.TERM));
    lines.push("platform: " + process.platform);
    lines.push("");
    lines.push("## Log of coc.nvim");
    lines.push("");
    let file = logger126.logfile;
    if (import_fs47.default.existsSync(file)) {
      let content = import_fs47.default.readFileSync(file, { encoding: "utf8" });
      lines.push(...content.split(/\r?\n/));
    }
    await this.nvim.command("vnew +setl\\ buftype=nofile\\ bufhidden=wipe\\ nobuflisted");
    let buf = await this.nvim.buffer;
    await buf.setLines(lines, { start: 0, end: -1, strictIndexing: false });
  }
};

// src/handler/selectionRange.ts
var import_vscode_languageserver_protocol119 = __toESM(require_main2());
init_languages();
init_object();
init_position();
init_window();
var SelectionRangeHandler = class {
  constructor(nvim, handler) {
    this.nvim = nvim;
    this.handler = handler;
    this.selectionRange = null;
  }
  async getSelectionRanges() {
    let { doc, position } = await this.handler.getCurrentState();
    this.handler.checkProvier("selectionRange", doc.textDocument);
    await doc.synchronize();
    let selectionRanges = await this.handler.withRequestToken("selection ranges", (token) => {
      return languages_default.getSelectionRanges(doc.textDocument, [position], token);
    });
    return selectionRanges;
  }
  async selectRange(visualmode, forward) {
    let { nvim } = this;
    let { doc } = await this.handler.getCurrentState();
    this.handler.checkProvier("selectionRange", doc.textDocument);
    let positions2 = [];
    if (!forward && (!this.selectionRange || !visualmode))
      return;
    if (visualmode) {
      let range2 = await window_default.getSelectedRange(visualmode);
      positions2.push(range2.start, range2.end);
    } else {
      let position = await window_default.getCursorPosition();
      positions2.push(position);
    }
    if (!forward) {
      let curr = import_vscode_languageserver_protocol119.Range.create(positions2[0], positions2[1]);
      let { selectionRange: selectionRange2 } = this;
      while (selectionRange2 && selectionRange2.parent) {
        if (equals(selectionRange2.parent.range, curr)) {
          break;
        }
        selectionRange2 = selectionRange2.parent;
      }
      if (selectionRange2 && selectionRange2.parent) {
        await window_default.selectRange(selectionRange2.range);
      }
      return;
    }
    await doc.synchronize();
    let selectionRanges = await this.handler.withRequestToken("selection ranges", (token) => {
      return languages_default.getSelectionRanges(doc.textDocument, positions2, token);
    });
    if (!selectionRanges || selectionRanges.length == 0)
      return;
    let mode = await nvim.eval("mode()");
    if (mode != "n")
      await nvim.eval(`feedkeys("\\<Esc>", 'in')`);
    let selectionRange;
    if (selectionRanges.length == 1) {
      selectionRange = selectionRanges[0];
    } else {
      let end = positions2[1] ?? positions2[0];
      let r = import_vscode_languageserver_protocol119.Range.create(positions2[0], end);
      selectionRange = selectionRanges[0];
      while (selectionRange) {
        if (equals(r, selectionRange.range)) {
          selectionRange = selectionRange.parent;
          continue;
        }
        if (positionInRange(positions2[0], selectionRange.range) == 0 && positionInRange(end, selectionRange.range) == 0) {
          break;
        }
        selectionRange = selectionRange.parent;
      }
    }
    if (!selectionRange)
      return;
    this.selectionRange = selectionRanges[0];
    await window_default.selectRange(selectionRange.range);
  }
};

// src/handler/callHierarchy.ts
var import_path42 = __toESM(require("path"));
var import_vscode_languageserver_protocol120 = __toESM(require_main2());
init_esm();
init_commands2();
init_events();
init_languages();
init_tree();
init_TreeView();
init_util();
init_lodash();
init_window();
init_workspace();
var logger127 = require_logger2()("Handler-callHierarchy");
function isCallHierarchyItem(item) {
  if (item && typeof item.name === "string" && item.kind && import_vscode_languageserver_protocol120.Range.is(item.range))
    return true;
  return false;
}
var _CallHierarchyHandler = class {
  constructor(nvim, handler) {
    this.nvim = nvim;
    this.handler = handler;
    this.disposables = [];
    this.highlightWinids = /* @__PURE__ */ new Set();
    this.loadConfiguration();
    workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
    this.disposables.push(commands_default.registerCommand(_CallHierarchyHandler.commandId, async (winid, item, openCommand) => {
      var _a;
      let { nvim: nvim2 } = this;
      await nvim2.call("win_gotoid", [winid]);
      await workspace_default.jumpTo(item.uri, item.selectionRange.start, openCommand);
      let win = await nvim2.window;
      win.clearMatchGroup(_CallHierarchyHandler.rangesHighlight);
      win.highlightRanges(_CallHierarchyHandler.rangesHighlight, [item.selectionRange], 10, true);
      if (!((_a = item.ranges) == null ? void 0 : _a.length))
        return;
      if (item.sourceUri) {
        let doc = workspace_default.getDocument(item.sourceUri);
        if (!doc)
          return;
        let winid2 = await nvim2.call("coc#compat#buf_win_id", [doc.bufnr]);
        if (winid2 == -1)
          return;
        if (winid2 != win.id) {
          win = nvim2.createWindow(winid2);
          win.clearMatchGroup(_CallHierarchyHandler.rangesHighlight);
        }
      }
      win.highlightRanges(_CallHierarchyHandler.rangesHighlight, item.ranges, 100, true);
      this.highlightWinids.add(win.id);
    }, null, true));
    events_default.on("BufWinEnter", (_, winid) => {
      if (this.highlightWinids.has(winid)) {
        this.highlightWinids.delete(winid);
        let win = nvim.createWindow(winid);
        win.clearMatchGroup(_CallHierarchyHandler.rangesHighlight);
      }
    }, null, this.disposables);
  }
  loadConfiguration(e) {
    if (!e || e.affectsConfiguration("callHierarchy")) {
      let c = workspace_default.getConfiguration("callHierarchy");
      this.config = {
        splitCommand: c.get("splitCommand"),
        openCommand: c.get("openCommand"),
        enableTooltip: c.get("enableTooltip")
      };
    }
  }
  createProvider(rootItems, doc, winid, position, kind) {
    let _onDidChangeTreeData = new import_vscode_languageserver_protocol120.Emitter();
    let source;
    const cancel = () => {
      if (source) {
        source.cancel();
        source.dispose();
        source = null;
      }
    };
    const findParent = (curr, element) => {
      let children = curr.children;
      if (!Array.isArray(children))
        return void 0;
      let find = children.find((o) => o == element);
      if (find)
        return curr;
      for (let item of children) {
        let res = findParent(item, element);
        if (res)
          return res;
      }
    };
    let provider = {
      kind,
      onDidChangeTreeData: _onDidChangeTreeData.event,
      getTreeItem: (element) => {
        var _a;
        let item = new TreeItem(element.name, element.children ? 2 /* Expanded */ : 1 /* Collapsed */);
        if (this.config.enableTooltip) {
          item.tooltip = import_path42.default.relative(workspace_default.cwd, URI2.parse(element.uri).fsPath);
        }
        item.description = element.detail;
        item.deprecated = (_a = element.tags) == null ? void 0 : _a.includes(import_vscode_languageserver_protocol120.SymbolTag.Deprecated);
        item.icon = this.handler.getIcon(element.kind);
        item.command = {
          command: _CallHierarchyHandler.commandId,
          title: "open location",
          arguments: [winid, element, this.config.openCommand]
        };
        return item;
      },
      getChildren: async (element) => {
        cancel();
        source = new import_vscode_languageserver_protocol120.CancellationTokenSource();
        let { token } = source;
        if (!element) {
          for (let o of rootItems) {
            let children = await this.getChildren(doc, o, provider.kind, token);
            if (token.isCancellationRequested)
              break;
            if (Array.isArray(children))
              o.children = children;
          }
          return rootItems;
        }
        if (element.children)
          return element.children;
        let items = await this.getChildren(doc, element, provider.kind, token);
        source = null;
        if (token.isCancellationRequested)
          return [];
        element.children = items;
        return items;
      },
      resolveActions: () => {
        return [{
          title: "Open in new tab",
          handler: async (element) => {
            await commands_default.executeCommand(_CallHierarchyHandler.commandId, winid, element, "tabe");
          }
        }, {
          title: "Show Incoming Calls",
          handler: (element) => {
            rootItems = [omit(element, ["children", "ranges", "sourceUri"])];
            provider.kind = "incoming";
            _onDidChangeTreeData.fire(void 0);
          }
        }, {
          title: "Show Outgoing Calls",
          handler: (element) => {
            rootItems = [omit(element, ["children", "ranges", "sourceUri"])];
            provider.kind = "outgoing";
            _onDidChangeTreeData.fire(void 0);
          }
        }, {
          title: "Dismiss",
          handler: async (element) => {
            let parentElement;
            for (let curr of rootItems) {
              parentElement = findParent(curr, element);
              if (parentElement)
                break;
            }
            if (!parentElement)
              return;
            let idx = parentElement.children.findIndex((o) => o === element);
            parentElement.children.splice(idx, 1);
            _onDidChangeTreeData.fire(parentElement);
          }
        }];
      },
      dispose: () => {
        cancel();
        _onDidChangeTreeData.dispose();
        rootItems = void 0;
        _onDidChangeTreeData = void 0;
      }
    };
    return provider;
  }
  async getChildren(doc, item, kind, token) {
    let items = [];
    if (kind == "incoming") {
      let res = await languages_default.provideIncomingCalls(doc, item, token);
      if (res)
        items = res.map((o) => Object.assign(o.from, { ranges: o.fromRanges }));
    } else {
      let res = await languages_default.provideOutgoingCalls(doc, item, token);
      if (res)
        items = res.map((o) => Object.assign(o.to, { ranges: o.fromRanges, sourceUri: item.uri }));
    }
    return items;
  }
  async prepare(doc, position, token) {
    this.handler.checkProvier("callHierarchy", doc);
    const res = await languages_default.prepareCallHierarchy(doc, position, token);
    return isCallHierarchyItem(res) ? [res] : res;
  }
  async getCallHierarchyItems(item, kind) {
    const { doc, position } = await this.handler.getCurrentState();
    const source = new import_vscode_languageserver_protocol120.CancellationTokenSource();
    if (!item) {
      await doc.synchronize();
      let res = await this.prepare(doc.textDocument, position, source.token);
      item = res ? res[0] : void 0;
      if (!res)
        throw new Error("Unable to getCallHierarchyItem at current position");
    }
    let method = kind == "incoming" ? "provideIncomingCalls" : "provideOutgoingCalls";
    return await languages_default[method](doc.textDocument, item, source.token);
  }
  async getIncoming(item) {
    return await this.getCallHierarchyItems(item, "incoming");
  }
  async getOutgoing(item) {
    return await this.getCallHierarchyItems(item, "outgoing");
  }
  async showCallHierarchyTree(kind) {
    const { doc, position, winid } = await this.handler.getCurrentState();
    await doc.synchronize();
    if (!languages_default.hasProvider("callHierarchy", doc.textDocument)) {
      void window_default.showErrorMessage(`CallHierarchy provider not found for current document, it's not supported by your languageserver`);
      return;
    }
    const res = await languages_default.prepareCallHierarchy(doc.textDocument, position, import_vscode_languageserver_protocol120.CancellationToken.None);
    const rootItems = isCallHierarchyItem(res) ? [res] : res;
    if (!Array.isArray(rootItems) || rootItems.length == 0) {
      void window_default.showWarningMessage("Unable to get CallHierarchyItem at cursor position.");
      return;
    }
    let provider = this.createProvider(rootItems, doc.textDocument, winid, position, kind);
    let treeView = new BasicTreeView("calls", { treeDataProvider: provider });
    treeView.title = `${kind.toUpperCase()} CALLS`;
    provider.onDidChangeTreeData((e) => {
      if (!e)
        treeView.title = `${provider.kind.toUpperCase()} CALLS`;
    });
    treeView.onDidChangeVisibility((e) => {
      if (!e.visible)
        provider.dispose();
    });
    this.disposables.push(treeView);
    await treeView.show(this.config.splitCommand);
  }
  dispose() {
    this.highlightWinids.clear();
    disposeAll(this.disposables);
  }
};
var CallHierarchyHandler = _CallHierarchyHandler;
CallHierarchyHandler.commandId = "callHierarchy.reveal";
CallHierarchyHandler.rangesHighlight = "CocSelectedRange";

// src/handler/semanticTokens/index.ts
init_commands2();
init_events();
init_languages();
init_highligher();
init_util();
init_array();
init_string();
init_window();
init_workspace();

// src/handler/semanticTokens/buffer.ts
var import_debounce13 = __toESM(require_debounce());
var import_vscode_languageserver_protocol121 = __toESM(require_main2());
init_languages();

// src/model/regions.ts
var Regions = class {
  constructor() {
    this.ranges = [];
  }
  get current() {
    let res = [];
    this.ranges.sort((a, b) => a[0] - b[0]);
    this.ranges.forEach((o) => {
      res.push(o[0], o[1]);
    });
    return res;
  }
  clear() {
    this.ranges = [];
  }
  add(start, end) {
    if (start > end) {
      [start, end] = [end, start];
    }
    let { ranges } = this;
    if (ranges.length == 0) {
      ranges.push([start, end]);
    } else {
      ranges.sort((a, b) => a[0] - b[0]);
      let s;
      let e;
      let removedIndexes = [];
      for (let i = 0; i < ranges.length; i++) {
        let r = ranges[i];
        if (r[1] < start || r[0] > end)
          continue;
        removedIndexes.push(i);
        if (s == null)
          s = Math.min(start, r[0]);
        e = Math.max(end, r[1]);
      }
      let newRanges = removedIndexes.length ? ranges.filter((_, i) => !removedIndexes.includes(i)) : ranges;
      this.ranges = newRanges;
      if (s != null && e != null) {
        this.ranges.push([s, e]);
      } else {
        this.ranges.push([start, end]);
      }
    }
  }
  has(start, end) {
    let idx = this.ranges.findIndex((o) => o[0] <= start && o[1] >= end);
    return idx !== -1;
  }
  static mergeSpans(ranges) {
    let res = [];
    for (let r of ranges) {
      let idx = res.findIndex((o) => !(r[1] < o[0] || r[0] > o[1]));
      if (idx == -1) {
        res.push(r);
      } else {
        let o = res[idx];
        res[idx] = [Math.min(r[0], o[0]), Math.max(r[1], o[1])];
      }
    }
    return res;
  }
};

// src/handler/semanticTokens/buffer.ts
init_errors();
init_util();
init_string();
init_window();
init_workspace();
var logger128 = require_logger2()("semanticTokens-buffer");
var yieldEveryMilliseconds = 15;
var HLGROUP_PREFIX = "CocSem";
var NAMESPACE3 = "semanticTokens";
var debounceInterval = global.__TEST__ ? 10 : 100;
var SemanticTokensBuffer = class {
  constructor(nvim, doc, config) {
    this.nvim = nvim;
    this.doc = doc;
    this.config = config;
    this._dirty = false;
    this.regions = new Regions();
    this._onDidRefresh = new import_vscode_languageserver_protocol121.Emitter();
    this.onDidRefresh = this._onDidRefresh.event;
    this.highlight = (0, import_debounce13.default)(() => {
      void this.doHighlight();
    }, debounceInterval);
    this.highlight();
  }
  get bufnr() {
    return this.doc.bufnr;
  }
  onChange() {
    this.highlight();
  }
  onTextChange() {
    this.cancel();
  }
  async forceHighlight() {
    this.previousResults = void 0;
    this._highlights = void 0;
    this.clearHighlight();
    this.cancel();
    await this.doHighlight(true);
  }
  async onShown() {
    if (this.shouldRangeHighlight)
      return;
    const { doc } = this;
    if (doc.dirty || doc.version === this._version)
      return;
    await this.doHighlight(false, true);
  }
  get hasProvider() {
    let { textDocument } = this.doc;
    return languages_default.hasProvider("semanticTokens", textDocument) || languages_default.hasProvider("semanticTokensRange", textDocument);
  }
  get hasLegend() {
    let { textDocument } = this.doc;
    return languages_default.getLegend(textDocument) != null || languages_default.getLegend(textDocument, true) != null;
  }
  get rangeProviderOnly() {
    let { textDocument } = this.doc;
    return !languages_default.hasProvider("semanticTokens", textDocument) && languages_default.hasProvider("semanticTokensRange", textDocument);
  }
  get shouldRangeHighlight() {
    let { textDocument } = this.doc;
    return languages_default.hasProvider("semanticTokensRange", textDocument) && this.previousResults == null;
  }
  get lineCount() {
    return this.doc.lineCount;
  }
  get highlights() {
    if (!this._highlights)
      return void 0;
    if (this._highlights[0] == this.doc.version)
      return this._highlights[1];
    return void 0;
  }
  get buffer() {
    return this.nvim.createBuffer(this.bufnr);
  }
  get enabled() {
    var _a;
    if (!this.config.filetypes.length)
      return false;
    if (!workspace_default.env.updateHighlight)
      return false;
    if (!((_a = this.doc) == null ? void 0 : _a.attached))
      return false;
    if (!this.hasLegend)
      return false;
    if (!this.config.filetypes.includes("*") && !this.config.filetypes.includes(this.doc.filetype))
      return false;
    return this.hasProvider;
  }
  checkState() {
    if (!workspace_default.env.updateHighlight) {
      throw new Error(`Can't perform highlight update, highlight update requires vim >= 8.1.1719 or neovim >= 0.5.0`);
    }
    if (!this.doc.attached)
      throw new Error(`Document not attached, ${this.doc.notAttachReason}`);
    let { filetypes } = this.config;
    if (!(filetypes == null ? void 0 : filetypes.includes("*")) && !filetypes.includes(this.doc.filetype)) {
      throw new Error(`Semantic tokens highlight not enabled for current filetype: ${this.doc.filetype}`);
    }
    if (!this.hasProvider)
      throw new Error(`SemanticTokens provider not found for ${this.doc.uri}`);
  }
  async getTokenRanges(tokens, legend, token) {
    let currentLine = 0;
    let currentCharacter = 0;
    let tickStart = Date.now();
    let highlights = [];
    for (let i = 0; i < tokens.length; i += 5) {
      if (Date.now() - tickStart > yieldEveryMilliseconds) {
        await waitImmediate();
        if (token.isCancellationRequested)
          break;
        tickStart = Date.now();
      }
      const deltaLine = tokens[i];
      const deltaStartCharacter = tokens[i + 1];
      const length = tokens[i + 2];
      const tokenType = legend.tokenTypes[tokens[i + 3]];
      const tokenModifiers = legend.tokenModifiers.filter((_, m) => tokens[i + 4] & 1 << m);
      const lnum = currentLine + deltaLine;
      const startCharacter = deltaLine === 0 ? currentCharacter + deltaStartCharacter : deltaStartCharacter;
      const endCharacter = startCharacter + length;
      currentLine = lnum;
      currentCharacter = startCharacter;
      this.addHighlightItems(highlights, lnum, startCharacter, endCharacter, tokenType, tokenModifiers);
    }
    if (token.isCancellationRequested)
      return null;
    return highlights;
  }
  addHighlightItems(highlights, lnum, startCharacter, endCharacter, tokenType, tokenModifiers) {
    let { highlightGroups, combinedModifiers } = this.config;
    tokenModifiers = tokenModifiers || [];
    let highlightGroup2;
    let combine = false;
    for (let item of tokenModifiers) {
      let hlGroup = HLGROUP_PREFIX + upperFirst(item) + upperFirst(tokenType);
      if (highlightGroups.includes(hlGroup)) {
        combine = combinedModifiers.includes(item);
        highlightGroup2 = hlGroup;
        break;
      }
    }
    if (!highlightGroup2) {
      for (let item of tokenModifiers) {
        let hlGroup = HLGROUP_PREFIX + upperFirst(item);
        if (highlightGroups.includes(hlGroup)) {
          highlightGroup2 = hlGroup;
          combine = combinedModifiers.includes(item);
          break;
        }
      }
    }
    if (!highlightGroup2) {
      let hlGroup = HLGROUP_PREFIX + upperFirst(tokenType);
      if (highlightGroups.includes(hlGroup)) {
        highlightGroup2 = hlGroup;
      }
    }
    let line = this.doc.getline(lnum);
    let colStart = byteIndex(line, startCharacter);
    let colEnd = byteIndex(line, endCharacter);
    highlights.push({
      range: [lnum, colStart, colEnd],
      tokenType,
      combine,
      hlGroup: highlightGroup2,
      tokenModifiers
    });
  }
  toHighlightItems(highlights, startLine, endLine) {
    let { incrementTypes } = this.config;
    let filter2 = typeof startLine === "number" && typeof endLine === "number";
    let res = [];
    for (let hi of highlights) {
      if (!hi.hlGroup)
        continue;
      let lnum = hi.range[0];
      if (filter2 && (lnum < startLine || lnum >= endLine))
        continue;
      let item = {
        lnum,
        hlGroup: hi.hlGroup,
        colStart: hi.range[1],
        colEnd: hi.range[2],
        combine: hi.combine
      };
      if (incrementTypes.includes(hi.tokenType)) {
        item.end_incl = true;
        item.start_incl = true;
      }
      res.push(item);
    }
    return res;
  }
  async doHighlight(forceFull = false, onShown = false) {
    var _a;
    this.cancel();
    if (!this.enabled)
      return;
    let tokenSource = this.tokenSource = new import_vscode_languageserver_protocol121.CancellationTokenSource();
    let token = tokenSource.token;
    if (!onShown) {
      let hidden = await this.nvim.eval(`get(get(getbufinfo(${this.bufnr}),0,{}),'hidden',0)`);
      if (hidden == 1 || token.isCancellationRequested)
        return;
    }
    if (this.shouldRangeHighlight) {
      let rangeTokenSource = this.rangeTokenSource = new import_vscode_languageserver_protocol121.CancellationTokenSource();
      await this.doRangeHighlight(rangeTokenSource.token);
      if (token.isCancellationRequested || this.rangeProviderOnly)
        return;
    }
    const { doc } = this;
    const version2 = doc.version;
    let tokenRanges;
    if (version2 === ((_a = this.previousResults) == null ? void 0 : _a.version)) {
      if (this._highlights && this._highlights[0] == version2) {
        tokenRanges = this._highlights[1];
      } else {
        const tokens = this.previousResults.tokens;
        const legend = languages_default.getLegend(doc.textDocument);
        tokenRanges = await this.getTokenRanges(tokens, legend, token);
        if (tokenRanges)
          this._highlights = [version2, tokenRanges];
      }
    } else {
      tokenRanges = await this.sendRequest(() => {
        return this.requestAllHighlights(token, forceFull);
      }, token);
      if (tokenRanges)
        this._highlights = [version2, tokenRanges];
    }
    if (!tokenRanges || token.isCancellationRequested)
      return;
    if (!this._dirty || tokenRanges.length < 200) {
      let items = this.toHighlightItems(tokenRanges);
      let diff = await window_default.diffHighlights(this.bufnr, NAMESPACE3, items, void 0, token);
      if (token.isCancellationRequested || !diff)
        return;
      this._dirty = true;
      this._version = version2;
      const priority = this.config.highlightPriority;
      await window_default.applyDiffHighlights(this.bufnr, NAMESPACE3, priority, diff);
    } else {
      this.regions.clear();
      await this.highlightRegions(token);
    }
    this._onDidRefresh.fire();
  }
  async waitRefresh() {
    return new Promise((resolve3, reject) => {
      let timer = setTimeout(() => {
        disposable.dispose();
        reject(new Error(`Timeout after 500ms`));
      }, 500);
      let disposable = this.onDidRefresh(() => {
        disposable.dispose();
        clearTimeout(timer);
        resolve3();
      });
    });
  }
  async sendRequest(fn, token) {
    try {
      return await fn();
    } catch (e) {
      if (!token.isCancellationRequested) {
        if (e instanceof CancellationError) {
          this.highlight();
        } else {
          logger128.error("Error on request semanticTokens: ", e);
        }
      }
      return void 0;
    }
  }
  async doRangeHighlight(token) {
    if (!this.enabled)
      return;
    let { version: version2 } = this.doc;
    let res = await this.sendRequest(() => {
      return this.requestRangeHighlights(token);
    }, token);
    if (res == null || token.isCancellationRequested)
      return;
    const { highlights, start, end } = res;
    if (this.rangeProviderOnly || !this.previousResults) {
      if (!this._highlights || version2 !== this._highlights[0]) {
        this._highlights = [version2, []];
      }
      let tokenRanges = this._highlights[1];
      let used = tokenRanges.reduce((p, c) => p.add(c.range[0]), /* @__PURE__ */ new Set());
      highlights.forEach((hi) => {
        if (!used.has(hi.range[0])) {
          tokenRanges.push(hi);
        }
      });
    }
    const items = this.toHighlightItems(highlights);
    const priority = this.config.highlightPriority;
    let diff = await window_default.diffHighlights(this.bufnr, NAMESPACE3, items, [start, end], token);
    if (diff) {
      await window_default.applyDiffHighlights(this.bufnr, NAMESPACE3, priority, diff, true);
      this._dirty = true;
    }
  }
  async highlightRegions(token, skipCheck = false) {
    let { regions, highlights, config, lineCount, bufnr } = this;
    if (!highlights)
      return;
    let priority = config.highlightPriority;
    let spans = await this.nvim.call("coc#window#visible_ranges", [bufnr]);
    if (token.isCancellationRequested || spans.length === 0)
      return;
    let height = workspace_default.env.lines;
    spans.forEach((o) => {
      let s = o[0];
      o[0] = Math.max(0, Math.floor(s - height * 1.5));
      o[1] = Math.min(lineCount, Math.ceil(o[1] + height * 1.5), s + height * 2);
    });
    for (let [start, end] of Regions.mergeSpans(spans)) {
      if (!skipCheck && regions.has(start, end))
        continue;
      let items = this.toHighlightItems(highlights, start, end);
      let diff = await window_default.diffHighlights(bufnr, NAMESPACE3, items, [start, end], token);
      if (token.isCancellationRequested)
        break;
      regions.add(start, end);
      if (diff)
        void window_default.applyDiffHighlights(bufnr, NAMESPACE3, priority, diff, true);
    }
  }
  async onCursorMoved() {
    this.cancel(true);
    if (!this.enabled || this.doc.dirty)
      return;
    let rangeTokenSource = this.rangeTokenSource = new import_vscode_languageserver_protocol121.CancellationTokenSource();
    let token = rangeTokenSource.token;
    await wait(global.__TEST__ ? 10 : 100);
    if (token.isCancellationRequested)
      return;
    if (this.shouldRangeHighlight) {
      await this.doRangeHighlight(token);
    } else {
      await this.highlightRegions(token);
    }
  }
  async requestRangeHighlights(token) {
    let { nvim, doc } = this;
    let region = await nvim.call("coc#window#visible_range", [this.bufnr]);
    if (!region || token.isCancellationRequested)
      return null;
    const endLine = Math.min(region[0] + workspace_default.env.lines * 2, region[1]);
    let range2 = import_vscode_languageserver_protocol121.Range.create(region[0] - 1, 0, endLine, 0);
    let res = await languages_default.provideDocumentRangeSemanticTokens(doc.textDocument, range2, token);
    if (!res || !import_vscode_languageserver_protocol121.SemanticTokens.is(res) || token.isCancellationRequested)
      return null;
    let legend = languages_default.getLegend(doc.textDocument, true);
    let highlights = await this.getTokenRanges(res.data, legend, token);
    if (token.isCancellationRequested)
      return null;
    return { highlights, start: region[0] - 1, end: region[1] };
  }
  async requestAllHighlights(token, forceFull) {
    const { doc } = this;
    const legend = languages_default.getLegend(doc.textDocument);
    const hasEditProvider = languages_default.hasSemanticTokensEdits(doc.textDocument);
    const previousResult = forceFull ? null : this.previousResults;
    const version2 = doc.version;
    let result;
    if (hasEditProvider && (previousResult == null ? void 0 : previousResult.resultId)) {
      result = await languages_default.provideDocumentSemanticTokensEdits(doc.textDocument, previousResult.resultId, token);
    } else {
      result = await languages_default.provideDocumentSemanticTokens(doc.textDocument, token);
    }
    if (token.isCancellationRequested || result == null)
      return;
    let tokens = [];
    if (import_vscode_languageserver_protocol121.SemanticTokens.is(result)) {
      tokens = result.data;
    } else if (previousResult && Array.isArray(result.edits)) {
      tokens = previousResult.tokens;
      result.edits.forEach((e) => {
        tokens.splice(e.start, e.deleteCount ? e.deleteCount : 0, ...e.data ?? []);
      });
    }
    this.previousResults = { resultId: result.resultId, tokens, version: version2 };
    return await this.getTokenRanges(tokens, legend, token);
  }
  clearHighlight() {
    this.buffer.clearNamespace(NAMESPACE3);
  }
  abandonResult() {
    this.previousResults = void 0;
  }
  cancel(rangeOnly = false) {
    if (this.rangeTokenSource) {
      this.rangeTokenSource.cancel();
      this.rangeTokenSource.dispose();
      this.rangeTokenSource = null;
    }
    if (rangeOnly)
      return;
    this.regions.clear();
    this.highlight.clear();
    if (this.tokenSource) {
      this.tokenSource.cancel();
      this.tokenSource.dispose();
      this.tokenSource = null;
    }
  }
  dispose() {
    this.cancel();
    this.previousResults = void 0;
    this._highlights = void 0;
    this._onDidRefresh.dispose();
  }
};

// src/handler/semanticTokens/index.ts
var logger129 = require_logger2()("semanticTokens");
var headGroup = "Statement";
var SemanticTokens6 = class {
  constructor(nvim) {
    this.nvim = nvim;
    this.disposables = [];
    this.loadConfiguration();
    this.floatFactory = window_default.createFloatFactory({
      title: "Semantic token info",
      highlight: "Normal",
      borderhighlight: "MoreMsg",
      border: [1, 1, 1, 1]
    });
    workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
    commands_default.register({
      id: "semanticTokens.checkCurrent",
      execute: async () => {
        await this.showHighlightInfo();
      }
    }, false, "show semantic tokens highlight information of current buffer");
    commands_default.register({
      id: "semanticTokens.refreshCurrent",
      execute: () => {
        return this.highlightCurrent();
      }
    }, false, "refresh semantic tokens highlight of current buffer.");
    commands_default.register({
      id: "semanticTokens.inspect",
      execute: () => {
        return this.inspectSemanticToken();
      }
    }, false, "Inspect semantic token information at cursor position.");
    commands_default.register({
      id: "semanticTokens.clearCurrent",
      execute: async () => {
        let buf = await nvim.buffer;
        buf.clearNamespace(NAMESPACE3, 0, -1);
      }
    }, false, "clear semantic tokens highlight of current buffer");
    commands_default.register({
      id: "semanticTokens.clearAll",
      execute: async () => {
        let bufs = await nvim.buffers;
        for (let buf of bufs) {
          buf.clearNamespace(NAMESPACE3, 0, -1);
        }
      }
    }, false, "clear semantic tokens highlight of all buffers");
    this.highlighters = workspace_default.registerBufferSync((doc) => {
      return new SemanticTokensBuffer(this.nvim, doc, this.config);
    });
    languages_default.onDidSemanticTokensRefresh(async (selector) => {
      let visibleBufs = await this.nvim.call("coc#window#bufnrs");
      for (let item of this.highlighters.items) {
        let doc = workspace_default.getDocument(item.bufnr);
        if (!doc || !workspace_default.match(selector, doc.textDocument))
          continue;
        item.abandonResult();
        if (visibleBufs.includes(item.bufnr)) {
          item.highlight();
        }
      }
    }, null, this.disposables);
    events_default.on("BufWinEnter", async (bufnr) => {
      let item = this.highlighters.getItem(bufnr);
      if (item)
        await item.onShown();
    }, null, this.disposables);
    events_default.on("CursorMoved", async (bufnr) => {
      let item = this.highlighters.getItem(bufnr);
      if (item)
        await item.onCursorMoved();
    }, null, this.disposables);
  }
  loadConfiguration(e) {
    var _a;
    if (!e || e.affectsConfiguration("semanticTokens")) {
      let highlightGroups = [];
      if ((_a = this.config) == null ? void 0 : _a.highlightGroups) {
        highlightGroups = this.config.highlightGroups;
      } else {
        highlightGroups = workspace_default.env.semanticHighlights || [];
      }
      let config = workspace_default.getConfiguration("semanticTokens");
      this.config = Object.assign(this.config || {}, {
        highlightGroups,
        filetypes: config.get("filetypes", []),
        highlightPriority: config.get("highlightPriority", 2048),
        incrementTypes: config.get("incrementTypes", []),
        combinedModifiers: config.get("combinedModifiers", [])
      });
    }
  }
  async inspectSemanticToken() {
    let item = await this.getCurrentItem();
    if (!item || !item.enabled) {
      if (!item) {
        let doc = await workspace_default.document;
        void window_default.showErrorMessage(`Document not attached, ${doc == null ? void 0 : doc.notAttachReason}`);
      } else {
        try {
          item.checkState();
        } catch (e) {
          void window_default.showErrorMessage(e.message);
        }
      }
      this.floatFactory.close();
      return;
    }
    let [_, line, col] = await this.nvim.call("getcurpos", []);
    let highlights = item.highlights ?? [];
    let highlight = highlights.find((o) => {
      let column = col - 1;
      return o.range[0] === line - 1 && column >= o.range[1] && column < o.range[2];
    });
    if (highlight) {
      let modifiers = highlight.tokenModifiers || [];
      let highlights2 = [];
      if (highlight.hlGroup) {
        let s = "Highlight group: ".length;
        highlights2.push({
          lnum: 2,
          colStart: s,
          colEnd: s + highlight.hlGroup.length,
          hlGroup: highlight.hlGroup
        });
      }
      let docs = [{
        filetype: "txt",
        content: `Type: ${highlight.tokenType}
Modifiers: ${modifiers.join(", ")}
Highlight group: ${highlight.hlGroup || ""}`,
        highlights: highlights2
      }];
      await this.floatFactory.show(docs);
    } else {
      this.floatFactory.close();
    }
  }
  async fetchHighlightGroups() {
    let res = await this.nvim.call("coc#util#semantic_hlgroups");
    this.config.highlightGroups = res;
  }
  async getCurrentItem() {
    let buf = await this.nvim.buffer;
    let highlighter = this.highlighters.getItem(buf.id);
    if (!highlighter)
      null;
    return highlighter;
  }
  getItem(bufnr) {
    return this.highlighters.getItem(bufnr);
  }
  async highlightCurrent() {
    let item = await this.getCurrentItem();
    if (!item || !item.enabled)
      throw new Error(`Unable to perform semantic highlights for current buffer.`);
    await this.fetchHighlightGroups();
    await item.forceHighlight();
  }
  async showHighlightInfo() {
    let buf = await this.nvim.buffer;
    let { nvim } = this;
    let item = this.highlighters.getItem(buf.id);
    if (!item)
      return nvim.echoError("Document not attached.");
    let hl = new Highlighter();
    nvim.pauseNotification();
    nvim.command(`vs +setl\\ buftype=nofile __coc_semantic_highlights_${buf.id}__`, true);
    nvim.command(`setl bufhidden=wipe noswapfile nobuflisted wrap undolevels=-1`, true);
    nvim.call("bufnr", ["%"], true);
    let res = await nvim.resumeNotification();
    hl.addLine("Semantic highlights info", headGroup);
    hl.addLine("");
    try {
      item.checkState();
      let highlights = item.highlights ?? [];
      hl.addLine("The number of semantic tokens: ");
      hl.addText(String(highlights.length), "Number");
      hl.addLine("");
      hl.addLine("Semantic highlight groups used by current buffer", headGroup);
      hl.addLine("");
      const groups = distinct(highlights.filter((o) => o.hlGroup != null).map(({ hlGroup }) => hlGroup));
      for (const hlGroup of groups) {
        hl.addTexts([{ text: "-", hlGroup: "Comment" }, { text: " " }, { text: hlGroup, hlGroup }]);
      }
      hl.addLine("");
      hl.addLine("Tokens types that current Language Server supported:", headGroup);
      hl.addLine("");
      let doc = workspace_default.getDocument(item.bufnr);
      let legend = languages_default.getLegend(doc.textDocument) ?? languages_default.getLegend(doc.textDocument, true);
      if (legend.tokenTypes.length) {
        for (const t of [...new Set(legend.tokenTypes)]) {
          let text = HLGROUP_PREFIX + upperFirst(t);
          hl.addTexts([{ text: "-", hlGroup: "Comment" }, { text: " " }, { text, hlGroup: text }]);
        }
        hl.addLine("");
      } else {
        hl.addLine("No token types supported", "Comment");
        hl.addLine("");
      }
      hl.addLine("Tokens modifiers that current Language Server supported:", headGroup);
      hl.addLine("");
      if (legend.tokenModifiers.length) {
        for (const t of [...new Set(legend.tokenModifiers)]) {
          let text = HLGROUP_PREFIX + upperFirst(t);
          hl.addTexts([{ text: "-", hlGroup: "Comment" }, { text: " " }, { text, hlGroup: text }]);
        }
        hl.addLine("");
      } else {
        hl.addLine("No token modifiers exist", "Comment");
        hl.addLine("");
      }
    } catch (e) {
      hl.addLine(e instanceof Error ? e.message : e.toString(), "Error");
    }
    nvim.pauseNotification();
    let bufnr = res[0][2];
    hl.render(nvim.createBuffer(bufnr));
    nvim.resumeNotification(true, true);
  }
  dispose() {
    this.floatFactory.dispose();
    this.highlighters.dispose();
    disposeAll(this.disposables);
  }
};

// src/handler/signature.ts
var import_vscode_languageserver_protocol122 = __toESM(require_main2());
init_events();
init_languages();
init_util();
init_string();
init_window();
init_workspace();
var logger130 = require_logger2()("handler-signature");
var Signature = class {
  constructor(nvim, handler) {
    this.nvim = nvim;
    this.handler = handler;
    this.disposables = [];
    this.loadConfiguration();
    this.signatureFactory = window_default.createFloatFactory(Object.assign({
      preferTop: this.config.preferAbove,
      autoHide: false,
      modes: ["i", "ic", "s"]
    }, this.config.floatConfig));
    this.disposables.push(this.signatureFactory);
    workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
    events_default.on("CursorMovedI", async (bufnr, cursor) => {
      let pos = this.lastPosition;
      if (!pos)
        return;
      if (pos.bufnr == bufnr && pos.lnum == cursor[0] && pos.col <= cursor[1])
        return;
      this.signatureFactory.close();
    }, null, this.disposables);
    events_default.on(["InsertLeave", "BufEnter"], () => {
      var _a;
      (_a = this.tokenSource) == null ? void 0 : _a.cancel();
    }, null, this.disposables);
    events_default.on("TextChangedI", () => {
      if (this.config.hideOnChange) {
        this.signatureFactory.close();
      }
    }, null, this.disposables);
    events_default.on("TextInsert", async (bufnr, info, character) => {
      if (!this.config.trigger)
        return;
      let doc = this.getTextDocument(bufnr);
      if (!doc || !languages_default.shouldTriggerSignatureHelp(doc.textDocument, character))
        return;
      await this._triggerSignatureHelp(doc, { line: info.lnum - 1, character: info.pre.length }, false);
    }, null, this.disposables);
  }
  getTextDocument(bufnr) {
    let doc = workspace_default.getDocument(bufnr);
    if (!doc || doc.isCommandLine || !doc.attached)
      return;
    return doc;
  }
  loadConfiguration(e) {
    if (!e || e.affectsConfiguration("signature")) {
      let config = workspace_default.getConfiguration("signature");
      let target = config.get("target", "float");
      if (target == "float" && !workspace_default.floatSupported) {
        target = "echo";
      }
      this.config = {
        target,
        floatConfig: config.get("floatConfig", {}),
        trigger: config.get("enable", true),
        wait: Math.max(config.get("triggerSignatureWait", 500), 200),
        preferAbove: config.get("preferShownAbove", true),
        hideOnChange: config.get("hideOnTextChange", false)
      };
    }
  }
  async triggerSignatureHelp() {
    let { doc, position } = await this.handler.getCurrentState();
    if (!languages_default.hasProvider("signature", doc.textDocument))
      return false;
    return await this._triggerSignatureHelp(doc, position, true, 0);
  }
  async _triggerSignatureHelp(doc, position, invoke = true, offset = 0) {
    var _a;
    (_a = this.tokenSource) == null ? void 0 : _a.cancel();
    let tokenSource = this.tokenSource = new import_vscode_languageserver_protocol122.CancellationTokenSource();
    let token = tokenSource.token;
    token.onCancellationRequested(() => {
      tokenSource.dispose();
      this.tokenSource = void 0;
    });
    let { target } = this.config;
    let timer = this.timer = setTimeout(() => {
      tokenSource.cancel();
    }, this.config.wait);
    await doc.patchChange(true);
    let signatureHelp = await languages_default.getSignatureHelp(doc.textDocument, position, token, {
      isRetrigger: this.signatureFactory.checkRetrigger(doc.bufnr),
      triggerKind: invoke ? import_vscode_languageserver_protocol122.SignatureHelpTriggerKind.Invoked : import_vscode_languageserver_protocol122.SignatureHelpTriggerKind.TriggerCharacter
    });
    clearTimeout(timer);
    if (token.isCancellationRequested)
      return false;
    if (!signatureHelp || signatureHelp.signatures.length == 0) {
      this.signatureFactory.close();
      return false;
    }
    let { activeSignature, signatures } = signatureHelp;
    if (activeSignature) {
      let [active] = signatures.splice(activeSignature, 1);
      if (active)
        signatures.unshift(active);
    }
    if (target == "echo") {
      this.echoSignature(signatureHelp);
    } else {
      await this.showSignatureHelp(doc, position, signatureHelp, offset);
    }
    return true;
  }
  async showSignatureHelp(doc, position, signatureHelp, offset) {
    let { signatures, activeParameter } = signatureHelp;
    activeParameter = typeof activeParameter === "number" ? activeParameter : void 0;
    let paramDoc = null;
    let startOffset = offset;
    let docs = signatures.reduce((p, c, idx) => {
      var _a, _b;
      let activeIndexes = null;
      let activeIndex = c.activeParameter ?? activeParameter;
      if (activeIndex === void 0 && ((_a = c.parameters) == null ? void 0 : _a.length) > 0) {
        activeIndex = 0;
      }
      let nameIndex = c.label.indexOf("(");
      if (idx == 0 && typeof activeIndex === "number") {
        let active = (_b = c.parameters) == null ? void 0 : _b[activeIndex];
        if (active) {
          let after = c.label.slice(nameIndex == -1 ? 0 : nameIndex);
          paramDoc = active.documentation;
          if (typeof active.label === "string") {
            let str = after.slice(0);
            let ms = str.match(new RegExp("\\b" + active.label.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") + "\\b"));
            let index = ms ? ms.index : str.indexOf(active.label);
            if (index != -1) {
              activeIndexes = [
                index + nameIndex,
                index + active.label.length + nameIndex
              ];
            }
          } else {
            activeIndexes = active.label;
          }
        }
      }
      if (activeIndexes == null) {
        activeIndexes = [nameIndex + 1, nameIndex + 1];
      }
      if (offset == startOffset) {
        offset = offset + activeIndexes[0] + 1;
      }
      p.push({
        content: c.label,
        filetype: doc.filetype,
        active: activeIndexes
      });
      if (paramDoc) {
        let content2 = typeof paramDoc === "string" ? paramDoc : paramDoc.value;
        if (content2.trim().length) {
          p.push({
            content: content2,
            filetype: isMarkdown(c.documentation) ? "markdown" : "txt"
          });
        }
      }
      if (idx == 0 && c.documentation) {
        let { documentation } = c;
        let content2 = typeof documentation === "string" ? documentation : documentation.value;
        if (content2.trim().length) {
          p.push({
            content: content2,
            filetype: isMarkdown(c.documentation) ? "markdown" : "txt"
          });
        }
      }
      return p;
    }, []);
    let content = doc.getline(position.line, false).slice(0, position.character);
    this.lastPosition = { bufnr: doc.bufnr, lnum: position.line + 1, col: byteLength(content) + 1 };
    await this.signatureFactory.show(docs, { offsetX: offset });
  }
  echoSignature(signatureHelp) {
    var _a;
    let { signatures, activeParameter } = signatureHelp;
    let columns = workspace_default.env.columns;
    signatures = signatures.slice(0, workspace_default.env.cmdheight);
    let signatureList = [];
    for (let signature of signatures) {
      let parts = [];
      let { label } = signature;
      label = label.replace(/\n/g, " ");
      if (label.length >= columns - 16) {
        label = label.slice(0, columns - 16) + "...";
      }
      let nameIndex = label.indexOf("(");
      if (nameIndex == -1) {
        parts = [{ text: label, type: "Normal" }];
      } else {
        parts.push({
          text: label.slice(0, nameIndex),
          type: "Label"
        });
        let after = label.slice(nameIndex);
        if (signatureList.length == 0 && activeParameter != null) {
          let active = (_a = signature.parameters) == null ? void 0 : _a[activeParameter];
          if (active) {
            let start;
            let end;
            if (typeof active.label === "string") {
              let str = after.slice(0);
              let ms = str.match(new RegExp("\\b" + active.label.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") + "\\b"));
              let idx = ms ? ms.index : str.indexOf(active.label);
              if (idx == -1) {
                parts.push({ text: after, type: "Normal" });
              } else {
                start = idx;
                end = idx + active.label.length;
              }
            } else {
              [start, end] = active.label;
              start = start - nameIndex;
              end = end - nameIndex;
            }
            if (start != null && end != null) {
              parts.push({ text: after.slice(0, start), type: "Normal" });
              parts.push({ text: after.slice(start, end), type: "MoreMsg" });
              parts.push({ text: after.slice(end), type: "Normal" });
            }
          }
        } else {
          parts.push({
            text: after,
            type: "Normal"
          });
        }
      }
      signatureList.push(parts);
    }
    this.nvim.callTimer("coc#ui#echo_signatures", [signatureList], true);
  }
  dispose() {
    disposeAll(this.disposables);
    if (this.timer) {
      clearTimeout(this.timer);
    }
  }
};

// src/handler/symbols/index.ts
var import_vscode_languageserver_protocol127 = __toESM(require_main2());
init_events();
init_languages();
init_util();
init_object();
init_position();
init_window();
init_workspace();

// src/handler/symbols/buffer.ts
var import_debounce14 = __toESM(require_debounce());
var import_vscode_languageserver_protocol124 = __toESM(require_main2());
init_languages();
init_util();
init_workspace();

// src/handler/symbols/util.ts
var import_vscode_languageserver_protocol123 = __toESM(require_main2());
init_convert();
init_position();
function convertSymbols(symbols) {
  let res = [];
  let arr = symbols.slice();
  arr.sort(sortDocumentSymbols);
  arr.forEach((s) => addDocumentSymbol(res, s, 0));
  return res;
}
function sortDocumentSymbols(a, b) {
  let ra = a.selectionRange;
  let rb = b.selectionRange;
  return comparePosition(ra.start, rb.start);
}
function addDocumentSymbol(res, sym, level) {
  let { name: name2, selectionRange, detail, kind, children, range: range2, tags } = sym;
  let { start } = selectionRange || range2;
  let obj = {
    col: start.character + 1,
    lnum: start.line + 1,
    text: name2,
    level,
    kind: getSymbolKind(kind),
    range: range2,
    selectionRange
  };
  if (detail)
    obj.detail = detail;
  if (tags && tags.includes(import_vscode_languageserver_protocol123.SymbolTag.Deprecated))
    obj.deprecated = true;
  res.push(obj);
  if (children && children.length) {
    children.sort(sortDocumentSymbols);
    for (let sym2 of children) {
      addDocumentSymbol(res, sym2, level + 1);
    }
  }
}
function isDocumentSymbol(a) {
  return a && !a.hasOwnProperty("location");
}
function isDocumentSymbols(a) {
  return isDocumentSymbol(a[0]);
}

// src/handler/symbols/buffer.ts
var SymbolsBuffer = class {
  constructor(bufnr, autoUpdateBufnrs) {
    this.bufnr = bufnr;
    this.autoUpdateBufnrs = autoUpdateBufnrs;
    this.disposables = [];
    this._onDidUpdate = new import_vscode_languageserver_protocol124.Emitter();
    this.onDidUpdate = this._onDidUpdate.event;
    this.fetchSymbols = (0, import_debounce14.default)(() => {
      this._fetchSymbols().logError();
    }, global.hasOwnProperty("__TEST__") ? 10 : 500);
  }
  async getSymbols() {
    var _a;
    let doc = workspace_default.getDocument(this.bufnr);
    if (!doc)
      return [];
    await doc.patchChange();
    this.autoUpdateBufnrs.add(this.bufnr);
    if (doc.version == this.version && ((_a = this.symbols) == null ? void 0 : _a.length))
      return this.symbols;
    this.cancel();
    await this._fetchSymbols();
    return this.symbols;
  }
  onChange(e) {
    if (e.contentChanges.length === 0)
      return;
    this.cancel();
    if (this.autoUpdateBufnrs.has(this.bufnr)) {
      this.fetchSymbols();
    }
  }
  get textDocument() {
    var _a;
    return (_a = workspace_default.getDocument(this.bufnr)) == null ? void 0 : _a.textDocument;
  }
  async _fetchSymbols() {
    let { textDocument } = this;
    if (!textDocument)
      return;
    let { version: version2 } = textDocument;
    let tokenSource = this.tokenSource = new import_vscode_languageserver_protocol124.CancellationTokenSource();
    let { token } = tokenSource;
    let symbols = await languages_default.getDocumentSymbol(textDocument, token);
    this.tokenSource = void 0;
    if (symbols == null || token.isCancellationRequested)
      return;
    let res;
    if (isDocumentSymbols(symbols)) {
      res = symbols;
    } else {
      res = symbols.map((o) => {
        let sym = import_vscode_languageserver_protocol124.DocumentSymbol.create(o.name, "", o.kind, o.location.range, o.location.range);
        if (o.deprecated)
          sym.tags = [import_vscode_languageserver_protocol124.SymbolTag.Deprecated];
        return sym;
      });
    }
    this.version = version2;
    this.symbols = res;
    this._onDidUpdate.fire(res);
  }
  cancel() {
    this.fetchSymbols.clear();
    if (this.tokenSource) {
      this.tokenSource.cancel();
      this.tokenSource.dispose();
      this.tokenSource = null;
    }
  }
  dispose() {
    this.cancel();
    this.symbols = void 0;
    this._onDidUpdate.dispose();
    disposeAll(this.disposables);
  }
};

// src/handler/symbols/outline.ts
var import_vscode_languageserver_protocol126 = __toESM(require_main2());
init_events();
init_languages();

// src/tree/BasicDataProvider.ts
init_esm_node();
var import_vscode_languageserver_protocol125 = __toESM(require_main2());
init_commands2();
init_util();
init_TreeItem();
function isIcon(obj) {
  if (!obj)
    return false;
  return typeof obj.text === "string" && typeof obj.hlGroup === "string";
}
function sameTreeNode(one, two) {
  if (one.label === two.label && one.deprecated === two.deprecated && one.key === two.key) {
    return true;
  }
  return false;
}
function sameTreeNodes(one, two) {
  if (one.length !== two.length)
    return false;
  return one.every((v, idx) => sameTreeNode(v, two[idx]));
}
var BasicDataProvider = class {
  constructor(opts) {
    this.opts = opts;
    this.disposables = [];
    this._onDidChangeTreeData = new import_vscode_languageserver_protocol125.Emitter();
    this.onDidChangeTreeData = this._onDidChangeTreeData.event;
    this.invokeCommand = `_invoke_${v4_default()}`;
    this.disposables.push(commands_default.registerCommand(this.invokeCommand, async (node) => {
      if (typeof opts.handleClick === "function") {
        await opts.handleClick(node);
      } else {
        console.error("Handler not found");
      }
    }, null, true));
    if (typeof opts.resolveActions === "function") {
      this.resolveActions = opts.resolveActions.bind(this);
    }
  }
  iterate(node, parentNode, level, fn) {
    let res = fn(node, parentNode, level);
    if (res === false)
      return false;
    if (Array.isArray(node.children)) {
      for (let element of node.children) {
        let res2 = this.iterate(element, node, level + 1, fn);
        if (res2 === false)
          return false;
      }
    }
    return res;
  }
  updateNodes(old, data, parentNode, fireEvent = true) {
    let sameNodes = sameTreeNodes(old, data);
    const applyNode = (previous, curr, fireEvent2) => {
      var _a, _b, _c, _d, _e, _f;
      let changed = false;
      for (let key of Object.keys(curr)) {
        if (["children", "key"].includes(key))
          continue;
        previous[key] = curr[key];
      }
      if (((_a = previous.children) == null ? void 0 : _a.length) && !((_b = curr.children) == null ? void 0 : _b.length)) {
        delete previous.children;
        changed = true;
      }
      if (!((_c = previous.children) == null ? void 0 : _c.length) && ((_d = curr.children) == null ? void 0 : _d.length)) {
        previous.children = curr.children;
        changed = true;
      }
      if (changed) {
        if (fireEvent2)
          this._onDidChangeTreeData.fire(previous);
        return;
      }
      if (((_e = previous.children) == null ? void 0 : _e.length) && ((_f = curr.children) == null ? void 0 : _f.length)) {
        this.updateNodes(previous.children, curr.children, previous, fireEvent2);
      }
    };
    if (sameNodes) {
      for (let i = 0; i < old.length; i++) {
        applyNode(old[i], data[i], fireEvent);
      }
    } else {
      let oldNodes = old.splice(0, old.length);
      let used = /* @__PURE__ */ new Set();
      for (let i = 0; i < data.length; i++) {
        let curr = data[i];
        let findIndex2;
        if (curr.key) {
          findIndex2 = oldNodes.findIndex((o, i2) => !used.has(i2) && o.key == curr.key);
        } else {
          findIndex2 = oldNodes.findIndex((o, i2) => !used.has(i2) && o.label == curr.label);
        }
        if (findIndex2 === -1) {
          old[i] = curr;
        } else {
          used.add(findIndex2);
          let previous = oldNodes[findIndex2];
          applyNode(previous, curr, false);
          old[i] = previous;
        }
      }
      if (fireEvent) {
        this._onDidChangeTreeData.fire(parentNode);
      }
    }
  }
  update(data, reset) {
    if (!this.data)
      return;
    if (reset) {
      this.data = data || [];
      this._onDidChangeTreeData.fire(void 0);
    } else {
      this.updateNodes(this.data, data || [], void 0);
    }
    return this.data;
  }
  getTreeItem(node) {
    var _a;
    let label = node.label;
    let { expandLevel } = this.opts;
    let item;
    if (!((_a = node.children) == null ? void 0 : _a.length)) {
      item = new TreeItem(label);
    } else {
      if (expandLevel && expandLevel > 0) {
        let level = this.getLevel(node);
        let state = level && level <= expandLevel ? 2 /* Expanded */ : 1 /* Collapsed */;
        item = new TreeItem(label, state);
      } else {
        item = new TreeItem(label, 1 /* Collapsed */);
      }
    }
    item.description = node.description;
    if (node.deprecated)
      item.deprecated = true;
    if (node.tooltip)
      item.tooltip = node.tooltip;
    if (isIcon(node.icon)) {
      item.icon = node.icon;
    } else if (typeof this.opts.resolveIcon === "function") {
      let res = this.opts.resolveIcon(node);
      if (res)
        item.icon = res;
    }
    return item;
  }
  async getChildren(element) {
    if (element)
      return element.children || [];
    if (this.data)
      return this.data;
    let data = await Promise.resolve(this.opts.provideData());
    if (!Array.isArray(data))
      throw new Error(`Unable to fetch data`);
    this.data = data;
    return data;
  }
  getParent(element) {
    if (!this.data)
      return void 0;
    let find;
    for (let item of this.data) {
      let res = this.iterate(item, null, 0, (node, parentNode) => {
        if (node === element) {
          find = parentNode;
          return false;
        }
      });
      if (res === false)
        break;
    }
    return find;
  }
  getLevel(element) {
    if (!this.data)
      return void 0;
    let level = 0;
    for (let item of this.data) {
      let res = this.iterate(item, null, 1, (node, _parentNode, l) => {
        if (node === element) {
          level = l;
          return false;
        }
      });
      if (res === false)
        break;
    }
    return level;
  }
  async resolveTreeItem(item, element, token) {
    if (typeof this.opts.resolveItem === "function") {
      let res = await Promise.resolve(this.opts.resolveItem(item, element, token));
      if (res)
        Object.assign(item, res);
    }
    if (!item.command) {
      item.command = {
        title: `invoke ${element.label}`,
        command: this.invokeCommand,
        arguments: [element]
      };
    }
    return item;
  }
  dispose() {
    this.data = [];
    this._onDidChangeTreeData.dispose();
    if (typeof this.opts.onDispose === "function") {
      this.opts.onDispose();
    }
    disposeAll(this.disposables);
  }
};

// src/handler/symbols/outline.ts
init_TreeView();
init_util();
init_position();
init_window();
init_workspace();
var logger131 = require_logger2()("symbols-outline");
var SymbolsOutline = class {
  constructor(nvim, buffers, handler) {
    this.nvim = nvim;
    this.buffers = buffers;
    this.handler = handler;
    this.treeViewList = [];
    this.providersMap = /* @__PURE__ */ new Map();
    this.sortByMap = /* @__PURE__ */ new Map();
    this.disposables = [];
    this.loadConfiguration();
    workspace_default.onDidChangeConfiguration(this.loadConfiguration, this, this.disposables);
    workspace_default.onDidCloseTextDocument(async (e) => {
      let { bufnr } = e;
      let provider = this.providersMap.get(bufnr);
      if (!provider)
        return;
      let loaded = await nvim.call("bufloaded", [bufnr]);
      if (loaded)
        return;
      this.providersMap.delete(bufnr);
      provider.dispose();
    }, null, this.disposables);
    window_default.onDidChangeActiveTextEditor(async (editor) => {
      if (!this.config.checkBufferSwitch)
        return;
      let view = this.treeViewList.find((v) => v.visible && v.targetTabnr == editor.tabpagenr);
      if (view) {
        await this.showOutline(editor.document.bufnr, editor.tabpagenr);
        await nvim.command(`noa call win_gotoid(${editor.winid})`);
      }
    }, null, this.disposables);
    events_default.on("CursorHold", async (bufnr) => {
      if (!this.config.followCursor)
        return;
      let provider = this.providersMap.get(bufnr);
      if (!provider)
        return;
      let tabnr = await nvim.call("tabpagenr");
      let view = this.treeViewList.find((o) => o.visible && o.targetBufnr == bufnr && o.targetTabnr == tabnr);
      if (!view)
        return;
      let pos = await window_default.getCursorPosition();
      await this.revealPosition(view, pos);
    }, null, this.disposables);
  }
  async revealPosition(treeView, position) {
    let curr;
    let checkNode = (node) => {
      if (positionInRange(position, node.range) != 0)
        return false;
      curr = node;
      if (Array.isArray(node.children)) {
        for (let n of node.children) {
          if (n.kind === import_vscode_languageserver_protocol126.SymbolKind.Variable)
            continue;
          if (checkNode(n))
            break;
        }
      }
      return true;
    };
    let provider = this.providersMap.get(treeView.targetBufnr);
    if (!provider)
      return;
    let nodes = await Promise.resolve(provider.getChildren());
    for (let n of nodes) {
      if (checkNode(n))
        break;
    }
    if (curr)
      await treeView.reveal(curr);
  }
  loadConfiguration(e) {
    if (!e || e.affectsConfiguration("outline")) {
      let c = workspace_default.getConfiguration("outline");
      this.config = {
        splitCommand: c.get("splitCommand"),
        switchSortKey: c.get("switchSortKey"),
        followCursor: c.get("followCursor"),
        keepWindow: c.get("keepWindow"),
        expandLevel: c.get("expandLevel"),
        autoWidth: c.get("autoWidth"),
        checkBufferSwitch: c.get("checkBufferSwitch"),
        detailAsDescription: c.get("detailAsDescription"),
        sortBy: c.get("sortBy"),
        showLineNumber: c.get("showLineNumber"),
        codeActionKinds: c.get("codeActionKinds")
      };
    }
  }
  convertSymbolToNode(documentSymbol, sortFn) {
    var _a;
    let descs = [];
    let { detailAsDescription, showLineNumber } = this.config;
    if (detailAsDescription && documentSymbol.detail)
      descs.push(documentSymbol.detail);
    if (showLineNumber)
      descs.push(`${documentSymbol.selectionRange.start.line + 1}`);
    return {
      label: documentSymbol.name,
      tooltip: detailAsDescription ? void 0 : documentSymbol.detail,
      description: descs.join(" "),
      icon: this.handler.getIcon(documentSymbol.kind),
      deprecated: (_a = documentSymbol.tags) == null ? void 0 : _a.includes(import_vscode_languageserver_protocol126.SymbolTag.Deprecated),
      kind: documentSymbol.kind,
      range: documentSymbol.range,
      selectRange: documentSymbol.selectionRange,
      children: Array.isArray(documentSymbol.children) ? documentSymbol.children.map((o) => {
        return this.convertSymbolToNode(o, sortFn);
      }).sort(sortFn) : void 0
    };
  }
  setMessage(bufnr, msg) {
    let views = this.treeViewList.filter((v) => v.valid && v.targetBufnr == bufnr);
    if (views) {
      views.forEach((view) => {
        view.message = msg;
      });
    }
  }
  convertSymbols(bufnr, symbols) {
    let sortBy = this.getSortBy(bufnr);
    let sortFn = (a, b) => {
      if (sortBy === "name") {
        return a.label < b.label ? -1 : 1;
      }
      if (sortBy === "category") {
        if (a.kind == b.kind)
          return a.label < b.label ? -1 : 1;
        return a.kind - b.kind;
      }
      return comparePosition(a.selectRange.start, b.selectRange.start);
    };
    return symbols.map((s) => this.convertSymbolToNode(s, sortFn)).sort(sortFn);
  }
  onSymbolsUpdate(bufnr, symbols) {
    let provider = this.providersMap.get(bufnr);
    if (provider)
      provider.update(this.convertSymbols(bufnr, symbols));
  }
  createProvider(bufnr) {
    let { nvim } = this;
    let disposable;
    let provider = new BasicDataProvider({
      expandLevel: this.config.expandLevel,
      provideData: async () => {
        let buf = this.buffers.getItem(bufnr);
        if (!buf)
          throw new Error("Document not attached");
        let doc = workspace_default.getDocument(bufnr);
        if (!languages_default.hasProvider("documentSymbol", doc.textDocument)) {
          throw new Error("Document symbol provider not found");
        }
        let meta = languages_default.getDocumentSymbolMetadata(doc.textDocument);
        if (meta && meta.label) {
          let views = this.treeViewList.filter((v) => v.valid && v.targetBufnr == bufnr);
          views.forEach((view) => view.description = meta.label);
        }
        this.setMessage(bufnr, "Loading document symbols");
        let arr = await buf.getSymbols();
        if (!arr || arr.length == 0) {
          throw new Error("Empty symbols returned from language server. ");
        }
        this.setMessage(bufnr, void 0);
        return this.convertSymbols(bufnr, arr);
      },
      handleClick: async (item) => {
        let winnr = await nvim.call("bufwinnr", [bufnr]);
        if (winnr == -1)
          return;
        nvim.pauseNotification();
        nvim.command(`${winnr}wincmd w`, true);
        let pos = item.selectRange.start;
        nvim.call("coc#cursor#move_to", [pos.line, pos.character], true);
        nvim.command(`normal! zz`, true);
        let buf = nvim.createBuffer(bufnr);
        buf.highlightRanges("outline-hover", "CocHoverRange", [item.selectRange]);
        nvim.command("redraw", true);
        await nvim.resumeNotification();
        setTimeout(() => {
          buf.clearNamespace("outline-hover");
          nvim.command("redraw", true);
        }, global.hasOwnProperty("__TEST__") ? 10 : 300);
      },
      resolveActions: async (_, element) => {
        let winnr = await nvim.call("bufwinnr", [bufnr]);
        if (winnr == -1)
          return;
        let doc = workspace_default.getDocument(bufnr);
        let actions = await this.handler.getCodeActions(doc, element.range, this.config.codeActionKinds);
        let arr = actions.map((o) => {
          return {
            title: o.title,
            handler: async () => {
              let position = element.range.start;
              await nvim.command(`${winnr}wincmd w`);
              await this.nvim.call("coc#cursor#move_to", [position.line, position.character]);
              await this.handler.applyCodeAction(o);
            }
          };
        });
        return [...arr, {
          title: "Visual Select",
          handler: async (item) => {
            await nvim.command(`${winnr}wincmd w`);
            await window_default.selectRange(item.range);
          }
        }];
      },
      onDispose: () => {
        if (disposable)
          disposable.dispose();
        for (let view of this.treeViewList) {
          if (view.provider === provider)
            view.dispose();
        }
      }
    });
    return provider;
  }
  getSortBy(bufnr) {
    return this.sortByMap.get(bufnr) ?? this.config.sortBy;
  }
  async showOutline(bufnr, tabnr) {
    if (!this.providersMap.has(bufnr)) {
      this.providersMap.set(bufnr, this.createProvider(bufnr));
    }
    let treeView = this.treeViewList.find((v) => v.valid && v.targetBufnr == bufnr && v.targetTabnr == tabnr);
    if (!treeView) {
      treeView = new BasicTreeView("OUTLINE", {
        autoWidth: this.config.autoWidth,
        bufhidden: "hide",
        enableFilter: true,
        treeDataProvider: this.providersMap.get(bufnr)
      });
      let sortBy = this.getSortBy(bufnr);
      treeView.description = `${sortBy[0].toUpperCase()}${sortBy.slice(1)}`;
      this.treeViewList.push(treeView);
      treeView.onDispose(() => {
        let idx = this.treeViewList.findIndex((v) => v === treeView);
        if (idx !== -1)
          this.treeViewList.splice(idx, 1);
      });
    }
    let shown = await treeView.show(this.config.splitCommand);
    if (shown) {
      treeView.registerLocalKeymap("n", this.config.switchSortKey, async () => {
        let arr = ["category", "name", "position"];
        let curr = this.getSortBy(bufnr);
        let items = arr.map((s) => {
          return { text: s, disabled: s === curr };
        });
        let res = await window_default.showMenuPicker(items, { title: "Choose sort method" });
        if (res < 0)
          return;
        let sortBy = arr[res];
        this.sortByMap.set(bufnr, sortBy);
        let views = this.treeViewList.filter((o) => o.targetBufnr == bufnr);
        views.forEach((view) => {
          view.description = `${sortBy[0].toUpperCase()}${sortBy.slice(1)}`;
        });
        let item = this.buffers.getItem(bufnr);
        if (item && item.symbols)
          this.onSymbolsUpdate(bufnr, item.symbols);
      });
    }
    return treeView;
  }
  async show(keep) {
    let [filetype, bufnr, tabnr, winid] = await this.nvim.eval('[&filetype,bufnr("%"),tabpagenr(),win_getid()]');
    if (filetype === "coctree")
      return;
    let position = await window_default.getCursorPosition();
    let treeView = await this.showOutline(bufnr, tabnr);
    if (keep == 1 || keep === void 0 && this.config.keepWindow) {
      await this.nvim.command(`noa call win_gotoid(${winid})`);
    } else if (this.config.followCursor) {
      let disposable = treeView.onDidRefrash(async () => {
        disposable.dispose();
        let filetype2 = await this.nvim.eval("&filetype");
        if (filetype2 == "coctree" && treeView.visible) {
          await this.revealPosition(treeView, position);
        }
      });
    }
  }
  has(bufnr) {
    return this.providersMap.has(bufnr);
  }
  async hide() {
    let winid = await this.nvim.call("coc#window#find", ["cocViewId", "OUTLINE"]);
    if (winid == -1)
      return;
    await this.nvim.call("coc#window#close", [winid]);
  }
  dispose() {
    for (let view of this.treeViewList) {
      view.dispose();
    }
    this.treeViewList = [];
    for (let provider of this.providersMap.values()) {
      provider.dispose();
    }
    this.providersMap.clear();
    disposeAll(this.disposables);
  }
};

// src/handler/symbols/index.ts
var Symbols2 = class {
  constructor(nvim, handler) {
    this.nvim = nvim;
    this.handler = handler;
    this.disposables = [];
    this.autoUpdateBufnrs = /* @__PURE__ */ new Set();
    this.buffers = workspace_default.registerBufferSync((doc) => {
      if (doc.buftype != "")
        return void 0;
      let buf = new SymbolsBuffer(doc.bufnr, this.autoUpdateBufnrs);
      buf.onDidUpdate((symbols) => {
        if (!this.outline)
          return;
        this.outline.onSymbolsUpdate(buf.bufnr, symbols);
      });
      return buf;
    });
    this.outline = new SymbolsOutline(nvim, this.buffers, handler);
    events_default.on("CursorHold", async (bufnr) => {
      if (!this.functionUpdate || !this.buffers.getItem(bufnr))
        return;
      await this.getCurrentFunctionSymbol(bufnr);
    }, null, this.disposables);
    events_default.on("InsertEnter", (bufnr) => {
      let buf = this.buffers.getItem(bufnr);
      if (buf)
        buf.cancel();
    }, null, this.disposables);
  }
  get functionUpdate() {
    let config = workspace_default.getConfiguration("coc.preferences");
    return config.get("currentFunctionSymbolAutoUpdate", false);
  }
  get labels() {
    return workspace_default.getConfiguration("suggest").get("completionItemKindLabels", {});
  }
  async getWorkspaceSymbols(input) {
    this.handler.checkProvier("workspaceSymbols", null);
    let tokenSource = new import_vscode_languageserver_protocol127.CancellationTokenSource();
    return await languages_default.getWorkspaceSymbols(input, tokenSource.token);
  }
  async resolveWorkspaceSymbol(symbolInfo) {
    var _a;
    if ((_a = symbolInfo.location) == null ? void 0 : _a.uri)
      return symbolInfo;
    let tokenSource = new import_vscode_languageserver_protocol127.CancellationTokenSource();
    return await languages_default.resolveWorkspaceSymbol(symbolInfo, tokenSource.token);
  }
  async getDocumentSymbols(bufnr) {
    if (!bufnr) {
      let doc = await workspace_default.document;
      if (!doc || doc.isCommandLine || !doc.attached)
        return void 0;
      await wait(1);
      bufnr = doc.bufnr;
    }
    let buf = this.buffers.getItem(bufnr);
    if (!buf)
      return;
    let res = await buf.getSymbols();
    return res ? convertSymbols(res) : void 0;
  }
  async getCurrentFunctionSymbol(bufnr) {
    if (!bufnr)
      bufnr = await this.nvim.call("bufnr", ["%"]);
    let doc = workspace_default.getDocument(bufnr);
    if (!doc || !doc.attached)
      return;
    if (!languages_default.hasProvider("documentSymbol", doc.textDocument))
      return;
    let position = await window_default.getCursorPosition();
    let symbols = await this.getDocumentSymbols(bufnr);
    let buffer = this.nvim.createBuffer(bufnr);
    if (!symbols || symbols.length === 0) {
      buffer.setVar("coc_current_function", "", true);
      this.nvim.call("coc#util#do_autocmd", ["CocStatusChange"], true);
      return "";
    }
    symbols = symbols.filter((s) => [
      "Class",
      "Method",
      "Function",
      "Struct"
    ].includes(s.kind));
    let functionName = "";
    for (let sym of symbols.reverse()) {
      if (sym.range && positionInRange(position, sym.range) == 0 && !sym.text.endsWith(") callback")) {
        functionName = sym.text;
        let label = this.labels[sym.kind.toLowerCase()];
        if (label)
          functionName = `${label} ${functionName}`;
        break;
      }
    }
    if (this.functionUpdate) {
      buffer.setVar("coc_current_function", functionName, true);
      this.nvim.call("coc#util#do_autocmd", ["CocStatusChange"], true);
    }
    return functionName;
  }
  async selectSymbolRange(inner, visualmode, supportedSymbols) {
    let { doc } = await this.handler.getCurrentState();
    this.handler.checkProvier("documentSymbol", doc.textDocument);
    let range2;
    if (visualmode) {
      range2 = await window_default.getSelectedRange(visualmode);
    } else {
      let pos = await window_default.getCursorPosition();
      range2 = import_vscode_languageserver_protocol127.Range.create(pos, pos);
    }
    let symbols = await this.getDocumentSymbols(doc.bufnr);
    if (!symbols || symbols.length === 0) {
      window_default.showMessage("No symbols found", "warning");
      return;
    }
    symbols = symbols.filter((s) => supportedSymbols.includes(s.kind));
    let selectRange2;
    for (let sym of symbols.reverse()) {
      if (sym.range && !equals(sym.range, range2) && rangeInRange(range2, sym.range)) {
        selectRange2 = sym.range;
        break;
      }
    }
    if (inner && selectRange2) {
      let { start, end } = selectRange2;
      let line = doc.getline(start.line + 1);
      let endLine = doc.getline(end.line - 1);
      selectRange2 = import_vscode_languageserver_protocol127.Range.create(start.line + 1, line.match(/^\s*/)[0].length, end.line - 1, endLine.length);
    }
    if (selectRange2) {
      await window_default.selectRange(selectRange2);
    } else if (["v", "V", ""].includes(visualmode)) {
      await this.nvim.command("normal! gv");
    }
  }
  async showOutline(keep) {
    await this.outline.show(keep);
  }
  async hideOutline() {
    await this.outline.hide();
  }
  hasOutline(bufnr) {
    return this.outline.has(bufnr);
  }
  dispose() {
    this.outline.dispose();
    this.buffers.dispose();
    disposeAll(this.disposables);
  }
};

// src/handler/index.ts
init_convert();

// src/handler/linkedEditing.ts
var import_debounce15 = __toESM(require_debounce());
var import_vscode_languageserver_protocol128 = __toESM(require_main2());
init_events();
init_languages();
init_position();
init_string();
init_window();
init_workspace();
var logger132 = require_logger2()("handler-linkedEditing");
var LinkedEditingHandler = class {
  constructor(nvim, handler) {
    this.nvim = nvim;
    this.changing = false;
    this.checkPosition = (0, import_debounce15.default)(this._checkPosition, global.__TEST__ ? 10 : 100);
    handler.addDisposable(events_default.on("CursorMoved", (bufnr, cursor) => {
      this.cancel();
      this.checkPosition(bufnr, cursor);
    }));
    handler.addDisposable(events_default.on("CursorMovedI", (bufnr, cursor) => {
      this.cancel();
      this.checkPosition(bufnr, cursor);
    }));
    handler.addDisposable(window_default.onDidChangeActiveTextEditor(() => {
      this.cancel();
      this.cancelEdit();
    }));
    handler.addDisposable(events_default.on("InsertCharPre", (character, bufnr) => {
      if (bufnr !== this.bufnr)
        return;
      let doc = workspace_default.getDocument(bufnr);
      if (!this.wordPattern) {
        if (!doc.isWord(character) && character !== "-")
          this.cancelEdit();
      } else {
        let r = new RegExp(this.wordPattern);
        if (!r.test(character))
          this.cancelEdit();
      }
    }));
    handler.addDisposable(workspace_default.onDidChangeTextDocument(async (e) => {
      await this.onChange(e);
    }));
  }
  cancelEdit() {
    var _a;
    (_a = this.window) == null ? void 0 : _a.clearMatchGroup("^CocLinkedEditing");
    this.ranges = void 0;
    this.window = void 0;
    this.bufnr = void 0;
  }
  async onChange(e) {
    if (e.bufnr !== this.bufnr || this.changing || !this.ranges)
      return;
    if (e.contentChanges.length === 0) {
      this.doHighlights();
      return;
    }
    let change = e.contentChanges[0];
    let { text, range: range2 } = change;
    let affected = this.ranges.filter((r) => {
      if (!rangeIntersect(range2, r.range))
        return false;
      if (rangeAdjacent(range2, r.range)) {
        if (text.includes("\n") || !emptyRange(range2))
          return false;
      }
      return true;
    });
    if (affected.length == 1 && rangeInRange(range2, affected[0].range)) {
      if (text.includes("\n")) {
        this.cancelEdit();
        return;
      }
      logger132.debug("affected single range");
      await this.applySingleEdit(affected[0], { range: range2, newText: text });
    } else {
      this.cancelEdit();
    }
  }
  async applySingleEdit(textRange, edit2) {
    let { bufnr, ranges } = this;
    let doc = workspace_default.getDocument(bufnr);
    let after = ranges.filter((r) => r !== textRange && r.position.line == textRange.position.line);
    after.forEach((r) => r.adjustFromEdit(edit2));
    let change = getChange(textRange, edit2.range, edit2.newText);
    let delta = getDelta(change);
    ranges.forEach((r) => r.applyChange(change));
    let edits = ranges.filter((r) => r !== textRange).map((o) => o.textEdit);
    this.changing = true;
    await doc.applyEdits(edits, true, true);
    this.changing = false;
    if (delta != 0) {
      for (let r of ranges) {
        let n = getBeforeCount(r, this.ranges, textRange);
        r.move(n * delta);
      }
    }
    this.doHighlights();
  }
  doHighlights() {
    let { window: window2, ranges, nvim } = this;
    if (window2 && ranges) {
      nvim.pauseNotification();
      window2.clearMatchGroup("^CocLinkedEditing");
      window2.highlightRanges("CocLinkedEditing", ranges.map((o) => o.range), 99, true);
      nvim.resumeNotification(true, true);
    }
  }
  _checkPosition(bufnr, cursor) {
    if (events_default.pumvisible || !workspace_default.isAttached(bufnr))
      return;
    let doc = workspace_default.getDocument(bufnr);
    let config = workspace_default.getConfiguration("coc.preferences", doc.uri);
    let enabled = config.get("enableLinkedEditing", false);
    if (!enabled || !languages_default.hasProvider("linkedEditing", doc.textDocument))
      return;
    let character = characterIndex(doc.getline(cursor[0] - 1), cursor[1] - 1);
    let position = import_vscode_languageserver_protocol128.Position.create(cursor[0] - 1, character);
    if (this.ranges) {
      if (this.ranges.some((r) => positionInRange(position, r.range) == 0)) {
        return;
      }
      this.cancelEdit();
    }
    void this.enable(doc, position);
  }
  async enable(doc, position) {
    let textDocument = doc.textDocument;
    let tokenSource = this.tokenSource = new import_vscode_languageserver_protocol128.CancellationTokenSource();
    let token = tokenSource.token;
    let win = await this.nvim.window;
    let linkedRanges;
    try {
      linkedRanges = await languages_default.provideLinkedEdits(textDocument, position, token);
    } catch (e) {
      logger132.error(`Error on provideLinkedEdits: `, e);
      void window_default.showErrorMessage(`Error on provideLinkedEdits: ${e instanceof Error ? e.message : e}`);
      return;
    }
    if (token.isCancellationRequested || !linkedRanges || linkedRanges.ranges.length == 0)
      return;
    let ranges = linkedRanges.ranges.map((o) => new TextRange(o.start.line, o.start.character, textDocument.getText(o)));
    this.wordPattern = linkedRanges.wordPattern;
    this.bufnr = doc.bufnr;
    this.window = win;
    this.ranges = ranges;
    this.doHighlights();
  }
  cancel() {
    if (this.tokenSource) {
      this.tokenSource.cancel();
      this.tokenSource = null;
    }
  }
};

// src/handler/inlayHint/index.ts
init_events();
init_languages();
init_commands2();
init_workspace();

// src/handler/inlayHint/buffer.ts
var import_debounce16 = __toESM(require_debounce());
var import_vscode_languageserver_protocol129 = __toESM(require_main2());
init_events();
init_languages();
init_inlayHintManager();
init_util();
init_position();
init_string();
var logger133 = require_logger2()("inlayHint-buffer");
var srcId;
var debounceInterval2 = global.__TEST__ ? 10 : 100;
var highlightGroup = "CocInlayHint";
var InlayHintBuffer = class {
  constructor(nvim, doc, config, isVim6) {
    this.nvim = nvim;
    this.doc = doc;
    this.config = config;
    this.isVim = isVim6;
    this._enabled = true;
    this.disposables = [];
    this.regions = new Regions();
    this.currentHints = [];
    this._onDidRefresh = new import_vscode_languageserver_protocol129.Emitter();
    this.onDidRefresh = this._onDidRefresh.event;
    if (!config.refreshOnInsertMode) {
      events_default.on("InsertLeave", () => {
        void this.renderRange();
      }, null, this.disposables);
      events_default.on("InsertEnter", () => {
        void this.cancel();
      }, null, this.disposables);
    }
    this.render = (0, import_debounce16.default)(() => {
      void this.renderRange();
    }, debounceInterval2);
    this.render();
  }
  get current() {
    return this.currentHints;
  }
  get enabled() {
    let { filetypes } = this.config;
    if (!this._enabled)
      return false;
    if (!filetypes.length)
      return false;
    if (!filetypes.includes("*") && !filetypes.includes(this.doc.filetype))
      return false;
    return languages_default.hasProvider("inlayHint", this.doc.textDocument);
  }
  toggle() {
    if (!languages_default.hasProvider("inlayHint", this.doc.textDocument))
      throw new Error("Inlay hint provider not found for current document");
    let { filetypes } = this.config;
    if (!filetypes.includes("*") && !filetypes.includes(this.doc.filetype)) {
      throw new Error(`Filetype "${this.doc.filetype}" not enabled by inlayHint.filetypes configuration`);
    }
    if (this._enabled) {
      this._enabled = false;
      this.clearCache();
      this.clearVirtualText();
    } else {
      this._enabled = true;
      void this.renderRange();
    }
  }
  clearCache() {
    this.currentHints = [];
    this.regions.clear();
    this.render.clear();
  }
  onTextChange() {
    this.regions.clear();
    this.cancel();
  }
  onChange() {
    this.clearCache();
    this.cancel();
    this.render();
  }
  cancel() {
    this.render.clear();
    if (this.tokenSource) {
      this.tokenSource.cancel();
      this.tokenSource = null;
    }
  }
  async renderRange() {
    this.cancel();
    if (events_default.insertMode && !this.config.refreshOnInsertMode)
      return;
    if (!this.enabled)
      return;
    this.tokenSource = new import_vscode_languageserver_protocol129.CancellationTokenSource();
    let token = this.tokenSource.token;
    let res = await this.nvim.call("coc#window#visible_range", [this.doc.bufnr]);
    if (!srcId)
      srcId = await this.nvim.createNamespace("coc-inlayHint");
    if (!Array.isArray(res) || token.isCancellationRequested)
      return;
    if (this.regions.has(res[0], res[1]))
      return;
    let range2 = import_vscode_languageserver_protocol129.Range.create(res[0] - 1, 0, res[1], 0);
    let inlayHints = await languages_default.provideInlayHints(this.doc.textDocument, range2, token);
    if (inlayHints == null || token.isCancellationRequested)
      return;
    if (!this.config.enableParameter) {
      inlayHints = inlayHints.filter((o) => o.kind !== import_vscode_languageserver_protocol129.InlayHintKind.Parameter);
    }
    this.regions.add(res[0], res[1]);
    this.currentHints = this.currentHints.filter((o) => positionInRange(o.position, range2) !== 0);
    this.currentHints.push(...inlayHints);
    this.setVirtualText(range2, inlayHints, this.isVim);
  }
  setVirtualText(range2, inlayHints, isVim6) {
    let { nvim, doc } = this;
    let buffer = doc.buffer;
    let { subSeparator, parameterSeparator, typeSeparator } = this.config;
    const chunksMap = /* @__PURE__ */ new Map();
    if (!isVim6) {
      for (const item of inlayHints) {
        let { line } = item.position;
        const chunks = chunksMap.get(line) ?? [];
        if (chunks.length > 0) {
          chunks.push([subSeparator, subSeparator === " " ? "Normal" : highlightGroup]);
        }
        let sep = item.kind === import_vscode_languageserver_protocol129.InlayHintKind.Parameter ? parameterSeparator : typeSeparator;
        chunks.push([sep + getLabel(item), highlightGroup]);
        chunksMap.set(line, chunks);
      }
    }
    nvim.pauseNotification();
    buffer.clearNamespace(srcId, range2.start.line, range2.end.line + 1);
    if (isVim6) {
      for (const item of inlayHints) {
        const chunks = [];
        let { position } = item;
        let line = this.doc.getline(position.line);
        let col = byteIndex(line, position.character) + 1;
        if (item.paddingLeft) {
          chunks.push([" ", "Normal"]);
        }
        chunks.push([getLabel(item), highlightGroup]);
        if (item.paddingRight) {
          chunks.push([" ", "Normal"]);
        }
        buffer.setVirtualText(srcId, position.line, chunks, { col });
      }
    } else {
      for (let [line, chunks] of chunksMap.entries()) {
        buffer.setExtMark(srcId, line, 0, {
          virt_text: chunks,
          virt_text_pos: "eol",
          hl_mode: "combine"
        });
      }
    }
    nvim.resumeNotification(true, true);
    this._onDidRefresh.fire();
  }
  clearVirtualText() {
    if (srcId)
      this.doc.buffer.clearNamespace(srcId);
  }
  dispose() {
    disposeAll(this.disposables);
    this.cancel();
  }
};

// src/handler/inlayHint/index.ts
init_window();
var InlayHintHandler = class {
  constructor(nvim, handler) {
    this.buffers = workspace_default.registerBufferSync((doc) => {
      if (!workspace_default.env.virtualText)
        return;
      let config = this.getConfig(doc.uri);
      return new InlayHintBuffer(nvim, doc, config, nvim.isVim);
    });
    handler.addDisposable(this.buffers);
    handler.addDisposable(languages_default.onDidInlayHintRefresh(async (e) => {
      for (let item of this.buffers.items) {
        if (workspace_default.match(e, item.doc.textDocument)) {
          item.clearCache();
          if (languages_default.hasProvider("inlayHint", item.doc.textDocument)) {
            item.render();
          } else {
            item.clearVirtualText();
          }
        }
      }
    }));
    handler.addDisposable(events_default.on("CursorMoved", (bufnr) => {
      this.refresh(bufnr);
    }));
    handler.addDisposable(events_default.on("WinScrolled", async (winid) => {
      let bufnr = await nvim.call("winbufnr", [winid]);
      if (bufnr != -1)
        this.refresh(bufnr);
    }));
    handler.addDisposable(commands_default.registerCommand("document.toggleInlayHint", (bufnr) => {
      this.toggle(bufnr ?? workspace_default.bufnr);
    }));
  }
  toggle(bufnr) {
    let item = this.getItem(bufnr);
    if (item) {
      try {
        item.toggle();
      } catch (e) {
        void window_default.showErrorMessage(e.message);
      }
    }
  }
  getConfig(uri) {
    let config = workspace_default.getConfiguration("inlayHint", uri);
    return {
      filetypes: config.get("filetypes", []),
      refreshOnInsertMode: config.get("refreshOnInsertMode"),
      enableParameter: config.get("enableParameter", false),
      typeSeparator: config.get("typeSeparator", ""),
      parameterSeparator: config.get("parameterSeparator", ""),
      subSeparator: config.get("subSeparator", " ")
    };
  }
  getItem(bufnr) {
    return this.buffers.getItem(bufnr);
  }
  refresh(bufnr) {
    let buf = this.buffers.getItem(bufnr);
    if (buf)
      buf.render();
  }
};

// src/handler/index.ts
var logger134 = require_logger2()("Handler");
var Handler = class {
  constructor(nvim) {
    this.nvim = nvim;
    this.disposables = [];
    this.requestStatusItem = window_default.createStatusBarItem(0, { progress: true });
    events_default.on(["CursorMoved", "CursorMovedI", "InsertEnter", "InsertSnippet", "InsertLeave"], () => {
      if (this.requestTokenSource) {
        this.requestTokenSource.cancel();
        this.requestTokenSource = null;
      }
    }, null, this.disposables);
    this.labels = workspace_default.getConfiguration("suggest").get("completionItemKindLabels", {});
    this.fold = new FoldHandler(nvim, this);
    this.links = new Links(nvim, this);
    this.codeLens = new CodeLensManager2(nvim);
    this.colors = new Colors(nvim, this);
    this.format = new FormatHandler(nvim, this);
    this.symbols = new Symbols2(nvim, this);
    this.refactor = new Refactor(nvim, this);
    this.hover = new HoverHandler(nvim, this);
    this.locations = new LocationsHandler(nvim, this);
    this.signature = new Signature(nvim, this);
    this.rename = new Rename(nvim, this);
    this.workspace = new WorkspaceHandler(nvim, this);
    this.codeActions = new CodeActions(nvim, this);
    this.commands = new Commands(nvim, workspace_default.env);
    this.callHierarchy = new CallHierarchyHandler(nvim, this);
    this.documentHighlighter = new Highlights(nvim, this);
    this.semanticHighlighter = new SemanticTokens6(nvim);
    this.selectionRange = new SelectionRangeHandler(nvim, this);
    this.linkedEditingHandler = new LinkedEditingHandler(nvim, this);
    this.inlayHintHandler = new InlayHintHandler(nvim, this);
    this.disposables.push({
      dispose: () => {
        this.callHierarchy.dispose();
        this.codeLens.dispose();
        this.links.dispose();
        this.refactor.dispose();
        this.signature.dispose();
        this.symbols.dispose();
        this.hover.dispose();
        this.locations.dispose();
        this.colors.dispose();
        this.documentHighlighter.dispose();
        this.semanticHighlighter.dispose();
      }
    });
    void this.refactor.init();
  }
  async getCurrentState() {
    let { nvim } = this;
    let [bufnr, [line, character], winid, mode] = await nvim.eval("[bufnr('%'),coc#cursor#position(),win_getid(),mode()]");
    let doc = workspace_default.getAttachedDocument(bufnr);
    return {
      doc,
      mode,
      position: import_vscode_languageserver_protocol130.Position.create(line, character),
      winid
    };
  }
  addDisposable(disposable) {
    this.disposables.push(disposable);
  }
  checkProvier(id, document2) {
    if (!languages_default.hasProvider(id, document2)) {
      throw new Error(`${id} provider not found for current buffer, your language server doesn't support it.`);
    }
  }
  async withRequestToken(name2, fn, checkEmpty) {
    if (this.requestTokenSource) {
      this.requestTokenSource.cancel();
      this.requestTokenSource.dispose();
    }
    if (this.requestTimer) {
      clearTimeout(this.requestTimer);
    }
    let statusItem = this.requestStatusItem;
    this.requestTokenSource = new import_vscode_languageserver_protocol130.CancellationTokenSource();
    let { token } = this.requestTokenSource;
    token.onCancellationRequested(() => {
      statusItem.text = `${name2} request canceled`;
      statusItem.isProgress = false;
      this.requestTimer = setTimeout(() => {
        statusItem.hide();
      }, 500);
    });
    statusItem.isProgress = true;
    statusItem.text = `requesting ${name2}`;
    statusItem.show();
    let res;
    try {
      res = await Promise.resolve(fn(token));
    } catch (e) {
      this.nvim.echoError(e);
    }
    if (this.requestTokenSource) {
      this.requestTokenSource.dispose();
      this.requestTokenSource = void 0;
    }
    if (token.isCancellationRequested)
      return null;
    statusItem.hide();
    if (checkEmpty && (!res || Array.isArray(res) && res.length == 0)) {
      window_default.showMessage(`${name2} not found`, "warning");
      return null;
    }
    return res;
  }
  getIcon(kind) {
    let { labels } = this;
    let kindText = getSymbolKind(kind);
    let defaultIcon = typeof labels["default"] === "string" ? labels["default"] : kindText[0].toLowerCase();
    let text = kindText == "Unknown" ? "" : labels[kindText[0].toLowerCase() + kindText.slice(1)];
    if (!text || typeof text !== "string")
      text = defaultIcon;
    return {
      text,
      hlGroup: kindText == "Unknown" ? "CocSymbolDefault" : `CocSymbol${kindText}`
    };
  }
  async getCodeActions(doc, range2, only) {
    let codeActions = await this.codeActions.getCodeActions(doc, range2, only);
    return codeActions.filter((o) => !o.disabled);
  }
  async applyCodeAction(action) {
    await this.codeActions.applyCodeAction(action);
  }
  async hasProvider(id) {
    let bufnr = await this.nvim.call("bufnr", "%");
    let doc = workspace_default.getDocument(bufnr);
    if (!doc)
      return false;
    return languages_default.hasProvider(id, doc.textDocument);
  }
  dispose() {
    if (this.requestTimer) {
      clearTimeout(this.requestTimer);
    }
    disposeAll(this.disposables);
  }
};

// src/plugin.ts
init_manager2();
init_services();
init_manager3();
init_sources2();
init_util();
init_window();
init_workspace();
var logger135 = require_logger2()("plugin");
var Plugin = class extends import_events54.EventEmitter {
  constructor(nvim) {
    super();
    this.nvim = nvim;
    this._ready = false;
    this.actions = /* @__PURE__ */ new Map();
    this.disposables = [];
    this.disposables.push(workspace_default.registerTextDocumentContentProvider("output", channels_default.getProvider(nvim)));
    Object.defineProperty(workspace_default, "nvim", {
      get: () => this.nvim
    });
    Object.defineProperty(window_default, "cursors", {
      get: () => this.cursors
    });
    workspace_default.onDidChangeWorkspaceFolders(() => {
      nvim.setVar("WorkspaceFolders", workspace_default.folderPaths, true);
    }, null, this.disposables);
    events_default.on("VimResized", (columns, lines) => {
      if (workspace_default.env)
        Object.assign(workspace_default.env, { columns, lines });
    }, null, this.disposables);
    this.cursors = new Cursors(nvim);
    commands_default.init(nvim, this);
    this.addAction("checkJsonExtension", () => {
      if (extensions_default.has("coc-json"))
        return;
      window_default.showMessage(`Run :CocInstall coc-json for json intellisense`, "more");
    });
    this.addAction("rootPatterns", (bufnr) => this.handler.workspace.getRootPatterns(bufnr));
    this.addAction("ensureDocument", () => this.handler.workspace.ensureDocument());
    this.addAction("getConfig", async (key) => this.handler.workspace.getConfiguration(key));
    this.addAction("doAutocmd", async (id, ...args) => this.handler.workspace.doAutocmd(id, args));
    this.addAction("openLog", async () => this.handler.workspace.openLog());
    this.addAction("attach", () => workspace_default.attach());
    this.addAction("detach", () => workspace_default.detach());
    this.addAction("doKeymap", async (key, defaultReturn, pressed) => this.handler.workspace.doKeymap(key, defaultReturn, pressed));
    this.addAction("registExtensions", (...folders) => extensions_default.loadExtension(folders));
    this.addAction("snippetCheck", async (checkExpand, checkJump) => this.handler.workspace.snippetCheck(checkExpand, checkJump));
    this.addAction("snippetNext", () => manager_default3.nextPlaceholder());
    this.addAction("snippetPrev", () => manager_default3.previousPlaceholder());
    this.addAction("snippetCancel", () => manager_default3.cancel());
    this.addAction("openLocalConfig", () => window_default.openLocalConfig());
    this.addAction("bufferCheck", () => window_default.bufferCheck());
    this.addAction("showInfo", () => this.handler.workspace.showInfo());
    this.addAction("hasProvider", (id) => this.handler.hasProvider(id));
    this.addAction("listNames", () => manager_default2.names);
    this.addAction("listDescriptions", () => manager_default2.descriptions);
    this.addAction("listLoadItems", (name2) => manager_default2.loadItems(name2));
    this.addAction("search", (...args) => this.handler.refactor.search(args));
    this.addAction("cursorsSelect", (bufnr, kind, mode) => this.cursors.select(bufnr, kind, mode));
    this.addAction("fillDiagnostics", (bufnr) => manager_default.setLocationlist(bufnr));
    this.addAction("saveRefactor", (bufnr) => this.handler.refactor.save(bufnr));
    this.addAction("commandList", () => this.handler.commands.getCommandList());
    this.addAction("selectSymbolRange", (inner, visualmode, supportedSymbols) => this.handler.symbols.selectSymbolRange(inner, visualmode, supportedSymbols));
    this.addAction("openList", (...args) => manager_default2.start(args));
    this.addAction("listResume", (name2) => manager_default2.resume(name2));
    this.addAction("listCancel", () => manager_default2.cancel(true));
    this.addAction("listPrev", (name2) => manager_default2.previous(name2));
    this.addAction("listNext", (name2) => manager_default2.next(name2));
    this.addAction("listFirst", (name2) => manager_default2.first(name2));
    this.addAction("listLast", (name2) => manager_default2.last(name2));
    this.addAction("sendRequest", (id, method, params) => services_default.sendRequest(id, method, params));
    this.addAction("sendNotification", (id, method, params) => services_default.sendNotification(id, method, params));
    this.addAction("registNotification", (id, method) => services_default.registNotification(id, method));
    this.addAction("updateConfig", (section2, val) => workspace_default.configurations.updateUserConfig({ [section2]: val }));
    this.addAction("links", () => this.handler.links.getLinks());
    this.addAction("openLink", () => this.handler.links.openCurrentLink());
    this.addAction("pickColor", () => this.handler.colors.pickColor());
    this.addAction("colorPresentation", () => this.handler.colors.pickPresentation());
    this.addAction("highlight", () => this.handler.documentHighlighter.highlight());
    this.addAction("fold", (kind) => this.handler.fold.fold(kind));
    this.addAction("startCompletion", (option) => completion_default.startCompletion(option));
    this.addAction("sourceStat", () => sources_default.sourceStats());
    this.addAction("refreshSource", (name2) => sources_default.refresh(name2));
    this.addAction("toggleSource", (name2) => sources_default.toggleSource(name2));
    this.addAction("diagnosticRefresh", (bufnr) => manager_default.refresh(bufnr));
    this.addAction("diagnosticInfo", () => manager_default.echoMessage());
    this.addAction("diagnosticToggle", (enable) => manager_default.toggleDiagnostic(enable));
    this.addAction("diagnosticToggleBuffer", (bufnr, enable) => manager_default.toggleDiagnosticBuffer(bufnr, enable));
    this.addAction("diagnosticNext", (severity) => manager_default.jumpNext(severity));
    this.addAction("diagnosticPrevious", (severity) => manager_default.jumpPrevious(severity));
    this.addAction("diagnosticPreview", () => manager_default.preview());
    this.addAction("diagnosticList", async () => manager_default.getDiagnosticList());
    this.addAction("findLocations", (id, method, params, openCommand) => this.handler.locations.findLocations(id, method, params, openCommand));
    this.addAction("getTagList", () => this.handler.locations.getTagList());
    this.addAction("jumpDefinition", (openCommand) => this.handler.locations.gotoDefinition(openCommand));
    this.addAction("definitions", () => this.handler.locations.definitions());
    this.addAction("jumpDeclaration", (openCommand) => this.handler.locations.gotoDeclaration(openCommand));
    this.addAction("declarations", () => this.handler.locations.declarations());
    this.addAction("jumpImplementation", (openCommand) => this.handler.locations.gotoImplementation(openCommand));
    this.addAction("implementations", () => this.handler.locations.implementations());
    this.addAction("jumpTypeDefinition", (openCommand) => this.handler.locations.gotoTypeDefinition(openCommand));
    this.addAction("typeDefinitions", () => this.handler.locations.typeDefinitions());
    this.addAction("jumpReferences", (openCommand) => this.handler.locations.gotoReferences(openCommand));
    this.addAction("references", (excludeDeclaration) => this.handler.locations.references(excludeDeclaration));
    this.addAction("jumpUsed", (openCommand) => this.handler.locations.gotoReferences(openCommand, false));
    this.addAction("doHover", (hoverTarget) => this.handler.hover.onHover(hoverTarget));
    this.addAction("definitionHover", (hoverTarget) => this.handler.hover.definitionHover(hoverTarget));
    this.addAction("getHover", () => this.handler.hover.getHover());
    this.addAction("showSignatureHelp", () => this.handler.signature.triggerSignatureHelp());
    this.addAction("documentSymbols", (bufnr) => this.handler.symbols.getDocumentSymbols(bufnr));
    this.addAction("symbolRanges", () => this.handler.documentHighlighter.getSymbolsRanges());
    this.addAction("selectionRanges", () => this.handler.selectionRange.getSelectionRanges());
    this.addAction("rangeSelect", (visualmode, forward) => this.handler.selectionRange.selectRange(visualmode, forward));
    this.addAction("rename", (newName) => this.handler.rename.rename(newName));
    this.addAction("getWorkspaceSymbols", (input) => this.handler.symbols.getWorkspaceSymbols(input));
    this.addAction("resolveWorkspaceSymbol", (symbolInfo) => this.handler.symbols.resolveWorkspaceSymbol(symbolInfo));
    this.addAction("formatSelected", (mode) => this.handler.format.formatCurrentRange(mode));
    this.addAction("format", () => this.handler.format.formatCurrentBuffer());
    this.addAction("commands", () => this.handler.commands.getCommands());
    this.addAction("services", () => services_default.getServiceStats());
    this.addAction("toggleService", (name2) => services_default.toggle(name2));
    this.addAction("codeAction", (mode, only) => this.handler.codeActions.doCodeAction(mode, only));
    this.addAction("organizeImport", () => this.handler.codeActions.organizeImport());
    this.addAction("fixAll", () => this.handler.codeActions.doCodeAction(null, [import_vscode_languageserver_protocol131.CodeActionKind.SourceFixAll]));
    this.addAction("doCodeAction", (codeAction) => this.handler.codeActions.applyCodeAction(codeAction));
    this.addAction("codeActions", (mode, only) => this.handler.codeActions.getCurrentCodeActions(mode, only));
    this.addAction("quickfixes", (mode) => this.handler.codeActions.getCurrentCodeActions(mode, [import_vscode_languageserver_protocol131.CodeActionKind.QuickFix]));
    this.addAction("codeLensAction", () => this.handler.codeLens.doAction());
    this.addAction("runCommand", (...args) => this.handler.commands.runCommand(...args));
    this.addAction("doQuickfix", () => this.handler.codeActions.doQuickfix());
    this.addAction("refactor", () => this.handler.refactor.doRefactor());
    this.addAction("repeatCommand", () => this.handler.commands.repeat());
    this.addAction("installExtensions", (...list2) => extensions_default.installExtensions(list2));
    this.addAction("updateExtensions", (sync) => extensions_default.updateExtensions(sync));
    this.addAction("extensionStats", () => extensions_default.getExtensionStates());
    this.addAction("loadedExtensions", () => extensions_default.loadedExtensions());
    this.addAction("watchExtension", (id) => extensions_default.watchExtension(id));
    this.addAction("activeExtension", (name2) => extensions_default.activate(name2));
    this.addAction("deactivateExtension", (name2) => extensions_default.deactivate(name2));
    this.addAction("reloadExtension", (name2) => extensions_default.reloadExtension(name2));
    this.addAction("toggleExtension", (name2) => extensions_default.toggleExtension(name2));
    this.addAction("uninstallExtension", (...args) => extensions_default.uninstallExtension(args));
    this.addAction("getCurrentFunctionSymbol", () => this.handler.symbols.getCurrentFunctionSymbol());
    this.addAction("showOutline", (keep) => this.handler.symbols.showOutline(keep));
    this.addAction("hideOutline", () => this.handler.symbols.hideOutline());
    this.addAction("getWordEdit", () => this.handler.rename.getWordEdit());
    this.addAction("addCommand", (cmd) => this.handler.commands.addVimCommand(cmd));
    this.addAction("addRanges", (ranges) => this.cursors.addRanges(ranges));
    this.addAction("currentWorkspacePath", () => workspace_default.rootPath);
    this.addAction("selectCurrentPlaceholder", (triggerAutocmd) => manager_default3.selectCurrentPlaceholder(!!triggerAutocmd));
    this.addAction("codeActionRange", (start, end, only) => this.handler.codeActions.codeActionRange(start, end, only));
    this.addAction("incomingCalls", (item) => this.handler.callHierarchy.getIncoming(item));
    this.addAction("outgoingCalls", (item) => this.handler.callHierarchy.getOutgoing(item));
    this.addAction("showIncomingCalls", () => this.handler.callHierarchy.showCallHierarchyTree("incoming"));
    this.addAction("showOutgoingCalls", () => this.handler.callHierarchy.showCallHierarchyTree("outgoing"));
    this.addAction("inspectSemanticToken", () => this.handler.semanticHighlighter.inspectSemanticToken());
    this.addAction("semanticHighlight", () => this.handler.semanticHighlighter.highlightCurrent());
    this.addAction("showSemanticHighlightInfo", () => this.handler.semanticHighlighter.showHighlightInfo());
  }
  addAction(key, fn) {
    if (this.actions.has(key)) {
      throw new Error(`Action ${key} already exists`);
    }
    this.actions.set(key, fn);
  }
  async init() {
    let { nvim } = this;
    let s = Date.now();
    try {
      await extensions_default.init();
      await workspace_default.init(window_default);
      nvim.setVar("coc_workspace_initialized", true, true);
      manager_default3.init();
      completion_default.init();
      manager_default.init();
      manager_default2.init(nvim);
      sources_default.init();
      this.handler = new Handler(nvim);
      services_default.init();
      extensions_default.activateExtensions();
      workspace_default.autocmds.setupDynamicAutocmd(true);
      nvim.pauseNotification();
      nvim.setVar("WorkspaceFolders", workspace_default.folderPaths, true);
      nvim.setVar("coc_service_initialized", 1, true);
      nvim.call("coc#util#do_autocmd", ["CocNvimInit"], true);
      nvim.resumeNotification(false, true);
      this._ready = true;
      await events_default.fire("ready", []);
      logger135.info(`coc.nvim initialized with node: ${process.version} after ${Date.now() - s}ms`);
      this.emit("ready");
    } catch (e) {
      nvim.echoError(e);
    }
  }
  get isReady() {
    return this._ready;
  }
  get ready() {
    if (this._ready)
      return Promise.resolve();
    return new Promise((resolve3) => {
      this.once("ready", () => {
        resolve3();
      });
    });
  }
  hasAction(method) {
    return this.actions.has(method);
  }
  async cocAction(method, ...args) {
    let fn = this.actions.get(method);
    if (!fn)
      throw new Error(`Action "${method}" doesn't exist`);
    let ts = Date.now();
    let res = await Promise.resolve(fn.apply(null, args));
    let dt = Date.now() - ts;
    if (dt > 500)
      logger135.warn(`Slow action "${method}" cost ${dt}ms`);
    return res;
  }
  getHandler() {
    return this.handler;
  }
  dispose() {
    this.removeAllListeners();
    disposeAll(this.disposables);
    extensions_default.dispose();
    manager_default2.dispose();
    workspace_default.dispose();
    channels_default.dispose();
    window_default.dispose();
    sources_default.dispose();
    services_default.stopAll();
    services_default.dispose();
    if (this.handler) {
      this.handler.dispose();
    }
    manager_default3.dispose();
    commands_default.dispose();
    completion_default.dispose();
    manager_default.dispose();
  }
};

// src/attach.ts
var import_semver4 = __toESM(require_semver2());
init_is();
init_esm();
init_package();
var logger136 = require_logger2()("attach");
var isTest = global.hasOwnProperty("__TEST__");
var ACTIONS_NO_WAIT = ["installExtensions", "updateExtensions"];
var attach_default = (opts, requestApi = true) => {
  const nvim = (0, import_neovim.attach)(opts, import_log4js.default.getLogger("node-client"), requestApi);
  if (!global.hasOwnProperty("__TEST__")) {
    nvim.call("coc#util#path_replace_patterns").then((prefixes) => {
      if (objectLiteral(prefixes)) {
        const old_uri = URI2.file;
        URI2.file = (path41) => {
          path41 = path41.replace(/\\/g, "/");
          Object.keys(prefixes).forEach((k) => path41 = path41.replace(new RegExp("^" + k), prefixes[k]));
          return old_uri(path41);
        };
      }
    }).logError();
  }
  nvim.setVar("coc_process_pid", process.pid, true);
  const plugin = new Plugin(nvim);
  let clientReady = false;
  let initialized = false;
  nvim.on("notification", async (method, args) => {
    switch (method) {
      case "VimEnter": {
        if (!initialized && clientReady) {
          initialized = true;
          await plugin.init();
        }
        break;
      }
      case "Log": {
        logger136.debug(...args);
        break;
      }
      case "TaskExit":
      case "TaskStderr":
      case "TaskStdout":
      case "GlobalChange":
      case "PromptInsert":
      case "InputChar":
      case "MenuInput":
      case "OptionSet":
      case "PromptKeyPress":
      case "FloatBtnClick":
      case "CompleteStop":
        logger136.trace("Event: ", method, ...args);
        await events_default.fire(method, args);
        break;
      case "CocAutocmd":
        logger136.trace("Notification autocmd:", ...args);
        await events_default.fire(args[0], args.slice(1));
        break;
      case "redraw":
        break;
      default: {
        let exists = plugin.hasAction(method);
        if (!exists) {
          console.error(`action "${method}" does not exist`);
          return;
        }
        try {
          if (!plugin.isReady) {
            logger136.warn(`Plugin not ready when received "${method}"`, args);
          } else {
            logger136.info("receive notification:", method, args);
          }
          await plugin.ready;
          await plugin.cocAction(method, ...args);
        } catch (e) {
          nvim.echoError(`Error on notification "${method}": ${e instanceof Error ? e.message : e}`);
          logger136.error(e);
        }
      }
    }
  });
  nvim.on("request", async (method, args, resp) => {
    if (method == "redraw") {
      resp.send();
      return;
    }
    let timer = setTimeout(() => {
      logger136.error("Request cost more than 3s", method, args);
    }, 3e3);
    try {
      if (method == "CocAutocmd") {
        logger136.trace("Request autocmd:", ...args);
        await events_default.fire(args[0], args.slice(1));
        resp.send(void 0);
      } else {
        if (!plugin.isReady && !ACTIONS_NO_WAIT.includes(method)) {
          logger136.warn(`Plugin not ready on request "${method}"`, args);
          resp.send("Plugin not ready", true);
          return;
        }
        logger136.info("Request action:", method, args);
        let res = await plugin.cocAction(method, ...args);
        resp.send(res);
      }
      clearTimeout(timer);
    } catch (e) {
      clearTimeout(timer);
      resp.send(e instanceof Error ? e.message : e.toString(), true);
      logger136.error(`Request error:`, method, args, e);
    }
  });
  nvim.channelId.then(async (channelId) => {
    clientReady = true;
    if (isTest)
      nvim.call("coc#rpc#set_channel", [channelId], true);
    let { major, minor, patch } = import_semver4.default.parse(version);
    nvim.setClientInfo("coc", { major, minor, patch }, "remote", {}, {});
    let entered = await nvim.getVvar("vim_did_enter");
    if (entered && !initialized) {
      initialized = true;
      await plugin.init();
    }
  }).catch((e) => {
    console.error(`Channel create error: ${e.message}`);
  });
  return plugin;
};

// src/main.ts
Object.defineProperty(console, "log", {
  value() {
    if (logger137)
      logger137.info(...arguments);
  }
});
var logger137 = require_logger2()("server");
attach_default({ reader: process.stdin, writer: process.stdout });
process.on("uncaughtException", function(err) {
  let msg = "Uncaught exception: " + err.message;
  console.error(msg);
  logger137.error("uncaughtException", err.stack);
});
process.on("unhandledRejection", function(reason, p) {
  if (reason instanceof Error) {
    console.error("UnhandledRejection: " + reason.message + "\n" + reason.stack);
  } else {
    console.error("UnhandledRejection: " + reason);
  }
  logger137.error("unhandledRejection ", p, reason);
});
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */
/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/*! (c) 2020 Andrea Giammarchi */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * event-lite.js - Light-weight EventEmitter (less than 1KB when gzipped)
 *
 * @copyright Yusuke Kawasaki
 * @license MIT
 * @constructor
 * @see https://github.com/kawanet/event-lite
 * @see http://kawanet.github.io/event-lite/EventLite.html
 * @example
 * var EventLite = require("event-lite");
 *
 * function MyClass() {...}             // your class
 *
 * EventLite.mixin(MyClass.prototype);  // import event methods
 *
 * var obj = new MyClass();
 * obj.on("foo", function() {...});     // add event listener
 * obj.once("bar", function() {...});   // add one-time event listener
 * obj.emit("foo");                     // dispatch event
 * obj.emit("bar");                     // dispatch another event
 * obj.off("foo");                      // remove event listener
 */
